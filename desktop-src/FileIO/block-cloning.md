---
description: Uma operação de clonagem de bloco instrui o sistema de arquivos a copiar um intervalo de bytes de arquivo em nome de um aplicativo.
ms.assetid: E18E8D79-3985-40B8-A4C5-A73A21E5C527
title: Bloquear clonagem
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b33aa1c1eee693b6ed4b502aedc6da6176ece3e9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104506179"
---
# <a name="block-cloning"></a><span data-ttu-id="067d2-103">Bloquear clonagem</span><span class="sxs-lookup"><span data-stu-id="067d2-103">Block Cloning</span></span>

<span data-ttu-id="067d2-104">Uma operação de *clonagem de bloco* instrui o sistema de arquivos a copiar um intervalo de bytes de arquivo em nome de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="067d2-104">A *block clone* operation instructs the file system to copy a range of file bytes on behalf of an application.</span></span> <span data-ttu-id="067d2-105">O arquivo de destino pode ser igual ou diferente do arquivo de origem.</span><span class="sxs-lookup"><span data-stu-id="067d2-105">The destination file may be the same as, or different from, the source file.</span></span>

<span data-ttu-id="067d2-106">Um sistema de arquivos gerencia os mapeamentos de [clusters e extensões](clusters-and-extents.md), e pode ser capaz de realizar a cópia alterando o número do cluster virtual (VCN) para mapeamentos de número de cluster lógico (LCN) como uma operação de metadados de baixo custo, em vez de ler e gravar os dados de arquivo subjacentes.</span><span class="sxs-lookup"><span data-stu-id="067d2-106">A file system manages the mappings of [Clusters and Extents](clusters-and-extents.md), and may be able to perform the copy by altering the virtual cluster number (VCN) to logical cluster number (LCN) mappings as a low-cost metadata operation, rather than reading and writing the underlying file data.</span></span> <span data-ttu-id="067d2-107">Isso permite que a cópia seja concluída mais rapidamente e gera menos e/s para o armazenamento subjacente.</span><span class="sxs-lookup"><span data-stu-id="067d2-107">This allows the copy to complete faster and generates less I/O to the underlying storage.</span></span> <span data-ttu-id="067d2-108">Além disso, vários arquivos podem agora compartilhar clusters lógicos após o clone do bloco, economizando capacidade, não armazenando clusters idênticos várias vezes no disco.</span><span class="sxs-lookup"><span data-stu-id="067d2-108">Moreover, multiple files may now share logical clusters after the block clone, saving capacity by not storing identical clusters multiple times on disk.</span></span>

<span data-ttu-id="067d2-109">Uma operação de clonagem de bloco não interrompe o isolamento fornecido entre os arquivos.</span><span class="sxs-lookup"><span data-stu-id="067d2-109">A block clone operation does not break the isolation provided between files.</span></span> <span data-ttu-id="067d2-110">Após a conclusão de um clone de bloco, as gravações no arquivo de origem não aparecem no destino ou vice-versa.</span><span class="sxs-lookup"><span data-stu-id="067d2-110">After a block clone completes, writes to the source file do not appear in the destination, or vice versa.</span></span>

<span data-ttu-id="067d2-111">A clonagem de bloco está disponível apenas no tipo de [sistema de arquivos ReFS](/windows/desktop/w8cookbook/resilient-file-system--refs-) a partir do Windows Server 2016.</span><span class="sxs-lookup"><span data-stu-id="067d2-111">Block cloning is available only on the [ReFS file system](/windows/desktop/w8cookbook/resilient-file-system--refs-) type beginning with Windows Server 2016.</span></span>

## <a name="block-cloning-on-refs"></a><span data-ttu-id="067d2-112">Bloquear clonagem em ReFS</span><span class="sxs-lookup"><span data-stu-id="067d2-112">Block Cloning on ReFS</span></span>

<span data-ttu-id="067d2-113">O ReFS no Windows Server 2016 implementa a clonagem de bloco ao remapear clusters lógicos (ou seja, locais físicos em um volume) da região de origem para a região de destino.</span><span class="sxs-lookup"><span data-stu-id="067d2-113">ReFS on Windows Server 2016 implements block cloning by remapping logical clusters (that is, physical locations on a volume) from the source region to the destination region.</span></span> <span data-ttu-id="067d2-114">Em seguida, ele usa um mecanismo de alocação na gravação para garantir o isolamento entre essas regiões.</span><span class="sxs-lookup"><span data-stu-id="067d2-114">It then uses an allocate-on-write mechanism to ensure isolation between those regions.</span></span> <span data-ttu-id="067d2-115">As regiões de origem e de destino podem estar nos mesmos arquivos, ou diferentes.</span><span class="sxs-lookup"><span data-stu-id="067d2-115">The source and destination regions may be in the same, or different, files.</span></span>

<span data-ttu-id="067d2-116">Essa implementação requer que os deslocamentos de arquivo inicial e final sejam alinhados aos limites do cluster.</span><span class="sxs-lookup"><span data-stu-id="067d2-116">This implementation requires that the starting and ending file offsets be aligned to cluster boundaries.</span></span> <span data-ttu-id="067d2-117">No ReFS no Windows Server 2016, os clusters têm 4 KB de tamanho por padrão, mas, opcionalmente, podem ser definidos como 64 KB.</span><span class="sxs-lookup"><span data-stu-id="067d2-117">In ReFS on Windows Server 2016, clusters are 4KB in size by default, but can optionally be set to 64KB.</span></span> <span data-ttu-id="067d2-118">O tamanho do cluster é um conjunto de parâmetros em todo o volume no momento do formato.</span><span class="sxs-lookup"><span data-stu-id="067d2-118">The cluster size is a volume-wide parameter set at format time.</span></span>

## <a name="restrictions-and-remarks"></a><span data-ttu-id="067d2-119">Restrições e comentários</span><span class="sxs-lookup"><span data-stu-id="067d2-119">Restrictions and Remarks</span></span>

-   <span data-ttu-id="067d2-120">As regiões de origem e de destino devem começar e terminar em um limite de cluster.</span><span class="sxs-lookup"><span data-stu-id="067d2-120">The source and destination regions must begin and end at a cluster boundary.</span></span>
-   <span data-ttu-id="067d2-121">A região clonada deve ter menos de 4 GB.</span><span class="sxs-lookup"><span data-stu-id="067d2-121">The cloned region must be less than 4GB in length.</span></span>
-   <span data-ttu-id="067d2-122">A região de destino não deve ultrapassar o fim do arquivo.</span><span class="sxs-lookup"><span data-stu-id="067d2-122">The destination region must not extend past the end of file.</span></span> <span data-ttu-id="067d2-123">Se o aplicativo quiser estender o destino com dados clonados, ele deverá primeiro chamar [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span><span class="sxs-lookup"><span data-stu-id="067d2-123">If the application wishes to extend the destination with cloned data, it must first call [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span></span>
-   <span data-ttu-id="067d2-124">Se as regiões de origem e de destino estiverem no mesmo arquivo, elas não deverão se sobrepor.</span><span class="sxs-lookup"><span data-stu-id="067d2-124">If the source and destination regions are in the same file, they must not overlap.</span></span> <span data-ttu-id="067d2-125">(O aplicativo pode continuar dividindo a operação bloquear clonagem em vários clones de bloco que não se sobrepõem mais.)</span><span class="sxs-lookup"><span data-stu-id="067d2-125">(The application may able to proceed by splitting up the block clone operation into multiple block clones that no longer overlap.)</span></span>
-   <span data-ttu-id="067d2-126">Os arquivos de origem e de destino devem estar no mesmo volume do ReFS.</span><span class="sxs-lookup"><span data-stu-id="067d2-126">The source and destination files must be on the same ReFS volume.</span></span>
-   <span data-ttu-id="067d2-127">Os arquivos de origem e destino devem ter a mesma configuração de [**fluxos de integridade**](file-attribute-constants.md) (ou seja, os fluxos de integridade devem ser habilitados em ambos os arquivos ou desabilitados em ambos os arquivos).</span><span class="sxs-lookup"><span data-stu-id="067d2-127">The source and destination files must have the same [**Integrity Streams**](file-attribute-constants.md) setting (that is, Integrity Streams must be enabled in both files, or disabled in both files).</span></span>
-   <span data-ttu-id="067d2-128">Se o arquivo de origem for esparso, o arquivo de destino também deverá ser esparso.</span><span class="sxs-lookup"><span data-stu-id="067d2-128">If the source file is sparse, the destination file must also be sparse.</span></span>
-   <span data-ttu-id="067d2-129">A operação bloquear clonagem interromperá bloqueios oportunistas compartilhados (também conhecidos como [bloqueios oportunistas de nível 2](types-of-opportunistic-locks.md)).</span><span class="sxs-lookup"><span data-stu-id="067d2-129">The block clone operation will break Shared Opportunistic Locks (also known as [Level 2 Opportunistic Locks](types-of-opportunistic-locks.md)).</span></span>
-   <span data-ttu-id="067d2-130">O volume ReFS deve ter sido formatado com o Windows Server 2016 e, se o clustering de failover do Windows estiver em uso, o nível funcional de clustering deverá ter sido o Windows Server 2016 ou posterior no formato de hora.</span><span class="sxs-lookup"><span data-stu-id="067d2-130">The ReFS volume must have been formatted with Windows Server 2016, and if Windows Failover Clustering is in use, the Clustering Functional Level must have been Windows Server 2016 or later at format time.</span></span>

## <a name="example"></a><span data-ttu-id="067d2-131">Exemplo</span><span class="sxs-lookup"><span data-stu-id="067d2-131">Example</span></span>

<span data-ttu-id="067d2-132">Suponha que tenhamos dois arquivos, X e Y, onde cada arquivo é composto por 3 regiões distintas.</span><span class="sxs-lookup"><span data-stu-id="067d2-132">Suppose we have two files, X and Y, where each file is composed of 3 distinct regions.</span></span> <span data-ttu-id="067d2-133">Cada região de arquivo é armazenada em uma região distinta do volume.</span><span class="sxs-lookup"><span data-stu-id="067d2-133">Each file region is stored on a distinct region of the volume.</span></span> <span data-ttu-id="067d2-134">O sistema de arquivos armazena o conhecimento de que cada uma dessas regiões de volume é referenciada em uma região de arquivo:</span><span class="sxs-lookup"><span data-stu-id="067d2-134">The file system stores the knowledge that each of those volume regions is referenced in one file region:</span></span>

![antes do clone](images/before-clone.png)

<span data-ttu-id="067d2-136">Agora suponha que um aplicativo emita uma operação de clonagem de bloco do arquivo X, nas regiões de arquivo A e B, para o arquivo Y no deslocamento onde E atualmente é.</span><span class="sxs-lookup"><span data-stu-id="067d2-136">Now suppose an application issues a block clone operation from File X, over file regions A and B, to File Y at the offset where E currently is.</span></span> <span data-ttu-id="067d2-137">O seguinte estado do sistema de arquivos resultaria:</span><span class="sxs-lookup"><span data-stu-id="067d2-137">The following file system state would result:</span></span>

![após o clone](images/after-clone.png)

<span data-ttu-id="067d2-139">Os dados nas regiões A e B eram efetivamente duplicados do arquivo X para o arquivo Y alterando o VCN para mapeamentos de LCN dentro do volume ReFS.</span><span class="sxs-lookup"><span data-stu-id="067d2-139">The data in regions A and B were effectively duplicated from File X to File Y by altering the VCN to LCN mappings within the ReFS volume.</span></span> <span data-ttu-id="067d2-140">As extensões de disco nas regiões A e B não foram lidas, nem as extensões de disco que faziam o backup das regiões antigas e e F foram substituídas durante a operação.</span><span class="sxs-lookup"><span data-stu-id="067d2-140">The disk extents backing regions A and B were not read, nor were the disk extents backing the old regions E and F overwritten during the operation.</span></span>

<span data-ttu-id="067d2-141">Os arquivos X e Y agora compartilham clusters lógicos no disco.</span><span class="sxs-lookup"><span data-stu-id="067d2-141">Files X and Y now share logical clusters on disk.</span></span> <span data-ttu-id="067d2-142">Isso é refletido nas contagens de referência mostradas na tabela.</span><span class="sxs-lookup"><span data-stu-id="067d2-142">This is reflected in the reference counts shown in the table.</span></span> <span data-ttu-id="067d2-143">O compartilhamento resulta em um consumo de capacidade de volume menor do que se as regiões A e B estivessem duplicadas no volume subjacente.</span><span class="sxs-lookup"><span data-stu-id="067d2-143">The sharing results in lower volume capacity consumption than if regions A and B were duplicated on the underlying volume.</span></span>

<span data-ttu-id="067d2-144">Agora, suponha que o aplicativo substitua a região A no arquivo X. ReFS faz uma cópia duplicada de A, que agora chamamos de G. ReFS e, em seguida, mapeia G no arquivo X e aplica a modificação.</span><span class="sxs-lookup"><span data-stu-id="067d2-144">Now, suppose the application overwrites region A in File X. ReFS makes a duplicate copy of A, which we’ll now call G. ReFS then maps G into File X, and applies the modification.</span></span> <span data-ttu-id="067d2-145">Isso garante que o isolamento entre os arquivos seja preservado.</span><span class="sxs-lookup"><span data-stu-id="067d2-145">This ensures that isolation between the files is preserved.</span></span> <span data-ttu-id="067d2-146">As contagens de referência são atualizadas adequadamente:</span><span class="sxs-lookup"><span data-stu-id="067d2-146">Reference counts are updated appropriately:</span></span>

![Depois de modificar a gravação](images/after-modifying-write.png)

<span data-ttu-id="067d2-148">Após a gravação de modificação, a região B ainda é compartilhada no disco.</span><span class="sxs-lookup"><span data-stu-id="067d2-148">After the modifying write, region B is still shared on disk.</span></span> <span data-ttu-id="067d2-149">Observe que, se a região A fosse maior que um cluster, somente o cluster modificado teria sido duplicado, e a parte restante continuaria compartilhada.</span><span class="sxs-lookup"><span data-stu-id="067d2-149">Note that if region A were larger than a cluster, only the modified cluster would have been duplicated, and the remaining portion would have remained shared.</span></span>

## <a name="related-topics"></a><span data-ttu-id="067d2-150">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="067d2-150">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="067d2-151">**dados de extensões DUPLICAdas \_ \_**</span><span class="sxs-lookup"><span data-stu-id="067d2-151">**DUPLICATE\_EXTENTS\_DATA**</span></span>](/windows/desktop/api/WinIoCtl/ns-winioctl-duplicate_extents_data)
</dt> <dt>

[<span data-ttu-id="067d2-152">**FSCTL \_ \_ extensões duplicadas \_ para o \_ arquivo**</span><span class="sxs-lookup"><span data-stu-id="067d2-152">**FSCTL\_DUPLICATE\_EXTENTS\_TO\_FILE**</span></span>](/windows/win32/api/winioctl/ni-winioctl-fsctl_duplicate_extents_to_file)
</dt> </dl>

 

 
