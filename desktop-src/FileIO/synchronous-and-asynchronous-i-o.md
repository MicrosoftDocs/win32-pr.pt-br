---
description: 'Há dois tipos de sincronização de e/s (entrada/saída): e/s síncrona e e/SS assíncrona. E/s assíncrona também é conhecida como e/s sobreposta.'
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: E/s síncrona e síncrona
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 071dd2943537dcb6aff67a95cb5e2c3d514f4c1a
ms.sourcegitcommit: af120ad5c30da2fc5eb717ca2a1c4c45878efd71
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/20/2021
ms.locfileid: "105758039"
---
# <a name="synchronous-and-asynchronous-io"></a><span data-ttu-id="c182d-104">E/s síncrona e síncrona</span><span class="sxs-lookup"><span data-stu-id="c182d-104">Synchronous and Asynchronous I/O</span></span>

<span data-ttu-id="c182d-105">Consulte também [aplicativos de exemplo relacionados a e/s](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span><span class="sxs-lookup"><span data-stu-id="c182d-105">Also see [I/O-related sample applications](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span></span>

<span data-ttu-id="c182d-106">Há dois tipos de sincronização de e/s (entrada/saída): e/s síncrona e e/SS assíncrona.</span><span class="sxs-lookup"><span data-stu-id="c182d-106">There are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="c182d-107">E/s assíncrona também é conhecida como e/s sobreposta.</span><span class="sxs-lookup"><span data-stu-id="c182d-107">Asynchronous I/O is also referred to as overlapped I/O.</span></span>

<span data-ttu-id="c182d-108">Em *e/s de arquivo síncrono*, um thread inicia uma operação de e/s e entra imediatamente em um estado de espera até que a solicitação de e/s seja concluída.</span><span class="sxs-lookup"><span data-stu-id="c182d-108">In *synchronous file I/O*, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed.</span></span> <span data-ttu-id="c182d-109">Um thread que executa a e */s de arquivo assíncrono* envia uma solicitação de e/s para o kernel chamando uma função apropriada.</span><span class="sxs-lookup"><span data-stu-id="c182d-109">A thread performing *asynchronous file I/O* sends an I/O request to the kernel by calling an appropriate function.</span></span> <span data-ttu-id="c182d-110">Se a solicitação for aceita pelo kernel, o thread de chamada continuará processando outro trabalho até que o kernel sinalize ao thread de que a operação de e/s está concluída.</span><span class="sxs-lookup"><span data-stu-id="c182d-110">If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete.</span></span> <span data-ttu-id="c182d-111">Em seguida, ele interrompe seu trabalho atual e processa os dados da operação de e/s conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="c182d-111">It then interrupts its current job and processes the data from the I/O operation as necessary.</span></span>

<span data-ttu-id="c182d-112">Os dois tipos de sincronização são ilustrados na figura a seguir.</span><span class="sxs-lookup"><span data-stu-id="c182d-112">The two synchronization types are illustrated in the following figure.</span></span>

![e/s síncrona e síncrona](images/fig2bedit.png)

<span data-ttu-id="c182d-114">Em situações em que espera-se que uma solicitação de e/s demore muito tempo, como uma atualização ou um backup de um banco de dados grande ou um link de comunicação lento, a e/s assíncrona geralmente é uma boa maneira de otimizar a eficiência do processamento.</span><span class="sxs-lookup"><span data-stu-id="c182d-114">In situations where an I/O request is expected to take a large amount of time, such as a refresh or backup of a large database or a slow communications link, asynchronous I/O is generally a good way to optimize processing efficiency.</span></span> <span data-ttu-id="c182d-115">No entanto, para operações de e/s relativamente rápidas, a sobrecarga de processamento de solicitações de e/s de kernel e sinais de kernel pode tornar a e/s assíncrona menos benéfica, especialmente se muitas operações de e/s rápidas precisarem ser feitas.</span><span class="sxs-lookup"><span data-stu-id="c182d-115">However, for relatively fast I/O operations, the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial, particularly if many fast I/O operations need to be made.</span></span> <span data-ttu-id="c182d-116">Nesse caso, a e/s síncrona seria melhor.</span><span class="sxs-lookup"><span data-stu-id="c182d-116">In this case, synchronous I/O would be better.</span></span> <span data-ttu-id="c182d-117">Os mecanismos e os detalhes de implementação de como realizar essas tarefas variam de acordo com o tipo de identificador de dispositivo usado e as necessidades específicas do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c182d-117">The mechanisms and implementation details of how to accomplish these tasks vary depending on the type of device handle that is used and the particular needs of the application.</span></span> <span data-ttu-id="c182d-118">Em outras palavras, geralmente há várias maneiras de resolver o problema.</span><span class="sxs-lookup"><span data-stu-id="c182d-118">In other words, there are usually multiple ways to solve the problem.</span></span>

## <a name="synchronous-and-asynchronous-io-considerations"></a><span data-ttu-id="c182d-119">Considerações de e/s síncronas e assíncronas</span><span class="sxs-lookup"><span data-stu-id="c182d-119">Synchronous and Asynchronous I/O Considerations</span></span>

<span data-ttu-id="c182d-120">Se um arquivo ou dispositivo for aberto para e/s síncrona (ou seja, **o \_ sinalizador \_ de arquivo sobreposto** não for especificado), as chamadas subsequentes para funções como [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) poderão bloquear a execução do thread de chamada até que ocorra um dos seguintes eventos:</span><span class="sxs-lookup"><span data-stu-id="c182d-120">If a file or device is opened for synchronous I/O (that is, **FILE\_FLAG\_OVERLAPPED** is not specified), subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) can block execution of the calling thread until one of the following events occurs:</span></span>

-   <span data-ttu-id="c182d-121">A operação de e/s é concluída (neste exemplo, uma gravação de dados).</span><span class="sxs-lookup"><span data-stu-id="c182d-121">The I/O operation completes (in this example, a data write).</span></span>
-   <span data-ttu-id="c182d-122">Ocorre um erro de E/S.</span><span class="sxs-lookup"><span data-stu-id="c182d-122">An I/O error occurs.</span></span> <span data-ttu-id="c182d-123">(Por exemplo, o pipe é fechado da outra extremidade.)</span><span class="sxs-lookup"><span data-stu-id="c182d-123">(For example, the pipe is closed from the other end.)</span></span>
-   <span data-ttu-id="c182d-124">Foi feito um erro na chamada em si (por exemplo, um ou mais parâmetros não são válidos).</span><span class="sxs-lookup"><span data-stu-id="c182d-124">An error was made in the call itself (for example, one or more parameters are not valid).</span></span>
-   <span data-ttu-id="c182d-125">Outro thread no processo chama a função [**CancelSynchronousIo**](cancelsynchronousio-func.md) usando o identificador de thread do thread bloqueado, que encerra a e/s para esse thread, falha na operação de e/s.</span><span class="sxs-lookup"><span data-stu-id="c182d-125">Another thread in the process calls the [**CancelSynchronousIo**](cancelsynchronousio-func.md) function using the blocked thread's thread handle, which terminates I/O for that thread, failing the I/O operation.</span></span>
-   <span data-ttu-id="c182d-126">O thread bloqueado é encerrado pelo sistema; por exemplo, o próprio processo é encerrado ou outro thread chama a função [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) usando o identificador do thread bloqueado.</span><span class="sxs-lookup"><span data-stu-id="c182d-126">The blocked thread is terminated by the system; for example, the process itself is terminated, or another thread calls the [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) function using the blocked thread's handle.</span></span> <span data-ttu-id="c182d-127">(Isso geralmente é considerado um último recurso e não um bom design de aplicativo.)</span><span class="sxs-lookup"><span data-stu-id="c182d-127">(This is generally considered a last resort and not good application design.)</span></span>

<span data-ttu-id="c182d-128">Em alguns casos, esse atraso pode ser inaceitável para o design e a finalidade do aplicativo, portanto, os designers de aplicativos devem considerar O uso de e/s assíncrona com objetos de sincronização de thread apropriados, como [portas de conclusão de e/s](i-o-completion-ports.md).</span><span class="sxs-lookup"><span data-stu-id="c182d-128">In some cases, this delay may be unacceptable to the application's design and purpose, so application designers should consider using asynchronous I/O with appropriate thread synchronization objects such as [I/O completion ports](i-o-completion-ports.md).</span></span> <span data-ttu-id="c182d-129">Para obter mais informações sobre a sincronização de threads, consulte [sobre a sincronização](/windows/desktop/Sync/about-synchronization).</span><span class="sxs-lookup"><span data-stu-id="c182d-129">For more information about thread synchronization, see [About Synchronization](/windows/desktop/Sync/about-synchronization).</span></span>

<span data-ttu-id="c182d-130">Um processo abre um arquivo para e/s assíncrona em sua chamada para [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) especificando o sinalizador de **\_ sinalizador \_ sobreposto do arquivo** no parâmetro *dwFlagsAndAttributes* .</span><span class="sxs-lookup"><span data-stu-id="c182d-130">A process opens a file for asynchronous I/O in its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) by specifying the **FILE\_FLAG\_OVERLAPPED** flag in the *dwFlagsAndAttributes* parameter.</span></span> <span data-ttu-id="c182d-131">Se **o \_ sinalizador \_ de arquivo sobreposto** não for especificado, o arquivo será aberto para e/s síncrona.</span><span class="sxs-lookup"><span data-stu-id="c182d-131">If **FILE\_FLAG\_OVERLAPPED** is not specified, the file is opened for synchronous I/O.</span></span> <span data-ttu-id="c182d-132">Quando o arquivo foi aberto para e/s assíncrona, um ponteiro para uma estrutura [**sobreposta**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) é passado para a chamada para [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) e [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="c182d-132">When the file has been opened for asynchronous I/O, a pointer to an [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure is passed into the call to [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="c182d-133">Ao executar e/s síncrona, essa estrutura não é necessária em chamadas para **ReadFile** e **WriteFile**.</span><span class="sxs-lookup"><span data-stu-id="c182d-133">When performing synchronous I/O, this structure is not required in calls to **ReadFile** and **WriteFile**.</span></span>

> [!Note]  
> <span data-ttu-id="c182d-134">Se um arquivo ou dispositivo for aberto para e/s assíncrona, as chamadas subsequentes para funções como [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) usando esse identificador geralmente retornarão imediatamente, mas também podem se comportar de forma síncrona em relação à execução bloqueada.</span><span class="sxs-lookup"><span data-stu-id="c182d-134">If a file or device is opened for asynchronous I/O, subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) using that handle generally return immediately but can also behave synchronously with respect to blocked execution.</span></span> <span data-ttu-id="c182d-135">Para obter mais informações, confira [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span><span class="sxs-lookup"><span data-stu-id="c182d-135">For more information, see [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span></span>

 

<span data-ttu-id="c182d-136">Embora [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) seja a função mais comum a ser usada para abrir arquivos, volumes de disco, Pipes anônimos e outros dispositivos semelhantes, as operações de e/s também podem ser executadas usando um identificador *conversão* de outros objetos do sistema, como um soquete criado pelo [**soquete**](/windows/desktop/api/winsock2/nf-winsock2-socket) ou [**aceitam**](/windows/desktop/api/winsock2/nf-winsock2-accept) funções.</span><span class="sxs-lookup"><span data-stu-id="c182d-136">Although [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) is the most common function to use for opening files, disk volumes, anonymous pipes, and other similar devices, I/O operations can also be performed using a handle *typecast* from other system objects such as a socket created by the [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) or [**accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) functions.</span></span>

<span data-ttu-id="c182d-137">Identificadores para objetos de diretório são obtidos chamando a função [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) com o atributo **arquivo de \_ \_ \_ semântica de backup de sinalizador** .</span><span class="sxs-lookup"><span data-stu-id="c182d-137">Handles to directory objects are obtained by calling the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function with the **FILE\_FLAG\_BACKUP\_SEMANTICS** attribute.</span></span> <span data-ttu-id="c182d-138">Identificadores de diretório quase nunca são usados — aplicativos de backup são um dos poucos aplicativos que normalmente os usarão.</span><span class="sxs-lookup"><span data-stu-id="c182d-138">Directory handles are almost never used—backup applications are one of the few applications that will typically use them.</span></span>

<span data-ttu-id="c182d-139">Depois de abrir o objeto de arquivo para e/s assíncrona, uma estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) deve ser criada, inicializada e passada corretamente em cada chamada para funções como [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) e [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="c182d-139">After opening the file object for asynchronous I/O, an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must be properly created, initialized, and passed into each call to functions such as [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="c182d-140">Tenha em mente o seguinte ao usar a estrutura [**sobreposta**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) em operações assíncronas de leitura e gravação:</span><span class="sxs-lookup"><span data-stu-id="c182d-140">Keep the following in mind when using the [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure in asynchronous read and write operations:</span></span>

-   <span data-ttu-id="c182d-141">Não desaloque ou modifique a estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ou o buffer de dados até que todas as operações de e/s assíncronas para o objeto de arquivo tenham sido concluídas.</span><span class="sxs-lookup"><span data-stu-id="c182d-141">Do not deallocate or modify the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure or the data buffer until all asynchronous I/O operations to the file object have been completed.</span></span>
-   <span data-ttu-id="c182d-142">Se você declarar o ponteiro para a estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) como uma variável local, não saia da função local até que todas as operações de e/s assíncronas para o objeto de arquivo tenham sido concluídas.</span><span class="sxs-lookup"><span data-stu-id="c182d-142">If you declare your pointer to the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure as a local variable, do not exit the local function until all asynchronous I/O operations to the file object have been completed.</span></span> <span data-ttu-id="c182d-143">Se a função local for encerrada prematuramente, a estrutura **sobreposta** sairá do escopo e será inacessível para as funções [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) ou [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) que encontrar fora dessa função.</span><span class="sxs-lookup"><span data-stu-id="c182d-143">If the local function is exited prematurely, the **OVERLAPPED** structure will go out of scope and it will be inaccessible to any [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) functions it encounters outside of that function.</span></span>

<span data-ttu-id="c182d-144">Você também pode criar um evento e colocar o identificador na estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ; as [funções Wait](/windows/desktop/Sync/wait-functions) podem então ser usadas para aguardar a conclusão da operação de e/s aguardando o identificador de evento.</span><span class="sxs-lookup"><span data-stu-id="c182d-144">You can also create an event and put the handle in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure; the [wait functions](/windows/desktop/Sync/wait-functions) can then be used to wait for the I/O operation to complete by waiting on the event handle.</span></span>

<span data-ttu-id="c182d-145">Como mencionado anteriormente, ao trabalhar com um identificador assíncrono, os aplicativos devem tomar cuidado ao fazer determinações sobre quando liberar recursos associados a uma operação de e/s especificada nesse identificador.</span><span class="sxs-lookup"><span data-stu-id="c182d-145">As previously stated, when working with an asynchronous handle, applications should use care when making determinations about when to free resources associated with a specified I/O operation on that handle.</span></span> <span data-ttu-id="c182d-146">Se o identificador for desalocado prematuramente, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) ou [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) poderá relatar incorretamente que a operação de e/s está concluída.</span><span class="sxs-lookup"><span data-stu-id="c182d-146">If the handle is deallocated prematurely, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) may incorrectly report that the I/O operation is complete.</span></span> <span data-ttu-id="c182d-147">Além disso, a função **WriteFile** às vezes retorna **true** com um valor [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) de **\_ êxito de erro**, mesmo que esteja usando um identificador assíncrono (que também pode retornar **false** com **erro \_ e/s \_ pendente**).</span><span class="sxs-lookup"><span data-stu-id="c182d-147">Further, the **WriteFile** function will sometimes return **TRUE** with a [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) value of **ERROR\_SUCCESS**, even though it is using an asynchronous handle (which can also return **FALSE** with **ERROR\_IO\_PENDING**).</span></span> <span data-ttu-id="c182d-148">Os programadores acostumados ao design de e/s síncrono normalmente lançarão os recursos de buffer de dados neste ponto, porque **verdadeiro** e o **\_ êxito do erro** significam que a operação foi concluída.</span><span class="sxs-lookup"><span data-stu-id="c182d-148">Programmers accustomed to synchronous I/O design will usually release data buffer resources at this point because **TRUE** and **ERROR\_SUCCESS** signify the operation is complete.</span></span> <span data-ttu-id="c182d-149">No entanto, se [as portas de conclusão de e/s](i-o-completion-ports.md) estiverem sendo usadas com esse identificador assíncrono, um pacote de conclusão também será enviado, mesmo que a operação de e/s seja concluída imediatamente.</span><span class="sxs-lookup"><span data-stu-id="c182d-149">However, if [I/O completion ports](i-o-completion-ports.md) are being used with this asynchronous handle, a completion packet will also be sent even though the I/O operation completed immediately.</span></span> <span data-ttu-id="c182d-150">Em outras palavras, se o aplicativo liberar recursos após **WriteFile** retornar **true** com o **\_ êxito de erro** além da rotina de porta de conclusão de e/s, ele terá uma condição de erro livre.</span><span class="sxs-lookup"><span data-stu-id="c182d-150">In other words, if the application frees resources after **WriteFile** returns **TRUE** with **ERROR\_SUCCESS** in addition to in the I/O completion port routine, it will have a double-free error condition.</span></span> <span data-ttu-id="c182d-151">Neste exemplo, a recomendação seria permitir que a rotina de porta de conclusão seja exclusivamente responsável por todas as operações de liberação para tais recursos.</span><span class="sxs-lookup"><span data-stu-id="c182d-151">In this example, the recommendation would be to allow the completion port routine to be solely responsible for all freeing operations for such resources.</span></span>

<span data-ttu-id="c182d-152">O sistema não mantém o ponteiro do arquivo em identificadores assíncronos para arquivos e dispositivos que dão suporte a ponteiros de arquivo (ou seja, dispositivos de busca), portanto, a posição do arquivo deve ser passada para as funções de leitura e gravação nos membros de dados de deslocamento relacionados da estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="c182d-152">The system does not maintain the file pointer on asynchronous handles to files and devices that support file pointers (that is, seeking devices), therefore the file position must be passed to the read and write functions in the related offset data members of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="c182d-153">Para obter mais informações, consulte [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) e [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span><span class="sxs-lookup"><span data-stu-id="c182d-153">For more information, see [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) and [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span></span>

<span data-ttu-id="c182d-154">A posição do ponteiro de arquivo para um identificador síncrono é mantida pelo sistema, pois os dados são lidos ou gravados e também podem ser atualizados usando a função [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) ou [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) .</span><span class="sxs-lookup"><span data-stu-id="c182d-154">File pointer position for a synchronous handle is maintained by the system as data is read or written and can also be updated using the [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) or [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) function.</span></span>

<span data-ttu-id="c182d-155">Um aplicativo também pode aguardar o identificador de arquivo para sincronizar a conclusão de uma operação de e/s, mas isso requer extrema cautela.</span><span class="sxs-lookup"><span data-stu-id="c182d-155">An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution.</span></span> <span data-ttu-id="c182d-156">Cada vez que uma operação de e/s é iniciada, o sistema operacional define o identificador de arquivo para o estado não sinalizado.</span><span class="sxs-lookup"><span data-stu-id="c182d-156">Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state.</span></span> <span data-ttu-id="c182d-157">Cada vez que uma operação de e/s é concluída, o sistema operacional define o identificador de arquivo para o estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="c182d-157">Each time an I/O operation is completed, the operating system sets the file handle to the signaled state.</span></span> <span data-ttu-id="c182d-158">Portanto, se um aplicativo iniciar duas operações de e/s e aguardar o identificador do arquivo, não será possível determinar qual operação será concluída quando o identificador for definido como o estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="c182d-158">Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state.</span></span> <span data-ttu-id="c182d-159">Se um aplicativo precisar executar várias operações de e/s assíncronas em um único arquivo, ele deverá aguardar o identificador de evento na estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) específica para cada operação de e/s, em vez do identificador de arquivo comum.</span><span class="sxs-lookup"><span data-stu-id="c182d-159">If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the specific [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for each I/O operation, rather than on the common file handle.</span></span>

<span data-ttu-id="c182d-160">Para cancelar todas as operações de e/s assíncronas pendentes, use:</span><span class="sxs-lookup"><span data-stu-id="c182d-160">To cancel all pending asynchronous I/O operations, use either:</span></span>

-   <span data-ttu-id="c182d-161">[**CancelIo**](cancelio.md)– essa função cancela apenas as operações emitidas pelo thread de chamada para o identificador de arquivo especificado.</span><span class="sxs-lookup"><span data-stu-id="c182d-161">[**CancelIo**](cancelio.md)—this function only cancels operations issued by the calling thread for the specified file handle.</span></span>
-   <span data-ttu-id="c182d-162">[**CancelIoEx**](cancelioex-func.md)– essa função cancela todas as operações emitidas pelos threads para o identificador de arquivo especificado.</span><span class="sxs-lookup"><span data-stu-id="c182d-162">[**CancelIoEx**](cancelioex-func.md)—this function cancels all operations issued by the threads for the specified file handle.</span></span>

<span data-ttu-id="c182d-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) para cancelar operações de e/s síncronas pendentes.</span><span class="sxs-lookup"><span data-stu-id="c182d-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) to cancel pending synchronous I/O operations.</span></span>

<span data-ttu-id="c182d-164">As funções [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) e [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) permitem que um aplicativo especifique uma rotina a ser executada (consulte [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) quando a solicitação de e/s assíncrona for concluída.</span><span class="sxs-lookup"><span data-stu-id="c182d-164">The [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) functions enable an application to specify a routine to execute (see [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) when the asynchronous I/O request is completed.</span></span>

 

 
