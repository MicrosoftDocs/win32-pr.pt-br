---
description: Descreve as considerações sobre O controle de aplicativo do buffer de arquivo, também conhecido como e/s (entrada/saída) de arquivo sem buffer.
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: Armazenar arquivo em buffer
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104171502"
---
# <a name="file-buffering"></a><span data-ttu-id="2e8cc-103">Armazenar arquivo em buffer</span><span class="sxs-lookup"><span data-stu-id="2e8cc-103">File Buffering</span></span>

<span data-ttu-id="2e8cc-104">Este tópico aborda as várias considerações para o controle de aplicativo do buffer de arquivo, também conhecido como e/s (entrada/saída) de arquivo sem buffer.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-104">This topic covers the various considerations for application control of file buffering, also known as unbuffered file input/output (I/O).</span></span> <span data-ttu-id="2e8cc-105">O buffer de arquivos geralmente é tratado pelo sistema nos bastidores e é considerado parte do [cache de arquivos](file-caching.md) no sistema operacional Windows, a menos que especificado de outra forma.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-105">File buffering is usually handled by the system behind the scenes and is considered part of [file caching](file-caching.md) within the Windows operating system unless otherwise specified.</span></span> <span data-ttu-id="2e8cc-106">Embora os termos *cache* e *buffer* , às vezes, sejam usados de maneira intercambiável, este tópico usa o termo *buffering* especificamente no contexto explicando como interagir com os dados que não estão sendo armazenados em cache (em buffer) pelo sistema, onde ele é, de outra forma, parte do controle direto de aplicativos de modo de usuário.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-106">Although the terms *caching* and *buffering* are sometimes used interchangeably, this topic uses the term *buffering* specifically in the context of explaining how to interact with data that is not being cached (buffered) by the system, where it is otherwise largely out of the direct control of user-mode applications.</span></span>

<span data-ttu-id="2e8cc-107">Ao abrir ou criar um arquivo com a função [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) , o sinalizador de **arquivo sem sinalizador de \_ \_ \_ buffer** pode ser especificado para desabilitar o cache do sistema de dados que estão sendo lidos ou gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-107">When opening or creating a file with the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function, the **FILE\_FLAG\_NO\_BUFFERING** flag can be specified to disable system caching of data being read from or written to the file.</span></span> <span data-ttu-id="2e8cc-108">Embora isso forneça controle completo e direto sobre O buffer de e/s de dados, no caso de arquivos e dispositivos semelhantes, há requisitos de alinhamento de dados que devem ser considerados.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-108">Although this gives complete and direct control over data I/O buffering, in the case of files and similar devices there are data alignment requirements that must be considered.</span></span>

> [!Note]  
> <span data-ttu-id="2e8cc-109">Essas informações de alinhamento se aplicam à e/s em dispositivos, como arquivos que dão suporte à busca e ao conceito de ponteiros de posição de arquivo (ou *deslocamentos*).</span><span class="sxs-lookup"><span data-stu-id="2e8cc-109">This alignment information applies to I/O on devices such as files that support seeking and the concept of file position pointers (or *offsets*).</span></span> <span data-ttu-id="2e8cc-110">Para dispositivos que não buscam, como pipes nomeados ou dispositivos de comunicação, desativar o buffer pode não exigir nenhum alinhamento específico.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-110">For devices that do not seek, such as named pipes or communications devices, turning off buffering may not require any particular alignment.</span></span> <span data-ttu-id="2e8cc-111">Quaisquer limitações ou eficiências que possam ser obtidas pelo alinhamento nesse caso dependem da tecnologia subjacente.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-111">Any limitations or efficiencies that may be gained by alignment in that case are dependent on the underlying technology.</span></span>

 

<span data-ttu-id="2e8cc-112">Em um exemplo simples, o aplicativo abriria um arquivo para acesso de gravação com o sinalizador **File \_ Flag \_ no \_ buffer** e, em seguida, executaria uma chamada para a função [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) usando um buffer de dados definido no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-112">In a simple example, the application would open a file for write access with the **FILE\_FLAG\_NO\_BUFFERING** flag and then perform a call to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function using a data buffer defined within the application.</span></span> <span data-ttu-id="2e8cc-113">Esse buffer local é, nessas circunstâncias, efetivamente o único buffer de arquivo que existe para essa operação.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-113">This local buffer is, in these circumstances, effectively the only file buffer that exists for this operation.</span></span> <span data-ttu-id="2e8cc-114">Devido ao layout do disco físico, ao layout do armazenamento do sistema de arquivos e ao controle da posição do ponteiro de arquivo no nível do sistema, essa operação de gravação falhará, a menos que os buffers de dados definidos localmente atendam a certos critérios de alinhamento, discutidos na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-114">Because of physical disk layout, file system storage layout, and system-level file pointer position tracking, this write operation will fail unless the locally-defined data buffers meet certain alignment criteria, discussed in the following section.</span></span>

> [!Note]  
> <span data-ttu-id="2e8cc-115">A discussão sobre Caching não considera nenhum cache de hardware no próprio disco físico, o que não é garantido que esteja dentro do controle direto do sistema em qualquer caso.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-115">Discussion of caching does not consider any hardware caching on the physical disk itself, which is not guaranteed to be within the direct control of the system in any case.</span></span> <span data-ttu-id="2e8cc-116">Isso não tem nenhum efeito sobre os requisitos especificados neste tópico.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-116">This has no effect on the requirements specified in this topic.</span></span>

 

<span data-ttu-id="2e8cc-117">Para obter mais informações sobre como o **sinalizador de arquivo \_ \_ sem \_ buffer** interage com outros sinalizadores relacionados ao cache, consulte [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span><span class="sxs-lookup"><span data-stu-id="2e8cc-117">For more information on how **FILE\_FLAG\_NO\_BUFFERING** interacts with other cache-related flags, see [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span>

## <a name="alignment-and-file-access-requirements"></a><span data-ttu-id="2e8cc-118">Requisitos de acesso de alinhamento e arquivo</span><span class="sxs-lookup"><span data-stu-id="2e8cc-118">Alignment and File Access Requirements</span></span>

<span data-ttu-id="2e8cc-119">Conforme discutido anteriormente, um aplicativo deve atender a certos requisitos ao trabalhar com arquivos abertos com o **sinalizador de arquivo \_ \_ sem \_ buffer**.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-119">As previously discussed, an application must meet certain requirements when working with files opened with **FILE\_FLAG\_NO\_BUFFERING**.</span></span> <span data-ttu-id="2e8cc-120">As seguintes especificações se aplicam:</span><span class="sxs-lookup"><span data-stu-id="2e8cc-120">The following specifics apply:</span></span>

-   <span data-ttu-id="2e8cc-121">Tamanhos de acesso de arquivo, incluindo o deslocamento de arquivo opcional na estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , se especificado, devem ser para um número de bytes que é um inteiro múltiplo do tamanho do setor de volume.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-121">File access sizes, including the optional file offset in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, if specified, must be for a number of bytes that is an integer multiple of the volume sector size.</span></span> <span data-ttu-id="2e8cc-122">Por exemplo, se o tamanho do setor for 512 bytes, um aplicativo poderá solicitar leituras e gravações de 512, 1.024, 1.536 ou 2.048 bytes, mas não de 335, 981 ou 7.171 bytes.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-122">For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1,024, 1,536, or 2,048 bytes, but not of 335, 981, or 7,171 bytes.</span></span>
-   <span data-ttu-id="2e8cc-123">Os endereços de buffer de acesso a arquivos para operações de leitura e gravação devem ser alinhados ao setor físico, o que significa que alinhado em endereços na memória que são múltiplos inteiros do tamanho do setor físico do volume.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-123">File access buffer addresses for read and write operations should be physical sector-aligned, which means aligned on addresses in memory that are integer multiples of the volume's physical sector size.</span></span> <span data-ttu-id="2e8cc-124">Dependendo do disco, esse requisito pode não ser imposto.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-124">Depending on the disk, this requirement may not be enforced.</span></span>

<span data-ttu-id="2e8cc-125">Os desenvolvedores de aplicativos devem anotar os novos tipos de dispositivos de armazenamento introduzidos no mercado com um tamanho de setor de mídia física de 4.096 bytes.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-125">Application developers should take note of new types of storage devices being introduced into the market with a physical media sector size of 4,096 bytes.</span></span> <span data-ttu-id="2e8cc-126">O nome do setor para esses dispositivos é "Advanced Format".</span><span class="sxs-lookup"><span data-stu-id="2e8cc-126">The industry name for these devices is "Advanced Format".</span></span> <span data-ttu-id="2e8cc-127">Como pode haver problemas de compatibilidade com a introdução direta de 4.096 bytes como a unidade de endereçamento para a mídia, uma solução de compatibilidade temporária é introduzir dispositivos que emulam um dispositivo de armazenamento de setor de 512 bytes regular, mas disponibilizam informações sobre o tamanho de setor real por meio de comandos ATA e SCSI padrão.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-127">As there may be compatibility issues with directly introducing 4,096 bytes as the unit of addressing for the media, a temporary compatibility solution is to introduce devices that emulate a regular 512-byte sector storage device but make available information about the true sector size through standard ATA and SCSI commands.</span></span>

<span data-ttu-id="2e8cc-128">Como resultado dessa emulação, há, na essência, dois tamanhos de setor que os desenvolvedores precisarão entender:</span><span class="sxs-lookup"><span data-stu-id="2e8cc-128">As a result of this emulation, there are in essence two sector sizes that developers will need to understand:</span></span>

-   <span data-ttu-id="2e8cc-129">Setor lógico: a unidade usada para endereçamento de bloco lógico para a mídia.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-129">Logical Sector: The unit that is used for logical block addressing for the media.</span></span> <span data-ttu-id="2e8cc-130">Também podemos considerar isso como a menor unidade de gravação que o armazenamento pode aceitar.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-130">We can also think of it as the smallest unit of write that the storage can accept.</span></span> <span data-ttu-id="2e8cc-131">Esta é a "emulação".</span><span class="sxs-lookup"><span data-stu-id="2e8cc-131">This is the "emulation".</span></span>
-   <span data-ttu-id="2e8cc-132">Setor físico: a unidade para a qual as operações de leitura e gravação para o dispositivo são concluídas em uma única operação.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-132">Physical Sector: The unit for which read and write operations to the device are completed in a single operation.</span></span> <span data-ttu-id="2e8cc-133">Essa é a unidade de gravação atômica e qual e/s sem buffer precisará ser alinhada para ter as características de desempenho e confiabilidade ideais.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-133">This is the unit of atomic write, and what unbuffered I/O will need to be aligned to in order to have optimal performance and reliability characteristics.</span></span>

<span data-ttu-id="2e8cc-134">A maioria das APIs do Windows atuais, como o disco do IOCTL [](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), a [**\_ \_ \_ \_ geometria da unidade**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) e GetDiskFreeSpace, retornará o tamanho do setor lógico, mas o tamanho do setor físico pode ser recuperado por meio do código de controle da [**\_ \_ \_ propriedade de consulta de armazenamento do IOCTL**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) , com as informações relevantes contidas no membro **BytesPerPhysicalSector** na estrutura do [**\_ \_ \_ descritor de alinhamento de acesso de armazenamento**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) .</span><span class="sxs-lookup"><span data-stu-id="2e8cc-134">Most current Windows APIs, such as [**IOCTL\_DISK\_GET\_DRIVE\_GEOMETRY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) and [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), will return the logical sector size, but the physical sector size can be retrieved through the [**IOCTL\_STORAGE\_QUERY\_PROPERTY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) control code, with the relevant information contained in the **BytesPerPhysicalSector** member in the [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure.</span></span> <span data-ttu-id="2e8cc-135">Para obter um exemplo, consulte o código de exemplo no [**\_ \_ \_ descritor de alinhamento de acesso de armazenamento**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span><span class="sxs-lookup"><span data-stu-id="2e8cc-135">For an example, see the sample code at [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span></span> <span data-ttu-id="2e8cc-136">A Microsoft recomenda enfaticamente que os desenvolvedores alinhem e/s sem buffer ao tamanho do setor físico, conforme relatado pelo código de controle da propriedade de consulta de armazenamento do IOCTL para ajudar a garantir que seus aplicativos estejam preparados para essa transição de tamanho de setor. **\_ \_ \_**</span><span class="sxs-lookup"><span data-stu-id="2e8cc-136">Microsoft strongly recommends that developers align unbuffered I/O to the physical sector size as reported by the **IOCTL\_STORAGE\_QUERY\_PROPERTY** control code to help ensure their applications are prepared for this sector size transition.</span></span>

<span data-ttu-id="2e8cc-137">**Windows Server 2003 e Windows XP:** A estrutura do [**\_ \_ \_ descritor de alinhamento de acesso de armazenamento**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) não está disponível.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-137">**Windows Server 2003 and Windows XP:** The [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure is not available.</span></span> <span data-ttu-id="2e8cc-138">Ele foi introduzido com o Windows Vista e o Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-138">It was introduced with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="2e8cc-139">Como os endereços de buffer para operações de leitura e gravação devem ser alinhados ao setor, o aplicativo deve ter controle direto de como esses buffers são alocados.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-139">Because buffer addresses for read and write operations must be sector-aligned, the application must have direct control of how these buffers are allocated.</span></span> <span data-ttu-id="2e8cc-140">Uma maneira de alinhar os buffers do setor é usar a função do [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) para alocar os buffers.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-140">One way to sector-align buffers is to use the [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function to allocate the buffers.</span></span> <span data-ttu-id="2e8cc-141">Considere o seguinte:</span><span class="sxs-lookup"><span data-stu-id="2e8cc-141">Consider the following:</span></span>

-   <span data-ttu-id="2e8cc-142">O [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) aloca a memória que está alinhada em endereços que são múltiplos inteiros do tamanho de página do sistema.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) allocates memory that is aligned on addresses that are integer multiples of the system's page size.</span></span> <span data-ttu-id="2e8cc-143">O tamanho da página é 4.096 bytes em x64 e x86 ou 8.192 bytes para sistemas baseados em Itanium.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-143">Page size is 4,096 bytes on x64 and x86 or 8,192 bytes for Itanium-based systems.</span></span> <span data-ttu-id="2e8cc-144">Para obter mais informações, consulte a função [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) .</span><span class="sxs-lookup"><span data-stu-id="2e8cc-144">For additional information, see the [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) function.</span></span>
-   <span data-ttu-id="2e8cc-145">O tamanho do setor geralmente é de 512 a 4.096 bytes para dispositivos de armazenamento de acesso direto (discos rígidos) e 2.048 bytes para CD-ROMs.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-145">Sector size is typically 512 to 4,096 bytes for direct-access storage devices (hard drives) and 2,048 bytes for CD-ROMs.</span></span>
-   <span data-ttu-id="2e8cc-146">Os tamanhos de página e de setor são potências de 2.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-146">Both page and sector sizes are powers of 2.</span></span>

<span data-ttu-id="2e8cc-147">Portanto, na maioria das situações, a memória alinhada por página também será alinhada ao setor, pois o caso em que o tamanho do setor é maior do que o tamanho da página é raro.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-147">Therefore, in most situations, page-aligned memory will also be sector-aligned, because the case where the sector size is larger than the page size is rare.</span></span>

<span data-ttu-id="2e8cc-148">Outra maneira de obter buffers de memória alinhados manualmente é usar a função [ \_ \_ malloc alinhada](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) da biblioteca do C Run-Time.</span><span class="sxs-lookup"><span data-stu-id="2e8cc-148">Another way to obtain manually-aligned memory buffers is to use the [\_aligned\_malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) function from the C Run-Time library.</span></span> <span data-ttu-id="2e8cc-149">Para obter um exemplo de como controlar manualmente o alinhamento do buffer, consulte o exemplo de código de linguagem C++ na seção de código de exemplo de [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="2e8cc-149">For an example of how to manually control buffer alignment, see the C++ language code example in the Example Code section of [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span>

 

 
