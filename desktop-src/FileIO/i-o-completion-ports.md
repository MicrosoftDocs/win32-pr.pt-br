---
description: As portas de conclusão de e/s fornecem um modelo de Threading eficiente para processar várias solicitações de e/s assíncronas em um sistema multiprocessador.
ms.assetid: 213c48e8-bb21-43ed-9c00-2a5cf8ac25f0
title: Portas de conclusão de e/s
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 882363ef99821a0b0b40810f45d609c5b5f7760c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "105769354"
---
# <a name="io-completion-ports"></a><span data-ttu-id="af14f-103">Portas de conclusão de e/s</span><span class="sxs-lookup"><span data-stu-id="af14f-103">I/O Completion Ports</span></span>

<span data-ttu-id="af14f-104">As portas de conclusão de e/s fornecem um modelo de Threading eficiente para processar várias solicitações de e/s assíncronas em um sistema multiprocessador.</span><span class="sxs-lookup"><span data-stu-id="af14f-104">I/O completion ports provide an efficient threading model for processing multiple asynchronous I/O requests on a multiprocessor system.</span></span> <span data-ttu-id="af14f-105">Quando um processo cria uma porta de conclusão de e/s, o sistema cria um objeto de fila associado para solicitações cujo único propósito é atender a essas solicitações.</span><span class="sxs-lookup"><span data-stu-id="af14f-105">When a process creates an I/O completion port, the system creates an associated queue object for requests whose sole purpose is to service these requests.</span></span> <span data-ttu-id="af14f-106">Processos que lidam com muitas solicitações simultâneas de e/s assíncronas podem fazer isso com mais rapidez e eficiência usando portas de conclusão de e/s em conjunto com um pool de threads pré-alocado do que criar threads no momento em que recebem uma solicitação de e/s.</span><span class="sxs-lookup"><span data-stu-id="af14f-106">Processes that handle many concurrent asynchronous I/O requests can do so more quickly and efficiently by using I/O completion ports in conjunction with a pre-allocated thread pool than by creating threads at the time they receive an I/O request.</span></span>

## <a name="how-io-completion-ports-work"></a><span data-ttu-id="af14f-107">Como funcionam as portas de conclusão de e/s</span><span class="sxs-lookup"><span data-stu-id="af14f-107">How I/O Completion Ports Work</span></span>

<span data-ttu-id="af14f-108">A função [**CreateIoCompletionPort**](createiocompletionport.md) cria uma porta de conclusão de e/s e associa um ou mais identificadores de arquivo a essa porta.</span><span class="sxs-lookup"><span data-stu-id="af14f-108">The [**CreateIoCompletionPort**](createiocompletionport.md) function creates an I/O completion port and associates one or more file handles with that port.</span></span> <span data-ttu-id="af14f-109">Quando uma operação de e/s assíncrona em um desses identificadores de arquivo é concluída, um pacote de conclusão de e/s é enfileirado na ordem FIFO (primeiro a entrar, primeiro a sair) para a porta de conclusão de e/s associada.</span><span class="sxs-lookup"><span data-stu-id="af14f-109">When an asynchronous I/O operation on one of these file handles completes, an I/O completion packet is queued in first-in-first-out (FIFO) order to the associated I/O completion port.</span></span> <span data-ttu-id="af14f-110">Um uso poderoso para esse mecanismo é combinar o ponto de sincronização para vários identificadores de arquivo em um único objeto, embora também haja outros aplicativos úteis.</span><span class="sxs-lookup"><span data-stu-id="af14f-110">One powerful use for this mechanism is to combine the synchronization point for multiple file handles into a single object, although there are also other useful applications.</span></span> <span data-ttu-id="af14f-111">Observe que, enquanto os pacotes são enfileirados na ordem FIFO, eles podem ser recolocados na fila em uma ordem diferente.</span><span class="sxs-lookup"><span data-stu-id="af14f-111">Please note that while the packets are queued in FIFO order they may be dequeued in a different order.</span></span>

> [!Note]
>
> <span data-ttu-id="af14f-112">O termo *identificador de arquivo* conforme usado aqui refere-se a uma abstração de sistema que representa um ponto de extremidade de e/s sobreposto, não apenas um arquivo no disco.</span><span class="sxs-lookup"><span data-stu-id="af14f-112">The term *file handle* as used here refers to a system abstraction representing an overlapped I/O endpoint, not only a file on disk.</span></span> <span data-ttu-id="af14f-113">Por exemplo, ele pode ser um ponto de extremidade de rede, soquete TCP, pipe nomeado ou slot de correio.</span><span class="sxs-lookup"><span data-stu-id="af14f-113">For example, it can be a network endpoint, TCP socket, named pipe, or mail slot.</span></span> <span data-ttu-id="af14f-114">Qualquer objeto do sistema que dê suporte a e/s sobreposta pode ser usado.</span><span class="sxs-lookup"><span data-stu-id="af14f-114">Any system object that supports overlapped I/O can be used.</span></span> <span data-ttu-id="af14f-115">Para obter uma lista de funções de e/s relacionadas, consulte o final deste tópico.</span><span class="sxs-lookup"><span data-stu-id="af14f-115">For a list of related I/O functions, see the end of this topic.</span></span>

 

<span data-ttu-id="af14f-116">Quando um identificador de arquivo é associado a uma porta de conclusão, o bloco de status transmitido não será atualizado até que o pacote seja removido da porta de conclusão.</span><span class="sxs-lookup"><span data-stu-id="af14f-116">When a file handle is associated with a completion port, the status block passed in will not be updated until the packet is removed from the completion port.</span></span> <span data-ttu-id="af14f-117">A única exceção é se a operação original retornar de forma síncrona com um erro.</span><span class="sxs-lookup"><span data-stu-id="af14f-117">The only exception is if the original operation returns synchronously with an error.</span></span> <span data-ttu-id="af14f-118">Um thread (criado pelo thread principal ou o próprio thread principal) usa a função [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) para aguardar que um pacote de conclusão seja colocado na fila para a porta de conclusão de e/s, em vez de aguardar diretamente a conclusão da e/s assíncrona.</span><span class="sxs-lookup"><span data-stu-id="af14f-118">A thread (either one created by the main thread or the main thread itself) uses the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function to wait for a completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete.</span></span> <span data-ttu-id="af14f-119">Os threads que bloqueiam a execução em uma porta de conclusão de e/s são liberados na ordem UEPS (último a entrar, primeiro a sair) e o próximo pacote de conclusão é extraído da fila FIFO da porta de conclusão de e/s para esse thread.</span><span class="sxs-lookup"><span data-stu-id="af14f-119">Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order, and the next completion packet is pulled from the I/O completion port's FIFO queue for that thread.</span></span> <span data-ttu-id="af14f-120">Isso significa que, quando um pacote de conclusão é liberado para um thread, o sistema libera o último thread (mais recente) associado a essa porta, passando as informações de conclusão para a conclusão de e/s mais antiga.</span><span class="sxs-lookup"><span data-stu-id="af14f-120">This means that, when a completion packet is released to a thread, the system releases the last (most recent) thread associated with that port, passing it the completion information for the oldest I/O completion.</span></span>

<span data-ttu-id="af14f-121">Embora qualquer número de threads possa chamar [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) para uma porta de conclusão de e/s especificada, quando um thread especificado chama **GetQueuedCompletionStatus** na primeira vez, ele se torna associado à porta de conclusão de e/s especificada até que uma das três coisas ocorra: o thread sai, especifica uma porta de conclusão de e/s diferente ou fecha a porta de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="af14f-121">Although any number of threads can call [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) for a specified I/O completion port, when a specified thread calls **GetQueuedCompletionStatus** the first time, it becomes associated with the specified I/O completion port until one of three things occurs: The thread exits, specifies a different I/O completion port, or closes the I/O completion port.</span></span> <span data-ttu-id="af14f-122">Em outras palavras, um único thread pode ser associado a, no máximo, uma porta de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="af14f-122">In other words, a single thread can be associated with, at most, one I/O completion port.</span></span>

<span data-ttu-id="af14f-123">Quando um pacote de conclusão é enfileirado para uma porta de conclusão de e/s, o sistema verifica primeiro quantos threads associados a essa porta estão em execução.</span><span class="sxs-lookup"><span data-stu-id="af14f-123">When a completion packet is queued to an I/O completion port, the system first checks how many threads associated with that port are running.</span></span> <span data-ttu-id="af14f-124">Se o número de threads em execução for menor que o valor de simultaneidade (discutido na próxima seção), um dos threads em espera (o mais recente) tem permissão para processar o pacote de conclusão.</span><span class="sxs-lookup"><span data-stu-id="af14f-124">If the number of threads running is less than the concurrency value (discussed in the next section), one of the waiting threads (the most recent one) is allowed to process the completion packet.</span></span> <span data-ttu-id="af14f-125">Quando um thread em execução conclui seu processamento, ele normalmente chama [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) novamente, no ponto em que ele retorna com o próximo pacote de conclusão ou aguarda se a fila está vazia.</span><span class="sxs-lookup"><span data-stu-id="af14f-125">When a running thread completes its processing, it typically calls [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) again, at which point it either returns with the next completion packet or waits if the queue is empty.</span></span>

<span data-ttu-id="af14f-126">Os threads podem usar a função [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) para colocar os pacotes de conclusão em uma fila da porta de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="af14f-126">Threads can use the [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) function to place completion packets in an I/O completion port's queue.</span></span> <span data-ttu-id="af14f-127">Ao fazer isso, a porta de conclusão pode ser usada para receber comunicações de outros threads do processo, além de receber pacotes de conclusão de e/s do sistema de e/s.</span><span class="sxs-lookup"><span data-stu-id="af14f-127">By doing so, the completion port can be used to receive communications from other threads of the process, in addition to receiving I/O completion packets from the I/O system.</span></span> <span data-ttu-id="af14f-128">A função **PostQueuedCompletionStatus** permite que um aplicativo enfileirar seus próprios pacotes de conclusão de finalidade especial para a porta de conclusão de e/s sem iniciar uma operação de e/s assíncrona.</span><span class="sxs-lookup"><span data-stu-id="af14f-128">The **PostQueuedCompletionStatus** function allows an application to queue its own special-purpose completion packets to the I/O completion port without starting an asynchronous I/O operation.</span></span> <span data-ttu-id="af14f-129">Isso é útil para notificar threads de trabalho de eventos externos, por exemplo.</span><span class="sxs-lookup"><span data-stu-id="af14f-129">This is useful for notifying worker threads of external events, for example.</span></span>

<span data-ttu-id="af14f-130">O identificador de porta de conclusão de e/s e todos os identificadores de arquivo associados a essa porta de conclusão de e/s específica são conhecidos como *referências à porta de conclusão de e/s*.</span><span class="sxs-lookup"><span data-stu-id="af14f-130">The I/O completion port handle and every file handle associated with that particular I/O completion port are known as *references to the I/O completion port*.</span></span> <span data-ttu-id="af14f-131">A porta de conclusão de e/s é liberada quando não há mais referências a ela.</span><span class="sxs-lookup"><span data-stu-id="af14f-131">The I/O completion port is released when there are no more references to it.</span></span> <span data-ttu-id="af14f-132">Portanto, todos esses identificadores devem ser fechados corretamente para liberar a porta de conclusão de e/s e seus recursos de sistema associados.</span><span class="sxs-lookup"><span data-stu-id="af14f-132">Therefore, all of these handles must be properly closed to release the I/O completion port and its associated system resources.</span></span> <span data-ttu-id="af14f-133">Depois que essas condições forem satisfeitas, um aplicativo deverá fechar o identificador da porta de conclusão de e/s chamando a função [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) .</span><span class="sxs-lookup"><span data-stu-id="af14f-133">After these conditions are satisfied, an application should close the I/O completion port handle by calling the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span>

> [!Note]
>
> <span data-ttu-id="af14f-134">Uma porta de conclusão de e/s é associada ao processo que a criou e não é compartilhável entre processos.</span><span class="sxs-lookup"><span data-stu-id="af14f-134">An I/O completion port is associated with the process that created it and is not sharable between processes.</span></span> <span data-ttu-id="af14f-135">No entanto, um único identificador é compartilhável entre threads no mesmo processo.</span><span class="sxs-lookup"><span data-stu-id="af14f-135">However, a single handle is sharable between threads in the same process.</span></span>

 

## <a name="threads-and-concurrency"></a><span data-ttu-id="af14f-136">Threads e simultaneidade</span><span class="sxs-lookup"><span data-stu-id="af14f-136">Threads and Concurrency</span></span>

<span data-ttu-id="af14f-137">A propriedade mais importante de uma porta de conclusão de e/s a ser considerada cuidadosamente é o valor de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="af14f-137">The most important property of an I/O completion port to consider carefully is the concurrency value.</span></span> <span data-ttu-id="af14f-138">O valor de simultaneidade de uma porta de conclusão é especificado quando é criado com [**CreateIoCompletionPort**](createiocompletionport.md) por meio do parâmetro *NumberOfConcurrentThreads* .</span><span class="sxs-lookup"><span data-stu-id="af14f-138">The concurrency value of a completion port is specified when it is created with [**CreateIoCompletionPort**](createiocompletionport.md) via the *NumberOfConcurrentThreads* parameter.</span></span> <span data-ttu-id="af14f-139">Esse valor limita o número de threads executáveis associados à porta de conclusão.</span><span class="sxs-lookup"><span data-stu-id="af14f-139">This value limits the number of runnable threads associated with the completion port.</span></span> <span data-ttu-id="af14f-140">Quando o número total de threads executáveis associados à porta de conclusão atingir o valor de simultaneidade, o sistema bloqueará a execução de quaisquer threads subsequentes associados a essa porta de conclusão até que o número de threads executáveis fique abaixo do valor de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="af14f-140">When the total number of runnable threads associated with the completion port reaches the concurrency value, the system blocks the execution of any subsequent threads associated with that completion port until the number of runnable threads drops below the concurrency value.</span></span>

<span data-ttu-id="af14f-141">O cenário mais eficiente ocorre quando há pacotes de conclusão aguardando na fila, mas nenhuma espera pode ser satisfeita porque a porta atingiu seu limite de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="af14f-141">The most efficient scenario occurs when there are completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit.</span></span> <span data-ttu-id="af14f-142">Considere o que acontece com um valor de simultaneidade de um e vários threads aguardando na chamada de função [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) .</span><span class="sxs-lookup"><span data-stu-id="af14f-142">Consider what happens with a concurrency value of one and multiple threads waiting in the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function call.</span></span> <span data-ttu-id="af14f-143">Nesse caso, se a fila sempre tiver pacotes de conclusão aguardando, quando o thread em execução chamar **GetQueuedCompletionStatus**, ele não bloqueará a execução porque, como mencionado anteriormente, a fila de threads será UEPS.</span><span class="sxs-lookup"><span data-stu-id="af14f-143">In this case, if the queue always has completion packets waiting, when the running thread calls **GetQueuedCompletionStatus**, it will not block execution because, as mentioned earlier, the thread queue is LIFO.</span></span> <span data-ttu-id="af14f-144">Em vez disso, esse thread irá selecionar imediatamente o próximo pacote de conclusão na fila.</span><span class="sxs-lookup"><span data-stu-id="af14f-144">Instead, this thread will immediately pick up the next queued completion packet.</span></span> <span data-ttu-id="af14f-145">Nenhuma alternância de contexto de thread ocorrerá, pois o thread em execução está continuamente selecionando pacotes de conclusão e os outros threads não podem ser executados.</span><span class="sxs-lookup"><span data-stu-id="af14f-145">No thread context switches will occur, because the running thread is continually picking up completion packets and the other threads are unable to run.</span></span>

> [!Note]
>
> <span data-ttu-id="af14f-146">No exemplo anterior, os threads extras parecem ser inúteis e nunca são executados, mas isso pressupõe que o thread em execução nunca é colocado em um estado de espera por algum outro mecanismo, termina ou fecha sua porta de conclusão de e/s associada.</span><span class="sxs-lookup"><span data-stu-id="af14f-146">In the previous example, the extra threads appear to be useless and never run, but that assumes that the running thread never gets put in a wait state by some other mechanism, terminates, or otherwise closes its associated I/O completion port.</span></span> <span data-ttu-id="af14f-147">Considere todas essas ramificações de execução de thread ao projetar o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="af14f-147">Consider all such thread execution ramifications when designing the application.</span></span>

 

<span data-ttu-id="af14f-148">O melhor valor geral máximo a ser escolhido para o valor de simultaneidade é o número de CPUs no computador.</span><span class="sxs-lookup"><span data-stu-id="af14f-148">The best overall maximum value to pick for the concurrency value is the number of CPUs on the computer.</span></span> <span data-ttu-id="af14f-149">Se sua transação exigir uma computação demorada, um valor de simultaneidade maior permitirá a execução de mais threads.</span><span class="sxs-lookup"><span data-stu-id="af14f-149">If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run.</span></span> <span data-ttu-id="af14f-150">Cada pacote de conclusão pode levar mais tempo para ser concluído, mas os pacotes de conclusão serão processados ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="af14f-150">Each completion packet may take longer to finish, but more completion packets will be processed at the same time.</span></span> <span data-ttu-id="af14f-151">Você pode experimentar o valor de simultaneidade em conjunto com as ferramentas de criação de perfil para obter o melhor efeito para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="af14f-151">You can experiment with the concurrency value in conjunction with profiling tools to achieve the best effect for your application.</span></span>

<span data-ttu-id="af14f-152">O sistema também permite que um thread esperando em [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) processe um pacote de conclusão se outro thread em execução associado à mesma porta de conclusão de e/s entrar em um estado de espera por outros motivos, por exemplo, a função [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) .</span><span class="sxs-lookup"><span data-stu-id="af14f-152">The system also allows a thread waiting in [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) to process a completion packet if another running thread associated with the same I/O completion port enters a wait state for other reasons, for example the [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) function.</span></span> <span data-ttu-id="af14f-153">Quando o thread no estado de espera começar a ser executado novamente, poderá haver um breve período quando o número de threads ativos exceder o valor de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="af14f-153">When the thread in the wait state begins running again, there may be a brief period when the number of active threads exceeds the concurrency value.</span></span> <span data-ttu-id="af14f-154">No entanto, o sistema reduz rapidamente esse número, não permitindo novos threads ativos até que o número de threads ativos esteja abaixo do valor de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="af14f-154">However, the system quickly reduces this number by not allowing any new active threads until the number of active threads falls below the concurrency value.</span></span> <span data-ttu-id="af14f-155">Essa é uma razão para que seu aplicativo crie mais threads em seu pool de threads do que o valor de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="af14f-155">This is one reason to have your application create more threads in its thread pool than the concurrency value.</span></span> <span data-ttu-id="af14f-156">O gerenciamento de pool de threads está além do escopo deste tópico, mas uma boa regra prática é ter, no mínimo, o dobro de threads no pool de threads, pois há processadores no sistema.</span><span class="sxs-lookup"><span data-stu-id="af14f-156">Thread pool management is beyond the scope of this topic, but a good rule of thumb is to have a minimum of twice as many threads in the thread pool as there are processors on the system.</span></span> <span data-ttu-id="af14f-157">Para obter informações adicionais sobre o pool de threads, consulte [pools de threads](/windows/desktop/ProcThread/thread-pools).</span><span class="sxs-lookup"><span data-stu-id="af14f-157">For additional information about thread pooling, see [Thread Pools](/windows/desktop/ProcThread/thread-pools).</span></span>

## <a name="supported-io-functions"></a><span data-ttu-id="af14f-158">Funções de e/s com suporte</span><span class="sxs-lookup"><span data-stu-id="af14f-158">Supported I/O Functions</span></span>

<span data-ttu-id="af14f-159">As funções a seguir podem ser usadas para iniciar operações de e/s que são concluídas usando portas de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="af14f-159">The following functions can be used to start I/O operations that complete by using I/O completion ports.</span></span> <span data-ttu-id="af14f-160">Você deve passar a função de uma instância da estrutura [**sobreposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) e um identificador de arquivo associado anteriormente a uma porta de conclusão de e/s (por uma chamada para [**CreateIoCompletionPort**](createiocompletionport.md)) para habilitar o mecanismo de porta de conclusão de e/s:</span><span class="sxs-lookup"><span data-stu-id="af14f-160">You must pass the function an instance of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure and a file handle previously associated with an I/O completion port (by a call to [**CreateIoCompletionPort**](createiocompletionport.md)) to enable the I/O completion port mechanism:</span></span>

-   [<span data-ttu-id="af14f-161">**ConnectNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="af14f-161">**ConnectNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)
-   [<span data-ttu-id="af14f-162">**DeviceIoControl**</span><span class="sxs-lookup"><span data-stu-id="af14f-162">**DeviceIoControl**</span></span>](/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol)
-   [<span data-ttu-id="af14f-163">**LockFileEx**</span><span class="sxs-lookup"><span data-stu-id="af14f-163">**LockFileEx**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-lockfileex)
-   [<span data-ttu-id="af14f-164">**ReadDirectoryChangesW**</span><span class="sxs-lookup"><span data-stu-id="af14f-164">**ReadDirectoryChangesW**</span></span>](/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw)
-   [<span data-ttu-id="af14f-165">**ReadFile**</span><span class="sxs-lookup"><span data-stu-id="af14f-165">**ReadFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-readfile)
-   [<span data-ttu-id="af14f-166">**TransactNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="af14f-166">**TransactNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)
-   [<span data-ttu-id="af14f-167">**WaitCommEvent**</span><span class="sxs-lookup"><span data-stu-id="af14f-167">**WaitCommEvent**</span></span>](/windows/desktop/api/winbase/nf-winbase-waitcommevent)
-   [<span data-ttu-id="af14f-168">**WriteFile**</span><span class="sxs-lookup"><span data-stu-id="af14f-168">**WriteFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-writefile)
-   [<span data-ttu-id="af14f-169">**WSASendMsg**</span><span class="sxs-lookup"><span data-stu-id="af14f-169">**WSASendMsg**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)
-   [<span data-ttu-id="af14f-170">**WSASendTo**</span><span class="sxs-lookup"><span data-stu-id="af14f-170">**WSASendTo**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendto)
-   [<span data-ttu-id="af14f-171">**WSASend**</span><span class="sxs-lookup"><span data-stu-id="af14f-171">**WSASend**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasend)
-   [<span data-ttu-id="af14f-172">**WSARecvFrom**</span><span class="sxs-lookup"><span data-stu-id="af14f-172">**WSARecvFrom**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom)
-   [<span data-ttu-id="af14f-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span><span class="sxs-lookup"><span data-stu-id="af14f-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span></span>](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)
-   [<span data-ttu-id="af14f-174">**WSARecv**</span><span class="sxs-lookup"><span data-stu-id="af14f-174">**WSARecv**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecv)

## <a name="related-topics"></a><span data-ttu-id="af14f-175">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="af14f-175">Related topics</span></span>

<dl> <span data-ttu-id="af14f-176"><dt>


</dt> <dt></span><span class="sxs-lookup"><span data-stu-id="af14f-176"><dt>


</dt> <dt></span></span>

[<span data-ttu-id="af14f-177">Sobre Processos e Threads</span><span class="sxs-lookup"><span data-stu-id="af14f-177">About Processes and Threads</span></span>](/windows/desktop/ProcThread/about-processes-and-threads)
</dt> <dt>

[<span data-ttu-id="af14f-178">**BindIoCompletionCallback**</span><span class="sxs-lookup"><span data-stu-id="af14f-178">**BindIoCompletionCallback**</span></span>](/windows/desktop/api/winbase/nf-winbase-bindiocompletioncallback)
</dt> <dt>

[<span data-ttu-id="af14f-179">**CreateIoCompletionPort**</span><span class="sxs-lookup"><span data-stu-id="af14f-179">**CreateIoCompletionPort**</span></span>](createiocompletionport.md)
</dt> <dt>

[<span data-ttu-id="af14f-180">**GetQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="af14f-180">**GetQueuedCompletionStatus**</span></span>](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)
</dt> <dt>

[<span data-ttu-id="af14f-181">**GetQueuedCompletionStatusEx**</span><span class="sxs-lookup"><span data-stu-id="af14f-181">**GetQueuedCompletionStatusEx**</span></span>](getqueuedcompletionstatusex-func.md)
</dt> <dt>

[<span data-ttu-id="af14f-182">**PostQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="af14f-182">**PostQueuedCompletionStatus**</span></span>](postqueuedcompletionstatus.md)
</dt> </dl>

 

 
