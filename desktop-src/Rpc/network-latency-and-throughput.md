---
title: Latência de rede e taxa de transferência
description: Latência de rede e taxa de transferência com RPC (chamada de procedimento remoto).
ms.assetid: 8285fd73-eb54-4c06-b01a-1bffafb7e675
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c5c51c4db75b904ac5feae8c4a1cc5965fc2b06e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "104160300"
---
# <a name="network-latency-and-throughput"></a><span data-ttu-id="c4c4c-103">Latência de rede e taxa de transferência</span><span class="sxs-lookup"><span data-stu-id="c4c4c-103">Network Latency and Throughput</span></span>

<span data-ttu-id="c4c4c-104">Três problemas importantes estão relacionados ao uso ideal da rede:</span><span class="sxs-lookup"><span data-stu-id="c4c4c-104">Three major issues relate to optimal use of the network:</span></span>

-   <span data-ttu-id="c4c4c-105">Latência da rede</span><span class="sxs-lookup"><span data-stu-id="c4c4c-105">Network latency</span></span>
-   <span data-ttu-id="c4c4c-106">Saturação de rede</span><span class="sxs-lookup"><span data-stu-id="c4c4c-106">Network saturation</span></span>
-   <span data-ttu-id="c4c4c-107">Implicações de processamento de pacotes</span><span class="sxs-lookup"><span data-stu-id="c4c4c-107">Packet processing implications</span></span>

<span data-ttu-id="c4c4c-108">Esta seção apresenta uma tarefa de programação que requer o uso de RPC e, em seguida, projeta duas soluções: uma mal gravada e uma bem gravada.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-108">This section introduces a programming task requiring use of RPC, then designs two solutions: one poorly written and one well written.</span></span> <span data-ttu-id="c4c4c-109">As duas soluções são então fiscalizadas e seu impacto no desempenho da rede é discutido.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-109">Both solutions are then scrutinized, and their affect on network performance is discussed.</span></span>

<span data-ttu-id="c4c4c-110">Antes de discutir as duas soluções, as próximas seções discutem e esclarecem os problemas de desempenho relacionados à rede.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-110">Before discussing the two solutions, the next few sections discuss and clarify network related performance issues.</span></span>

## <a name="network-latency"></a><span data-ttu-id="c4c4c-111">Latência de rede</span><span class="sxs-lookup"><span data-stu-id="c4c4c-111">Network Latency</span></span>

<span data-ttu-id="c4c4c-112">A largura de banda de rede e a latência de rede são termos separados.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-112">Network bandwidth and network latency are separate terms.</span></span> <span data-ttu-id="c4c4c-113">Redes com alta largura de banda não garantem baixa latência.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-113">Networks with high bandwidth do not guarantee low latency.</span></span> <span data-ttu-id="c4c4c-114">Por exemplo, um caminho de rede atravessando um link satélite geralmente tem alta latência, embora a taxa de transferência seja muito alta.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-114">For example, a network path traversing a satellite link often has high latency, even though throughput is very high.</span></span> <span data-ttu-id="c4c4c-115">Não é incomum uma viagem de ida e volta da rede atravessando um link satélite para ter cinco ou mais segundos de latência.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-115">It is not uncommon for a network round trip traversing a satellite link to have five or more seconds of latency.</span></span> <span data-ttu-id="c4c4c-116">A implicação desse atraso é: um aplicativo projetado para enviar uma solicitação, aguardar uma resposta, enviar outra solicitação, aguardar outra resposta e assim por diante, aguardará pelo menos cinco segundos para cada troca de pacotes, independentemente da velocidade do servidor.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-116">The implication of such a delay is this: an application designed to send a request, wait for a reply, send another request, wait for another reply, and so on, will wait at least five seconds for each packet exchange, regardless of how fast the server is.</span></span> <span data-ttu-id="c4c4c-117">Apesar da velocidade crescente dos computadores, as transmissões por satélite e a mídia de rede são baseadas na velocidade da luz, o que geralmente permanece constante.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-117">Despite the increasing speed of computers, satellite transmissions and network media are based on the speed of light, which generally stays constant.</span></span> <span data-ttu-id="c4c4c-118">Dessa forma, as melhorias na latência para redes satélite existentes provavelmente não ocorrerão.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-118">As such, improvements in latency for existing satellite networks is unlikely to occur.</span></span>

## <a name="network-saturation"></a><span data-ttu-id="c4c4c-119">Saturação de rede</span><span class="sxs-lookup"><span data-stu-id="c4c4c-119">Network Saturation</span></span>

<span data-ttu-id="c4c4c-120">Alguma saturação ocorre em muitas redes.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-120">Some saturation occurs in many networks.</span></span> <span data-ttu-id="c4c4c-121">As redes mais fáceis de saturar são links de modem lentos, como modems analógicos padrão de 56K.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-121">The easiest networks to saturate are slow modem links, such as standard 56k analog modems.</span></span> <span data-ttu-id="c4c4c-122">No entanto, os links Ethernet com muitos computadores em um único segmento também podem ser saturados.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-122">However, Ethernet links with many computers on a single segment can also become saturated.</span></span> <span data-ttu-id="c4c4c-123">O mesmo se aplica a redes de longa distância, com uma baixa largura de banda ou um link sobrecarregado de outra forma, como um roteador ou um comutador que possa lidar com uma quantidade limitada de tráfego.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-123">The same is true about wide area networks with a low-bandwidth or otherwise overburdened link, such as a router or switch that can handle a limited amount of traffic.</span></span> <span data-ttu-id="c4c4c-124">Nesses casos, se a rede enviar mais pacotes do que o link mais fraco pode manipular, ele descartará os pacotes.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-124">In such these cases, if the network sends more packets than its weakest link can handle, it drops packets.</span></span> <span data-ttu-id="c4c4c-125">Para evitar o congestionamento, a pilha TCP do Windows é dimensionada de volta quando pacotes descartados são detectados, o que pode resultar em atrasos significativos.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-125">To avoid congestion the Windows TCP stack scales back when dropped packets are detected which can result in significant delays.</span></span>

## <a name="packet-processing-implications"></a><span data-ttu-id="c4c4c-126">Implicações de processamento de pacotes</span><span class="sxs-lookup"><span data-stu-id="c4c4c-126">Packet Processing Implications</span></span>

<span data-ttu-id="c4c4c-127">Quando os programas são desenvolvidos para ambientes de nível superior, como RPC, COM e até mesmo Windows Sockets, os desenvolvedores tendem a se esquecer da quantidade de trabalho que ocorre nos bastidores de cada pacote enviado ou recebido.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-127">When programs are developed for higher level environments like RPC, COM, and even Windows Sockets, developers tend to forget how much work takes place behind the scenes for each sent or received packet.</span></span> <span data-ttu-id="c4c4c-128">Quando um pacote chega da rede, uma interrupção da placa de rede é atendida pelo computador.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-128">When a packet arrives from the network, an interrupt from the network card is serviced by the computer.</span></span> <span data-ttu-id="c4c4c-129">Em seguida, uma DPC (chamada de procedimento deferida) é enfileirada e deve fazer o caminho pelos drivers.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-129">Then a Deferred Procedure Call (DPC) is queued, and must make its way through the drivers.</span></span> <span data-ttu-id="c4c4c-130">Se qualquer forma de segurança for usada, o pacote poderá ter que ser descriptografado ou o hash criptográfico verificado.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-130">If any form of security is used, the packet may have to be decrypted, or the cryptographic hash verified.</span></span> <span data-ttu-id="c4c4c-131">Várias verificações de validade também devem ser executadas em cada Estado.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-131">A number of validity checks must also be performed at each state.</span></span> <span data-ttu-id="c4c4c-132">Somente o pacote chega no destino final: o código do servidor.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-132">Only then does the packet arrive at the final destination: the server code.</span></span> <span data-ttu-id="c4c4c-133">O envio de muitas partes pequenas de resultados de dados na sobrecarga de processamento de pacotes para cada pequena parte dos dados.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-133">Sending many small chunks of data results in packet processing overhead for each small chunk of data.</span></span> <span data-ttu-id="c4c4c-134">O envio de uma grande parte dos dados tende a consumir significativamente menos tempo de CPU em todo o sistema, embora o custo de execução de muitas partes pequenas em comparação com uma grande parte seja o mesmo para o aplicativo de servidor.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-134">Sending one big chunk of data tends to consume significantly less CPU time throughout the system, even though the cost of execution for many small chunks compared to one large chunk may be the same for the server application.</span></span>

## <a name="example-1-a-poorly-designed-rpc-server"></a><span data-ttu-id="c4c4c-135">Exemplo 1: um servidor RPC mal projetado</span><span class="sxs-lookup"><span data-stu-id="c4c4c-135">Example 1: A Poorly Designed RPC Server</span></span>

<span data-ttu-id="c4c4c-136">Imagine um aplicativo que deve acessar arquivos remotos e a tarefa em questão é criar uma interface RPC para manipular o arquivo remoto.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-136">Imagine an application that must access remote files, and the task at hand is to design an RPC interface for manipulating the remote file.</span></span> <span data-ttu-id="c4c4c-137">A solução mais simples é espelhar as rotinas de arquivo do estúdio para arquivos locais.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-137">The simplest solution is to mirror the studio file routines for local files.</span></span> <span data-ttu-id="c4c4c-138">Fazer isso pode resultar em uma interface bem limpa e familiar.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-138">Doing so may result in a deceptively clean and familiar interface.</span></span> <span data-ttu-id="c4c4c-139">Este é um arquivo. idl abreviado:</span><span class="sxs-lookup"><span data-stu-id="c4c4c-139">Here is an abbreviated .idl file:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
... .
interface remote_file
{
    remote_file remote_fopen(file_name);
    void remote_fclose(remote_file ...);
    size_t remote_fread(void *, size_t, size_t, remote_file ...);
    size_t remote_fwrite(const void *, size_t, size_t, remote_file ...);
    size_t remote_fseek(remote_file ..., long, int);
}
```

<span data-ttu-id="c4c4c-140">Isso parece elegante o bastante, mas, na verdade, essa é uma receita que é cumprida por um desastre de desempenho.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-140">This seems elegant enough, but actually, this is a time-honored recipe for performance disaster.</span></span> <span data-ttu-id="c4c4c-141">Ao contrário da opinião popular, a chamada de procedimento remoto não é simplesmente uma chamada de procedimento local com um fio entre o chamador e o receptor.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-141">Contrary to popular opinion, remote procedure call is not simply a local procedure call with a wire between the caller and callee.</span></span>

<span data-ttu-id="c4c4c-142">Para ver como essa receita grava o desempenho, considere um arquivo de 2K, onde 20 bytes são lidos desde o início e, em seguida, 20 bytes do final e veja como isso é executado.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-142">To see how this recipe burns performance, consider a 2K file, where 20 bytes are read from the beginning, and then 20 bytes from the end, and see how this performs.</span></span> <span data-ttu-id="c4c4c-143">No lado do cliente, as seguintes chamadas são feitas (muitos caminhos de código são omitidos para fins de brevidade):</span><span class="sxs-lookup"><span data-stu-id="c4c4c-143">On the client side, the following calls are made (many code paths are omitted for brevity):</span></span>

``` syntax
rfp = remote_fopen("c:\\sample.txt");
remote_read(...);
remote_fseek(...);
remote_read(...);
remote_fclose(rfp);
```

<span data-ttu-id="c4c4c-144">Agora imagine que o servidor esteja separado do cliente por um link de satélite com um tempo de ida e volta de cinco segundos.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-144">Now imagine that the server is separated from the client by a satellite link with a five-second round-trip time.</span></span> <span data-ttu-id="c4c4c-145">Cada uma dessas chamadas deve aguardar uma resposta antes que possa continuar, o que significa um mínimo absoluto para executar essa sequência de 25 segundos.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-145">Each of those calls must wait for a response before it can proceed, which means an absolute minimum for executing this sequence of 25 seconds.</span></span> <span data-ttu-id="c4c4c-146">Considerando que estamos recuperando apenas 40 bytes, isso é outrageously o desempenho lento.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-146">Considering we are retrieving only 40 bytes, this is outrageously slow performance.</span></span> <span data-ttu-id="c4c4c-147">Os clientes desse aplicativo seriam assombrosa.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-147">Customers of this application would be furious.</span></span>

<span data-ttu-id="c4c4c-148">Agora imagine que a rede está saturada, pois a capacidade de um roteador em algum lugar no caminho de rede é sobrecarregada.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-148">Now imagine the network is saturated, because a router's capacity somewhere in the network path is overburdened.</span></span> <span data-ttu-id="c4c4c-149">Esse design força o roteador a lidar com pelo menos 10 pacotes se não tivermos segurança (um para cada solicitação e um para cada resposta).</span><span class="sxs-lookup"><span data-stu-id="c4c4c-149">This design forces the router to handle at least 10 packets if we do not have security (one for each request, and one for each reply).</span></span> <span data-ttu-id="c4c4c-150">Isso também não é bom.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-150">That, too, is not good.</span></span>

<span data-ttu-id="c4c4c-151">Esse design também força o servidor a receber cinco pacotes e enviar cinco pacotes.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-151">This design also forces the server to receive five packets and send five packets.</span></span> <span data-ttu-id="c4c4c-152">Novamente, não é uma implementação muito boa.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-152">Again, not a very good implementation.</span></span>

## <a name="example-2-a-better-designed-rpc-server"></a><span data-ttu-id="c4c4c-153">Exemplo 2: um servidor RPC melhor projetado</span><span class="sxs-lookup"><span data-stu-id="c4c4c-153">Example 2: A Better Designed RPC Server</span></span>

<span data-ttu-id="c4c4c-154">Vamos reprojetar a interface discutida no exemplo 1 e ver se podemos melhorar.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-154">Let's redesign the interface discussed in Example 1, and see whether we can make it better.</span></span> <span data-ttu-id="c4c4c-155">É importante observar que tornar esse servidor realmente bom requer conhecimento do padrão de uso para os arquivos fornecidos: tal conhecimento não é assumido para este exemplo.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-155">It is important to note that making this server really good requires knowledge of the usage pattern for the given files: such knowledge is not assumed for this example.</span></span> <span data-ttu-id="c4c4c-156">Portanto, esse é um servidor RPC melhor projetado, mas não um servidor RPC com design ideal.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-156">Therefore, this is a better designed RPC server, but not an optimally designed RPC server.</span></span>

<span data-ttu-id="c4c4c-157">A ideia neste exemplo é recolher o máximo possível de operações remotas em uma operação.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-157">The idea in this example is to collapse as many remote operations into one operation as possible.</span></span> <span data-ttu-id="c4c4c-158">A primeira tentativa é a seguinte:</span><span class="sxs-lookup"><span data-stu-id="c4c4c-158">The first attempt is the following:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
typedef struct
{
    long position;
    int origin;
} remote_seek_instruction;
... .
interface remote_file
{
    remote_fread(file_name, void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
    size_t remote_fwrite(file_name, const void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
}
```

<span data-ttu-id="c4c4c-159">Este exemplo recolhe todas as operações para uma leitura e gravação, o que permite uma abertura opcional na mesma operação, bem como um fechamento e uma busca opcionais.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-159">This example collapses all operations to a read and write, which allows for an optional open on the same operation, as well as an optional close and seek.</span></span>

<span data-ttu-id="c4c4c-160">Essa mesma sequência de operação, quando escrita em formato abreviado, tem a seguinte aparência:</span><span class="sxs-lookup"><span data-stu-id="c4c4c-160">This same sequence of operation, when written in abbreviated form, looks like this:</span></span>

``` syntax
remote_read("c:\\sample.txt", ..., &rfp, FALSE, NULL);
remote_read(NULL, ..., &rfp, TRUE, seek_to_20_bytes_before_end);
```

<span data-ttu-id="c4c4c-161">Ao considerar o servidor RPC melhor projetado, na segunda chamada, o servidor verifica se o *\_ nome do arquivo* é **nulo** e usa o arquivo aberto armazenado na RFP.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-161">When considering the better designed RPC server, on the second call the server checks that the *file\_name* is **NULL**, and uses the stored open file in rfp.</span></span> <span data-ttu-id="c4c4c-162">Em seguida, ele vê que há instruções de busca e posicionará o ponteiro de arquivo 20 bytes antes do final antes de lê-lo.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-162">Then it sees there are seek instructions, and will position the file pointer 20 bytes before the end before it reads.</span></span> <span data-ttu-id="c4c4c-163">Quando terminar, ele reconhecerá que o sinalizador **CloseWhenDone** está definido como **true** e fechará o arquivo e fechará a RFP.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-163">When done, it will recognize the **CloseWhenDone** flag is set to **TRUE**, and will close the file, and close rfp.</span></span>

<span data-ttu-id="c4c4c-164">Na rede de alta latência, essa versão melhor leva 10 segundos para ser concluída (2,5 vezes mais rápido) e requer o processamento de apenas quatro pacotes; dois recebimentos do servidor e dois envios do servidor.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-164">On the high latency network, this better version takes 10 seconds to complete (2.5 times faster) and requires processing of only four packets; two receives from the server, and two sends from the server.</span></span> <span data-ttu-id="c4c4c-165">O *IFS* extra e o desempacotamento de desempenho do servidor são insignificantes em comparação com todo o resto.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-165">The extra *ifs* and unmarshaling the server performs are negligible compared to everything else.</span></span>

<span data-ttu-id="c4c4c-166">Se a ordenação causal for especificada corretamente, a interface poderá até mesmo se tornar assíncrona e as duas chamadas poderão ser enviadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-166">If causal ordering is specified properly, the interface can even be made asynchronous, and the two calls can be sent in parallel.</span></span> <span data-ttu-id="c4c4c-167">Quando a ordenação causal é usada, as chamadas ainda são expedidas na ordem, o que significa que, na rede de alta latência, apenas um atraso de cinco segundos é disparado, embora o número de pacotes enviados e recebidos seja o mesmo.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-167">When causal ordering is used calls are still dispatched in order, which means on the high latency network only a five-second delay is endured, even though the number of packets sent and received is the same.</span></span>

<span data-ttu-id="c4c4c-168">Podemos recolher isso ainda mais criando um método que usa uma matriz de estruturas, cada membro da matriz que descreve uma operação de arquivo específica; uma variação remota de dispersão/coleta de e/s.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-168">We can collapse this even further by creating one method that takes an array of structures, each member of the array describing a particular file operation; a remote variation of scatter/gather I/O.</span></span> <span data-ttu-id="c4c4c-169">A abordagem paga desde que o resultado de cada operação não exija processamento adicional no cliente; em outras palavras, o aplicativo vai ler os 20 bytes no final, independentemente da leitura dos primeiros 20 bytes.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-169">The approach pays off as long as the result of each operation does not require further processing on the client; in other words the application is going to read the 20 bytes at the end regardless of what the first 20 bytes read are.</span></span>

<span data-ttu-id="c4c4c-170">No entanto, se algum processamento precisar ser executado nos primeiros 20 bytes depois de lê-los para determinar a próxima operação, recolher tudo em uma única operação não funcionará (pelo menos não em todos os casos).</span><span class="sxs-lookup"><span data-stu-id="c4c4c-170">However, if some processing must be performed on the first 20 bytes after reading them to determine the next operation, collapsing everything into one operation does not work (at least not in all cases).</span></span> <span data-ttu-id="c4c4c-171">A elegância do RPC é que um aplicativo pode ter ambos os métodos na interface e chamar qualquer método, dependendo da necessidade.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-171">The elegance of RPC is that an application can have both methods in the interface, and call either method depending on need.</span></span>

<span data-ttu-id="c4c4c-172">Em geral, quando a rede está envolvida, é melhor combinar quantas chamadas forem possíveis para uma única chamada.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-172">In general, when the network is involved it is best to combine as many calls onto a single call as possible.</span></span> <span data-ttu-id="c4c4c-173">Se um aplicativo tiver duas atividades independentes, use operações assíncronas e permita que elas sejam executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-173">If an application has two independent activities, use asynchronous operations and let them run in parallel.</span></span> <span data-ttu-id="c4c4c-174">Essencialmente, mantenha o pipeline cheio.</span><span class="sxs-lookup"><span data-stu-id="c4c4c-174">Essentially, keep the pipeline full.</span></span>

 

 




