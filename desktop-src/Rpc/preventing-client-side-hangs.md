---
title: Prevenção de suspensões do lado do cliente
description: Há duas maneiras pelas quais o cliente pode interromper a conectividade de rede pode fazer com que as solicitações do servidor se tornem perdidas ou o próprio servidor pode falhar. Com as opções padrão, o RPC nunca atingirá o tempo limite de uma chamada e o thread do cliente aguardará para uma resposta de forma contínua.
ms.assetid: 2c201e29-9d9c-48e6-b0b5-68e4b25c3fb7
keywords:
- RPC de chamada de procedimento remoto, práticas recomendadas, impedindo o travamento do cliente
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 18d4b5fc92ca18b575d081cd7b5abf90929e7df5
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "103641221"
---
# <a name="preventing-client-side-hangs"></a><span data-ttu-id="4c87b-105">Prevenção de suspensões do lado do cliente</span><span class="sxs-lookup"><span data-stu-id="4c87b-105">Preventing Client-side Hangs</span></span>

<span data-ttu-id="4c87b-106">Há duas maneiras pelas quais o cliente pode travar: a conectividade de rede pode fazer com que as solicitações do servidor se tornem perdidas ou o próprio servidor pode falhar.</span><span class="sxs-lookup"><span data-stu-id="4c87b-106">There are two ways your client can hang: network connectivity can cause server requests to become lost, or the server itself can crash.</span></span> <span data-ttu-id="4c87b-107">Com as opções padrão, o RPC nunca atingirá o tempo limite de uma chamada e o thread do cliente aguardará para uma resposta de forma contínua.</span><span class="sxs-lookup"><span data-stu-id="4c87b-107">With default options, RPC will never time out a call, and your client thread will wait forever for a response.</span></span>

<span data-ttu-id="4c87b-108">Há dois métodos para evitar isso: Mantenha alives e tempos limite.</span><span class="sxs-lookup"><span data-stu-id="4c87b-108">There are two methods to prevent this: keep alives and time outs.</span></span>

## <a name="tcp-keep-alives"></a><span data-ttu-id="4c87b-109">TCP Keep Alive</span><span class="sxs-lookup"><span data-stu-id="4c87b-109">TCP Keep Alives</span></span>

<span data-ttu-id="4c87b-110">O cliente pode ser configurado para executar ping no servidor periodicamente para garantir que o servidor esteja ativo e em execução.</span><span class="sxs-lookup"><span data-stu-id="4c87b-110">The client can be set up to periodically ping the server to ensure the server is alive and running.</span></span> <span data-ttu-id="4c87b-111">Os pings são TCP Keep-Alive para as sequências de protocolo [**\_ http**](/windows/desktop/Midl/ncacn-http) TCP e ncacn de [**\_ \_ IP ncacn**](/windows/desktop/Midl/ncacn-ip-tcp) e, dessa forma, são eficientes na utilização da CPU e na largura de banda da rede.</span><span class="sxs-lookup"><span data-stu-id="4c87b-111">The pings are TCP keep-alives for the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences, and as such, they are efficient in CPU utilization and network bandwidth.</span></span> <span data-ttu-id="4c87b-112">Para habilitar o Keep Alive em uma determinada chamada de procedimento remoto, use a função [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) antes de a chamada ser iniciada.</span><span class="sxs-lookup"><span data-stu-id="4c87b-112">To enable keep alives on a given remote procedure call, use the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function before the call is initiated.</span></span> <span data-ttu-id="4c87b-113">Essa função usa um identificador de associação e um tempo limite como argumentos.</span><span class="sxs-lookup"><span data-stu-id="4c87b-113">This function takes a binding handle and a time out as arguments.</span></span> <span data-ttu-id="4c87b-114">Cada chamada de procedimento remoto nesse identificador de ligação após **RpcMgmtSetComTimeout** usa o tempo limite fornecido.</span><span class="sxs-lookup"><span data-stu-id="4c87b-114">Every remote procedure call on this binding handle after **RpcMgmtSetComTimeout** uses the supplied time out.</span></span>

<span data-ttu-id="4c87b-115">O parâmetro Timeout para a função [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) especifica por quanto tempo a execução de RPC espera antes de ativar Keep Alive.</span><span class="sxs-lookup"><span data-stu-id="4c87b-115">The Timeout parameter for the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function specifies how long the RPC run time waits before it turns on keep alives.</span></span> <span data-ttu-id="4c87b-116">O tempo limite é um valor entre 0 e 10, em que 0 é o tempo limite mínimo e 10 é o tempo limite infinito (sem tempo limite).</span><span class="sxs-lookup"><span data-stu-id="4c87b-116">The time out is a value between 0 and 10, where 0 is the minimal time out, and 10 is infinite time out (no time out).</span></span> <span data-ttu-id="4c87b-117">O tempo limite em si não é em segundos; a conversão do valor de tempo limite fornecido para a função **RpcMgmtSetComTimeout** para segundos é feita pelo tempo de execução de RPC e é específica da implementação.</span><span class="sxs-lookup"><span data-stu-id="4c87b-117">The time out itself is not in seconds; the translation from the time-out value supplied to the **RpcMgmtSetComTimeout** function to seconds is done by the RPC run time, and is implementation specific.</span></span>

<span data-ttu-id="4c87b-118">A tabela a seguir fornece a tradução para segundos para o Windows 2000 e o Windows XP.</span><span class="sxs-lookup"><span data-stu-id="4c87b-118">The following table provides the translation to seconds for Windows 2000 and Windows XP.</span></span> <span data-ttu-id="4c87b-119">Versões futuras do Windows podem alterar o mapeamento entre o parâmetro Timeout e o valor de tempo limite em segundos:</span><span class="sxs-lookup"><span data-stu-id="4c87b-119">Future versions of Windows may change the mapping between the Timeout parameter and the time-out value in seconds:</span></span>

| <span data-ttu-id="4c87b-120">Parâmetro Timeout</span><span class="sxs-lookup"><span data-stu-id="4c87b-120">Timeout parameter</span></span>                       | <span data-ttu-id="4c87b-121">Tempo limite real em segundos</span><span class="sxs-lookup"><span data-stu-id="4c87b-121">Actual time out in seconds</span></span> |
|-----------------------------------------|----------------------------|
| <span data-ttu-id="4c87b-122">0 ( \_ \_ \_ tempo limite mínimo de associação RPC C \_ )</span><span class="sxs-lookup"><span data-stu-id="4c87b-122">0 (RPC\_C\_BINDING\_MIN\_TIMEOUT)</span></span>       | <span data-ttu-id="4c87b-123">120</span><span class="sxs-lookup"><span data-stu-id="4c87b-123">120</span></span>                        |
| <span data-ttu-id="4c87b-124">1</span><span class="sxs-lookup"><span data-stu-id="4c87b-124">1</span></span>                                       | <span data-ttu-id="4c87b-125">240</span><span class="sxs-lookup"><span data-stu-id="4c87b-125">240</span></span>                        |
| <span data-ttu-id="4c87b-126">2</span><span class="sxs-lookup"><span data-stu-id="4c87b-126">2</span></span>                                       | <span data-ttu-id="4c87b-127">360</span><span class="sxs-lookup"><span data-stu-id="4c87b-127">360</span></span>                        |
| <span data-ttu-id="4c87b-128">3</span><span class="sxs-lookup"><span data-stu-id="4c87b-128">3</span></span>                                       | <span data-ttu-id="4c87b-129">480</span><span class="sxs-lookup"><span data-stu-id="4c87b-129">480</span></span>                        |
| <span data-ttu-id="4c87b-130">4</span><span class="sxs-lookup"><span data-stu-id="4c87b-130">4</span></span>                                       | <span data-ttu-id="4c87b-131">600</span><span class="sxs-lookup"><span data-stu-id="4c87b-131">600</span></span>                        |
| <span data-ttu-id="4c87b-132">5 ( \_ \_ \_ tempo limite padrão de associação RPC C \_ )</span><span class="sxs-lookup"><span data-stu-id="4c87b-132">5 (RPC\_C\_BINDING\_DEFAULT\_TIMEOUT)</span></span>   | <span data-ttu-id="4c87b-133">720</span><span class="sxs-lookup"><span data-stu-id="4c87b-133">720</span></span>                        |
| <span data-ttu-id="4c87b-134">6</span><span class="sxs-lookup"><span data-stu-id="4c87b-134">6</span></span>                                       | <span data-ttu-id="4c87b-135">840</span><span class="sxs-lookup"><span data-stu-id="4c87b-135">840</span></span>                        |
| <span data-ttu-id="4c87b-136">7</span><span class="sxs-lookup"><span data-stu-id="4c87b-136">7</span></span>                                       | <span data-ttu-id="4c87b-137">960</span><span class="sxs-lookup"><span data-stu-id="4c87b-137">960</span></span>                        |
| <span data-ttu-id="4c87b-138">8</span><span class="sxs-lookup"><span data-stu-id="4c87b-138">8</span></span>                                       | <span data-ttu-id="4c87b-139">1080</span><span class="sxs-lookup"><span data-stu-id="4c87b-139">1080</span></span>                       |
| <span data-ttu-id="4c87b-140">9 ( \_ \_ \_ tempo limite máximo de associação RPC C \_ )</span><span class="sxs-lookup"><span data-stu-id="4c87b-140">9 (RPC\_C\_BINDING\_MAX\_TIMEOUT)</span></span>       | <span data-ttu-id="4c87b-141">1200</span><span class="sxs-lookup"><span data-stu-id="4c87b-141">1200</span></span>                       |
| <span data-ttu-id="4c87b-142">10 ( \_ \_ \_ tempo limite infinito de associação RPC C \_ )</span><span class="sxs-lookup"><span data-stu-id="4c87b-142">10 (RPC\_C\_BINDING\_INFINITE\_TIMEOUT)</span></span> | <span data-ttu-id="4c87b-143">Tempo limite infinito</span><span class="sxs-lookup"><span data-stu-id="4c87b-143">Infinite time out</span></span>          |



 

<span data-ttu-id="4c87b-144">Quando os keep alives são ativados, o cliente envia um pacote Keep Alive a cada segundo.</span><span class="sxs-lookup"><span data-stu-id="4c87b-144">Once the keep alives are turned on, the client sends one keep alive packet every second.</span></span> <span data-ttu-id="4c87b-145">Se não houver nenhuma confirmação do servidor para três ou mais Keep Alive, o cliente declara a conexão inativa e falha na chamada de procedimento remoto.</span><span class="sxs-lookup"><span data-stu-id="4c87b-145">If there is no acknowledgment from the server for three or more keep alives, the client declares the connection dead and fails the remote procedure call.</span></span> <span data-ttu-id="4c87b-146">Se o servidor enviar uma resposta dentro do tempo limite especificado, o Keep Alive não será ativado.</span><span class="sxs-lookup"><span data-stu-id="4c87b-146">If the server sends a response within the specified time out, keep alives will not be turned on.</span></span> <span data-ttu-id="4c87b-147">Se o servidor responder ao Keep Alive, mas não responder à chamada de procedimento remoto, o cliente continuará enviando Keep Alive.</span><span class="sxs-lookup"><span data-stu-id="4c87b-147">If the server responds to keep alives, but does not respond to the remote procedure call, the client continues sending keep alives.</span></span> <span data-ttu-id="4c87b-148">Depois que o servidor responde à chamada RPC, as keep alives são desativadas.</span><span class="sxs-lookup"><span data-stu-id="4c87b-148">Once the server responds to the RPC call, the keep alives are turned off.</span></span> <span data-ttu-id="4c87b-149">Para o Windows 2000, Keep Alives são ativados apenas para chamadas RPC síncronas.</span><span class="sxs-lookup"><span data-stu-id="4c87b-149">For Windows 2000, keep alives are turned on only for synchronous RPC calls.</span></span> <span data-ttu-id="4c87b-150">Para o Windows XP, os keep alives também são ativados para chamadas RPC assíncronas.</span><span class="sxs-lookup"><span data-stu-id="4c87b-150">For Windows XP, keep alives are turned on for asynchronous RPC calls as well.</span></span>

<span data-ttu-id="4c87b-151">É tentador definir keep alives para o valor mais baixo para garantir que o aplicativo cliente responda a problemas de rede em tempo hábil.</span><span class="sxs-lookup"><span data-stu-id="4c87b-151">It is tempting to set keep alives to the lowest value to ensure the client application responds to network problems in a timely fashion.</span></span> <span data-ttu-id="4c87b-152">Uma consideração cuidadosa deve ser dada a essa tentação e fiscalização aplicada a se um valor agressivo é garantido.</span><span class="sxs-lookup"><span data-stu-id="4c87b-152">Careful consideration should be given to such temptation, and scrutiny applied to whether an aggressive value is warranted.</span></span> <span data-ttu-id="4c87b-153">Um servidor que perde temporariamente a conectividade pode se encontrar inundado com Keep Alive de vários clientes quando a conectividade é restaurada.</span><span class="sxs-lookup"><span data-stu-id="4c87b-153">A server that temporarily loses connectivity may find itself flooded with keep alives from numerous clients once connectivity is restored.</span></span> <span data-ttu-id="4c87b-154">Além disso, tarefas computacionais longas podem levar mais de dois minutos, e o servidor pode se perder mais tempo de CPU respondendo manter ativos do que a execução de um trabalho útil.</span><span class="sxs-lookup"><span data-stu-id="4c87b-154">In addition, long computational tasks can take more than two minutes, and the server may find itself spending more CPU time answering keep alives than performing useful work.</span></span> <span data-ttu-id="4c87b-155">Portanto, Keep Alives devem ser usados com moderação.</span><span class="sxs-lookup"><span data-stu-id="4c87b-155">Therefore, keep alives should be used with moderation.</span></span> <span data-ttu-id="4c87b-156">Se o cliente não puder tolerar seu thread sendo ligado por longos períodos, o RPC assíncrono deverá ser considerado.</span><span class="sxs-lookup"><span data-stu-id="4c87b-156">If the client cannot tolerate its thread being tied up for long periods, asynchronous RPC should be considered.</span></span>

<span data-ttu-id="4c87b-157">Outras sequências de protocolo podem implementar diferentes mecanismos para detectar servidores sem resposta, dependendo de qual transporte é usado.</span><span class="sxs-lookup"><span data-stu-id="4c87b-157">Other protocol sequences may implement different mechanisms for detecting unresponsive servers, depending on which transport is used.</span></span> <span data-ttu-id="4c87b-158">O transporte [**Ncalrpc**](/windows/desktop/Midl/ncalrpc) não usa keep alives.</span><span class="sxs-lookup"><span data-stu-id="4c87b-158">The [**ncalrpc**](/windows/desktop/Midl/ncalrpc) transport does not use keep alives.</span></span> <span data-ttu-id="4c87b-159">Como todas as comunicações em **Ncalrpc** são locais, se o servidor ficar sem resposta enquanto uma chamada estiver em andamento, o tempo de execução de RPC no cliente falhará imediatamente na chamada.</span><span class="sxs-lookup"><span data-stu-id="4c87b-159">Since all communications in **ncalrpc** are local, if the server becomes unresponsive while a call is in progress, the RPC run time on the client immediately fails the call.</span></span>

## <a name="call-time-outs"></a><span data-ttu-id="4c87b-160">Tempo limite de chamada</span><span class="sxs-lookup"><span data-stu-id="4c87b-160">Call Time Outs</span></span>

<span data-ttu-id="4c87b-161">O TCP Keep Alive será suficiente se a conectividade de rede for perdida ou se o servidor falhar.</span><span class="sxs-lookup"><span data-stu-id="4c87b-161">TCP keep alives are fine if network connectivity is lost, or if the server crashes.</span></span> <span data-ttu-id="4c87b-162">Mas se o servidor tiver deadlocks no modo de usuário, o TCP Keep Alives retornará com êxito, mas a chamada nunca será retornada.</span><span class="sxs-lookup"><span data-stu-id="4c87b-162">But if the server deadlocks in user mode, TCP keep alives return successfully but the call will never return.</span></span> <span data-ttu-id="4c87b-163">Para lidar com esse cenário, uma nova opção de tempo de execução foi adicionada ao Windows XP: \_ tempo limite de chamada de aceitação de RPC C \_ \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="4c87b-163">To deal with this scenario, a new run-time option was added for Windows XP: RPC\_C\_OPT\_CALL\_TIMEOUT.</span></span> <span data-ttu-id="4c87b-164">Essa opção instrui o tempo de execução de RPC a configurar um temporizador sempre que ele envia uma solicitação ao servidor.</span><span class="sxs-lookup"><span data-stu-id="4c87b-164">This option instructs the RPC run time to set up a timer each time it sends a request to the server.</span></span> <span data-ttu-id="4c87b-165">Se o temporizador expirar, a chamada será automaticamente cancelada e concluída com a \_ chamada RPC S \_ \_ cancelada.</span><span class="sxs-lookup"><span data-stu-id="4c87b-165">If the timer expires, the call is automatically canceled and completes with RPC\_S\_CALL\_CANCELLED.</span></span> <span data-ttu-id="4c87b-166">Desde que o servidor responda dentro do limite de tempo especificado, o cliente não cancelará a chamada.</span><span class="sxs-lookup"><span data-stu-id="4c87b-166">As long as the server responds within the specified time limit, the client will not cancel the call.</span></span> <span data-ttu-id="4c87b-167">Isso significa que uma chamada de multifrags pode levar mais do que o período de tempo limite para ser concluída, uma vez que cada resposta do servidor é recebida dentro do período de tempo limite, mesmo que o período para que todas as respostas cheguem seja maior que o período de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="4c87b-167">This means a multifragment call may take more than the time-out period to complete, as each response from the server is received within the time-out period, even though the time period for all responses to arrive was more than the time-out period.</span></span>

<span data-ttu-id="4c87b-168">Além disso, quando uma chamada é cancelada, o servidor não é notificado do cancelamento.</span><span class="sxs-lookup"><span data-stu-id="4c87b-168">Also, when a call is canceled the server is not notified of the cancellation.</span></span> <span data-ttu-id="4c87b-169">O servidor, portanto, provavelmente executará a chamada em algum momento, e o cliente simplesmente irá ignorar a resposta do servidor.</span><span class="sxs-lookup"><span data-stu-id="4c87b-169">The server, therefore, will likely execute the call at some point, and the client will simply ignore the response from the server.</span></span>

<span data-ttu-id="4c87b-170">A armadilha mais perigosa com tempos limite de chamada é estabelecer um curto tempo limite e repetir a chamada no mesmo servidor.</span><span class="sxs-lookup"><span data-stu-id="4c87b-170">The most dangerous pitfall with call time outs is establishing a short time out and retrying the call on the same server.</span></span> <span data-ttu-id="4c87b-171">O cenário a seguir ilustra os perigos dessa abordagem:</span><span class="sxs-lookup"><span data-stu-id="4c87b-171">The following scenario illustrates the dangers of this approach:</span></span>

<span data-ttu-id="4c87b-172">Imagine um servidor que opere perto da capacidade.</span><span class="sxs-lookup"><span data-stu-id="4c87b-172">Imagine a server that operates near capacity.</span></span> <span data-ttu-id="4c87b-173">Ele tem vários clientes com tempo limite muito curto, como cinco segundos.</span><span class="sxs-lookup"><span data-stu-id="4c87b-173">It has a number of clients with very short time outs, such as five seconds.</span></span> <span data-ttu-id="4c87b-174">Uma perda temporária de conectividade de rede ou congestionamento em um roteador faz com que um lapso no servidor responda por alguns segundos.</span><span class="sxs-lookup"><span data-stu-id="4c87b-174">A temporary loss of network connectivity or congestion at a router causes a lapse in server replies for a few seconds.</span></span> <span data-ttu-id="4c87b-175">Em redes Ethernet, essa situação pode ser facilmente causada por uma intermitência de atividade em um link que o servidor compartilha com outra máquina.</span><span class="sxs-lookup"><span data-stu-id="4c87b-175">On Ethernet networks, this situation can easily be caused by a burst of activity on a link that the server shares with another machine.</span></span> <span data-ttu-id="4c87b-176">O servidor não é gerenciado para enviar todas as respostas antes do tempo limite de cinco segundos. Os clientes obtêm suas chamadas canceladas e imediatamente tentam novamente.</span><span class="sxs-lookup"><span data-stu-id="4c87b-176">The server does not manage to send all replies before the five-second time out. The clients get their calls canceled, and immediately retry.</span></span> <span data-ttu-id="4c87b-177">O servidor não está ciente de que as chamadas são repetições e as executa também.</span><span class="sxs-lookup"><span data-stu-id="4c87b-177">The server is not aware the calls are retries, and executes them as well.</span></span> <span data-ttu-id="4c87b-178">Portanto, em vez de executar sua carga de trabalho normal de chamadas, ele executa 30-50% mais chamadas, dependendo de quantos clientes atingiram o tempo limite. Se isso exceder sua capacidade e o servidor não puder responder a todos os clientes em cinco segundos, outra rodada de chamadas será enviada ao servidor.</span><span class="sxs-lookup"><span data-stu-id="4c87b-178">Thus, instead of executing its normal workload of calls, it executes 30-50% more calls, depending on how many clients timed out. If this exceeds its capacity, and the server cannot respond to all clients within five seconds, another round of calls are sent to the server.</span></span> <span data-ttu-id="4c87b-179">Os clientes continuam reemitindo as mesmas chamadas e, como o servidor está sobrecarregado processando chamadas anteriores, não é possível responder dentro do tempo limite. Depois de responder, os clientes atingiram o tempo limite, emitiram uma nova chamada e descartaram a resposta.</span><span class="sxs-lookup"><span data-stu-id="4c87b-179">The clients keep reissuing the same calls, and since the server is overloaded processing previous calls, it is unable to respond within the time out. Once it responds, the clients have hit the time out, issued a new call, and discarded the answer.</span></span> <span data-ttu-id="4c87b-180">Em um cenário de pior caso, o servidor não será recuperado até a reinicialização e, dependendo do padrão de acesso do cliente, poderá não se recuperar até que um número suficiente de clientes seja interrompido.</span><span class="sxs-lookup"><span data-stu-id="4c87b-180">In a worst case scenario, the server will not recover until reboot, and depending on client access pattern, may not recover until a sufficient number of clients are stopped.</span></span>

> [!Note]  
> <span data-ttu-id="4c87b-181">O tempo limite de chamada funciona apenas nas sequências de [**protocolo \_ http**](/windows/desktop/Midl/ncacn-http) TCP e ncacn de [**\_ \_ IP ncacn**](/windows/desktop/Midl/ncacn-ip-tcp) .</span><span class="sxs-lookup"><span data-stu-id="4c87b-181">Call time outs work only on the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences.</span></span>

 

 

 