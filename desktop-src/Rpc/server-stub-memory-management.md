---
title: Gerenciamento de memória de stub de servidor
description: Gerenciamento de memória de stub de servidor
ms.assetid: 99e3ee56-5adb-4b25-bcf2-316d1bbdbdba
keywords:
- Gerenciamento de memória de stub de servidor
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6e052df6da999e5371ac498a1d39852b4be2b5e
ms.sourcegitcommit: ae73f4dd3cf5a3c6a1ea7d191ca32a5b01f6686b
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/08/2020
ms.locfileid: "103824034"
---
# <a name="server-stub-memory-management"></a><span data-ttu-id="74b87-104">Gerenciamento de memória de stub de servidor</span><span class="sxs-lookup"><span data-stu-id="74b87-104">Server Stub Memory Management</span></span>

## <a name="an-introduction-to-server-stub-memory-management"></a><span data-ttu-id="74b87-105">Uma introdução ao gerenciamento de memória Server-Stub</span><span class="sxs-lookup"><span data-stu-id="74b87-105">An Introduction to Server-Stub Memory Management</span></span>

<span data-ttu-id="74b87-106">Os stubs gerados pelo MIDL atuam como a interface entre um processo de cliente e um processo de servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-106">MIDL-generated stubs act as the interface between a client process and a server process.</span></span> <span data-ttu-id="74b87-107">Um stub de cliente realiza marshaling de todos os dados passados para os parâmetros marcados com o atributo [**\[ in \]**](../midl/in.md) e os envia para o stub do servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-107">A client stub marshals all data passed to parameters marked with the [**\[in\]**](../midl/in.md) attribute, and sends it to the server stub.</span></span> <span data-ttu-id="74b87-108">O stub de servidor, após receber esses dados, reconstrói a pilha de chamadas e, em seguida, executa a função de servidor correspondente implementada pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="74b87-108">The server stub, upon receiving this data, reconstructs the call stack, and then executes the corresponding user-implemented server function.</span></span> <span data-ttu-id="74b87-109">O stub do servidor também realiza marshaling dos dados do parâmetro marcados com o atributo [**\[ out \]**](../midl/out-idl.md) e o retorna ao aplicativo cliente.</span><span class="sxs-lookup"><span data-stu-id="74b87-109">The server stub also marshals the parameter data marked with the [**\[out\]**](../midl/out-idl.md) attribute and returns it to the client application.</span></span>

<span data-ttu-id="74b87-110">O formato de dados com marshaling de 32 bits usado pelo MSRPC é uma versão compatível da sintaxe de transferência de data de representação (NDR) de rede.</span><span class="sxs-lookup"><span data-stu-id="74b87-110">The 32-bit marshaled data format used by MSRPC is a compliant version of the Network Data Representation (NDR) transfer syntax.</span></span> <span data-ttu-id="74b87-111">Para obter mais informações sobre esse formato, consulte [o site do grupo aberto](https://www.opengroup.org/).</span><span class="sxs-lookup"><span data-stu-id="74b87-111">For more information about this format, see [The Open Group website](https://www.opengroup.org/).</span></span> <span data-ttu-id="74b87-112">Para plataformas de 64 bits, uma extensão de Microsoft 64 bits para a sintaxe de transferência de NDR chamada NDR64 pode ser usada para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="74b87-112">For 64-bit platforms, a Microsoft 64-bit extension to NDR transfer syntax called NDR64 can be used for better performance.</span></span>

## <a name="unmarshaling-inbound-data"></a><span data-ttu-id="74b87-113">Desempacotamento de dados de entrada</span><span class="sxs-lookup"><span data-stu-id="74b87-113">Unmarshaling Inbound Data</span></span>

<span data-ttu-id="74b87-114">No MSRPC, o stub de cliente realiza marshaling de todos os dados de parâmetro marcados como [**\[ em \]**](../midl/in.md) um buffer contínuo para transmissão para o stub do servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-114">In MSRPC, the client stub marshals all of the parameter data tagged as [**\[in\]**](../midl/in.md) in one continuous buffer for transmission to the server stub.</span></span> <span data-ttu-id="74b87-115">Da mesma forma, o stub de servidor realiza marshaling de todos os dados marcados com o atributo [**\[ out \]**](../midl/out-idl.md) em um buffer contínuo para retornar ao stub do cliente.</span><span class="sxs-lookup"><span data-stu-id="74b87-115">Likewise, the server stub marshals all data marked with the [**\[out\]**](../midl/out-idl.md) attribute in a continuous buffer for return to the client stub.</span></span> <span data-ttu-id="74b87-116">Embora a camada de protocolo de rede sob RPC possa fragmentar e armazenar o buffer para transmissão, a fragmentação é transparente para os stubs de RPC.</span><span class="sxs-lookup"><span data-stu-id="74b87-116">While the network protocol layer beneath RPC can fragment and packetize the buffer for transmission, the fragmentation is transparent to the RPC stubs.</span></span>

<span data-ttu-id="74b87-117">A alocação de memória para criar o quadro de chamada do servidor pode ser uma operação cara.</span><span class="sxs-lookup"><span data-stu-id="74b87-117">Memory allocation for creating the server call frame can be an expensive operation.</span></span> <span data-ttu-id="74b87-118">O stub do servidor tentará minimizar o uso de memória desnecessário, quando possível, e supõe-se que a rotina do servidor não liberará ou Realocará dados marcados com os atributos [**\[ in \]**](../midl/in.md) ou **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="74b87-118">The server stub will attempt to minimize unnecessary memory usage when possible, and it is assumed that the server routine will not free or reallocate data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="74b87-119">O stub de servidor tenta reutilizar os dados no buffer sempre que possível para evitar a duplicação desnecessária.</span><span class="sxs-lookup"><span data-stu-id="74b87-119">The server stub attempts to reuse data in the buffer whenever possible to avoid unnecessary duplication.</span></span> <span data-ttu-id="74b87-120">A regra geral é que, se o formato de dados marshaled for igual ao formato de memória, o RPC usará ponteiros para os dados marshalled em vez de alocar memória adicional para dados formatados de forma idêntica.</span><span class="sxs-lookup"><span data-stu-id="74b87-120">The general rule is that if the marshaled data format is the same as the memory format, RPC will use pointers to the marshalled data instead of allocating additional memory for identically formatted data.</span></span>

<span data-ttu-id="74b87-121">Por exemplo, a chamada RPC a seguir é definida com uma estrutura cujo formato empacotado é idêntico ao seu formato na memória.</span><span class="sxs-lookup"><span data-stu-id="74b87-121">For example, the following RPC call is defined with a structure whose marshaled format is identical to its in-memory format.</span></span>

``` syntax
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```

<span data-ttu-id="74b87-122">Nesse caso, o RPC não aloca memória adicional para os dados referenciados por *plInStructure*; em vez disso, ele simplesmente passa o ponteiro para os dados empacotados para a implementação da função do lado do servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-122">In this case, RPC does not allocate additional memory for the data referenced by *plInStructure*; rather, it simply passes the pointer to the marshaled data to the server-side function implementation.</span></span> <span data-ttu-id="74b87-123">O stub do servidor RPC verifica o buffer durante o processo de desempacotamento se o stub for compilado usando o sinalizador "-robusto" (que é uma configuração padrão na versão recente do nmost do compilador MIDL).</span><span class="sxs-lookup"><span data-stu-id="74b87-123">The RPC server stub verifies the buffer during the unmarshaling process if the stub is compiled using the "-robust" flag (which is a default setting in the nmost recent version of the MIDL compiler).</span></span> <span data-ttu-id="74b87-124">O RPC garante que os dados passados para a implementação da função do lado do servidor sejam válidos.</span><span class="sxs-lookup"><span data-stu-id="74b87-124">RPC guarantees that the data passed to the server-side function implementation is valid.</span></span>

<span data-ttu-id="74b87-125">Lembre-se de que a memória é alocada para *plOutStructure*, já que nenhum dado é passado para o servidor para ele.</span><span class="sxs-lookup"><span data-stu-id="74b87-125">Be aware that memory is allocated for *plOutStructure*, since no data is passed to the server for it.</span></span>

## <a name="memory-allocation-for-inbound-data"></a><span data-ttu-id="74b87-126">Alocação de memória para dados de entrada</span><span class="sxs-lookup"><span data-stu-id="74b87-126">Memory Allocation for Inbound Data</span></span>

<span data-ttu-id="74b87-127">Podem surgir casos em que o stub do servidor aloca memória para dados de parâmetro marcados com os atributos [**\[ in \]**](../midl/in.md) ou **\[ in \] , out** .</span><span class="sxs-lookup"><span data-stu-id="74b87-127">Cases can arise where the server stub allocates memory for parameter data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="74b87-128">Isso ocorre quando o formato de dados empacotados difere do formato de memória ou quando as estruturas que compõem os dados de marshaling são suficientes e devem ser lidas atomicamente pelo stub do servidor RPC.</span><span class="sxs-lookup"><span data-stu-id="74b87-128">This occurs when the marshaled data format differs from the memory format, or when the structures that comprise the marshaled data are sufficient complex and must be read atomically by the RPC server stub.</span></span> <span data-ttu-id="74b87-129">A lista abaixo mostra vários casos comuns em que a memória deve ser alocada para os dados recebidos pelo stub do servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-129">Listed below are several common cases when memory must be allocated for data received by the server stub.</span></span>

-   <span data-ttu-id="74b87-130">Os dados são uma matriz variável ou uma matriz de variação em conformidade.</span><span class="sxs-lookup"><span data-stu-id="74b87-130">The data is a varying array or a conformant varying array.</span></span> <span data-ttu-id="74b87-131">Essas são as matrizes (ou ponteiros para matrizes) que têm o [**\[ comprimento \_ () \]**](../midl/length-is.md) ou o [**\[ primeiro atributo \_ é () \]**](../midl/first-is.md) definido nelas.</span><span class="sxs-lookup"><span data-stu-id="74b87-131">These are arrays (or pointers to arrays) that have the [**\[length\_is()\]**](../midl/length-is.md) or [**\[first\_is()\]**](../midl/first-is.md) attribute set on them.</span></span> <span data-ttu-id="74b87-132">No NDR, somente o primeiro elemento dessas matrizes é empacotado e transmitido.</span><span class="sxs-lookup"><span data-stu-id="74b87-132">In NDR, only the first element of these arrays are marshaled and transmitted.</span></span> <span data-ttu-id="74b87-133">Por exemplo, no trecho de código abaixo, os dados passados no parâmetro *VP* terão memória alocada para ele.</span><span class="sxs-lookup"><span data-stu-id="74b87-133">For example, in the code snippet below, the data passed in the parameter *pv* will have memory allocated for it.</span></span>

    ``` syntax
    void RpcFunction
    (
        [in] long size,
        [in, out] long *pLength,
        [in, out, size_is(size), length_is(*pLength)] long *pv
    );
    ```

-   <span data-ttu-id="74b87-134">Os dados são uma cadeia de caracteres de tamanho ou uma cadeia de caracteres não compatível.</span><span class="sxs-lookup"><span data-stu-id="74b87-134">The data is a sized string or non-conformant string.</span></span> <span data-ttu-id="74b87-135">Essas cadeias de caracteres geralmente são ponteiros para dados de caractere marcados com o atributo [**\[ Size \_ is () \]**](../midl/size-is.md) .</span><span class="sxs-lookup"><span data-stu-id="74b87-135">These strings are usually pointers to character data tagged with the [**\[size\_is()\]**](../midl/size-is.md) attribute.</span></span> <span data-ttu-id="74b87-136">No exemplo a seguir, a cadeia de caracteres passada para a função **dimensionada** do lado do servidor terá memória alocada, enquanto a cadeia de caracteres passada para a função **normalstring** será reutilizada.</span><span class="sxs-lookup"><span data-stu-id="74b87-136">In the example below, the string passed to the **SizedString** server-side function will have memory allocated, whereas the string passed to the **NormalString** function will be reused.</span></span>

    ``` syntax
    void SizedString
    (
        [in] long size,
        [in, size_is(size), string] char *str
    );

    void NormalString
    (
        [in, string] char str
    );
    ```

-   <span data-ttu-id="74b87-137">Os dados são um tipo simples cujo tamanho da memória difere de seu tamanho de marshaling, como **enum16** e **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="74b87-137">The data is a simple type whose memory size differs from its marshaled size, such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="74b87-138">Os dados são definidos por uma estrutura cujo alinhamento de memória é menor do que o alinhamento natural, contém qualquer um dos tipos de dados acima ou tem um preenchimento de byte à direita.</span><span class="sxs-lookup"><span data-stu-id="74b87-138">The data is defined by a structure whose memory alignment is smaller than the natural alignment, contains any of the above data types, or has trailing byte padding.</span></span> <span data-ttu-id="74b87-139">Por exemplo, a estrutura de dados complexa a seguir forçou o alinhamento de 2 bytes e tem preenchimento no final.</span><span class="sxs-lookup"><span data-stu-id="74b87-139">For example, the following complex data structure has forced 2-byte alignment and has padding at the end.</span></span>

    ``` syntax
#pragma pack(2)
    typedef struct ComplexPackedStructure
    {
        char c;  
        long l;   // alignment is forced at the second byte
        char c2;  // there will be a trailing one-byte pad to keep 2-byte alignment
    }
    ```

-   <span data-ttu-id="74b87-140">Os dados contêm uma estrutura que deve ser empacotada em campo por campo.</span><span class="sxs-lookup"><span data-stu-id="74b87-140">The data contains a structure that must be marshaled field by field.</span></span> <span data-ttu-id="74b87-141">Esses campos incluem ponteiros de interface definidos em interfaces DCOM; ponteiros ignorados; valores inteiros definidos com o [**\[ atributo \] Range**](../midl/range.md) ; os elementos de matrizes definidos com a [**\[ conexão \_ Marshal \]**](../midl/wire-marshal.md), [**\[ user \_ Marshal \]**](../midl/user-marshal.md), [**\[ Transmit \_ como \]**](../midl/transmit-as.md) e [**\[ representam \_ como \]**](../midl/represent-as.md) atributos e estruturas de dados complexas inseridas.</span><span class="sxs-lookup"><span data-stu-id="74b87-141">These fields include interface pointers defined in DCOM interfaces; ignored pointers; integer values set with the [**\[range\]**](../midl/range.md) attribute; elements of arrays defined with the [**\[wire\_marshal\]**](../midl/wire-marshal.md), [**\[user\_marshal\]**](../midl/user-marshal.md), [**\[transmit\_as\]**](../midl/transmit-as.md) and [**\[represent\_as\]**](../midl/represent-as.md) attributes; and embedded complex data structures.</span></span>
-   <span data-ttu-id="74b87-142">Os dados contêm uma União, uma estrutura que contém uma União ou uma matriz de uniões.</span><span class="sxs-lookup"><span data-stu-id="74b87-142">The data contains a union, a structure containing a union, or an array of unions.</span></span> <span data-ttu-id="74b87-143">Somente a ramificação específica da União é empacotada na conexão.</span><span class="sxs-lookup"><span data-stu-id="74b87-143">Only the specific branch of the union is marshaled on the wire.</span></span>
-   <span data-ttu-id="74b87-144">Os dados contêm uma estrutura com uma matriz de conformidade multidimensional que tem pelo menos uma dimensão não fixa.</span><span class="sxs-lookup"><span data-stu-id="74b87-144">The data contains a structure with a multidimensional conformant array that has at least one non-fixed dimension.</span></span>
-   <span data-ttu-id="74b87-145">Os dados contêm uma matriz de estruturas complexas.</span><span class="sxs-lookup"><span data-stu-id="74b87-145">The data contains an array of complex structures.</span></span>
-   <span data-ttu-id="74b87-146">Os dados contêm uma matriz de tipos de dados simples, como **enum16** e **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="74b87-146">The data contains an array of simple data types such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="74b87-147">Os dados contêm uma matriz de ponteiros de referência e de interface.</span><span class="sxs-lookup"><span data-stu-id="74b87-147">The data contains an array of ref and interface pointers.</span></span>
-   <span data-ttu-id="74b87-148">Os dados têm um atributo [**\[ Force \_ ALLOCATE \]**](../midl/force-allocate.md) aplicado a um ponteiro.</span><span class="sxs-lookup"><span data-stu-id="74b87-148">The data has a [**\[force\_allocate\]**](../midl/force-allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="74b87-149">Os dados têm um atributo [**\[ ALLOCATE (todos os \_ nós) \]**](../midl/allocate.md) aplicado a um ponteiro.</span><span class="sxs-lookup"><span data-stu-id="74b87-149">The data has a [**\[allocate(all\_nodes)\]**](../midl/allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="74b87-150">Os dados têm um atributo de [**\[ \_ contagem \] de bytes**](../midl/byte-count.md) aplicado a um ponteiro.</span><span class="sxs-lookup"><span data-stu-id="74b87-150">The data has a [**\[byte\_count\]**](../midl/byte-count.md) attribute applied to a pointer.</span></span>

## <a name="64-bit-data-and-ndr64-transfer-syntax"></a><span data-ttu-id="74b87-151">Dados de 64 bits e a sintaxe de transferência NDR64</span><span class="sxs-lookup"><span data-stu-id="74b87-151">64-bit Data and NDR64 Transfer Syntax</span></span>

<span data-ttu-id="74b87-152">Conforme mencionado anteriormente, os dados de 64 bits são marshalled usando uma sintaxe de transferência de 64 bits específica chamada NDR64.</span><span class="sxs-lookup"><span data-stu-id="74b87-152">As mentioned previously, 64-bit data is marshalled using a specific 64-bit transfer syntax called NDR64.</span></span> <span data-ttu-id="74b87-153">Essa sintaxe de transferência foi desenvolvida para resolver o problema específico que surge quando os ponteiros são empacotados no NDR de 32 bits e transmitidos para um stub de servidor em uma plataforma de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="74b87-153">This transfer syntax was developed to address the specific issue that arises when pointers are marshaled under 32-bit NDR and transmitted to a server-stub on a 64-bit platform.</span></span> <span data-ttu-id="74b87-154">Nesse caso, um ponteiro de dados de 32 bits com marshaling não corresponde a um de 64 bits, e a alocação de memória invariavelmente ocorrerá.</span><span class="sxs-lookup"><span data-stu-id="74b87-154">In this case, a marshaled 32-bit data pointer does not match a 64-bit one, and memory allocation will invariably occur.</span></span> <span data-ttu-id="74b87-155">Para criar um comportamento mais consistente em plataformas de 64 bits, a Microsoft desenvolveu uma nova sintaxe de transferência chamada NDR64.</span><span class="sxs-lookup"><span data-stu-id="74b87-155">To create a more consistent behavior on 64-bit platforms, Microsoft developed a new transfer syntax called NDR64.</span></span>

<span data-ttu-id="74b87-156">Um exemplo que ilustra esse problema é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="74b87-156">An example illustrating this problem is as follows:</span></span>


```C++
typedef struct PtrStruct
{
  long l;
  long *pl;
}
```



<span data-ttu-id="74b87-157">Essa estrutura, quando empacotada, será reutilizada pelo stub do servidor em um sistema de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="74b87-157">This structure, when marshaled, will be reused by the server stub on a 32-bit system.</span></span> <span data-ttu-id="74b87-158">No entanto, se o stub do servidor residir em um sistema de 64 bits, os dados empacotados por NDR terão 4 bytes de comprimento, mas o tamanho de memória necessário será 8.</span><span class="sxs-lookup"><span data-stu-id="74b87-158">However, if the server stub resides on a 64-bit system, the NDR-marshaled data is 4 bytes in length, but the required memory size will be 8.</span></span> <span data-ttu-id="74b87-159">Como resultado, a alocação de memória é forçada e a reutilização de buffer raramente ocorrerá.</span><span class="sxs-lookup"><span data-stu-id="74b87-159">As a result, memory allocation is forced, and buffer reuse will rarely occur.</span></span> <span data-ttu-id="74b87-160">NDR64 resolve esse problema fazendo o tamanho do marshaling de um ponteiro de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="74b87-160">NDR64 addresses this problem by making the marshaled size of a pointer 64-bit.</span></span>

<span data-ttu-id="74b87-161">Em contraste com o NDR de 32 bits, tyes de dados simples como **enum16** e **\_ \_ int3264** não tornam uma estrutura ou matriz complexa em NDR64.</span><span class="sxs-lookup"><span data-stu-id="74b87-161">In contrast with 32-bit NDR, simple data tyes such as **enum16** and **\_\_int3264** do not make a structure or array complex under NDR64.</span></span> <span data-ttu-id="74b87-162">Da mesma forma, os valores de preenchimento à direita não tornam uma estrutura complexa.</span><span class="sxs-lookup"><span data-stu-id="74b87-162">Likewise, trailing pad values do not make a structure complex.</span></span> <span data-ttu-id="74b87-163">Ponteiros de interface são tratados como ponteiros exclusivos no nível superior; Como resultado, estruturas e matrizes contendo ponteiros de interface não são consideradas complexas e não exigem alocação de memória específica para seu uso.</span><span class="sxs-lookup"><span data-stu-id="74b87-163">Interface pointers are treated as unique pointers at the top level; as a result, structures and arrays containing interface pointers are not considered complex and will not require specific memory allocation for their use.</span></span>

## <a name="initializing-outbound-data"></a><span data-ttu-id="74b87-164">Inicializando dados de saída</span><span class="sxs-lookup"><span data-stu-id="74b87-164">Initializing Outbound Data</span></span>

<span data-ttu-id="74b87-165">Depois que todos os dados de entrada tiverem sido desempacotados, o stub do servidor precisará inicializar os ponteiros somente de saída marcados com o atributo [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="74b87-165">After all of the inbound data has been unmarshalled, the server stub needs to initialize the outbound-only pointers marked with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span>


```C++
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```



<span data-ttu-id="74b87-166">Na chamada acima, o stub do servidor deve inicializar *plOutStructure* porque ele não estava presente nos dados empacotados e é um ponteiro de [**\[ referência \]**](../midl/ref.md) implícito que deve ser disponibilizado para a implementação da função de servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-166">In the above call, the server stub must initialize *plOutStructure* because it was not present in the marshaled data, and it is an implied [**\[ref\]**](../midl/ref.md) pointer that must be made available to the server function implementation.</span></span> <span data-ttu-id="74b87-167">O stub do servidor RPC Inicializa e zera quaisquer ponteiros somente de referência de nível superior com o atributo [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="74b87-167">The RPC server stub initializes and zeroes out any top-level reference-only pointers with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span> <span data-ttu-id="74b87-168">Quaisquer ponteiros de referência **\[ out \]** abaixo dele são inicializados recursivamente também.</span><span class="sxs-lookup"><span data-stu-id="74b87-168">Any **\[out\]** reference pointers beneath it are recursively initialized as well.</span></span> <span data-ttu-id="74b87-169">A recursão é interrompida a qualquer ponteiro com os atributos [**\[ Unique \]**](../midl/unique.md) ou [**\[ PTR \]**](../midl/ptr.md) definidos neles.</span><span class="sxs-lookup"><span data-stu-id="74b87-169">The recursion stops at any pointers with the [**\[unique\]**](../midl/unique.md) or [**\[ptr\]**](../midl/ptr.md) attributes set on them.</span></span>

<span data-ttu-id="74b87-170">A implementação da função de servidor não pode alterar diretamente valores de ponteiro de nível superior e, portanto, não pode realocá-los.</span><span class="sxs-lookup"><span data-stu-id="74b87-170">The server function implementation cannot directly alter top-level pointer values, and thus cannot reallocate them.</span></span> <span data-ttu-id="74b87-171">Por exemplo, na implementação de **ProcessRpcStructure** acima, o código a seguir é inválido:</span><span class="sxs-lookup"><span data-stu-id="74b87-171">For example, in the implementation of **ProcessRpcStructure** above, the following code is invalid:</span></span>


```C++
void ProcessRpcStructure(RpcStructure *plInStructure, rpcStructure *plOutStructure)
{
    plOutStructure = MIDL_user_allocate(sizeof(RpcStructure));
    Process(plOutStructure);
}
```



<span data-ttu-id="74b87-172">*plOutStructure* é um valor de pilha e sua alteração não é propagada de volta para RPC.</span><span class="sxs-lookup"><span data-stu-id="74b87-172">*plOutStructure* is a stack value and its change is not propagated back to RPC.</span></span> <span data-ttu-id="74b87-173">A implementação da função de servidor pode tentar evitar a alocação ao tentar liberar *plOutStructure*, o que pode resultar em corrupção de memória.</span><span class="sxs-lookup"><span data-stu-id="74b87-173">The server function implementation can attempt to avoid allocation by attempting to free *plOutStructure*, which may result in memory corruption.</span></span> <span data-ttu-id="74b87-174">O stub de servidor alocará espaço para o ponteiro de nível superior na memória (no caso de ponteiro para ponteiro) e uma estrutura simples de nível superior cujo tamanho na pilha é menor do que o esperado.</span><span class="sxs-lookup"><span data-stu-id="74b87-174">The server stub will then allocate space for the top-level pointer in memory (in the pointer-to-pointer case) and a top-level simple structure whose size on the stack is smaller than expected.</span></span>

<span data-ttu-id="74b87-175">O cliente pode, em determinadas circunstâncias, especificar o tamanho de alocação de memória do lado do servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-175">The client can, under certain circumstances, specify the memory allocation size of the server side.</span></span> <span data-ttu-id="74b87-176">No exemplo a seguir, o cliente especifica o tamanho dos dados de saída no parâmetro de *tamanho* de entrada.</span><span class="sxs-lookup"><span data-stu-id="74b87-176">In the following example, the client specifies the size of the outbound data in the inbound *size* parameter.</span></span>

``` syntax
void VariableSizeData
(
    [in] long size,
    [out, size_is(size)] char *pv
);
```

<span data-ttu-id="74b87-177">Depois de desempacotar os dados de entrada, incluindo o *tamanho*, o stub do servidor aloca um buffer para *VP* com um tamanho de "tamanho (caractere) \* ".</span><span class="sxs-lookup"><span data-stu-id="74b87-177">After unmarshalling the inbound data, including *size*, the server stub allocates a buffer for *pv* with a size of "sizeof(char)\*size".</span></span> <span data-ttu-id="74b87-178">Depois que o espaço tiver sido alocado, o stub do servidor zerará o buffer.</span><span class="sxs-lookup"><span data-stu-id="74b87-178">After the space has been allocated, the server stub zeroes out the buffer.</span></span> <span data-ttu-id="74b87-179">Observe que nesse caso específico, o stub aloca a memória com o usuário de **MIDL \_ \_ ALLOCATE ()**, já que o tamanho do buffer é determinado em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="74b87-179">Note that in this particular case, the stub allocates the memory with **MIDL\_user\_allocate()**, since the size of the buffer is determined at runtime.</span></span>

<span data-ttu-id="74b87-180">Lembre-se de que, no caso das interfaces DCOM, os stubs gerados por MIDL podem não estar envolvidos se o cliente e o servidor compartilharem o mesmo apartamento COM ou se **ICallFrame** for implementado.</span><span class="sxs-lookup"><span data-stu-id="74b87-180">Be aware that in the case of DCOM interfaces, MIDL-generated stubs may not be involved at all if the client and server share the same COM apartment, or if **ICallFrame** is implemented.</span></span> <span data-ttu-id="74b87-181">Nesse caso, o servidor não pode depender do comportamento de alocação e precisa verificar a memória no tamanho do cliente de forma independente.</span><span class="sxs-lookup"><span data-stu-id="74b87-181">In this case, the server cannot depend on the allocation behavior, and needs to independently verify client-sized memory.</span></span>

## <a name="server-side-function-implementations-and-outbound-data-marshaling"></a><span data-ttu-id="74b87-182">Implementações de função do lado do servidor e marshaling de dados de saída</span><span class="sxs-lookup"><span data-stu-id="74b87-182">Server-side Function Implementations and Outbound Data Marshaling</span></span>

<span data-ttu-id="74b87-183">Logo após o desempacotamento em dados de entrada e a inicialização da memória alocada para conter dados de saída, o stub do servidor RPC executa a implementação do lado do servidor da função chamada pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="74b87-183">Immediately subsequent to the unmarshalling on inbound data and the initialization of the memory allocated to contain outbound data, the RPC server stub executes the server-side implementation of the function called by the client.</span></span> <span data-ttu-id="74b87-184">Neste momento, o servidor pode modificar os dados marcados especificamente com o atributo **\[ in, out \]** e ele pode preencher a memória alocada para dados somente de saída (os dados marcados com [**\[ out \]**](../midl/out-idl.md)).</span><span class="sxs-lookup"><span data-stu-id="74b87-184">At this time, the server can modify the data specifically marked with the **\[in, out\]** attribute, and it can populate the memory allocated for outbound-only data (the data tagged with [**\[out\]**](../midl/out-idl.md)).</span></span>

<span data-ttu-id="74b87-185">As regras gerais para a manipulação de dados de parâmetro marshalled são simples: o servidor só pode alocar uma nova memória ou modificar a memória especificamente alocada pelo stub do servidor.</span><span class="sxs-lookup"><span data-stu-id="74b87-185">The general rules for the manipulation of marshalled parameter data are simple: the server can only allocate new memory or modify the memory specifically allocated by the server stub.</span></span> <span data-ttu-id="74b87-186">A realocação ou liberação de memória existente para dados pode ter um impacto negativo nos resultados e no desempenho da chamada de função, e pode ser muito difícil de depurar.</span><span class="sxs-lookup"><span data-stu-id="74b87-186">Reallocating or releasing existing memory for data can have a negative impact on the results and performance of the function call, and can be very difficult to debug.</span></span>

<span data-ttu-id="74b87-187">Logicamente, o servidor RPC reside em um espaço de endereço diferente do cliente e, em geral, pode ser considerado que eles não compartilham memória.</span><span class="sxs-lookup"><span data-stu-id="74b87-187">Logically, the RPC server lives in a different address space than the client, and it can generally be assumed that they do not share memory.</span></span> <span data-ttu-id="74b87-188">Como resultado, é seguro que a implementação da função de servidor use os dados marcados com o atributo [**\[ in \]**](../midl/in.md) como a memória "Scratch" sem afetar os endereços de memória do cliente.</span><span class="sxs-lookup"><span data-stu-id="74b87-188">As a result, it is safe for the server function implementation to use the data marked with the [**\[in\]**](../midl/in.md) attribute as "scratch" memory without affecting the client memory addresses.</span></span> <span data-ttu-id="74b87-189">Dito isso, o servidor não deve tentar realocar **\[ \] ou liberar dados** , deixando o controle desses espaços para o próprio stub do servidor RPC.</span><span class="sxs-lookup"><span data-stu-id="74b87-189">That said, the server should not attempt to reallocate or release **\[in\]** data, leaving the control of those spaces to the RPC server stub itself.</span></span>

<span data-ttu-id="74b87-190">Em geral, a implementação da função de servidor não precisa realocar ou liberar dados marcados com o atributo **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="74b87-190">Generally, the server function implementation does not need to reallocate or release data marked with the **\[in, out\]** attribute.</span></span> <span data-ttu-id="74b87-191">Para dados de tamanho fixo, a lógica de implementação de função pode modificar os dados diretamente.</span><span class="sxs-lookup"><span data-stu-id="74b87-191">For fixed size data, the function implementation logic can directly modify the data.</span></span> <span data-ttu-id="74b87-192">Da mesma forma, para dados de tamanho variável, a implementação da função não deve modificar o valor do campo fornecido para o atributo [**\[ Size \_ () \]**](../midl/size-is.md) , seja.</span><span class="sxs-lookup"><span data-stu-id="74b87-192">Likewise, for variable-sized data, the function implementation must not modify the field value supplied to the [**\[size\_is()\]**](../midl/size-is.md) attribute, either.</span></span> <span data-ttu-id="74b87-193">Altere o valor do campo usado para dimensionar os resultados de dados em um buffer menor ou maior retornado ao cliente que pode estar mal equipado para lidar com o comprimento anormal.</span><span class="sxs-lookup"><span data-stu-id="74b87-193">Change the field value used to size the data results in a smaller or larger buffer returned to the client which may be ill-equipped to deal with the abnormal length.</span></span>

<span data-ttu-id="74b87-194">Se ocorrerem circunstâncias em que a rotina do servidor precisa realocar a memória usada pelos dados marcados com o atributo **\[ in, out \]** , é totalmente possível que a implementação da função do lado do servidor não saiba se o ponteiro fornecido pelo stub é a memória alocada com o **usuário de MIDL \_ \_ ALLOCATE ()** ou o buffer de fios com marshaling realizado.</span><span class="sxs-lookup"><span data-stu-id="74b87-194">If circumstances occur where the server routine has to reallocate the memory used by data marked with the **\[in, out\]** attribute, it is entirely possible that the server-side function implementation will not know if the pointer provided by the stub is to memory allocated with **MIDL\_user\_allocate()** or the marshaled wire buffer.</span></span> <span data-ttu-id="74b87-195">Para contornar esse problema, o MS RPC pode garantir que nenhum vazamento de memória ou corrupção ocorra se o atributo [**\[ Force \_ ALLOCATE \]**](../midl/force-allocate.md) estiver definido nos dados.</span><span class="sxs-lookup"><span data-stu-id="74b87-195">To work around this problem, MS RPC can ensure that no memory leak or corruption occurs if the [**\[force\_allocate\]**](../midl/force-allocate.md) attribute is set on the data.</span></span> <span data-ttu-id="74b87-196">Quando **\[ forçar \_ alocação \]** for definido, o stub do servidor sempre alocará memória para o ponteiro, embora a limitação seja a redução do desempenho para cada uso.</span><span class="sxs-lookup"><span data-stu-id="74b87-196">When **\[force\_allocate\]** is set, the server stub will always allocate memory for the pointer, although the caveat is that performance will decrease for every use of it.</span></span>

<span data-ttu-id="74b87-197">Quando a chamada retorna da implementação da função do lado do servidor, o stub do servidor realiza marshaling dos dados marcados com o atributo [**\[ out \]**](../midl/out-idl.md) e os envia para o cliente.</span><span class="sxs-lookup"><span data-stu-id="74b87-197">When the call returns from the server-side function implementation, the server stub marshals the data marked with the [**\[out\]**](../midl/out-idl.md) attribute and sends it to the client.</span></span> <span data-ttu-id="74b87-198">Lembre-se de que o stub não empacota os dados se a implementação da função do lado do servidor lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="74b87-198">Be aware that the stub does not marshal the data if the server-side function implementation throws an exception.</span></span>

## <a name="releasing-allocated-memory"></a><span data-ttu-id="74b87-199">Liberando memória alocada</span><span class="sxs-lookup"><span data-stu-id="74b87-199">Releasing Allocated Memory</span></span>

<span data-ttu-id="74b87-200">O stub do servidor RPC liberará a memória da pilha depois que a chamada for retornada da função do lado do servidor, se ocorrer uma exceção ou não.</span><span class="sxs-lookup"><span data-stu-id="74b87-200">The RPC server stub will release the stack memory after the call has returned from the server-side function, whether an exception occurs or not.</span></span> <span data-ttu-id="74b87-201">O stub do servidor libera toda a memória alocada pelo stub, bem como qualquer memória alocada com o **usuário de MIDL \_ \_ ALLOCATE ()**.</span><span class="sxs-lookup"><span data-stu-id="74b87-201">The server stub frees all memory allocated by the stub as well as any memory allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="74b87-202">A implementação da função do lado do servidor sempre deve fornecer um estado consistente de RPC, emitindo uma exceção ou retornando um código de erro.</span><span class="sxs-lookup"><span data-stu-id="74b87-202">The server-side function implementation must always give RPC a consistent state, either by throwing an exception or returning an error code.</span></span> <span data-ttu-id="74b87-203">Se a função falhar durante a população de estruturas de dados complicadas, ela deverá garantir que todos os ponteiros apontem para dados válidos ou sejam definidos como **NULL**.</span><span class="sxs-lookup"><span data-stu-id="74b87-203">If the function fails during the population of complicated data structures, it must ensure that all pointers point to valid data or are set to **NULL**.</span></span>

<span data-ttu-id="74b87-204">Durante esse passo, o stub do servidor libera toda a memória que não faz parte do buffer de marshaling que contém os dados [**\[ em \]**](../midl/in.md) .</span><span class="sxs-lookup"><span data-stu-id="74b87-204">During this pass, the server stub frees all memory that is not part of the marshaled buffer containing the [**\[in\]**](../midl/in.md) data.</span></span> <span data-ttu-id="74b87-205">Uma exceção a esse comportamento são os dados com o atributo [**\[ ALLOCATE (não \_ livre) \]**](../midl/allocate.md) definido neles-o stub do servidor não libera nenhuma memória associada a esses ponteiros.</span><span class="sxs-lookup"><span data-stu-id="74b87-205">One exception to this behavior is data with the [**\[allocate(dont\_free)\]**](../midl/allocate.md) attribute set on them - the server stub does not free any memory associated with these pointers.</span></span>

<span data-ttu-id="74b87-206">Depois que o stub do servidor liberar a memória alocada pelo stub e a implementação da função, o stub chamará uma função de notificação específica se o atributo [**\[ notificar do \_ sinalizador \]**](../midl/notify-flag.md) for especificado para dados específicos.</span><span class="sxs-lookup"><span data-stu-id="74b87-206">After the server stub releases the memory allocated by the stub and the function implementation, the stub calls a specific notification function if the [**\[notify\_flag\]**](../midl/notify-flag.md) attribute is specified for particular data.</span></span>

## <a name="marshalling-a-linked-list-over-rpc----an-example"></a><span data-ttu-id="74b87-207">Marshaling de uma lista vinculada por RPC – um exemplo</span><span class="sxs-lookup"><span data-stu-id="74b87-207">Marshalling a Linked List over RPC -- An Example</span></span>


```C++
typedef struct _LINKEDLIST
{
    long lSize;
    [size_is(lSize)] char *pData;
    struct _LINKEDLIST *pNext;
} LINKEDLIST, *PLINKEDLIST;

void Test
(
    [in] LINKEDLIST *pIn,
    [in, out] PLINKEDLIST *pInOut,
    [out] LINKEDLIST *pOut
);
```



<span data-ttu-id="74b87-208">No exemplo acima, o formato de memória para **LinkedList** será idêntico ao formato de conexão com marshaling.</span><span class="sxs-lookup"><span data-stu-id="74b87-208">In the above example, the memory format for **LINKEDLIST** will be identical to the marshaled wire format.</span></span> <span data-ttu-id="74b87-209">Como resultado, o stub do servidor não aloca memória para toda a cadeia de ponteiros de dados no *pIn*.</span><span class="sxs-lookup"><span data-stu-id="74b87-209">As a result, the server stub does not allocate memory for the entire chain of data pointers under *pIn*.</span></span> <span data-ttu-id="74b87-210">Em vez disso, o RPC reutiliza o buffer de conexão para toda a lista vinculada.</span><span class="sxs-lookup"><span data-stu-id="74b87-210">Rather, RPC reuses the wire buffer for the entire linked list.</span></span> <span data-ttu-id="74b87-211">Da mesma forma, o stub não aloca memória para *pinagem*, mas, em vez disso, reutiliza o buffer de conexão realizado pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="74b87-211">Similarly, the stub does not allocate memory for *pInOut*, but instead reuses the wire buffer marshaled by the client.</span></span>

<span data-ttu-id="74b87-212">Como a assinatura de função contém um parâmetro de saída, *pout*, o stub do servidor aloca memória para conter os dados retornados.</span><span class="sxs-lookup"><span data-stu-id="74b87-212">Because the function signature contains an outbound parameter, *pOut*, the server stub allocates memory to contain the returned data.</span></span> <span data-ttu-id="74b87-213">A memória alocada inicialmente é zerada, com **pNext** definido como **NULL**.</span><span class="sxs-lookup"><span data-stu-id="74b87-213">The allocated memory is initially zeroes out, with **pNext** set to **NULL**.</span></span> <span data-ttu-id="74b87-214">O aplicativo pode alocar a memória para uma nova lista vinculada e apontar *pout* -> **pNext** para ela.</span><span class="sxs-lookup"><span data-stu-id="74b87-214">The application can allocate the memory for a new linked list and point *pOut*->**pNext** to it.</span></span> <span data-ttu-id="74b87-215">o *pIn* e a lista vinculada que ele contém podem ser usados como uma área de rascunho, mas o aplicativo não deve alterar nenhum dos ponteiros pNext.</span><span class="sxs-lookup"><span data-stu-id="74b87-215">*pIn* and the linked list it contains can be used as a scratch area, but the application should not change any of the pNext pointers.</span></span>

<span data-ttu-id="74b87-216">O aplicativo pode alterar livremente o conteúdo da lista vinculada apontada por *pinagem*, mas não deve alterar nenhum dos ponteiros do **pNext** , permitindo apenas o link de nível superior em si.</span><span class="sxs-lookup"><span data-stu-id="74b87-216">The application can freely change the content of the linked list pointed to by *pInOut*, but it must not change any of the **pNext** pointers, let alone the top-level link itself.</span></span> <span data-ttu-id="74b87-217">Se o aplicativo decidir encurtar a lista vinculada, não poderá saber se um determinado ponteiro **pNext** vincula para um buffer interno de RPC ou um buffer especificamente alocado com o **\_ usuário MIDL \_ ALLOCATE ()**.</span><span class="sxs-lookup"><span data-stu-id="74b87-217">If the application decides to shorten the linked list, it cannot know if any given **pNext** pointer links tto an RPC internal buffer or a buffer specifically allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="74b87-218">Para contornar esse problema, você adiciona uma declaração de tipo específica para ponteiros de lista vinculada que força a alocação do usuário, como visto no código abaixo.</span><span class="sxs-lookup"><span data-stu-id="74b87-218">To work around this issue, you add a specific type declaration for linked list pointers that forces user allocation, as seen in the code below.</span></span>

``` syntax
typedef [force_allocate] PLINKEDLIST;
```

<span data-ttu-id="74b87-219">Esse atributo força o stub do servidor a alocar cada nó da lista vinculada separadamente e o aplicativo pode liberar a parte reduzida da lista vinculada chamando o **\_ usuário MIDL \_ Free ()**.</span><span class="sxs-lookup"><span data-stu-id="74b87-219">This attribute forces the server stub to allocate each node of the linked list separately, and the application can free the shortened part of the linked list by calling **MIDL\_user\_free()**.</span></span> <span data-ttu-id="74b87-220">Em seguida, o aplicativo pode definir com segurança o ponteiro **pNext** no final da lista vinculada recentemente encurtada para **NULL**.</span><span class="sxs-lookup"><span data-stu-id="74b87-220">The application can then safely set the **pNext** pointer at the end of the newly-shortened linked list to **NULL**.</span></span>

 

 