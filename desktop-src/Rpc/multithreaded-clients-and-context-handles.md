---
title: Clientes multithread e identificadores de contexto
description: Quando você tem um cliente multi-threaded em que vários threads estão usando a mesma instância de identificador de contexto, o acesso à instância de identificador de contexto é serializado no servidor por padrão.
ms.assetid: 192be467-b1e0-422b-878a-738cb7d72b5b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 67c621d75d8cc48ca1f71719066f455e0efce39f
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104007861"
---
# <a name="multithreaded-clients-and-context-handles"></a><span data-ttu-id="f4938-103">Clientes multithread e identificadores de contexto</span><span class="sxs-lookup"><span data-stu-id="f4938-103">Multithreaded Clients and Context Handles</span></span>

<span data-ttu-id="f4938-104">Quando você tem um cliente multi-threaded em que vários threads estão usando a mesma instância de identificador de contexto, o acesso à instância de identificador de contexto é serializado no servidor por padrão.</span><span class="sxs-lookup"><span data-stu-id="f4938-104">When you have a multithreaded client where multiple threads are using the same context handle instance, access to the context handle instance is serialized at the server by default.</span></span> <span data-ttu-id="f4938-105">Isso evita que o Gerenciador de servidores tenha que se proteger contra outro thread do mesmo cliente que está alterando o contexto ou o contexto que está sendo executado enquanto uma chamada é expedida.</span><span class="sxs-lookup"><span data-stu-id="f4938-105">This saves the server manager from having to guard against another thread from the same client changing the context or the context running down while a call is dispatched.</span></span> <span data-ttu-id="f4938-106">No entanto, em determinados casos, a serialização pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="f4938-106">However, in certain cases serialization may impact performance.</span></span>

<span data-ttu-id="f4938-107">Considere o seguinte: dois threads de cliente invocam uma chamada de procedimento remoto que não altera o estado do contexto (por exemplo, a chamada simplesmente obtém alguns valores dele).</span><span class="sxs-lookup"><span data-stu-id="f4938-107">Consider the following: two client threads invoke a remote procedure call that does not change the state of the context (for example, the call simply obtains some values from it).</span></span> <span data-ttu-id="f4938-108">Essas chamadas não precisam ser serializadas.</span><span class="sxs-lookup"><span data-stu-id="f4938-108">Such calls do not need to be serialized.</span></span>

<span data-ttu-id="f4938-109">Para essas situações, o Windows XP oferece um modelo de serialização de modo misto, onde cada método pode ser declarado para ter acesso exclusivo ou compartilhado a um identificador de contexto.</span><span class="sxs-lookup"><span data-stu-id="f4938-109">For such situations, Windows XP offers a mixed mode serialization model, where each method may be declared to have exclusive or shared access to a context handle.</span></span> <span data-ttu-id="f4938-110">Confira a [ \_ \_ serialização de identificador](/windows/desktop/Midl/context-handle-serialize) de contexto e o [identificador de contexto \_ \_ noserializate](/windows/desktop/Midl/context-handle-noserialize) para obter detalhes.</span><span class="sxs-lookup"><span data-stu-id="f4938-110">See [context\_handle\_serialize](/windows/desktop/Midl/context-handle-serialize) and [context\_handle\_noserialize](/windows/desktop/Midl/context-handle-noserialize) for details.</span></span>

<span data-ttu-id="f4938-111">Nas versões do Windows anteriores ao Windows XP, o único meio de permitir o acesso simultâneo a um identificador de contexto é chamar a função [**RpcSsDontSerializeContext**](/previous-versions/aa378473(v=vs.80)) para permitir que várias chamadas sejam expedidas em um único identificador de contexto.</span><span class="sxs-lookup"><span data-stu-id="f4938-111">In versions of Windows prior to Windows XP, the only means of allowing concurrent access to a context handle is to call the [**RpcSsDontSerializeContext**](/previous-versions/aa378473(v=vs.80)) function to allow multiple calls to be dispatched on a single context handle.</span></span> <span data-ttu-id="f4938-112">Chamar a função **RpcSsDontSerializeContext** não desabilita totalmente a serialização; Quando ocorre uma execução de contexto, a rotina de execução de contexto é executada somente quando todas as solicitações de cliente pendentes são concluídas.</span><span class="sxs-lookup"><span data-stu-id="f4938-112">Calling the **RpcSsDontSerializeContext** function does not disable serialization entirely; when a context run-down occurs, the context run-down routine runs only when all outstanding client requests have completed.</span></span> <span data-ttu-id="f4938-113">Uma chamada para **RpcScDontSerializeContext** afeta todo o processo e não é reversível.</span><span class="sxs-lookup"><span data-stu-id="f4938-113">A call to **RpcScDontSerializeContext** affects the entire process, and is not revertible.</span></span> <span data-ttu-id="f4938-114">O uso do **RpcScDontSerializeContext** no Windows XP e em versões posteriores não é recomendado; Ele torna o código do servidor muito complicado ao lidar de forma confiável com as condições de corrida inerentes a ambientes completamente não serializados.</span><span class="sxs-lookup"><span data-stu-id="f4938-114">Using **RpcScDontSerializeContext** in Windows XP and later versions is not recommended; it makes server code very complicated when dealing reliably with race conditions inherent in completely non-serialized environments.</span></span>

 

 