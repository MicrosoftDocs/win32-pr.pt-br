---
title: Buffers de Stub-Allocated
description: Em vez de forçar uma chamada distinta para cada nó da árvore ou do grafo, você pode direcionar os stubs para computar o tamanho dos dados e alocar e liberar memória fazendo uma única chamada para o usuário de MIDL \_ \_ alocar ou o usuário de MIDL \_ \_ gratuito.
ms.assetid: 9911649d-00e8-47d8-b512-7d9b185d1e09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 956acf6452c1a4e7d04afcd1da263439436e3bad
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104007892"
---
# <a name="stub-allocated-buffers"></a><span data-ttu-id="7140c-103">Buffers de Stub-Allocated</span><span class="sxs-lookup"><span data-stu-id="7140c-103">Stub-Allocated Buffers</span></span>

<span data-ttu-id="7140c-104">Em vez de forçar uma chamada distinta para cada nó da árvore ou do grafo, você pode direcionar os stubs para computar o tamanho dos dados e alocar e liberar memória fazendo uma única chamada para o usuário de [MIDL \_ \_ alocar](/windows/desktop/Midl/midl-user-allocate-1) ou o [usuário de MIDL \_ \_ gratuito](/windows/desktop/Midl/midl-user-free-1).</span><span class="sxs-lookup"><span data-stu-id="7140c-104">Rather than forcing a distinct call for each node of the tree or graph, you can direct the stubs to compute the size of the data and to allocate and free memory by making a single call to [midl\_user\_allocate](/windows/desktop/Midl/midl-user-allocate-1) or [midl\_user\_free](/windows/desktop/Midl/midl-user-free-1).</span></span> <span data-ttu-id="7140c-105">O atributo ACF **\[ ALLOCATE (todos os \_ nós \] )** direciona os stubs para alocar ou liberar todos os nós em uma única chamada para o usuário fornecido – funções de gerenciamento de memória.</span><span class="sxs-lookup"><span data-stu-id="7140c-105">The ACF attribute **\[allocate(all\_nodes)\]** directs the stubs to allocate or free all nodes in a single call to the user supplied–memory management functions.</span></span>

<span data-ttu-id="7140c-106">Por exemplo, um aplicativo RPC pode usar a seguinte estrutura de dados de árvore binária:</span><span class="sxs-lookup"><span data-stu-id="7140c-106">For example, an RPC application might use the following binary tree data structure:</span></span>

``` syntax
/* IDL file fragment */
typedef struct _TREE_TYPE 
{
    short sNumber;
    struct _TREE_TYPE * pLeft;
    struct _TREE_TYPE * pRight;
} TREE_TYPE;

typedef TREE_TYPE * P_TREE_TYPE;
```

<span data-ttu-id="7140c-107">O atributo ACF **\[ alocar (todos os \_ nós) \]** aplicados a esse tipo de dados aparece na declaração de **typedef** no ACF como:</span><span class="sxs-lookup"><span data-stu-id="7140c-107">The ACF attribute **\[allocate(all\_nodes)\]** applied to this data type appears in the **typedef** declaration in the ACF as:</span></span>

``` syntax
/* ACF file fragment */
typedef [allocate(all_nodes)] P_TREE_TYPE;
```

<span data-ttu-id="7140c-108">O atributo **\[ ALLOCATE \]** só pode ser aplicado a tipos de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="7140c-108">The **\[allocate\]** attribute can only be applied to pointer types.</span></span> <span data-ttu-id="7140c-109">O atributo **\[ \] ALLOCATE** ACF é uma extensão da Microsoft para o DCE IDL e, dessa forma, não estará disponível se você COMPILAR com a opção MIDL **/OSF**</span><span class="sxs-lookup"><span data-stu-id="7140c-109">The **\[allocate\]** ACF attribute is a Microsoft extension to DCE IDL and, as such, is not available if you compile with the MIDL **/osf** switch.</span></span> <span data-ttu-id="7140c-110">Quando a **\[ alocação (todos os \_ nós) \]** é aplicada a um tipo de ponteiro, os stubs gerados pelo compilador MIDL atravessam a estrutura de dados especificada para determinar o tamanho da alocação.</span><span class="sxs-lookup"><span data-stu-id="7140c-110">When **\[allocate(all\_nodes)\]** is applied to a pointer type, the stubs generated by the MIDL compiler traverse the specified data structure to determine the allocation size.</span></span> <span data-ttu-id="7140c-111">Os stubs fazem uma única chamada para alocar a quantidade inteira de memória necessária para o gráfico ou a árvore.</span><span class="sxs-lookup"><span data-stu-id="7140c-111">The stubs then make a single call to allocate the entire amount of memory needed by the graph or tree.</span></span> <span data-ttu-id="7140c-112">Um aplicativo cliente pode liberar memória com muito mais eficiência, fazendo uma única chamada para o **\_ usuário MIDL \_ livre**.</span><span class="sxs-lookup"><span data-stu-id="7140c-112">A client application can free memory much more efficiently by making a single call to **midl\_user\_free**.</span></span> <span data-ttu-id="7140c-113">No entanto, o desempenho do stub do servidor é geralmente aumentado ao usar a alocação de memória nó a nó porque os stubs de servidor geralmente podem usar a memória privada que não requer nenhuma alocação.</span><span class="sxs-lookup"><span data-stu-id="7140c-113">However, server-stub performance is generally increased when using node-by-node memory allocation because the server stubs can often use private memory that requires no allocations.</span></span>

<span data-ttu-id="7140c-114">Para obter informações adicionais, consulte [alocação e desalocação de nó por nó](node-by-node-allocation-and-deallocation.md).</span><span class="sxs-lookup"><span data-stu-id="7140c-114">For additional information, see [Node-by-Node Allocation and Deallocation](node-by-node-allocation-and-deallocation.md).</span></span>

 

 