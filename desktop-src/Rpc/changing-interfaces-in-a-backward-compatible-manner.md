---
title: Alterando interfaces de maneira compatível com versões anteriores
description: Os métodos explicados na teoria do controle de versão para RPC e COM podem ser inaceitáveis por vários motivos.
ms.assetid: 7dec4b67-3d50-453f-b0ef-290d091186fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 314daecc6b55aaf4a348411010eb578149f86921
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "103641725"
---
# <a name="changing-interfaces-in-a-backward-compatible-manner"></a><span data-ttu-id="3d3d0-103">Alterando interfaces de maneira compatível com versões anteriores</span><span class="sxs-lookup"><span data-stu-id="3d3d0-103">Changing Interfaces in a Backward Compatible Manner</span></span>

<span data-ttu-id="3d3d0-104">Os métodos explicados na [teoria do controle de versão para RPC e com](the-versioning-theory-for-rpc-and-com.md) podem ser inaceitáveis por vários motivos.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-104">The methods explained in [The Versioning Theory for RPC and COM](the-versioning-theory-for-rpc-and-com.md) may be unacceptable for many reasons.</span></span> <span data-ttu-id="3d3d0-105">A alteração de uma versão de interface de acordo com as regras requer basicamente que novos clientes não se comuniquem com servidores antigos.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-105">Changing an interface version according to the rules essentially requires that new clients not communicate with old servers.</span></span> <span data-ttu-id="3d3d0-106">Isso geralmente é impossível com software comercial implantado no campo.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-106">This is frequently impossible with commercial software deployed in the field.</span></span> <span data-ttu-id="3d3d0-107">Às vezes, o Windows introduziu alterações de interface ausentes de GUIDs ou versões alteradas.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-107">Sometimes, Windows has introduced interface changes absent of changed GUIDs or versions.</span></span> <span data-ttu-id="3d3d0-108">Isso foi resultado de novos clientes que precisam se comunicar com servidores herdados e porque a solução que um novo cliente ofereceria às interfaces antiga e nova foi considerada indesejável.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-108">This was a result of new clients needing to communicate with legacy servers, and because the solution that a new client would support both the old and new interfaces was deemed undesirable.</span></span>

## <a name="best-practice"></a><span data-ttu-id="3d3d0-109">Melhor prática</span><span class="sxs-lookup"><span data-stu-id="3d3d0-109">Best practice</span></span>

<span data-ttu-id="3d3d0-110">Esses são os métodos razoáveis de trabalhar em relação ao problema de incompatibilidade de conexão quando o GUID e a versão da interface não podem ser alterados.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-110">These are the reasonable methods of working around the wire incompatibility issue when the interface GUID and version cannot be changed.</span></span>

1.  <span data-ttu-id="3d3d0-111">Faça com que o aplicativo esteja ciente dos recursos do outro lado.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-111">Have the application be aware of the other side's capabilities.</span></span>

    <span data-ttu-id="3d3d0-112">O cliente e o servidor têm um protocolo que permite que cada um (ou pelo menos o novo cliente) estabeleça a identidade do parceiro.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-112">The client and server have a protocol that enables each (or at least the new client) to establish the identity of the partner.</span></span> <span data-ttu-id="3d3d0-113">Normalmente, é suficiente que o novo cliente esteja ciente dos recursos com suporte dos servidores novos e antigos.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-113">Typically it is sufficient to have the new client be aware of features supported by old and new servers.</span></span> <span data-ttu-id="3d3d0-114">Isso pode ser feito facilmente quando um aplicativo mantém em um contexto de conexão e tem suporte por meio de um tipo *XxxGetInfo* de chamada de função executado pelo cliente antes de executar qualquer operação RPC.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-114">This may easily be done when an application holds on to a connection context, and be supported through an *XxxGetInfo* type of function call executed by the client before performing any RPC operations.</span></span> <span data-ttu-id="3d3d0-115">Quando um aplicativo gerencia os recursos em uma base de versão por servidor, uma chamada com uma incompatibilidade para o servidor/cliente antigo nunca pode ocorrer, já que o aplicativo controla quais chamadas são emitidas para qual servidor.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-115">When an application manages the features on a per-server release basis, a call with an incompatibility to the old server/client can never occur, since the application controls which calls are issued to which server.</span></span> <span data-ttu-id="3d3d0-116">O resultado final é que o aplicativo é proativo para impedir que uma incompatibilidade ocorra.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-116">The bottom line is that the application is proactive in preventing a mismatch from happening.</span></span> <span data-ttu-id="3d3d0-117">Isso pode ser realizado em conjunto com a segunda prática.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-117">This may be performed in conjunction with the second practice.</span></span>

2.  <span data-ttu-id="3d3d0-118">Introduza uma nova API remota.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-118">Introduce a new remote API.</span></span>

    <span data-ttu-id="3d3d0-119">Um novo método remoto não colidirá com os métodos existentes se ele for adicionado no final da interface.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-119">A new remote method does not collide with existing methods if it is added at the very end of the interface.</span></span> <span data-ttu-id="3d3d0-120">Clientes antigos podem chamar novos servidores como sempre têm.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-120">Old clients can call new servers as they always have.</span></span> <span data-ttu-id="3d3d0-121">O novo cliente pode chamar o novo método sem saber a identidade do servidor, desde que ele Observe os erros provenientes do servidor que está sendo chamado.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-121">The new client can call the new method without knowing the server's identity, provided it watches for the errors coming from the server being called.</span></span> <span data-ttu-id="3d3d0-122">O tempo de execução RPC sempre verifica o número do método para cada interface antes de uma expedição para garantir que o método esteja dentro de uma tabela v apropriada.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-122">The RPC run time always checks the method number for each interface before a dispatch to ensure the method is within an appropriate v-table.</span></span> <span data-ttu-id="3d3d0-123">Para um método que é desconhecido para um servidor, o tempo de execução de RPC gera a exceção RPC \_ S \_ PROCNUM \_ fora \_ do \_ intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-123">For a method that is unknown to a server, the RPC run time raises the exception RPC\_S\_PROCNUM\_OUT\_OF\_RANGE.</span></span> <span data-ttu-id="3d3d0-124">Essa exceção é gerada somente nesta situação específica.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-124">This exception is raised only in this particular situation.</span></span> <span data-ttu-id="3d3d0-125">Portanto, um novo cliente pode observar a exceção como um sinal de que a chamada foi enviada para um servidor antigo e pode modificar seu comportamento normalmente.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-125">Therefore, a new client can watch for the exception as a sign that the call went to an old server and can modify its behavior gracefully.</span></span>

3.  <span data-ttu-id="3d3d0-126">Introduza novos parâmetros ou novos tipos de dados apenas nos novos métodos.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-126">Introduce new parameters or new data types only in the new methods.</span></span>

    <span data-ttu-id="3d3d0-127">Um motivo para introduzir um novo método é evitar a incompatibilidade de dados.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-127">One reason to introduce a new method is to avoid data incompatibility.</span></span> <span data-ttu-id="3d3d0-128">Se um novo tipo de dados for introduzido ou simplesmente modificado, em princípio, ele deve ser usado somente em um novo método (ou métodos).</span><span class="sxs-lookup"><span data-stu-id="3d3d0-128">If a new data type is introduced or simply modified, in principle it should be used only in a new method (or methods).</span></span> <span data-ttu-id="3d3d0-129">Veja [exemplos de alterações incompatíveis](examples-of-incompatible-changes.md) para obter exemplos de alterações de tipo de dados incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-129">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples of incompatible data type changes.</span></span> <span data-ttu-id="3d3d0-130">A única exceção notável a essa regra é descrita no item quatro.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-130">The only notable exception to this rule is described in item four.</span></span>

4.  <span data-ttu-id="3d3d0-131">Mapeie novos parâmetros ou novos tipos de dados por meio de um wrapper.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-131">Map new parameters or new data types through a wrapper.</span></span>

    <span data-ttu-id="3d3d0-132">Essa solução se aplica quando um novo parâmetro ou tipo de dados deve ser exposto a um usuário, mas, na verdade, não precisa ser remoto separadamente ou pode ser mapeado para os tipos de dados ou parâmetros antigos.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-132">This solution applies when a new parameter or data type must be exposed to a user, but actually does not have to be remoted separately or can be mapped to the old data types or parameters.</span></span> <span data-ttu-id="3d3d0-133">Por exemplo, muitas APIs de sistema desenvolvem e executam uma chamada remota.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-133">For example, many system APIs turn around and execute a remote call.</span></span> <span data-ttu-id="3d3d0-134">Eles podem ou não estar fazendo algum tipo de mapeamento dos tipos de dados conhecidos do usuário para os tipos de dados realmente usados na chamada RPC subjacente.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-134">They may or may not be doing some kind of mapping from the user known data types to the data types actually used in the underlying RPC call.</span></span> <span data-ttu-id="3d3d0-135">Portanto, vale a pena examinar se a alteração na interface do usuário precisa ser propagada como uma alteração para uma interface remota.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-135">It is therefore always worth examining if the change in the user interface needs to propagate as a change to a remote interface.</span></span>

    <span data-ttu-id="3d3d0-136">Uma situação semelhante pode ocorrer quando o usuário chama uma API remota diretamente, mas um wrapper pode ser introduzido para fazer um novo mapeamento de tipo ou outras ações adicionais que se tornaram necessárias.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-136">A similar situation may happen when the user calls a remote API directly, but a wrapper could be introduced to do a new type mapping or some other additional actions that have become necessary.</span></span> <span data-ttu-id="3d3d0-137">A IDL (Interface Definition Language) tem várias maneiras de facilitar esse remapeamento, como \[ [**chamar \_ como**](/windows/desktop/Midl/call-as) \] , \[ [**transmitir \_ como**](/windows/desktop/Midl/transmit-as) \] e \[ [**\_ realizar marshaling**](/windows/desktop/Midl/wire-marshal) \] .</span><span class="sxs-lookup"><span data-stu-id="3d3d0-137">Interface Definition Language (IDL) has several ways of facilitating such remapping, namely \[[**call\_as**](/windows/desktop/Midl/call-as)\], \[[**transmit\_as**](/windows/desktop/Midl/transmit-as)\], and \[[**wire\_marshal**](/windows/desktop/Midl/wire-marshal)\].</span></span> <span data-ttu-id="3d3d0-138">O \[ atributo **Call \_ as** \] introduz um wrapper de função no cliente e no servidor.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-138">The \[**call\_as**\] attribute introduces a function wrapper on the client and server.</span></span> <span data-ttu-id="3d3d0-139">Ambos são colocados entre o código do usuário e o marshaler.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-139">Both are placed between the user code and the marshaler.</span></span> <span data-ttu-id="3d3d0-140">Os outros atributos lidam com o mapeamento de tipo direto.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-140">The other attributes deal with direct type mapping.</span></span> <span data-ttu-id="3d3d0-141">Para problemas de extensão, \[ **chame \_ como** \] é o usado com mais frequência e é mais fácil de entender e manipular sem armadilhas.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-141">For extension problems, \[**call\_as**\] is the most frequently used, and is easiest to understand and manipulate without pitfalls.</span></span>

5.  <span data-ttu-id="3d3d0-142">Modifique os tipos de dados por meio de uma União defaultless.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-142">Modify data types through a defaultless union.</span></span>

    <span data-ttu-id="3d3d0-143">A alteração de um atributo ou tipo de dados geralmente leva a uma incompatibilidade.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-143">Changing an attribute or data type typically leads to wire incompatibility.</span></span> <span data-ttu-id="3d3d0-144">Consulte [exemplos de alterações incompatíveis](examples-of-incompatible-changes.md) para obter exemplos.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-144">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples.</span></span> <span data-ttu-id="3d3d0-145">No entanto, no caso de uma União sem uma cláusula padrão, a incompatibilidade pode ser gerenciada de forma semelhante ao caso de um procedimento fora do intervalo, conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-145">However, in the case of a union without a default clause, the incompatibility may be managed in a way similar to the case of a procedure out of range, as described previously.</span></span> <span data-ttu-id="3d3d0-146">Esse esquema é prontamente aplicável aos tipos populares de *XxxINFO* que usam uniões.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-146">This scheme is readily applicable to the popular *XxxINFO* types that use unions.</span></span>

    <span data-ttu-id="3d3d0-147">Por exemplo, uma chamada como esta</span><span class="sxs-lookup"><span data-stu-id="3d3d0-147">For example, a call like this</span></span>

    ```C++
    XxxGetInfo( [in] level, [out] XxxINFO  * pInfo );
    ```

    

    <span data-ttu-id="3d3d0-148">pode retornar informações no nível 1, 2 ou 3, com *XxxINFO* sendo uma União com três ramificações: 1, 2 e 3.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-148">could return information at level 1, 2 or 3, with *XxxINFO* being a union with three branches: 1, 2 and 3.</span></span>

6.  <span data-ttu-id="3d3d0-149">Use o \[ atributo [**Range**](/windows/desktop/Midl/range) \] para especificar o intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-149">Use the \[[**range**](/windows/desktop/Midl/range)\] attribute to specify range.</span></span>

    <span data-ttu-id="3d3d0-150">Você pode especificar o \[ atributo de [**intervalo**](/windows/desktop/Midl/range) \] em um tipo de escala simples sem interromper a compatibilidade com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-150">You can specify the \[[**range**](/windows/desktop/Midl/range)\] attribute on a simple scale type without breaking backward compatibility.</span></span> <span data-ttu-id="3d3d0-151">Esse atributo não afeta o formato de conexão, mas durante o desempacotamento RPC verifica o valor em fio para confirmar que ele está dentro do intervalo especificado no arquivo. idl.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-151">This attribute does not affect wire format, but during unmarshalling RPC checks the value on wire to confirm that it is within the range specified in the .idl file.</span></span> <span data-ttu-id="3d3d0-152">Caso contrário, uma exceção de associação de RPC \_ X \_ inválida \_ será lançada.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-152">If not, a RPC\_X\_INVALID\_BOUND exception is thrown.</span></span> <span data-ttu-id="3d3d0-153">Isso é especialmente útil se o servidor souber o tamanho máximo de uma matriz dimensionada.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-153">This is especially useful if the server knows the maximum size of a sized array.</span></span>

    <span data-ttu-id="3d3d0-154">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="3d3d0-154">For example:</span></span>

    ```C++
    HRESULT Method1( [in, range(0,100)] ULONG m, [size_is(m)] ULONG *plong); 
    ```

    

<span data-ttu-id="3d3d0-155">O comportamento de RPC quando o nível indicado é 4 e o ARM está ausente, depende da definição da União.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-155">The RPC behavior when the indicated level is 4 and the arm is missing, depends on the definition of the union.</span></span> <span data-ttu-id="3d3d0-156">Para uma União com a cláusula default definida, o RPC transmite um tipo indicado na cláusula default para qualquer coisa diferente dos rótulos de ARM conhecidos (nesse caso, algo diferente de 1, 2 ou 3).</span><span class="sxs-lookup"><span data-stu-id="3d3d0-156">For a union with the default clause defined, RPC transmits a type indicated in the default clause for anything different than the known arm labels (in this case, anything other than 1, 2 or 3).</span></span> <span data-ttu-id="3d3d0-157">Para uma União defaultmenos, o desempacotador gera uma exceção porque, por definição, não há nenhum padrão para fazer fallback.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-157">For a defaultless union, the unmarshaler raises an exception because by definition there is no default to fall back to.</span></span> <span data-ttu-id="3d3d0-158">A exceção é uma \_ marca de RPC S \_ inválida \_ .</span><span class="sxs-lookup"><span data-stu-id="3d3d0-158">The exception is RPC\_S\_INVALID\_TAG.</span></span>

<span data-ttu-id="3d3d0-159">Novamente, um novo cliente pode ajustar seu comportamento na descoberta de que ele chamou um servidor antigo.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-159">Again, a new client can adjust its behavior upon discovering that it called an old server.</span></span>

<span data-ttu-id="3d3d0-160">O que vem a seguir dessas práticas recomendadas é que, se um tipo de dados remoto tiver de ser criado, isso poderá ser estendido no futuro, use uma União defaultless no arquivo IDL.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-160">What follows from these recommended practices is that if a remotable data type must be designed that can be extended in future, use a defaultless union in the IDL file.</span></span> <span data-ttu-id="3d3d0-161">Dada uma escolha, uma União encapsulada é um pouco mais limpa.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-161">Given a choice, an encapsulated union is slightly cleaner.</span></span>

<span data-ttu-id="3d3d0-162">Devido a peculiaridades da representação interna do protocolo de fio NDR64, a recomendação para adicionar braços fornecidos anteriormente nesta seção precisa ser qualificada da seguinte maneira: o novo ARM que está sendo adicionado não pode alterar o alinhamento da União e, em particular, o maior alinhamento dos braços não deve ser alterado.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-162">Due to quirks of internal representation of the NDR64 wire protocol, the recommendation for adding arms provided earlier in this section needs to be qualified as follows: The new arm being added cannot change the alignment of the union, and in particular, the biggest alignment of the arms should not change.</span></span> <span data-ttu-id="3d3d0-163">Isso normalmente não é um problema, uma vez que um ponteiro em um ARM força o alinhamento a 8.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-163">This is typically not an issue, as a pointer in an arm forces alignment to 8.</span></span> <span data-ttu-id="3d3d0-164">Um design em que cada ARM é um ponteiro para um tipo de ARM é uma maneira limpa de satisfazer o requisito.</span><span class="sxs-lookup"><span data-stu-id="3d3d0-164">A design where each arm is a pointer to an arm type is one clean way of satisfying the requirement.</span></span>

 

 