---
title: O modelo para sistemas distribuídos
description: Tradicionalmente, ter um sistema monolítico executado em vários computadores significava dividir o sistema em componentes de cliente e servidor separados.
ms.assetid: 6055bcef-e34c-4f2d-92b9-9aec75cf3cec
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 82cd1ea3301d68e77562a63c542bc075692e5192
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "103916100"
---
# <a name="the-model-for-distributed-systems"></a><span data-ttu-id="bff42-103">O modelo para sistemas distribuídos</span><span class="sxs-lookup"><span data-stu-id="bff42-103">The Model for Distributed Systems</span></span>

<span data-ttu-id="bff42-104">Tradicionalmente, ter um sistema monolítico executado em vários computadores significava dividir o sistema em componentes de cliente e servidor separados.</span><span class="sxs-lookup"><span data-stu-id="bff42-104">Traditionally, having a monolithic system run across multiple computers meant splitting the system into separate client and server components.</span></span> <span data-ttu-id="bff42-105">Nesses sistemas, o componente cliente tratou a interface do usuário e o processamento de back-end fornecido pelo servidor, como acesso ao banco de dados, impressão e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="bff42-105">In such systems, the client component handled the user interface and the server provided back-end processing, such as database access, printing, and so on.</span></span> <span data-ttu-id="bff42-106">À medida que os computadores proliferaram, descartaram custos e se tornaram conectados por redes de largura de banda cada vez mais altas, dividir os sistemas de software em vários componentes se tornou mais conveniente, com cada componente em execução em um computador diferente e executando uma função especializada.</span><span class="sxs-lookup"><span data-stu-id="bff42-106">As computers proliferated, dropped in cost, and became connected by ever-higher bandwidth networks, splitting software systems into multiple components became more convenient, with each component running on a different computer and performing a specialized function.</span></span> <span data-ttu-id="bff42-107">Essa abordagem simplificava o desenvolvimento, o gerenciamento, a administração e, muitas vezes, o desempenho e a robustez aprimorados, uma vez que a falha em um computador não desabilitou necessariamente o sistema inteiro.</span><span class="sxs-lookup"><span data-stu-id="bff42-107">This approach simplified development, management, administration, and often improved performance and robustness, since failure in one computer did not necessarily disable the entire system.</span></span>

<span data-ttu-id="bff42-108">Em muitos casos, o sistema aparece para o cliente como uma nuvem opaca que executa as operações necessárias, embora o sistema distribuído seja composto por nós individuais, conforme ilustrado na figura a seguir.</span><span class="sxs-lookup"><span data-stu-id="bff42-108">In many cases the system appears to the client as an opaque cloud that performs the necessary operations, even though the distributed system is composed of individual nodes, as illustrated in the following figure.</span></span>

![Os clientes acessam serviços em um sistema de servidores RPC que aparece como uma nuvem opaca para clientes externos](images/indy-nodes.png)

<span data-ttu-id="bff42-110">A opacidade da nuvem é mantida porque as operações de computação são invocadas em nome do cliente.</span><span class="sxs-lookup"><span data-stu-id="bff42-110">The opacity of the cloud is maintained because computing operations are invoked on behalf of the client.</span></span> <span data-ttu-id="bff42-111">Assim, os clientes podem localizar um computador (um *nó*) na nuvem e solicitar uma determinada operação; ao executar a operação, esse computador pode invocar a funcionalidade em outros computadores na nuvem sem expor as etapas adicionais ou o computador no qual eles foram executados, para o cliente.</span><span class="sxs-lookup"><span data-stu-id="bff42-111">As such, clients can locate a computer (a *node*) within the cloud and request a given operation; in performing the operation, that computer can invoke functionality on other computers within the cloud without exposing the additional steps, or the computer on which they were carried out, to the client.</span></span>

<span data-ttu-id="bff42-112">Com esse paradigma, a mecânica de um sistema distribuído, semelhante à nuvem, pode ser dividida em muitas trocas de pacotes individuais ou conversas entre nós individuais.</span><span class="sxs-lookup"><span data-stu-id="bff42-112">With this paradigm, the mechanics of a distributed, cloud-like system can be broken down into many individual packet exchanges, or conversations between individual nodes.</span></span>

<span data-ttu-id="bff42-113">Os sistemas cliente-servidor tradicionais têm dois nós com funções e responsabilidades fixas.</span><span class="sxs-lookup"><span data-stu-id="bff42-113">Traditional client-server systems have two nodes with fixed roles and responsibilities.</span></span> <span data-ttu-id="bff42-114">Os sistemas distribuídos modernos podem ter mais de dois nós, e suas funções são geralmente dinâmicas.</span><span class="sxs-lookup"><span data-stu-id="bff42-114">Modern-distributed systems can have more than two nodes, and their roles are often dynamic.</span></span> <span data-ttu-id="bff42-115">Em uma conversa, um nó pode ser um cliente, enquanto em outra conversa o nó pode ser o servidor.</span><span class="sxs-lookup"><span data-stu-id="bff42-115">In one conversation a node can be a client, while in another conversation the node can be the server.</span></span> <span data-ttu-id="bff42-116">Em muitos casos, o consumidor final da funcionalidade exposta é um cliente com um usuário que está sentado em um teclado, assistindo à saída.</span><span class="sxs-lookup"><span data-stu-id="bff42-116">In many cases, the ultimate consumer of the exposed functionality is a client with a user sitting at a keyboard, watching the output.</span></span> <span data-ttu-id="bff42-117">Em outros casos, as funções de sistema distribuído autônomas, executando operações em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="bff42-117">In other cases the distributed system functions unattended, performing background operations.</span></span>

<span data-ttu-id="bff42-118">O sistema distribuído pode não ter clientes e servidores dedicados para cada troca de pacotes em particular, mas é importante lembrar que há um chamador, (ou iniciador, que é geralmente referido como o cliente).</span><span class="sxs-lookup"><span data-stu-id="bff42-118">The distributed system may not have dedicated clients and servers for each particular packet exchange, but it is important to remember there is a caller, (or initiator, either of which is often referred to as the client).</span></span> <span data-ttu-id="bff42-119">Também há o destinatário da chamada (geralmente chamado de servidor).</span><span class="sxs-lookup"><span data-stu-id="bff42-119">There is also the recipient of the call (often referred to as the server).</span></span> <span data-ttu-id="bff42-120">Não é necessário ter trocas de pacotes de duas vias no formato de solicitação-resposta de um sistema distribuído; muitas vezes, as mensagens são enviadas apenas uma delas.</span><span class="sxs-lookup"><span data-stu-id="bff42-120">It is not necessary to have two-way packet exchanges in the request-reply format of a distributed system; often messages are sent only one way.</span></span>

 

 




