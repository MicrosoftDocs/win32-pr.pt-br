---
title: Lidando com a perda de conectividade
description: Lidando com a perda de conectividade
ms.assetid: a90fcb5a-773e-4c21-bf6c-c3519ec13a09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: de8e7a8088cfe09a4c4026c16cc3dc5ea36b3430
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "103641491"
---
# <a name="dealing-with-loss-of-connectivity"></a><span data-ttu-id="1696c-103">Lidando com a perda de conectividade</span><span class="sxs-lookup"><span data-stu-id="1696c-103">Dealing with Loss of Connectivity</span></span>

<span data-ttu-id="1696c-104">Depois que uma chamada RPC é concluída, a conexão não é fechada; Ele é marcado como gratuito.</span><span class="sxs-lookup"><span data-stu-id="1696c-104">After an RPC call completes the connection is not closed; it is marked as free.</span></span> <span data-ttu-id="1696c-105">Assim, o servidor pode ficar inativo ou a conectividade de rede pode ser perdida durante ou entre chamadas, enquanto uma conexão está colocada no pool.</span><span class="sxs-lookup"><span data-stu-id="1696c-105">As such, the server can go down or network connectivity can be lost during or between calls, while a connection is sitting in the pool.</span></span> <span data-ttu-id="1696c-106">Como uma questão de política, o tempo de execução de RPC tenta novamente essas chamadas somente se as duas condições a seguir forem atendidas:</span><span class="sxs-lookup"><span data-stu-id="1696c-106">As a matter of policy, the RPC run time re-attempts those calls only if the following two conditions are met:</span></span>

-   <span data-ttu-id="1696c-107">O servidor não pode possivelmente executar a chamada ou a chamada é idempotente.</span><span class="sxs-lookup"><span data-stu-id="1696c-107">The server cannot possibly execute the call, or the call is idempotent.</span></span>
-   <span data-ttu-id="1696c-108">O cliente pode implementar repetições de maneira eficiente em termos de desempenho.</span><span class="sxs-lookup"><span data-stu-id="1696c-108">The client can implement retries in a performance-efficient manner.</span></span>

<span data-ttu-id="1696c-109">Os parágrafos a seguir expandem e esclarecem as duas condições.</span><span class="sxs-lookup"><span data-stu-id="1696c-109">The following paragraphs expand and clarify the two conditions.</span></span>

<span data-ttu-id="1696c-110">Uma chamada idempotente é uma chamada que pode ser executada mais de uma vez no servidor sem efeitos colaterais indesejáveis.</span><span class="sxs-lookup"><span data-stu-id="1696c-110">An idempotent call is a call that can be executed more than once on the server without undesirable side effects.</span></span> <span data-ttu-id="1696c-111">Por exemplo, ter uma chamada RPC que consulta o saldo no banco de uma determinada conta é idempotente.</span><span class="sxs-lookup"><span data-stu-id="1696c-111">For example, having an RPC call that queries the balance in the bank for a given account is idempotent.</span></span> <span data-ttu-id="1696c-112">Se essa chamada for executada duas vezes devido à perda de conectividade, nenhum dano será feito.</span><span class="sxs-lookup"><span data-stu-id="1696c-112">If this call is executed twice due to loss of connectivity, no harm is done.</span></span> <span data-ttu-id="1696c-113">Outro exemplo de uma chamada idempotente é alterar o endereço de um cliente em um banco de dados.</span><span class="sxs-lookup"><span data-stu-id="1696c-113">Another example of an idempotent call is changing the address of a customer in a database.</span></span> <span data-ttu-id="1696c-114">Executar duas vezes é bom, pois a segunda execução simplesmente substitui o endereço já atual pelo mesmo endereço.</span><span class="sxs-lookup"><span data-stu-id="1696c-114">Executing twice is fine, since the second execution simply replaces the already-current address with the same address.</span></span> <span data-ttu-id="1696c-115">Uma operação como "subtrair 50 dólares da conta xyz" não é idempotente.</span><span class="sxs-lookup"><span data-stu-id="1696c-115">An operation like "subtract fifty dollars from account xyz" is not idempotent.</span></span> <span data-ttu-id="1696c-116">A perda de conectividade de rede não deve resultar em várias execuções de tal chamada.</span><span class="sxs-lookup"><span data-stu-id="1696c-116">Loss of network connectivity should not result in multiple executions of such a call.</span></span>

<span data-ttu-id="1696c-117">Para ser seguro, o tempo de execução de RPC trata todas as chamadas como não idempotentes.</span><span class="sxs-lookup"><span data-stu-id="1696c-117">To be safe, the RPC run time treats all calls as non-idempotent.</span></span> <span data-ttu-id="1696c-118">O \[ \] atributo idempotente não tem suporte para [**\_ \_ TCP IP ncacn**](/windows/desktop/Midl/ncacn-ip-tcp)e é ignorado.</span><span class="sxs-lookup"><span data-stu-id="1696c-118">The \[idempotent\] attribute is not supported for [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp), and is ignored.</span></span> <span data-ttu-id="1696c-119">Como tal, a primeira condição na lista anterior é reduzida para *o servidor que não pode executar a chamada*.</span><span class="sxs-lookup"><span data-stu-id="1696c-119">As such, the first condition in the preceding list is reduced to *the server that cannot possibly execute the call*.</span></span>

<span data-ttu-id="1696c-120">Em muitos casos, o tempo de execução de RPC não pode determinar de determinadamente que a chamada ainda não foi executada no servidor.</span><span class="sxs-lookup"><span data-stu-id="1696c-120">In many cases the RPC run time is unable to conclusively determine the call was not already executed on the server.</span></span> <span data-ttu-id="1696c-121">Nesses casos, o cliente não tentará executar a chamada novamente.</span><span class="sxs-lookup"><span data-stu-id="1696c-121">In such cases, the client will not retry executing the call.</span></span>

<span data-ttu-id="1696c-122">Os exemplos a seguir ilustram quando o tempo de execução de RPC faz ou não tenta uma chamada novamente:</span><span class="sxs-lookup"><span data-stu-id="1696c-122">The following examples illustrate when the RPC run time does or does not retry a call:</span></span>

-   <span data-ttu-id="1696c-123">Um servidor é reinicializado.</span><span class="sxs-lookup"><span data-stu-id="1696c-123">A server is rebooted.</span></span>

    <span data-ttu-id="1696c-124">Uma chamada RPC simples, sem segurança, é feita em uma interface na qual nenhuma chamada anterior foi feita após a reinicialização.</span><span class="sxs-lookup"><span data-stu-id="1696c-124">A simple, no-security RPC call is made on an interface on which no previous call has been made after the reboot.</span></span> <span data-ttu-id="1696c-125">Como nenhuma chamada foi feita nessa interface, o tempo de execução de RPC primeiro tenta negociar o uso da interface.</span><span class="sxs-lookup"><span data-stu-id="1696c-125">Since no calls were made on this interface, the RPC run time first attempts to negotiate use of the interface.</span></span> <span data-ttu-id="1696c-126">Ele envia um pacote usando uma conexão no pool.</span><span class="sxs-lookup"><span data-stu-id="1696c-126">It sends a packet using a connection in the pool.</span></span> <span data-ttu-id="1696c-127">Como o servidor foi reinicializado e a conexão não é mais válida, ela retorna um erro.</span><span class="sxs-lookup"><span data-stu-id="1696c-127">Since the server was rebooted, and the connection is no longer valid, it returns an error.</span></span> <span data-ttu-id="1696c-128">Como o tempo de execução RPC do lado do cliente ainda não começou a enviar os dados para a chamada real, o cliente determina que o servidor não pôde ter sido executado nesses dados.</span><span class="sxs-lookup"><span data-stu-id="1696c-128">Since the client side RPC run time has not yet started sending the data for the actual call, the client determines that the server could not possibly have executed on those data.</span></span> <span data-ttu-id="1696c-129">Portanto, ele fecha a conexão e procura outra conexão no pool.</span><span class="sxs-lookup"><span data-stu-id="1696c-129">Therefore, it closes the connection and looks for another connection in the pool.</span></span> <span data-ttu-id="1696c-130">Se não for possível localizar uma conexão, ela abrirá uma nova conexão e tentará negociar o uso da interface novamente.</span><span class="sxs-lookup"><span data-stu-id="1696c-130">If it cannot find a connection, it opens a new connection and tries to negotiate use of the interface again.</span></span> <span data-ttu-id="1696c-131">Se isso tiver êxito, a chamada será feita (ou seja, uma nova tentativa será feita, pois a falha foi detectada antes da chamada ser iniciada).</span><span class="sxs-lookup"><span data-stu-id="1696c-131">If this succeeds, the call is made (that is, a retry is made, because the failure was detected before the call was started).</span></span>

-   <span data-ttu-id="1696c-132">Uma chamada RPC com segurança de nível de privacidade (criptografia) é feita em uma conexão com um contexto de segurança já negociado.</span><span class="sxs-lookup"><span data-stu-id="1696c-132">An RPC call with privacy-level security (encryption) is made on a connection with an already-negotiated security context.</span></span>

    <span data-ttu-id="1696c-133">Para garantir um desempenho eficiente, o tempo de execução do RPC criptografa o pacote empacotado embutido (sobre os dados de texto não criptografado).</span><span class="sxs-lookup"><span data-stu-id="1696c-133">To ensure efficient performance, the RPC run time encrypts the marshaled packet inline (over the clear text data).</span></span> <span data-ttu-id="1696c-134">Se a tentativa de enviar os dados falhar, o tempo de execução do RPC não poderá repetir a chamada, já que os dados de texto não criptografado foram substituídos por esses dados e não podem criptografar novamente os dados com um novo contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="1696c-134">If the attempt to send the data fails, the RPC run time cannot retry the call, since the clear text data have been overwritten with the encrypted data, and it cannot re-encrypt the data with a new security context.</span></span> <span data-ttu-id="1696c-135">Portanto, nenhuma repetição é feita.</span><span class="sxs-lookup"><span data-stu-id="1696c-135">Therefore, no retry is made.</span></span>

-   <span data-ttu-id="1696c-136">O envio de um fragmento não primeiro falha.</span><span class="sxs-lookup"><span data-stu-id="1696c-136">The sending of a non-first fragment fails.</span></span>

    <span data-ttu-id="1696c-137">A repetição não é feita, pois o tempo de execução de RPC pode optar por descartar o conteúdo do primeiro fragmento quando ele for concluído e não tiver como tentar enviar o primeiro fragmento.</span><span class="sxs-lookup"><span data-stu-id="1696c-137">Retry is not made, since the RPC run time may choose to discard the contents of the first fragment once it is complete, and has no way to retry sending the first fragment.</span></span>

-   <span data-ttu-id="1696c-138">A solicitação RPC é enviada.</span><span class="sxs-lookup"><span data-stu-id="1696c-138">The RPC request is sent.</span></span>

    <span data-ttu-id="1696c-139">O servidor anula a conexão.</span><span class="sxs-lookup"><span data-stu-id="1696c-139">The server aborts the connection.</span></span> <span data-ttu-id="1696c-140">Nenhuma tentativa é feita, já que a RPC não pode distinguir se o servidor recebeu a chamada e começou a executá-la.</span><span class="sxs-lookup"><span data-stu-id="1696c-140">No retry is attempted, since RPC cannot discern whether the server received the call and started executing it.</span></span>

<span data-ttu-id="1696c-141">Se o servidor usar um ponto de extremidade dinâmico, o RPC não resolverá o ponto de extremidade novamente durante novas tentativas.</span><span class="sxs-lookup"><span data-stu-id="1696c-141">If the server uses a dynamic endpoint, RPC will not re-resolve the endpoint during retries.</span></span> <span data-ttu-id="1696c-142">Isso significa que, se um servidor for desativado e voltar a ficar em funcionamento, ele poderá residir em um ponto de extremidade diferente e o RPC não resolverá de modo transparente o ponto de extremidade quando uma chamada for repetida.</span><span class="sxs-lookup"><span data-stu-id="1696c-142">This means that if a server is brought down and comes back up, it may reside on a different endpoint, and RPC will not transparently re-resolve the endpoint when a call is retried.</span></span> <span data-ttu-id="1696c-143">Para forçar a reresolução do ponto de extremidade, o cliente RPC deve chamar [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) antes de tentar novamente uma chamada.</span><span class="sxs-lookup"><span data-stu-id="1696c-143">To force re-resolving of the endpoint, the RPC client should calling [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) before it retries a call.</span></span>

<span data-ttu-id="1696c-144">Em muitos desses casos, se um cliente RPC puder determinar se uma chamada é idempotente ou se mantém os dados descartados pelo RPC, ele pode optar por criar um mecanismo de repetição sobre o RPC.</span><span class="sxs-lookup"><span data-stu-id="1696c-144">In many of these cases, if an RPC client can determine whether a call is idempotent, or if it keeps data that RPC discards, it may choose to build a retry mechanism on top of RPC.</span></span>

> [!Note]  
> <span data-ttu-id="1696c-145">Se o servidor for um cluster e os diferentes nós do cluster executarem versões diferentes do software do servidor, uma nova tentativa de RPC poderá chamar a chamada em um nó diferente do cluster no caso de failover e, potencialmente, em uma versão diferente do servidor.</span><span class="sxs-lookup"><span data-stu-id="1696c-145">If the server is a cluster, and the different nodes of the cluster run different versions of the server software, an RPC retry may land the call on a different node of the cluster in the case of failover, and potentially on a different version of the server.</span></span> <span data-ttu-id="1696c-146">Nesses cenários de implantação, verifique se o cliente não depende de uma versão específica do software de servidor para executar uma determinada chamada.</span><span class="sxs-lookup"><span data-stu-id="1696c-146">In such deployment scenarios, make sure the client does not rely on a particular version of the server software to execute a given call.</span></span> <span data-ttu-id="1696c-147">Se tiver, o cliente deverá criar um mecanismo sobre o RPC que detecta e manipula essas condições.</span><span class="sxs-lookup"><span data-stu-id="1696c-147">If it does, the client should build a mechanism on top of RPC that detects and handles such conditions.</span></span>

 

 

 