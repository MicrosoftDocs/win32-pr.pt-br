---
title: Proteção de buffer MCCP
description: A partir do Windows Vista, o mecanismo de Marshalling de RPC executa etapas adicionais para tentar evitar estouros de buffer do lado do cliente devido a dados retornados. Esse recurso é chamado de proteção de conformidade de mini computação (MCCP).
ms.assetid: 37fe743b-c64e-469d-b8f4-abab9f05c813
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a70d04de57974bd9665d659129590d72513eb83e
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "103641724"
---
# <a name="mccp-buffer-protection"></a><span data-ttu-id="5f87e-104">Proteção de buffer MCCP</span><span class="sxs-lookup"><span data-stu-id="5f87e-104">MCCP Buffer Protection</span></span>

<span data-ttu-id="5f87e-105">A partir do Windows Vista, o mecanismo de Marshalling de RPC executa etapas adicionais para tentar evitar estouros de buffer do lado do cliente devido a dados retornados.</span><span class="sxs-lookup"><span data-stu-id="5f87e-105">Starting with Windows Vista, the RPC Marshalling Engine takes further steps to try to prevent client-side buffer overruns due to returned data.</span></span> <span data-ttu-id="5f87e-106">Esse recurso é chamado de proteção de conformidade de mini computação (MCCP).</span><span class="sxs-lookup"><span data-stu-id="5f87e-106">This facility is called Mini Compute Conformance Protection (MCCP).</span></span>

<span data-ttu-id="5f87e-107">Quando o cliente passa um ponteiro para um buffer existente para um \[ parâmetro [**out**](/windows/desktop/Midl/out-idl) \] ou \[ [**in**](/windows/desktop/Midl/in),**out** , \] os dados retornados para esse parâmetro são copiados para o buffer existente.</span><span class="sxs-lookup"><span data-stu-id="5f87e-107">When the client passes a pointer to an existing buffer to an \[[**out**](/windows/desktop/Midl/out-idl)\] or \[[**in**](/windows/desktop/Midl/in),**out**\] parameter, returned data for that parameter is copied into the existing buffer.</span></span> <span data-ttu-id="5f87e-108">Se os dados retornados forem maiores que o buffer passado, uma saturação de buffer poderá ocorrer quando o RPC copiar os dados retornados para o buffer muito pequeno.</span><span class="sxs-lookup"><span data-stu-id="5f87e-108">If the returned data is larger than the passed buffer, a buffer overrun can occur when RPC copies the returned data into the too-small buffer.</span></span> <span data-ttu-id="5f87e-109">Consulte [ponteiros de nível superior e inseridos](top-level-and-embedded-pointers.md).</span><span class="sxs-lookup"><span data-stu-id="5f87e-109">See [Top-Level and Embedded Pointers](top-level-and-embedded-pointers.md).</span></span>

<span data-ttu-id="5f87e-110">Com o MCCP, o RPC tenta detectar essa condição e rejeitar a chamada se ela for detectada.</span><span class="sxs-lookup"><span data-stu-id="5f87e-110">With MCCP, RPC attempts to detect this condition and reject the call if it is detected.</span></span> <span data-ttu-id="5f87e-111">Para buffers com um valor de correlação, como \[ [**tamanho \_**](/windows/desktop/Midl/size-is) \] , se os dados retornados não couberem no tamanho do buffer especificado, a chamada será rejeitada e a \_ \_ exceção de dados stub inválidos RPC X \_ \_ será gerada.</span><span class="sxs-lookup"><span data-stu-id="5f87e-111">For buffers with a correlation value, such as \[[**size\_is**](/windows/desktop/Midl/size-is)\], if the returned data does not fit in the specified buffer size, the call is rejected and RPC\_X\_BAD\_STUB\_DATA exception is raised.</span></span> <span data-ttu-id="5f87e-112">Para cadeias de caracteres sem tamanho, a chamada será rejeitada se o tamanho da cadeia de caracteres existente (comprimento até o terminador **NULL** ) não for suficiente para manter a cadeia de caracteres retornada, a chamada será rejeitada.</span><span class="sxs-lookup"><span data-stu-id="5f87e-112">For unsized strings, the call is rejected if the existing string size (length until the **null** terminator) is insufficient to hold the returned string, the call is rejected.</span></span> <span data-ttu-id="5f87e-113">O RPC não pode detectar estouros de buffer em todas as condições, portanto, é aconselhável que o desenvolvedor continue a tomar precauções normais contra estouros de buffer.</span><span class="sxs-lookup"><span data-stu-id="5f87e-113">RPC cannot detect buffer overruns in all conditions, so the developer is advised to continue to take normal precautions against buffer overruns.</span></span>

<span data-ttu-id="5f87e-114">Se o cliente não passar um buffer existente para um parâmetro \[ [**out**](/windows/desktop/Midl/out-idl) \] , mas, em vez disso, passar um ponteiro de referência para **NULL**, o RPC seguirá as regras normais para alocar um novo buffer em nome do cliente.</span><span class="sxs-lookup"><span data-stu-id="5f87e-114">If the client does not pass an existing buffer for an \[[**out**](/windows/desktop/Midl/out-idl)\] parameter, but instead passes a dereferenced pointer to **NULL**, RPC will follow normal rules to allocate a new buffer on the client’s behalf.</span></span> <span data-ttu-id="5f87e-115">Esse buffer será alocado com espaço suficiente para manter os dados retornados.</span><span class="sxs-lookup"><span data-stu-id="5f87e-115">This buffer will be allocated with sufficient space to hold the returned data.</span></span>

<span data-ttu-id="5f87e-116">Uma segunda proteção é que, para parâmetros correlacionados, o RPC irá impor que um buffer não **nulo** seja passado quando a variável de contagem de correlação for não **nula**.</span><span class="sxs-lookup"><span data-stu-id="5f87e-116">A second protection is that for correlated parameters, RPC will enforce that a non-**null** buffer is passed when the correlation count variable is non-**null**.</span></span>

``` syntax
HRESULT PassString( [in] DWORD Length, [in, unique, string, size_is( Length )]LPWSTR MyString );
```

<span data-ttu-id="5f87e-117">Se *MyString* for **NULL**, o RPC rejeitará a chamada, a menos que *Length* esteja definido como 0.</span><span class="sxs-lookup"><span data-stu-id="5f87e-117">If *MyString* is **NULL**, RPC will reject the call unless *Length* is set to 0.</span></span> <span data-ttu-id="5f87e-118">Observe que o RPC permitirá que o *comprimento* seja 0 enquanto o *MyString* não for **nulo** e o RPC tratará *MyString* como uma alocação de buffer de comprimento 0.</span><span class="sxs-lookup"><span data-stu-id="5f87e-118">Note that RPC will allow *Length* to be 0 while *MyString* is non-**NULL**, and RPC will treat *MyString* as a 0-length buffer allocation.</span></span>

 

 