---
title: Limitações de acesso de bloco com mapeamentos duplicados
description: Esta seção descreve as limitações de acesso de bloco com mapeamentos duplicados.
ms.assetid: 7A498E0D-9151-4A89-B7C3-C4F476457D17
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0909b0d10e286e5f774f6893b692abdeb19d3ef7
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "104005040"
---
# <a name="tile-access-limitations-with-duplicate-mappings"></a><span data-ttu-id="88502-103">Limitações de acesso de bloco com mapeamentos duplicados</span><span class="sxs-lookup"><span data-stu-id="88502-103">Tile access limitations with duplicate mappings</span></span>

<span data-ttu-id="88502-104">Esta seção descreve as limitações de acesso de bloco com mapeamentos duplicados.</span><span class="sxs-lookup"><span data-stu-id="88502-104">This section describes tile access limitations with duplicate mappings.</span></span>

## <a name="copying-tiled-resources-with-overlapping-source-and-destination"></a><span data-ttu-id="88502-105">Copiando recursos em ladrilho com sobreposição de origem e destino</span><span class="sxs-lookup"><span data-stu-id="88502-105">Copying tiled resources with overlapping source and destination</span></span>

<span data-ttu-id="88502-106">Se os blocos na área de origem e de destino de uma operação de cópia \* tiverem mapeamentos duplicados na área de cópia que teriam sobreposição, mesmo se os dois recursos não fossem recursos de lado, e a operação de cópia \* der suporte a cópias sobrepostas, a operação de cópia \* se comportará bem (como se a origem fosse copiada para um local temporário antes de ir para o</span><span class="sxs-lookup"><span data-stu-id="88502-106">If tiles in the source and destination area of a Copy\* operation have duplicated mappings in the copy area that would have overlapped even if both resources were not tiled resources and the Copy\* operation supports overlapping copies, the Copy\* operation will behave fine (as if the source is copied to a temporary location before going to the destination).</span></span> <span data-ttu-id="88502-107">Mas, se a sobreposição não for óbvia (por exemplo, os recursos de origem e destino são diferentes, mas compartilham mapeamentos, ou os mapeamentos são duplicados sobre uma determinada superfície), os resultados da operação de cópia nos blocos que são compartilhados serão indefinidos.</span><span class="sxs-lookup"><span data-stu-id="88502-107">But if the overlap is not obvious (like the source and destination resources are different but share mappings or mappings are duplicated over a given surface), results of the copy operation on the tiles that are shared are undefined.</span></span>

## <a name="copying-to-tiled-resource-with-duplicated-tiles-in-destination-area"></a><span data-ttu-id="88502-108">Copiando para o recurso de bloco com blocos duplicados na área de destino</span><span class="sxs-lookup"><span data-stu-id="88502-108">Copying to tiled resource with duplicated tiles in destination area</span></span>

<span data-ttu-id="88502-109">A cópia para um recurso de bloco ao lado com blocos duplicados na área de destino produz resultados indefinidos nesses blocos, a menos que os próprios dados sejam idênticos; blocos diferentes podem gravar os blocos em ordens diferentes.</span><span class="sxs-lookup"><span data-stu-id="88502-109">Copying to a tiled resource with duplicated tiles in the destination area produces undefined results in these tiles unless the data itself is identical; different tiles might write the tiles in different orders.</span></span>

## <a name="uav-accesses-to-duplicate-tiles-mappings"></a><span data-ttu-id="88502-110">Acessos UAV a mapeamentos de blocos duplicados</span><span class="sxs-lookup"><span data-stu-id="88502-110">UAV accesses to duplicate tiles mappings</span></span>

<span data-ttu-id="88502-111">Suponha que um modo de exibição de acesso não ordenado (UAV) em um recurso de mosaico tenha mapeamentos de bloco duplicados em sua área ou com outros recursos associados ao pipeline.</span><span class="sxs-lookup"><span data-stu-id="88502-111">Suppose an unordered access view (UAV) on a tiled resource has duplicate tile mappings in its area or with other resources bound to the pipeline.</span></span> <span data-ttu-id="88502-112">A ordenação dos acessos a estes blocos duplicados é indefinida se realizada por threads diferentes, assim como qualquer ordenação de acesso da memória a UAVs em geral é não ordenada.</span><span class="sxs-lookup"><span data-stu-id="88502-112">Ordering of accesses to these duplicated tiles is undefined if performed by different threads, just as any ordering of memory access to UAVs in general is unordered.</span></span>

## <a name="rendering-after-tile-mapping-changes-or-content-updates-from-outside-mappings"></a><span data-ttu-id="88502-113">Renderizando após alterações no mapeamento de blocos ou atualizações de conteúdo de mapeamentos externos</span><span class="sxs-lookup"><span data-stu-id="88502-113">Rendering after tile mapping changes or content updates from outside mappings</span></span>

<span data-ttu-id="88502-114">Se os mapeamentos de bloco de um recurso do lado do ladrilho tiverem sido alterados ou se o conteúdo em blocos de pool de mosaico mapeados tiver mudado por meio de mapeamentos de outro recurso, e o recurso de bloco ao lado será renderizado por meio da exibição de destino de renderização ou exibição de estêncil de profundidade, o aplicativo deverá limpar (usando as APIs de limpeza de função fixa) ou copiar totalmente usando \* APIs Copy/update \* os blocos que foram alterados dentro da área que está sendo renderizada (mapeada ou não).</span><span class="sxs-lookup"><span data-stu-id="88502-114">If a tiled resource's tile mappings have changed or content in mapped tiled pool tiles have changed via another tiled resource's mappings, and the tiled resource is going to be rendered via render target view or depth stencil view, the application must Clear (using the fixed function Clear APIs) or fully copy over using Copy\*/Update\* APIs the tiles that have changed within the area being rendered (mapped or not).</span></span> <span data-ttu-id="88502-115">A falha de um aplicativo para limpar ou copiar nesses casos faz com que estruturas de otimização de hardware para a exibição de destino de renderização determinada ou exibição de estêncil de profundidade sejam obsoletas e resultarão em resultados de renderização de lixo em algum hardware e inconsistência em diferentes hardwares.</span><span class="sxs-lookup"><span data-stu-id="88502-115">Failure of an application to clear or copy in these cases results in hardware optimization structures for the given render target view or depth stencil view being stale and will result in garbage rendering results on some hardware and inconsistency across different hardware.</span></span> <span data-ttu-id="88502-116">Essas estruturas de dados de otimização ocultas usadas pelo hardware podem ser mapeamentos locais a individuais e não visíveis para outros mapeamentos na mesma memória.</span><span class="sxs-lookup"><span data-stu-id="88502-116">These hidden optimization data structures used by hardware might be local to individual mappings and not visible to other mappings to the same memory.</span></span>

<span data-ttu-id="88502-117">A operação [**ID3D11DeviceContext1:: Clearview**](/windows/desktop/api/D3D11_1/nf-d3d11_1-id3d11devicecontext1-clearview) dá suporte à limpeza de exibições de destino de renderização com retângulos.</span><span class="sxs-lookup"><span data-stu-id="88502-117">The [**ID3D11DeviceContext1::ClearView**](/windows/desktop/api/D3D11_1/nf-d3d11_1-id3d11devicecontext1-clearview) operation supports clearing render target views with rectangles.</span></span> <span data-ttu-id="88502-118">Para hardware que dá suporte a recursos de lado, o **Clearview** também deve oferecer suporte à limpeza de exibições de estêncil de profundidade com retângulos, apenas para superfícies de profundidade (sem estêncil).</span><span class="sxs-lookup"><span data-stu-id="88502-118">For hardware that supports tiled resources, **ClearView** must also support clearing of depth stencil views with rectangles, for depth only surfaces (without stencil).</span></span> <span data-ttu-id="88502-119">Essa operação permite que os aplicativos limpem apenas a área necessária de uma superfície.</span><span class="sxs-lookup"><span data-stu-id="88502-119">This operation allows applications to clear only the necessary area of a surface.</span></span>

<span data-ttu-id="88502-120">Se um aplicativo precisar preservar o conteúdo de memória existente de áreas em um recurso de lado-a-ponto em que os mapeamentos foram alterados, esse aplicativo deverá solucionar o requisito claro.</span><span class="sxs-lookup"><span data-stu-id="88502-120">If an application needs to preserve existing memory contents of areas in a tiled resource where mappings have changed, that application must work around the clear requirement.</span></span> <span data-ttu-id="88502-121">O aplicativo pode realizar essa solução alternativa salvando primeiro o conteúdo em que os mapeamentos de bloco foram alterados (copiando-os para uma superfície temporária, por exemplo, usando [**ID3D11DeviceContext2:: CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles)), emitindo o comando clear necessário e, em seguida, copiando o conteúdo de volta.</span><span class="sxs-lookup"><span data-stu-id="88502-121">The application can accomplish this work-around by first saving the contents where tile mappings have changed (by copying them to a temporary surface, for example, by using [**ID3D11DeviceContext2::CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles)), issuing the required clear command and then copying the contents back.</span></span> <span data-ttu-id="88502-122">Embora isso conclua a tarefa de preservar o conteúdo da superfície para renderização incremental, a desvantagem é que o desempenho da renderização subsequente na superfície poderá ser prejudicado porque as otimizações de renderização poderão ser perdidas.</span><span class="sxs-lookup"><span data-stu-id="88502-122">While this would accomplish the task of preserving surface contents for incremental rendering, the downside is that subsequent rendering performance on the surface might suffer because rendering optimizations might be lost.</span></span>

<span data-ttu-id="88502-123">Se um bloco for mapeado em vários recursos de lado, ao mesmo tempo e os conteúdos de bloco forem manipulados por qualquer meio (renderizar, copiar e assim por diante) por meio de um dos recursos ao lado do xadrez, se o mesmo bloco for renderizado por meio de qualquer outro recurso de lado, o bloco deverá ser limpo primeiro conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="88502-123">If a tile is mapped into multiple tiled resources at the same time and tile contents are manipulated by any means (render, copy, and so on) via one of the tiled resources, if the same tile is to be rendered via any other tiled resource, the tile must be cleared first as previously described.</span></span>

## <a name="rendering-to-tiles-shared-outside-render-area"></a><span data-ttu-id="88502-124">Renderizando blocos compartilhados fora da área de renderização</span><span class="sxs-lookup"><span data-stu-id="88502-124">Rendering to tiles shared outside render area</span></span>

<span data-ttu-id="88502-125">Suponha que uma área em um recurso do lado do xadrez esteja sendo renderizada e os blocos do pool de blocos referenciados pela área de renderização também sejam mapeados para fora da área de renderização (incluindo por meio de outros recursos de lado, ao mesmo tempo ou não).</span><span class="sxs-lookup"><span data-stu-id="88502-125">Suppose an area in a tiled resource is being rendered to and the tile pool tiles referenced by the render area are also mapped to from outside the render area (including via other tiled resources, at the same time or not).</span></span> <span data-ttu-id="88502-126">Não há garantira de que os dados renderizados nesses blocos aparecerão corretamente quando visualizados por meio de outros mapeamentos, mesmo que o layout de memória subjacente seja compatível.</span><span class="sxs-lookup"><span data-stu-id="88502-126">Data rendered to these tiles isn't guaranteed to appear correctly when viewed through the other mappings, even though the underlying memory layout is compatible.</span></span> <span data-ttu-id="88502-127">Isso se deve às estruturas de dados de otimização que alguns hardwares usam que podem ser mapeamentos locais a individuais para superfícies renderizáveis e não visíveis para outros mapeamentos no mesmo local de memória.</span><span class="sxs-lookup"><span data-stu-id="88502-127">This fact is due to optimization data structures some hardware use that can be local to individual mappings for renderable surfaces and not visible to other mappings to the same memory location.</span></span> <span data-ttu-id="88502-128">Você pode usar uma solução alternativa para essa restrição copiando do mapeamento renderizado para todos os outros mapeamentos na mesma memória que pode ser acessada (ou limpando essa memória ou copiando outros dados para ela se o conteúdo antigo não for mais necessário).</span><span class="sxs-lookup"><span data-stu-id="88502-128">You can work around this restriction by copying from the rendered mapping to all the other mappings to the same memory that might be accessed (or clearing that memory or copying other data to it if the old contents are no longer needed).</span></span> <span data-ttu-id="88502-129">Embora essa solução alternativa pareça redundante, isso faz com que todos os outros mapeamentos para a mesma memória entendam corretamente como acessar seu conteúdo, e pelo menos a economia de memória de se ter apenas uma única memória física de backup permanece intacta.</span><span class="sxs-lookup"><span data-stu-id="88502-129">While this work-around seems redundant, it makes all other mappings to the same memory correctly understand how to access its contents, and at least the memory savings of having only a single physical memory backing remains intact.</span></span> <span data-ttu-id="88502-130">Além disso, quando você alterna entre o uso de diferentes recursos de lado do toque que compartilham mapeamentos (a menos que apenas leitura), você deve chamar a API [**ID3D11DeviceContext2:: TiledResourceBarrier**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier) entre as opções.</span><span class="sxs-lookup"><span data-stu-id="88502-130">Also, when you switch between using different tiled resources that share mappings (unless only reading), you must call the [**ID3D11DeviceContext2::TiledResourceBarrier**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier) API in between the switches.</span></span>

## <a name="rendering-to-tiles-shared-within-render-area"></a><span data-ttu-id="88502-131">Renderizando blocos compartilhados dentro da área de renderização</span><span class="sxs-lookup"><span data-stu-id="88502-131">Rendering to tiles shared within render area</span></span>

<span data-ttu-id="88502-132">Se uma área em um recurso de bloco ao lado estiver sendo renderizada para e dentro da área de renderização, vários blocos serão mapeados para o mesmo local do pool de blocos, os resultados de renderização serão indefinidos nesses blocos.</span><span class="sxs-lookup"><span data-stu-id="88502-132">If an area in a tiled resource is being rendered to and within the render area multiple tiles are mapped to the same tile pool location, rendering results are undefined on those tiles.</span></span>

## <a name="data-compatibility-across-tiled-resources-sharing-tiles"></a><span data-ttu-id="88502-133">Compatibilidade de dados entre blocos de compartilhamento de recursos</span><span class="sxs-lookup"><span data-stu-id="88502-133">Data compatibility across tiled resources sharing tiles</span></span>

<span data-ttu-id="88502-134">Suponha que vários recursos ao lado dos blocos tenham mapeamentos para os mesmos locais de pool de peças e cada recurso é usado para acessar os mesmos dados.</span><span class="sxs-lookup"><span data-stu-id="88502-134">Suppose multiple tiled resources have mappings to the same tile pool locations and each resource is used to access the same data.</span></span> <span data-ttu-id="88502-135">Esse cenário só será válido se as outras regras sobre como evitar problemas com estruturas de otimização de hardware forem evitadas, as chamadas apropriadas para [**ID3D11DeviceContext2:: TiledResourceBarrier**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier) são feitas, e os recursos do lado do ladrilho são compatíveis entre si.</span><span class="sxs-lookup"><span data-stu-id="88502-135">This scenario is only valid if the other rules about avoiding problems with hardware optimization structures are avoided, appropriate calls to [**ID3D11DeviceContext2::TiledResourceBarrier**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier) are made, and the tiled resources are compatible with each other.</span></span> <span data-ttu-id="88502-136">O último é descrito aqui em termos de o que significa que os blocos de compartilhamento de recursos ao lado do bloco são incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="88502-136">The latter is described here in terms of what it means for tiled resources sharing tiles to be incompatible.</span></span> <span data-ttu-id="88502-137">As condições de incompatibilidade de acesso aos mesmos dados em mapeamentos de blocos duplicados são o uso de diferentes dimensões ou formatos de superfície, ou diferenças na presença de sinalizadores de associação do destino de renderização ou do estêncil de profundidade nos recursos.</span><span class="sxs-lookup"><span data-stu-id="88502-137">The incompatibility conditions of accessing the same data across duplicate tile mappings are the use of different surface dimensions or format, or differences in the presence of render target or depth stencil bind flags on the resources.</span></span> <span data-ttu-id="88502-138">A gravação na memória com um tipo de mapeamento gera resultados indefinidos quando, subsequentemente, você lê ou renderiza usando um mapeamento de um recurso incompatível.</span><span class="sxs-lookup"><span data-stu-id="88502-138">Writing to the memory with one type of mapping produces undefined results if you subsequently read or render via a mapping from an incompatible resource.</span></span> <span data-ttu-id="88502-139">Se os outros mapeamentos de compartilhamento de recursos forem inicializados primeiro com novos dados (reciclando a memória para um objetivo diferente), a operação de leitura ou renderização subsequente funcionará bem, pois não haverá sangria dos dados entre interpretações incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="88502-139">If the other resource sharing mappings are first initialized with new data (recycling the memory for a different purpose), the subsequent read or render operation is fine since data isn't bleeding across incompatible interpretations.</span></span> <span data-ttu-id="88502-140">Mas, você deve chamar a API **TiledResourceBarrier** quando alternar entre o acesso a mapeamentos incompatíveis como este.</span><span class="sxs-lookup"><span data-stu-id="88502-140">But, you must call the **TiledResourceBarrier** API when you switch between accessing incompatible mappings like this.</span></span>

<span data-ttu-id="88502-141">Se o sinalizador de associação do destino de renderização ou do estêncil de profundidade não estiver definido em qualquer um dos recursos que compartilham mapeamentos entre si, haverá bem menos restrições.</span><span class="sxs-lookup"><span data-stu-id="88502-141">If the render target or depth stencil bind flag isn't set on any of the resources sharing mappings with each other, there are far fewer restrictions.</span></span> <span data-ttu-id="88502-142">Contanto que os tipos de formato e superfície (por exemplo, Texture2D) sejam os mesmos, os blocos poderão ser compartilhados.</span><span class="sxs-lookup"><span data-stu-id="88502-142">As long as the format and surface types (for example, Texture2D) are the same, tiles can be shared.</span></span> <span data-ttu-id="88502-143">Formatos diferentes compatíveis são casos como superfícies de BC \* e o tamanho equivalente, sem compactação de 32 bits ou 16 bits por formato de componente, como BC6H e R32G32B32A32.</span><span class="sxs-lookup"><span data-stu-id="88502-143">Different formats being compatible are cases such as BC\* surfaces and the equivalent sized uncompressed 32 bit or 16 bit per component format, like BC6H and R32G32B32A32.</span></span> <span data-ttu-id="88502-144">Muitos formatos de 32 bits por elemento também podem ter um alias com R32 \_ \* (R10G10B10A2 \_ \* , R8G8B8A8 \_ \* , B8G8R8A8 \_ \* , B8G8R8X8 \_ \* , R16G16 \_ \* ); essa operação sempre foi permitida para recursos que não são de lado do ladrilho.</span><span class="sxs-lookup"><span data-stu-id="88502-144">Many 32 bit per element formats can be aliased with R32\_\* as well (R10G10B10A2\_\*, R8G8B8A8\_\*, B8G8R8A8\_\*,B8G8R8X8\_\*,R16G16\_\*); this operation has always been allowed for non-tiled resources.</span></span>

<span data-ttu-id="88502-145">Não há problema no compartilhamento entre blocos compactados e não compactados quando os formatos são compatíveis e os blocos são preenchidos com cor sólida.</span><span class="sxs-lookup"><span data-stu-id="88502-145">Sharing between packed and non-packed tiles is fine if the formats are compatible and the tiles are filled with solid color.</span></span>

<span data-ttu-id="88502-146">Por fim, se não houver nada em comum nos mapeamentos de blocos de compartilham recursos, exceto que nenhum apresente sinalizadores de associação do destino de renderização ou do estêncil de profundidade, somente a memória preenchida com 0 poderá ser compartilhada com segurança; o mapeamento aparecerá como o valor que o 0 decodificar para a definição do formato de recurso específico (normalmente 0).</span><span class="sxs-lookup"><span data-stu-id="88502-146">Finally, if nothing is common about the resources sharing tile mappings except that none have render target or depth stencil bind flags, only memory filled with 0 can be shared safely; the mapping will appear as whatever 0 decodes to for the definition of the given resource format (typically just 0).</span></span>

## <a name="related-topics"></a><span data-ttu-id="88502-147">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="88502-147">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="88502-148">Acesso ao pipeline para recursos lado a lado</span><span class="sxs-lookup"><span data-stu-id="88502-148">Pipeline access to tiled resources</span></span>](pipeline-access-to-tiled-resources.md)
</dt> </dl>

 

 




