---
title: APIs de recursos de lado
description: As APIs descritas nesta seção funcionam com os recursos de lado e o pool de blocos.
ms.assetid: 02DCF9BA-F9EA-4176-AD6F-AA620CE968BA
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8a0d97f5272f4f96db56e6e89b871951de035105
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "104363722"
---
# <a name="tiled-resource-apis"></a><span data-ttu-id="03c4e-103">APIs de recursos de lado</span><span class="sxs-lookup"><span data-stu-id="03c4e-103">Tiled Resource APIs</span></span>

<span data-ttu-id="03c4e-104">As APIs descritas nesta seção funcionam com os recursos de lado e o pool de blocos.</span><span class="sxs-lookup"><span data-stu-id="03c4e-104">The APIs described in this section work with tiled resources and tile pool.</span></span>

-   [<span data-ttu-id="03c4e-105">Atribuindo blocos de um pool de peças a um recurso</span><span class="sxs-lookup"><span data-stu-id="03c4e-105">Assigning tiles from a tile pool to a resource</span></span>](#assigning-tiles-from-a-tile-pool-to-a-resource)
-   [<span data-ttu-id="03c4e-106">Consultando suporte e disposição do recurso</span><span class="sxs-lookup"><span data-stu-id="03c4e-106">Querying resource tiling and support</span></span>](#querying-resource-tiling-and-support)
-   [<span data-ttu-id="03c4e-107">Copiando dados em ladrilhos</span><span class="sxs-lookup"><span data-stu-id="03c4e-107">Copying tiled data</span></span>](#copying-tiled-data)
-   [<span data-ttu-id="03c4e-108">Redimensionando o pool de blocos</span><span class="sxs-lookup"><span data-stu-id="03c4e-108">Resizing tile pool</span></span>](#resizing-tile-pool)
-   [<span data-ttu-id="03c4e-109">Barreira de recurso por lado</span><span class="sxs-lookup"><span data-stu-id="03c4e-109">Tiled resource barrier</span></span>](#tiled-resource-barrier)
-   [<span data-ttu-id="03c4e-110">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="03c4e-110">Related topics</span></span>](#related-topics)

## <a name="assigning-tiles-from-a-tile-pool-to-a-resource"></a><span data-ttu-id="03c4e-111">Atribuindo blocos de um pool de peças a um recurso</span><span class="sxs-lookup"><span data-stu-id="03c4e-111">Assigning tiles from a tile pool to a resource</span></span>

<span data-ttu-id="03c4e-112">As APIs [**ID3D11DeviceContext2:: UpdateTileMappings**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-updatetilemappings) e [**ID3D11DeviceContext2:: CopyTileMappings**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytilemappings) manipulam e consultam mapeamentos de bloco.</span><span class="sxs-lookup"><span data-stu-id="03c4e-112">The [**ID3D11DeviceContext2::UpdateTileMappings**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-updatetilemappings) and [**ID3D11DeviceContext2::CopyTileMappings**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytilemappings) APIs manipulate and query tile mappings.</span></span> <span data-ttu-id="03c4e-113">As chamadas de atualização afetam apenas os blocos identificados na chamada, e outros são deixados conforme definido anteriormente.</span><span class="sxs-lookup"><span data-stu-id="03c4e-113">Update calls only affect the tiles identified in the call, and others are left as defined previously.</span></span>

<span data-ttu-id="03c4e-114">Qualquer bloco específico de um pool de peças pode ser mapeado para vários locais em um recurso e até mesmo vários recursos.</span><span class="sxs-lookup"><span data-stu-id="03c4e-114">Any given tile from a tile pool can be mapped to multiple locations in a resource and even multiple resources.</span></span> <span data-ttu-id="03c4e-115">Esse mapeamento inclui blocos em um recurso que têm um layout escolhido pela implementação ([empacotamento de mipmap](mipmap-packing.md)), em que vários mipmaps são empacotados juntos em um único bloco.</span><span class="sxs-lookup"><span data-stu-id="03c4e-115">This mapping includes tiles in a resource that have an implementation-chosen layout ([Mipmap packing](mipmap-packing.md)) where multiple mipmaps are packed together into a single tile.</span></span> <span data-ttu-id="03c4e-116">O problema é que, se os dados forem gravados no bloco por meio de um mapeamento, mas lidos por meio de um mapeamento configurado de forma diferente, os resultados serão indefinidos.</span><span class="sxs-lookup"><span data-stu-id="03c4e-116">The catch is that if data is written to the tile via one mapping, but read via a differently configured mapping, the results are undefined.</span></span> <span data-ttu-id="03c4e-117">No entanto, o uso cuidadoso dessa flexibilidade ainda pode ser útil para um aplicativo, como compartilhar um bloco entre os recursos que não serão usados simultaneamente, onde o conteúdo do bloco sempre será inicializado por meio do mesmo mapeamento de recursos, pois eles serão lidos posteriormente.</span><span class="sxs-lookup"><span data-stu-id="03c4e-117">Careful use of this flexibility can still be useful for an application though, like sharing a tile between resources that will not be used simultaneously, where the contents of the tile are always initialized through the same resource mapping as they will be subsequently read from.</span></span> <span data-ttu-id="03c4e-118">Da mesma forma, um bloco mapeado para manter o mipmaps empacotado de vários recursos diferentes com as mesmas dimensões de superfície funcionará bem. os dados serão exibidos da mesma forma em ambos os mapeamentos.</span><span class="sxs-lookup"><span data-stu-id="03c4e-118">Similarly, a tile mapped to hold the packed mipmaps of multiple different resources with the same surface dimensions will work fine - the data will appear the same in both mappings.</span></span>

<span data-ttu-id="03c4e-119">Alterações nas atribuições de bloco para um recurso podem ser feitas a qualquer momento em um contexto imediato ou adiado.</span><span class="sxs-lookup"><span data-stu-id="03c4e-119">Changes to tile assignments for a resource can be made at any time in an immediate or deferred context.</span></span>

## <a name="querying-resource-tiling-and-support"></a><span data-ttu-id="03c4e-120">Consultando suporte e disposição do recurso</span><span class="sxs-lookup"><span data-stu-id="03c4e-120">Querying resource tiling and support</span></span>

<span data-ttu-id="03c4e-121">Para consultar o recurso em blocos, use [**ID3D11Device2:: GetResourceTiling**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11device2-getresourcetiling).</span><span class="sxs-lookup"><span data-stu-id="03c4e-121">To query resource tiling, use [**ID3D11Device2::GetResourceTiling**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11device2-getresourcetiling).</span></span>

<span data-ttu-id="03c4e-122">Para outro suporte ao lado do recurso, use [**ID3D11Device2:: CheckMultisampleQualityLevels1**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11device2-checkmultisamplequalitylevels1).</span><span class="sxs-lookup"><span data-stu-id="03c4e-122">For other resource tiling support, use [**ID3D11Device2::CheckMultisampleQualityLevels1**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11device2-checkmultisamplequalitylevels1).</span></span>

## <a name="copying-tiled-data"></a><span data-ttu-id="03c4e-123">Copiando dados em ladrilhos</span><span class="sxs-lookup"><span data-stu-id="03c4e-123">Copying tiled data</span></span>

<span data-ttu-id="03c4e-124">Quaisquer métodos no Direct3D para mover dados em todo o trabalho com recursos de lado, assim como se eles não fossem lado, exceto que as gravações em áreas não mapeadas são descartadas e as leituras de áreas não mapeadas produzem 0.</span><span class="sxs-lookup"><span data-stu-id="03c4e-124">Any methods in Direct3D for moving data around work with tiled resources just as if they are not tiled, except that writes to unmapped areas are dropped and reads from unmapped areas produce 0.</span></span> <span data-ttu-id="03c4e-125">Se uma operação de cópia envolver a gravação no mesmo local de memória várias vezes porque vários locais no recurso de destino são mapeados para a mesma memória de bloco, as gravações resultantes em blocos de vários mapeados são não determinísticas e não repetíveis.</span><span class="sxs-lookup"><span data-stu-id="03c4e-125">If a copy operation involves writing to the same memory location multiple times because multiple locations in the destination resource are mapped to the same tile memory, the resulting writes to multi-mapped tiles are non-deterministic and non-repeatable.</span></span> <span data-ttu-id="03c4e-126">Ou seja, os acessos acontecem em qualquer ordem em que o hardware for executar a cópia.</span><span class="sxs-lookup"><span data-stu-id="03c4e-126">That is, accesses happen in whatever order the hardware happens to execute the copy.</span></span>

<span data-ttu-id="03c4e-127">O Direct3D 11,2 apresenta métodos para essas maneiras adicionais de copiar:</span><span class="sxs-lookup"><span data-stu-id="03c4e-127">Direct3D 11.2 introduces methods for these additional ways to copy:</span></span>

-   <span data-ttu-id="03c4e-128">Copiar entre blocos em um recurso do lado do ladrilho (com granularidade de bloco de 64 KB) e (de/para) um buffer na memória da GPU (unidade de processamento gráfico) (ou recurso de preparo)- [ **ID3D11DeviceContext2:: CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles)</span><span class="sxs-lookup"><span data-stu-id="03c4e-128">Copy between tiles in a tiled resource (at 64KB tile granularity) and (to/from) a buffer in graphics processing unit (GPU) memory (or staging resource) - [**ID3D11DeviceContext2::CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles)</span></span>
-   <span data-ttu-id="03c4e-129">Copiar da memória fornecida pelo aplicativo para blocos em um recurso de lado-a- [ **ID3D11DeviceContext2:: UpdateTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-updatetiles)</span><span class="sxs-lookup"><span data-stu-id="03c4e-129">Copy from application-provided memory to tiles in a tiled resource - [**ID3D11DeviceContext2::UpdateTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-updatetiles)</span></span>

<span data-ttu-id="03c4e-130">Esses métodos swizzle/deswizzle conforme necessário e permitem um bloco de \_ D3D11 \_ copiar \_ sem \_ sinalizador de substituição quando o chamador promete que a memória de destino não é referenciada pelo trabalho de GPU que está em trânsito.</span><span class="sxs-lookup"><span data-stu-id="03c4e-130">These methods swizzle/deswizzle as needed, and allow a D3D11\_TILE\_COPY\_NO\_OVERWRITE flag when the caller promises the destination memory is not referenced by GPU work that is in flight.</span></span>

<span data-ttu-id="03c4e-131">Os blocos envolvidos na cópia não podem incluir blocos que contenham mipmaps empacotados ou que tenham resultados indefinidos.</span><span class="sxs-lookup"><span data-stu-id="03c4e-131">The tiles involved in the copy can't include tiles that contain packed mipmaps or that have results that are undefined.</span></span> <span data-ttu-id="03c4e-132">Para transferir dados de/para o mipmaps que os pacotes de hardware em um único bloco, você deve usar as APIs de cópia/atualização padrão (não específicas do bloco) ou [**ID3D11DeviceContext:: GenerateMips**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-generatemips) para toda a cadeia MIP.</span><span class="sxs-lookup"><span data-stu-id="03c4e-132">To transfer data to/from mipmaps that the hardware packs into one tile, you must use the standard (non-tile specific) Copy/Update APIs or [**ID3D11DeviceContext::GenerateMips**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-generatemips) for the whole mip chain.</span></span>

<span data-ttu-id="03c4e-133">**Observação em [**GenerateMips**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-generatemips):** usar [**ID3D11DeviceContext:: GenerateMips**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-generatemips) em um recurso com blocos parcialmente mapeados produzirá resultados que simplesmente seguem as regras para leitura e gravação de **NULL** aplicadas a qualquer algoritmo que o hardware e o driver de vídeo aconteçam para serem usados para **GenerateMips**.</span><span class="sxs-lookup"><span data-stu-id="03c4e-133">**Note on [**GenerateMips**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-generatemips):** Using [**ID3D11DeviceContext::GenerateMips**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-generatemips) on a resource with partially mapped tiles will produce results that simply follow the rules for reading and writing **NULL** applied to whatever algorithm the hardware and display driver happen to use to **GenerateMips**.</span></span> <span data-ttu-id="03c4e-134">Portanto, não é particularmente útil que um aplicativo se preocupe em fazer isso, a menos que as áreas com mapeamentos **nulos** (e seus efeitos em outros MIPS durante a fase de geração) não tenham nenhuma conseqüência sobre as partes da superfície para as quais o aplicativo se preocupa.</span><span class="sxs-lookup"><span data-stu-id="03c4e-134">So, it is not particularly useful for an application to bother doing this unless somehow the areas with **NULL** mappings (and their effect on other mips during the generation phase) will have no consequence on the parts of the surface the application does care about.</span></span>

<span data-ttu-id="03c4e-135">Copiar dados de bloco de uma superfície de preparo ou da memória do aplicativo seria a maneira de carregar blocos que podem ter sido transmitidos em disco, por exemplo.</span><span class="sxs-lookup"><span data-stu-id="03c4e-135">Copying tile data from a staging surface or from application memory would be the way to upload tiles that may have been streamed off disk, for example.</span></span> <span data-ttu-id="03c4e-136">Uma variação na transmissão fora do disco é carregar algum tipo de dados compactados para a memória da GPU e, em seguida, decodificar na GPU.</span><span class="sxs-lookup"><span data-stu-id="03c4e-136">A variation when streaming off disk is uploading some sort of compressed data to GPU memory and then decoding on the GPU.</span></span> <span data-ttu-id="03c4e-137">O destino de decodificação pode ser um recurso de buffer na memória de GPU, do qual o [**CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles) , em seguida, copia para o recurso em ladrilhos real.</span><span class="sxs-lookup"><span data-stu-id="03c4e-137">The decode target could be a buffer resource in GPU memory, from which [**CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles) then copies to the actual tiled resource.</span></span> <span data-ttu-id="03c4e-138">Essa etapa de cópia permite que a GPU swizzle quando o padrão de swizzle não é conhecido.</span><span class="sxs-lookup"><span data-stu-id="03c4e-138">This copy step allows the GPU to swizzle when the swizzle pattern is not known.</span></span> <span data-ttu-id="03c4e-139">Swizzling não será necessário se o próprio recurso de ladrilho for um recurso de buffer (por exemplo, em oposição a uma textura).</span><span class="sxs-lookup"><span data-stu-id="03c4e-139">Swizzling is not needed if the tiled resource itself is a buffer resource (for example, as opposed to a Texture).</span></span>

<span data-ttu-id="03c4e-140">O layout de memória dos blocos no lado do recurso de buffer que não se dispõe de lado da cópia é simplesmente linear na memória dentro dos blocos de 64 KB, que o hardware e o driver de vídeo swizzle/deswizzle por bloco, conforme apropriado, ao transferir de/para um recurso de lado.</span><span class="sxs-lookup"><span data-stu-id="03c4e-140">The memory layout of the tiles in the non-tiled buffer resource side of the copy is simply linear in memory within 64KB tiles, which the hardware and display driver would swizzle/deswizzle per tile as appropriate when transferring to/from a tiled resource.</span></span> <span data-ttu-id="03c4e-141">Para superfícies de MSAA (multiamostragem), as amostras de cada pixel são percorridas em ordem de índice de exemplo antes de passar para o próximo pixel.</span><span class="sxs-lookup"><span data-stu-id="03c4e-141">For multisample antialiasing (MSAA) surfaces, each pixel's samples are traversed in sample-index order before moving to the next pixel.</span></span> <span data-ttu-id="03c4e-142">Para blocos parcialmente preenchidos no lado direito (para uma superfície que tenha uma largura que não seja um múltiplo de largura de bloco em pixels), a densidade/distância para mover uma linha é o tamanho total em bytes do número de pixels que se ajustaria ao bloco se o bloco estivesse cheio.</span><span class="sxs-lookup"><span data-stu-id="03c4e-142">For tiles that are partially filled on the right side (for a surface that has a width not a multiple of tile width in pixels), the pitch/stride to move down a row is the full size in bytes of the number pixels that would fit across the tile if the tile was full.</span></span> <span data-ttu-id="03c4e-143">Portanto, pode haver uma lacuna entre cada linha de pixels na memória.</span><span class="sxs-lookup"><span data-stu-id="03c4e-143">So, there can be a gap between each row of pixels in memory.</span></span> <span data-ttu-id="03c4e-144">Para simplificar a especificação, mipmaps menor do que um bloco não é empacotado juntos no layout linear.</span><span class="sxs-lookup"><span data-stu-id="03c4e-144">For specification simplicity, mipmaps smaller than a tile are not packed together in the linear layout.</span></span> <span data-ttu-id="03c4e-145">Isso parece ser um desperdício de espaço de memória, mas, conforme mencionado, copie para MIPS que os pacotes de hardware juntos não são permitidos por meio de [**CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles) ou [**UpdateTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-updatetiles).</span><span class="sxs-lookup"><span data-stu-id="03c4e-145">This seems to be a waste of memory space, but as mentioned copying to mips that the hardware packs together is not allowed via [**CopyTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-copytiles) or [**UpdateTiles**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-updatetiles).</span></span> <span data-ttu-id="03c4e-146">O aplicativo só pode usar as \* APIs UpdateSubresource () ou CopySubresource \* () genéricas para copiar pequenas MIPS individualmente, embora no caso de CopySubresource \* (), que significa que a memória linear deve ser a mesma dimensão que o recurso de lado-a-CopySubresource \* () não pode copiar de um recurso de buffer para um Texture2D para a instância.</span><span class="sxs-lookup"><span data-stu-id="03c4e-146">The application can just use generic UpdateSubresource\*() or CopySubresource\*() APIs to copy small mips individually, though in the case of CopySubresource\*() that means the linear memory has to be the same dimension as the tiled resource - CopySubresource\*() can't copy from a buffer resource to a Texture2D for instance.</span></span>

<span data-ttu-id="03c4e-147">Se um swizzle de hardware padrão for definido, os sinalizadores poderão ser adicionados para indicar que os dados no buffer devem ser interpretados nesse formato (nenhum swizzle necessário na transferência), embora abordagens alternativas para carregar dados também possam fazer sentido nesse caso, como permitir que os aplicativos acessem diretamente a memória do pool de blocos.</span><span class="sxs-lookup"><span data-stu-id="03c4e-147">If a hardware standard swizzle is defined, flags could be added to indicate that the data in the buffer is to be interpreted in that format (no swizzle necessary on transfer), though alternative approaches to uploading data may also make sense in that case such as allowing applications direct access to tile pool memory.</span></span>

<span data-ttu-id="03c4e-148">Operações de cópia podem ser feitas em um contexto imediato ou adiado.</span><span class="sxs-lookup"><span data-stu-id="03c4e-148">Copying operations can be done on an immediate or deferred context.</span></span>

## <a name="resizing-tile-pool"></a><span data-ttu-id="03c4e-149">Redimensionando o pool de blocos</span><span class="sxs-lookup"><span data-stu-id="03c4e-149">Resizing tile pool</span></span>

<span data-ttu-id="03c4e-150">Para redimensionar um pool de blocos, use [**ID3D11DeviceContext2:: ResizeTilePool**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool).</span><span class="sxs-lookup"><span data-stu-id="03c4e-150">To resize a tile pool, use [**ID3D11DeviceContext2::ResizeTilePool**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool).</span></span>

## <a name="tiled-resource-barrier"></a><span data-ttu-id="03c4e-151">Barreira de recurso por lado</span><span class="sxs-lookup"><span data-stu-id="03c4e-151">Tiled resource barrier</span></span>

<span data-ttu-id="03c4e-152">Para especificar uma restrição de ordenação de acesso a dados entre vários recursos de lado, use [**ID3D11DeviceContext2:: TiledResourceBarrier**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier).</span><span class="sxs-lookup"><span data-stu-id="03c4e-152">To specify a data access ordering constraint between multiple tiled resources, use [**ID3D11DeviceContext2::TiledResourceBarrier**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier).</span></span>

## <a name="related-topics"></a><span data-ttu-id="03c4e-153">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="03c4e-153">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="03c4e-154">Recursos em ladrilho</span><span class="sxs-lookup"><span data-stu-id="03c4e-154">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 




