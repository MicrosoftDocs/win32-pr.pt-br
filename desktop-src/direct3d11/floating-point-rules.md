---
title: Regras de ponto flutuante (Direct3D 11)
description: O Direct3D 11 dá suporte a várias representações de ponto flutuante. Todos os cálculos de ponto flutuante operam em um subconjunto das regras de ponto flutuante de precisão única de 32 bits 754 IEEE definido.
ms.assetid: 33F21BD0-FDF8-4D35-95C0-0A3920814CB6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d83c87db0daa69c0393d0399ece5bdb6cf01d519
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104366127"
---
# <a name="floating-point-rules-direct3d-11"></a><span data-ttu-id="ad0bc-104">Regras de ponto flutuante (Direct3D 11)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-104">Floating-point rules (Direct3D 11)</span></span>

<span data-ttu-id="ad0bc-105">O Direct3D 11 dá suporte a várias representações de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-105">Direct3D 11 supports several floating-point representations.</span></span> <span data-ttu-id="ad0bc-106">Todos os cálculos de ponto flutuante operam em um subconjunto das regras de ponto flutuante de precisão única de 32 bits 754 IEEE definido.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-106">All floating-point computations operate under a defined subset of the IEEE 754 32-bit single precision floating-point rules.</span></span>

-   [<span data-ttu-id="ad0bc-107">regras de ponto flutuante de 32 bits</span><span class="sxs-lookup"><span data-stu-id="ad0bc-107">32-bit floating-point rules</span></span>](#32-bit-floating-point-rules)
    -   [<span data-ttu-id="ad0bc-108">Regras do IEEE-754 respeitadas</span><span class="sxs-lookup"><span data-stu-id="ad0bc-108">Honored IEEE-754 rules</span></span>](#honored-ieee-754-rules)
    -   [<span data-ttu-id="ad0bc-109">Desvios ou requisitos adicionais das regras IEEE-754</span><span class="sxs-lookup"><span data-stu-id="ad0bc-109">Deviations or additional requirements from IEEE-754 rules</span></span>](#deviations-or-additional-requirements-from-ieee-754-rules)
-   [<span data-ttu-id="ad0bc-110">regras de ponto flutuante de 64 bits (precisão dupla)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-110">64-bit (double precision) floating point rules</span></span>](#64-bit-double-precision-floating-point-rules)
-   [<span data-ttu-id="ad0bc-111">regras de ponto flutuante de 16 bits</span><span class="sxs-lookup"><span data-stu-id="ad0bc-111">16-bit floating-point rules</span></span>](#16-bit-floating-point-rules)
-   [<span data-ttu-id="ad0bc-112">regras de ponto flutuante de 11 e 10 bits</span><span class="sxs-lookup"><span data-stu-id="ad0bc-112">11-bit and 10-bit floating-point rules</span></span>](#11-bit-and-10-bit-floating-point-rules)
-   [<span data-ttu-id="ad0bc-113">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="ad0bc-113">Related topics</span></span>](#related-topics)

## <a name="32-bit-floating-point-rules"></a><span data-ttu-id="ad0bc-114">Regras de ponto flutuante de 32 bits</span><span class="sxs-lookup"><span data-stu-id="ad0bc-114">32-bit floating-point rules</span></span>

<span data-ttu-id="ad0bc-115">Existem dois conjuntos de regras: aquele em conformidade com IEEE-754, e aquele que desvia do padrão.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-115">There are two sets of rules: those that conform to IEEE-754, and those that deviate from the standard.</span></span>

### <a name="honored-ieee-754-rules"></a><span data-ttu-id="ad0bc-116">Regras de IEEE-754 respeitadas</span><span class="sxs-lookup"><span data-stu-id="ad0bc-116">Honored IEEE-754 rules</span></span>

<span data-ttu-id="ad0bc-117">Algumas dessas regras são uma única opção onde a IEEE-754 oferece opções.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-117">Some of these rules are a single option where IEEE-754 offers choices.</span></span>

-   <span data-ttu-id="ad0bc-118">Divisão por 0 produz + /-INF, exceto 0/0, o que resulta em NaN.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-118">Divide by 0 produces +/- INF, except 0/0 which results in NaN.</span></span>
-   <span data-ttu-id="ad0bc-119">o log de (+/-) 0 produz -INF.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-119">log of (+/-) 0 produces -INF.</span></span> <span data-ttu-id="ad0bc-120">o log de um valor negativo (diferente de -0) produz NaN.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-120">log of a negative value (other than -0) produces NaN.</span></span>
-   <span data-ttu-id="ad0bc-121">A raiz quadrada recíproca (rsq) ou raiz quadrada (sqrt) de um número negativo produz NaN.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-121">Reciprocal square root (rsq) or square root (sqrt) of a negative number produces NaN.</span></span> <span data-ttu-id="ad0bc-122">A exceção é - 0; sqrt(-0) produz - 0 e rsq(-0) produz -INF.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-122">The exception is -0; sqrt(-0) produces -0, and rsq(-0) produces -INF.</span></span>
-   <span data-ttu-id="ad0bc-123">INF - INF = NaN</span><span class="sxs-lookup"><span data-stu-id="ad0bc-123">INF - INF = NaN</span></span>
-   <span data-ttu-id="ad0bc-124">(+/-)INF / (+/-)INF = NaN</span><span class="sxs-lookup"><span data-stu-id="ad0bc-124">(+/-)INF / (+/-)INF = NaN</span></span>
-   <span data-ttu-id="ad0bc-125">(+/-) INF \* 0 = Nan</span><span class="sxs-lookup"><span data-stu-id="ad0bc-125">(+/-)INF \* 0 = NaN</span></span>
-   <span data-ttu-id="ad0bc-126">Qualquer valor NaN (qualquer OP) = NaN</span><span class="sxs-lookup"><span data-stu-id="ad0bc-126">NaN (any OP) any-value = NaN</span></span>
-   <span data-ttu-id="ad0bc-127">As comparações EQ, GT, GE, LT e LE, quando um ou ambos operandos for NaN retornará **FALSE**.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-127">The comparisons EQ, GT, GE, LT, and LE, when either or both operands is NaN returns **FALSE**.</span></span>
-   <span data-ttu-id="ad0bc-128">As comparações ignoram o sinal de 0 (sendo assim, +0 igual -0).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-128">Comparisons ignore the sign of 0 (so +0 equals -0).</span></span>
-   <span data-ttu-id="ad0bc-129">A comparação NE, quando um ou ambos operandos for NaN retornará **TRUE**.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-129">The comparison NE, when either or both operands is NaN returns **TRUE**.</span></span>
-   <span data-ttu-id="ad0bc-130">As comparações de qualquer valor não NaN com +/-INF retornam o resultado correto.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-130">Comparisons of any non-NaN value against +/- INF return the correct result.</span></span>

### <a name="deviations-or-additional-requirements-from-ieee-754-rules"></a><span data-ttu-id="ad0bc-131">Desvios ou requisitos adicionais de regras de IEEE-754</span><span class="sxs-lookup"><span data-stu-id="ad0bc-131">Deviations or additional requirements from IEEE-754 rules</span></span>

-   <span data-ttu-id="ad0bc-132">O IEEE-754 exibe que as operações de ponto flutuante produzam um resultado que seja o valor representável mais próximo a um resultado infinitamente preciso, conhecido como valor arredondado para o número par mais próximo.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-132">IEEE-754 requires floating-point operations to produce a result that is the nearest representable value to an infinitely-precise result, known as round-to-nearest-even.</span></span> <span data-ttu-id="ad0bc-133">O Direct3D 11 define o mesmo requisito: as operações de ponto flutuante de 32 bits produzem um resultado que está dentro de 0,5 unidade-último local (ULP) do resultado infinitamente preciso.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-133">Direct3D 11 defines the same requirement: 32-bit floating-point operations produce a result that is within 0.5 unit-last-place (ULP) of the infinitely-precise result.</span></span> <span data-ttu-id="ad0bc-134">Isso significa que, por exemplo, o hardware tem permissão para truncar os resultados para 32 bits em vez de executar de round para mais próximo – mesmo, pois isso resultaria em erro de no máximo 0,5 ULP. Essa regra se aplica somente a adição, subtração e multiplicação.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-134">This means that, for example, hardware is allowed to truncate results to 32-bit rather than perform round-to-nearest-even, as that would result in error of at most 0.5 ULP.This rule applies only to addition, subtraction, and multiplication.</span></span>
-   <span data-ttu-id="ad0bc-135">Não há nenhum suporte para exceções de ponto flutuante, bits de status ou interrupções.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-135">There is no support for floating-point exceptions, status bits or traps.</span></span>
-   <span data-ttu-id="ad0bc-136">Denorms são liberadas para zero com sinal preservado na entrada e saída de qualquer operação matemática de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-136">Denorms are flushed to sign-preserved zero on input and output of any floating-point mathematical operation.</span></span> <span data-ttu-id="ad0bc-137">Exceções são feitas para qualquer operação de movimentação de E/S ou dados que não manipula os dados.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-137">Exceptions are made for any I/O or data movement operation that doesn't manipulate the data.</span></span>
-   <span data-ttu-id="ad0bc-138">Os Estados que contêm valores de ponto flutuante, como visor MinDepth/MaxDepth, valores BorderColor, podem ser fornecidos como valores não normativos e podem ou não ser liberados antes de o hardware usá-los.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-138">States that contain floating-point values, such as Viewport MinDepth/MaxDepth, BorderColor values, may be provided as denorm values and may or may not be flushed before the hardware uses them.</span></span>
-   <span data-ttu-id="ad0bc-139">As operações de mínimo ou máximo liberam denorms para a comparação, mas o resultado pode ou não ser um denorm liberado.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-139">Min or max operations flush denorms for comparison, but the result may or may not be denorm flushed.</span></span>
-   <span data-ttu-id="ad0bc-140">A entrada NaN para uma operação sempre produz NaN na saída.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-140">NaN input to an operation always produces NaN on output.</span></span> <span data-ttu-id="ad0bc-141">Mas o padrão de bit exato do NaN não é necessário para manter o mesmo (a menos que a operação seja uma instrução de movimento bruta - que não altera os dados.)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-141">But the exact bit pattern of the NaN is not required to stay the same (unless the operation is a raw move instruction - which doesn't alter data.)</span></span>
-   <span data-ttu-id="ad0bc-142">As operações de mínimo ou máximo para as quais somente um operando é NaN retornam o outro operando como resultado (ao contrário das regras de comparação que vimos anteriormente).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-142">Min or max operations for which only one operand is NaN return the other operand as the result (contrary to comparison rules we looked at earlier).</span></span> <span data-ttu-id="ad0bc-143">Esta é uma regra IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-143">This is a IEEE 754R rule.</span></span>

    <span data-ttu-id="ad0bc-144">A especificação IEEE 754R para operações de mínimo e máximo de ponto flutuante diz que se uma das entradas para mínimo ou máximo for um valor de QNaN silencioso, o resultado da operação será outro parâmetro.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-144">The IEEE-754R specification for floating point min and max operations states that if one of the inputs to min or max is a quiet QNaN value, the result of the operation is the other parameter.</span></span> <span data-ttu-id="ad0bc-145">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-145">For example:</span></span>

    ```C++
    min(x,QNaN) == min(QNaN,x) == x (same for max)
    ```

    

    <span data-ttu-id="ad0bc-146">Uma revisão da especificação IEEE 754R adotou um comportamento diferente para mínimo e máximo quando uma entrada é um valor SNaN de "sinalização" em relação a um valor QNaN:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-146">A revision of the IEEE-754R specification adopted a different behavior for min and max when one input is a "signaling" SNaN value versus a QNaN value:</span></span>

    ```C++
    min(x,SNaN) == min(SNaN,x) == QNaN (same for max)
     
    ```

    

    <span data-ttu-id="ad0bc-147">Em geral, o Direct3D segue os padrões para aritmética: IEEE-754 e IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-147">Generally, Direct3D follows the standards for arithmetic: IEEE-754 and IEEE-754R.</span></span> <span data-ttu-id="ad0bc-148">Mas, nesse caso, temos um desvio.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-148">But in this case, we have a deviation.</span></span>

    <span data-ttu-id="ad0bc-149">As regras aritméticas no Direct3D 10 e posterior não fazem qualquer distinção entre valores NaN de sinalização e silenciosos (QNaN versus SNaN).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-149">The arithmetic rules in Direct3D 10 and later don't make any distinctions between quiet and signaling NaN values (QNaN versus SNaN).</span></span> <span data-ttu-id="ad0bc-150">Todos os valores NaN são tratados da mesma maneira.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-150">All NaN values are handled the same way.</span></span> <span data-ttu-id="ad0bc-151">No caso de mínimo e máximo, o comportamento do Direct3D para qualquer valor NaN é semelhante à forma que QNaN é manipulado na definição de IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-151">In the case of min and max, the Direct3D behavior for any NaN value is like how QNaN is handled in the IEEE-754R definition.</span></span> <span data-ttu-id="ad0bc-152">(Como complemento - se ambas as entradas forem NaN, qualquer valor NaN será retornado.)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-152">(For completeness - if both inputs are NaN, any NaN value is returned.)</span></span>

-   <span data-ttu-id="ad0bc-153">Outra regra IEEE 754R é que min(-0,+0) == min(+0,-0) == -0, and max(-0,+0) == max(+0,-0) == +0, o que respeita o sinal, diferente das regras de comparação para zero com sinal (como vimos anteriormente).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-153">Another IEEE 754R rule is that min(-0,+0) == min(+0,-0) == -0, and max(-0,+0) == max(+0,-0) == +0, which honors the sign, in contrast to the comparison rules for signed zero (as we saw earlier).</span></span> <span data-ttu-id="ad0bc-154">O Direct3D recomenda o comportamento do IEEE 754R aqui, mas não o impõe; é permitido que o resultado da comparação de zeros seja dependente da ordem dos parâmetros, usando uma comparação que ignora os sinais.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-154">Direct3D recommends the IEEE 754R behavior here, but doesn't enforce it; it is permissible for the result of comparing zeros to be dependent on the order of parameters, using a comparison that ignores the signs.</span></span>
-   <span data-ttu-id="ad0bc-155">x \* 1.0 f sempre resulta em x (exceto descarregamento desnormal).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-155">x\*1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="ad0bc-156">x/1.0f sempre resulta em x (exceto denorm liberados).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-156">x/1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="ad0bc-157">x +/- 0.0f sempre resulta em x (exceto denorm liberados).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-157">x +/- 0.0f always results in x (except denorm flushed).</span></span> <span data-ttu-id="ad0bc-158">Mas -0 + 0 = +0.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-158">But -0 + 0 = +0.</span></span>
-   <span data-ttu-id="ad0bc-159">As operações fundidas (como mad, dp3) produzem resultados que não são menos precisos do que a pior ordem serial possível da avaliação da expansão não fundida da operação.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-159">Fused operations (such as mad, dp3) produce results that are no less accurate than the worst possible serial ordering of evaluation of the unfused expansion of the operation.</span></span> <span data-ttu-id="ad0bc-160">A definição de pior ordem possível, para fins de tolerância, não é uma definição fixa para uma determinada operação fundida; depende dos valores específicos das entradas.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-160">The definition of the worst possible ordering, for the purpose of tolerance, is not a fixed definition for a given fused operation; it depends on the particular values of the inputs.</span></span> <span data-ttu-id="ad0bc-161">As etapas individuais na expansão não fundida têm tolerância de 1 ULP (ou para qualquer instrução que o Direct3D chamar com uma tolerância lax maior que 1 ULP, mais a tolerância lax será permitida).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-161">The individual steps in the unfused expansion are each allowed 1 ULP tolerance (or for any instructions Direct3D calls out with a more lax tolerance than 1 ULP, the more lax tolerance is allowed).</span></span>
-   <span data-ttu-id="ad0bc-162">As operações fundidas cumprem as mesmas regras NaN que as operações não fundidas.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-162">Fused operations adhere to the same NaN rules as non-fused operations.</span></span>
-   <span data-ttu-id="ad0bc-163">sqrt e rcp têm tolerância de 1 ULP.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-163">sqrt and rcp have 1 ULP tolerance.</span></span> <span data-ttu-id="ad0bc-164">As instruções de raiz quadrada recíproca e recíproca de sombreador, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) e [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), têm seu próprios requisitos separados de precisão relaxada.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-164">The shader reciprocal and reciprocal square-root instructions, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) and [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), have their own separate relaxed precision requirement.</span></span>
-   <span data-ttu-id="ad0bc-165">Multiplique e divide cada operação no nível de precisão de ponto flutuante de 32 bits (precisão de até 0,5 ULP para multiplicação e 1,0 ULP para recíproca).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-165">Multiply and divide each operate at the 32-bit floating-point precision level (accuracy to 0.5 ULP for multiply, 1.0 ULP for reciprocal).</span></span> <span data-ttu-id="ad0bc-166">Se x/y é implementado diretamente, os resultados devem ter precisão maior ou igual à de um método de duas etapas.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-166">If x/y is implemented directly, results must be of greater or equal accuracy than a two-step method.</span></span>

## <a name="64-bit-double-precision-floating-point-rules"></a><span data-ttu-id="ad0bc-167">Regras de ponto flutuante de 64 bits (precisão dupla)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-167">64-bit (double precision) floating point rules</span></span>

<span data-ttu-id="ad0bc-168">Drivers de hardware e exibição opcionalmente suportam ponto flutuante de precisão dupla.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-168">Hardware and display drivers optionally support double-precision floating-point.</span></span> <span data-ttu-id="ad0bc-169">Para indicar suporte, quando você chama [**ID3D11Device:: CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) com [**\_ \_ duplos de recurso D3D11**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), o driver define **DoublePrecisionFloatShaderOps** de dados de [**recurso de D3D11 \_ \_ \_ duplo**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) para verdadeiro.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-169">To indicate support, when you call [**ID3D11Device::CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) with [**D3D11\_FEATURE\_DOUBLES**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), the driver sets **DoublePrecisionFloatShaderOps** of [**D3D11\_FEATURE\_DATA\_DOUBLES**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) to TRUE.</span></span> <span data-ttu-id="ad0bc-170">Em seguida, o driver e o hardware devem dar suporte a todas as instruções de ponto flutuante de precisão dupla.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-170">The driver and hardware must then support all double-precision floating-point instructions.</span></span>

<span data-ttu-id="ad0bc-171">As instruções de precisão dupla seguem os requisitos de comportamento IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-171">Double-precision instructions follow IEEE 754R behavior requirements.</span></span>

<span data-ttu-id="ad0bc-172">O suporte à geração de valores desnormalizados é necessário para os dados de precisão dupla (nenhum comportamento flush-para-zero).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-172">Support for generation of denormalized values is required for double-precision data (no flush-to-zero behavior).</span></span> <span data-ttu-id="ad0bc-173">Da mesma forma, as instruções não fazem a leitura de dados desordenados como um zero com sinal, elas respeitam o valor denorm.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-173">Likewise, instructions don't read denormalized data as a signed zero, they honor the denorm value.</span></span>

## <a name="16-bit-floating-point-rules"></a><span data-ttu-id="ad0bc-174">Regras de ponto flutuante de 16 bits</span><span class="sxs-lookup"><span data-stu-id="ad0bc-174">16-bit floating-point rules</span></span>

<span data-ttu-id="ad0bc-175">O Direct3D 11 também dá suporte a representações de 16 bits de números de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-175">Direct3D 11 also supports 16-bit representations of floating-point numbers.</span></span>

<span data-ttu-id="ad0bc-176">Formato:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-176">Format:</span></span>

-   <span data-ttu-id="ad0bc-177">Sinal de 1 bit (s) na posição MSB bit</span><span class="sxs-lookup"><span data-stu-id="ad0bc-177">1 sign bit (s)in the MSB bit position</span></span>
-   <span data-ttu-id="ad0bc-178">5 bits de expoente ajustado (e)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-178">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="ad0bc-179">10 bits de fração (f), com um bit oculto adicional</span><span class="sxs-lookup"><span data-stu-id="ad0bc-179">10 bits of fraction (f), with an additional hidden bit</span></span>

<span data-ttu-id="ad0bc-180">Um valor de float16 (v) segue estas regras:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-180">A float16 value (v) follows these rules:</span></span>

-   <span data-ttu-id="ad0bc-181">Se e == 31 e f != 0, então v é NaN independente de s</span><span class="sxs-lookup"><span data-stu-id="ad0bc-181">if e == 31 and f != 0, then v is NaN regardless of s</span></span>
-   <span data-ttu-id="ad0bc-182">se e = = 31 e f = = 0, então v = (-1) s \* Infinity (infinito assinado)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-182">if e == 31 and f == 0, then v = (-1)s\*infinity (signed infinity)</span></span>
-   <span data-ttu-id="ad0bc-183">se e estiver entre 0 e 31, v = (-1) s \* 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-183">if e is between 0 and 31, then v = (-1)s\*2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="ad0bc-184">se e = = 0 e f! = 0, v = (-1) s \* 2 (e-14) \* (0. f) (números desnormalizados)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-184">if e == 0 and f != 0, then v = (-1)s\*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="ad0bc-185">se e = = 0 e f = = 0, então v = (-1) s \* 0 (assinado zero)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-185">if e == 0 and f == 0, then v = (-1)s\*0 (signed zero)</span></span>

<span data-ttu-id="ad0bc-186">As regras de ponto flutuante de 32 bits também esperam por números de ponto flutuante de 16 bits, ajustados para o layout de bit descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-186">32-bit floating-point rules also hold for 16-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="ad0bc-187">Algumas exceções:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-187">Exceptions to this include:</span></span>

-   <span data-ttu-id="ad0bc-188">Precisão: as operações não fundidas em números de ponto flutuante de 16 bits produzem um resultado que é o valor representável mais próximo de um resultado infinitamente preciso (arredondado para o número par mais próximo, de acordo com IEEE-754, aplicado aos valores de 16 bits).</span><span class="sxs-lookup"><span data-stu-id="ad0bc-188">Precision: Unfused operations on 16-bit floating-point numbers produce a result that is the nearest representable value to an infinitely-precise result (round to nearest even, per IEEE-754, applied to 16-bit values).</span></span> <span data-ttu-id="ad0bc-189">As regras de ponto flutuante de 32 bits aderem à tolerância de 1 ULP, as regras de ponto flutuante de 16 bits aderem a 0,5 ULP para as operações não fundidas e 0,6 ULP para operações fundidas.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-189">32-bit floating-point rules adhere to 1 ULP tolerance, 16-bit floating-point rules adhere to 0.5 ULP for unfused operations, and 0.6 ULP for fused operations.</span></span>
-   <span data-ttu-id="ad0bc-190">Os números de ponto flutuante de 16 bits preservam denorms.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-190">16-bit floating-point numbers preserve denorms.</span></span>

## <a name="11-bit-and-10-bit-floating-point-rules"></a><span data-ttu-id="ad0bc-191">Regras de ponto flutuante de 11 e 10 bits</span><span class="sxs-lookup"><span data-stu-id="ad0bc-191">11-bit and 10-bit floating-point rules</span></span>

<span data-ttu-id="ad0bc-192">O Direct3D 11 também dá suporte a formatos de ponto flutuante de 11 e 10 bits.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-192">Direct3D 11 also supports 11-bit and 10-bit floating-point formats.</span></span>

<span data-ttu-id="ad0bc-193">Formato:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-193">Format:</span></span>

-   <span data-ttu-id="ad0bc-194">Nenhum bit de sinal</span><span class="sxs-lookup"><span data-stu-id="ad0bc-194">No sign bit</span></span>
-   <span data-ttu-id="ad0bc-195">5 bits de expoente ajustado (e)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-195">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="ad0bc-196">6 bits de fração (f) para um formato de 11 bits, 5 bits de fração (f) para um formato de 10 bits, com um bit oculto adicional em ambos os casos.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-196">6 bits of fraction (f) for an 11-bit format, 5 bits of fraction (f) for a 10-bit format, with an additional hidden bit in either case.</span></span>

<span data-ttu-id="ad0bc-197">Um valor de float11/float10 (v) segue as regras a seguir:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-197">A float11/float10 value (v) follows the following rules:</span></span>

-   <span data-ttu-id="ad0bc-198">se e == 31 and f != 0, então v é NaN</span><span class="sxs-lookup"><span data-stu-id="ad0bc-198">if e == 31 and f != 0, then v is NaN</span></span>
-   <span data-ttu-id="ad0bc-199">se e == 31 e f == 0, então v = +infinito</span><span class="sxs-lookup"><span data-stu-id="ad0bc-199">if e == 31 and f == 0, then v = +infinity</span></span>
-   <span data-ttu-id="ad0bc-200">se e estiver entre 0 e 31, v = 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-200">if e is between 0 and 31, then v = 2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="ad0bc-201">se e = = 0 e f! = 0, v = \* 2 (e-14) \* (0. f) (números desnormalizados)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-201">if e == 0 and f != 0, then v = \*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="ad0bc-202">se e == 0 e f == 0, então v = 0 (zero)</span><span class="sxs-lookup"><span data-stu-id="ad0bc-202">if e == 0 and f == 0, then v = 0 (zero)</span></span>

<span data-ttu-id="ad0bc-203">As regras de ponto flutuante de 32 bits também esperam por números de ponto flutuante de 11 e 10 bits, ajustados para o layout de bit descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-203">32-bit floating-point rules also hold for 11-bit and 10-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="ad0bc-204">As exceções incluem:</span><span class="sxs-lookup"><span data-stu-id="ad0bc-204">Exceptions include:</span></span>

-   <span data-ttu-id="ad0bc-205">Precisão: as regras de ponto flutuante de 32 bits aderem a 0,5 ULP.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-205">Precision: 32-bit floating-point rules adhere to 0.5 ULP.</span></span>
-   <span data-ttu-id="ad0bc-206">Os números de ponto flutuante de 10/11 bits preservam denorms.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-206">10/11-bit floating-point numbers preserve denorms.</span></span>
-   <span data-ttu-id="ad0bc-207">Qualquer operação que poder resultar em um número menor que zero é vinculada com zero.</span><span class="sxs-lookup"><span data-stu-id="ad0bc-207">Any operation that would result in a number less than zero is clamped to zero.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ad0bc-208">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="ad0bc-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ad0bc-209">Recursos</span><span class="sxs-lookup"><span data-stu-id="ad0bc-209">Resources</span></span>](overviews-direct3d-11-resources.md)
</dt> <dt>

[<span data-ttu-id="ad0bc-210">Texturas</span><span class="sxs-lookup"><span data-stu-id="ad0bc-210">Textures</span></span>](overviews-direct3d-11-resources-textures.md)
</dt> </dl>

 

 