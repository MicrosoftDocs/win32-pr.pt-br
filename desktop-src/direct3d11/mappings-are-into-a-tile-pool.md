---
title: Mapeamentos estão em um pool de blocos
description: Quando um recurso é criado com o \_ sinalizador de \_ lado diverso do recurso D3D11 \_ , os blocos que compõem o recurso são apontados em locais em um pool de peças.
ms.assetid: 1DBE23B2-A1E6-4491-9B74-4E92508A68FC
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1537113d6685e39cab94445c8d3f16d406638820
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104988655"
---
# <a name="mappings-are-into-a-tile-pool"></a><span data-ttu-id="2510a-103">Mapeamentos estão em um pool de blocos</span><span class="sxs-lookup"><span data-stu-id="2510a-103">Mappings are into a tile pool</span></span>

<span data-ttu-id="2510a-104">Quando um recurso é criado com o sinalizador de [**\_ \_ \_ lado diverso do recurso D3D11**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_resource_misc_flag) , os blocos que compõem o recurso são apontados em locais em um pool de peças.</span><span class="sxs-lookup"><span data-stu-id="2510a-104">When a resource is created with the [**D3D11\_RESOURCE\_MISC\_TILED**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_resource_misc_flag) flag, the tiles that make up the resource come from pointing at locations in a tile pool.</span></span> <span data-ttu-id="2510a-105">Um pool de blocos é um pool de memória (sustentado por uma ou mais alocações nos bastidores - nunca vistos pelo app).</span><span class="sxs-lookup"><span data-stu-id="2510a-105">A tile pool is a pool of memory (backed by one or more allocations behind the scenes - unseen by the application).</span></span> <span data-ttu-id="2510a-106">O sistema operacional e o driver de vídeo gerenciam esse pool de memória, e o volume da memória é entendido facilmente por um app.</span><span class="sxs-lookup"><span data-stu-id="2510a-106">The operating system and display driver manage this pool of memory, and the memory footprint is easily understood by an application.</span></span> <span data-ttu-id="2510a-107">Os recursos de blocos gráficos mapeiam as regiões de 64 KB apontando para locais em um pool de peças.</span><span class="sxs-lookup"><span data-stu-id="2510a-107">Tiled resources map 64KB regions by pointing to locations in a tile pool.</span></span> <span data-ttu-id="2510a-108">Um resultado dessa configuração é permitir que vários recursos compartilhem e reutilizem os mesmos blocos, e também que os mesmos blocos sejam reutilizados em locais diferentes em um recurso, se desejado.</span><span class="sxs-lookup"><span data-stu-id="2510a-108">One fallout of this setup is it allows multiple resources to share and reuse the same tiles, and also for the same tiles to be reused at different locations within a resource if desired.</span></span>

<span data-ttu-id="2510a-109">O custo da flexibilidade de preenchimento dos blocos de um recurso de um pool de blocos é que ele precisa definir e manter o mapeamento dos blocos no pool que representam aqueles necessários para o recurso.</span><span class="sxs-lookup"><span data-stu-id="2510a-109">The cost for the flexibility of populating the tiles for a resource out of a tile pool is that the resource has to do the work of defining and maintaining the mapping of which tiles in the tile pool represent the tiles needed for the resource.</span></span> <span data-ttu-id="2510a-110">Os mapeamentos de blocos podem ser alterados.</span><span class="sxs-lookup"><span data-stu-id="2510a-110">Tile mappings can be changed.</span></span> <span data-ttu-id="2510a-111">Além disso, nem todos os blocos em um recurso precisam ser mapeadas simultaneamente; um recurso pode ter mapeamentos **NULOS**.</span><span class="sxs-lookup"><span data-stu-id="2510a-111">Also, not all tiles in a resource need to be mapped at a time; a resource can have **NULL** mappings.</span></span> <span data-ttu-id="2510a-112">Um mapeamento **NULO** define um bloco como não disponível do ponto de vista do recurso que o acessa.</span><span class="sxs-lookup"><span data-stu-id="2510a-112">A **NULL** mapping defines a tile as not being available from the point of view of the resource accessing it.</span></span>

<span data-ttu-id="2510a-113">Vários pools de blocos podem ser criados, e qualquer número de recursos de blocos pode ser mapeado para um determinado pool de peças ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="2510a-113">Multiple tile pools can be created, and any number of tiled resources can map into any given tile pool at the same time.</span></span> <span data-ttu-id="2510a-114">Os pools de bloco também podem ser aumentados ou reduzidos.</span><span class="sxs-lookup"><span data-stu-id="2510a-114">Tile pools can also be grown or shrunk.</span></span> <span data-ttu-id="2510a-115">Para obter mais informações, consulte [Redimensionamento do pool de blocos](tile-pool-resizing.md).</span><span class="sxs-lookup"><span data-stu-id="2510a-115">For more info, see [Tile pool resizing](tile-pool-resizing.md).</span></span> <span data-ttu-id="2510a-116">Uma restrição que existe para simplificar a implementação do driver de vídeo e do tempo de execução é que um determinado recurso de mosaico só pode ter mapeamentos em no máximo um pool de peças por vez (em vez de ter mapeamento simultâneo para vários pools de blocos).</span><span class="sxs-lookup"><span data-stu-id="2510a-116">One constraint that exists to simplify display driver and runtime implementation is that a given tiled resource can only have mappings into at most one tile pool at a time (as opposed to having simultaneous mapping to multiple tile pools).</span></span>

<span data-ttu-id="2510a-117">A quantidade de armazenamento que está associada a um recurso de mosaico (ou seja, memória de pool de blocos independente) é basicamente proporcional ao número de blocos realmente mapeados para o pool em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="2510a-117">The amount of storage that is associated with a tiled resource itself (that is, independent tile-pool memory) is roughly proportional to the number of tiles actually mapped to the pool at any given time.</span></span> <span data-ttu-id="2510a-118">No hardware, esse fato se resume ao dimensionamento do volume de memória para armazenamento da tabela de página aproximadamente com a quantidade de blocos mapeados (por exemplo, usando um esquema de tabela de vários níveis de página conforme apropriado).</span><span class="sxs-lookup"><span data-stu-id="2510a-118">In hardware, this fact boils down to scaling the memory footprint for page table storage roughly with the amount of tiles that are mapped (for example, using a multilevel page table scheme as appropriate).</span></span>

<span data-ttu-id="2510a-119">O pool de blocos pode ser pensado como uma abstração de software que permite aos apps Direct3D estarem efetivamente prontos para programar as tabelas de página na unidade de processamento gráfico (GPU) sem precisar saber os detalhes de implementação de nível baixo (ou processar endereços de ponteiro diretamente).</span><span class="sxs-lookup"><span data-stu-id="2510a-119">The tile pool can be thought of as an entirely software abstraction that enables Direct3D applications to effectively be able to program the page tables on the graphics processing unit (GPU) without having to know the low level implementation details (or deal with pointer addresses directly).</span></span> <span data-ttu-id="2510a-120">Os pools de blocos não se aplicam a quaisquer níveis adicionais de indireção no hardware.</span><span class="sxs-lookup"><span data-stu-id="2510a-120">Tile pools don't apply any additional levels of indirection in hardware.</span></span> <span data-ttu-id="2510a-121">As otimizações de uma única tabela de página de nível único usando construções como diretórios de página são independentes do conceito de pool de blocos.</span><span class="sxs-lookup"><span data-stu-id="2510a-121">Optimizations of a single level page table using constructs like page directories are independent of the tile pool concept.</span></span>

<span data-ttu-id="2510a-122">Vamos explorar qual armazenamento a tabela de página pode exigir na pior das hipóteses (embora na prática as implementações exigem apenas armazenamento aproximadamente proporcional ao que é mapeado).</span><span class="sxs-lookup"><span data-stu-id="2510a-122">Let us explore what storage the page table itself could require in the worst case (though in practice implementations only require storage roughly proportional to what is mapped).</span></span>

<span data-ttu-id="2510a-123">Considere que cada entrada da tabela de página é de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="2510a-123">Suppose each page table entry is 64 bits.</span></span>

<span data-ttu-id="2510a-124">Para o pior caso, o tamanho da tabela de página de paginação é atingido para uma única superfície, dado os limites de recursos no Direct3D 11, suponha que um recurso de mosaico seja criado com um formato de 128 bits por elemento (por exemplo, um float de RGBA), para que um bloco de 64 KB contenha apenas 4096 pixels.</span><span class="sxs-lookup"><span data-stu-id="2510a-124">For the worst-case page table size hit for a single surface, given the resource limits in Direct3D 11, suppose a tiled resource is created with a 128 bit-per-element format (for example, a RGBA float), so a 64KB tile contains only 4096 pixels.</span></span> <span data-ttu-id="2510a-125">O tamanho máximo de [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray) com suporte de 16384 \* 16384 \* 2048 (mas com apenas um único mipmap) EXIGIRIA cerca de 1 GB de armazenamento na tabela de página, se totalmente populado (não incluindo mipmaps) usando entradas da tabela de bits 64.</span><span class="sxs-lookup"><span data-stu-id="2510a-125">The maximum supported [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray) size of 16384\*16384\*2048 (but with only a single mipmap) would require about 1GB of storage in the page table if fully populated (not including mipmaps) using 64 bit table entries.</span></span> <span data-ttu-id="2510a-126">A adição de mipmaps implica no crescimento do armazenamento de tabela de página totalmente mapeada (pior hipótese) em aproximadamente um terço, cerca de 1,3 GB.</span><span class="sxs-lookup"><span data-stu-id="2510a-126">Adding mipmaps would grow the fully-mapped (worst case) page table storage by about a third, to about 1.3GB.</span></span>

<span data-ttu-id="2510a-127">Nesse caso, seria equivalente a fornecer acesso a aproximadamente 10,6 terabytes de memória endereçável.</span><span class="sxs-lookup"><span data-stu-id="2510a-127">This case would give access to about 10.6 terabytes of addressable memory.</span></span> <span data-ttu-id="2510a-128">Pode haver um limite na quantidade de memória endereçável. Porém, isso reduziria esses valores, talvez próximos do intervalo de terabytes.</span><span class="sxs-lookup"><span data-stu-id="2510a-128">There might be a limit on the amount of addressable memory however, which would reduce these amounts, perhaps to around the terabyte range.</span></span>

<span data-ttu-id="2510a-129">Outro caso a ser levado em consideração é um único recurso de lado do [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) de 16384 \* 16384 com um formato com 32 bits por elemento, incluindo mipmaps.</span><span class="sxs-lookup"><span data-stu-id="2510a-129">Another case to consider is a single [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) tiled resource of 16384\*16384 with a 32 bit-per-element format, including mipmaps.</span></span> <span data-ttu-id="2510a-130">O espaço necessário em uma tabela de página totalmente preenchida é de aproximadamente 170 KB com entradas de tabela de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="2510a-130">The space needed in a fully populated page table would be roughly 170KB with 64 bit table entries.</span></span>

<span data-ttu-id="2510a-131">Por fim, considere um exemplo usando um formato BC, diga BC7 com 128 bits por bloco de 4 x 4 pixels.</span><span class="sxs-lookup"><span data-stu-id="2510a-131">Finally, consider an example using a BC format, say BC7 with 128 bits per tile of 4x4 pixels.</span></span> <span data-ttu-id="2510a-132">Isso equivale a um byte por pixel.</span><span class="sxs-lookup"><span data-stu-id="2510a-132">That is one byte per pixel.</span></span> <span data-ttu-id="2510a-133">Um [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray) de 16384 \* 16384 \* 2048, incluindo MIPMAPS exigiria aproximadamente 85MB para popular completamente essa memória em uma tabela de página.</span><span class="sxs-lookup"><span data-stu-id="2510a-133">A [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray) of 16384\*16384\*2048 including mipmaps would require roughly 85MB to fully populate this memory in a page table.</span></span> <span data-ttu-id="2510a-134">Isso não é errado, Considerando que isso permite que um recurso de lado-a-intervalo abranja 550 gigapixels (512 GB de memória nesse caso).</span><span class="sxs-lookup"><span data-stu-id="2510a-134">That is not bad considering this allows one tiled resource to span 550 gigapixels (512 GB of memory in this case).</span></span>

<span data-ttu-id="2510a-135">Na prática, essa quantidade de mapeamentos totais não seria definido considerando que a quantidade de memória física disponível não permite que essa quantidade seja mapeada e referenciada ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="2510a-135">In practice, nowhere near these full mappings would be defined given that the amount of physical memory available wouldn't allow anywhere near that much to be mapped and referenced at a time.</span></span> <span data-ttu-id="2510a-136">No entanto, com um pool de blocos, os apps podem optar por reutilizar blocos (um exemplo simples, reutilizar um bloco colorido "preto" para grandes regiões de preto em uma imagem), usando efetivamente o pool de blocos (ou seja, os mapeamentos de tabela de página) como uma ferramenta de compactação de memória.</span><span class="sxs-lookup"><span data-stu-id="2510a-136">But with a tile pool, applications could choose to reuse tiles (as a simple example, reusing a "black" colored tile for large black regions in an image) - effectively using the tile pool (that is, page table mappings) as a tool for memory compression.</span></span>

<span data-ttu-id="2510a-137">O conteúdo inicial da tabela da página é **NULO** para todas as entradas.</span><span class="sxs-lookup"><span data-stu-id="2510a-137">The initial contents of the page table are **NULL** for all entries.</span></span> <span data-ttu-id="2510a-138">Os apps também não podem passar dados iniciais do conteúdo da memória da superfície, pois já começa sem suporte da memória.</span><span class="sxs-lookup"><span data-stu-id="2510a-138">Applications also can't pass initial data for the memory contents of the surface since it starts off with no memory backing.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="2510a-139">Nesta seção</span><span class="sxs-lookup"><span data-stu-id="2510a-139">In this section</span></span>



| <span data-ttu-id="2510a-140">Tópico</span><span class="sxs-lookup"><span data-stu-id="2510a-140">Topic</span></span>                                                                                                   | <span data-ttu-id="2510a-141">Descrição</span><span class="sxs-lookup"><span data-stu-id="2510a-141">Description</span></span>                                                                                                                                                                                                                                                                                                                                                                |
|---------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="2510a-142">Criação de pool de blocos</span><span class="sxs-lookup"><span data-stu-id="2510a-142">Tile pool creation</span></span>](tile-pool-creation.md)<br/>                                                 | <span data-ttu-id="2510a-143">Um pool de blocos é criado por meio da API [**ID3D11Device:: CreateBuffer**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-createbuffer) passando o sinalizador de [**\_ \_ \_ \_ pool de blocos diversos do recurso D3D11**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_resource_misc_flag) no membro **MiscFlags** da estrutura [**\_ \_ Desc do buffer D3D11**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_buffer_desc) para a qual o parâmetro *pDesc* aponta.</span><span class="sxs-lookup"><span data-stu-id="2510a-143">A tile pool is created via the [**ID3D11Device::CreateBuffer**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-createbuffer) API by passing the [**D3D11\_RESOURCE\_MISC\_TILE\_POOL**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_resource_misc_flag) flag in the **MiscFlags** member of the [**D3D11\_BUFFER\_DESC**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_buffer_desc) structure that the *pDesc* parameter points to.</span></span> <br/> |
| [<span data-ttu-id="2510a-144">Redimensionamento de pool de blocos</span><span class="sxs-lookup"><span data-stu-id="2510a-144">Tile pool resizing</span></span>](tile-pool-resizing.md)<br/>                                                 | <span data-ttu-id="2510a-145">Use a API [**ID3D11DeviceContext2:: ResizeTilePool**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool) para aumentar um pool de blocos se o aplicativo precisar de mais um conjunto de trabalho para o mapeamento de recursos lado-a-quadro ou para reduzir se for necessário menos espaço.</span><span class="sxs-lookup"><span data-stu-id="2510a-145">Use the [**ID3D11DeviceContext2::ResizeTilePool**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool) API to grow a tile pool if the application needs more working set for the tiled resources mapping into it or to shrink if less space is needed.</span></span> <br/>                                                                                                                    |
| [<span data-ttu-id="2510a-146">Controle de risco versus recursos de pool de blocos</span><span class="sxs-lookup"><span data-stu-id="2510a-146">Hazard tracking versus tile pool resources</span></span>](hazard-tracking-versus-tile-pool-resources.md)<br/> | <span data-ttu-id="2510a-147">Para recursos sem blocos gráficos, o Direct3D pode impedir determinadas condições de risco durante a renderização, mas como o controle de riscos seria em um nível de bloco para recursos lado-a-quadrado, controlar condições de risco durante o processamento de recursos ao lado pode ser muito caro.</span><span class="sxs-lookup"><span data-stu-id="2510a-147">For non-tiled resources, Direct3D can prevent certain hazard conditions during rendering, but because hazard tracking would be at a tile level for tiled resources, tracking hazard conditions during rendering of tiled resources might be too expensive.</span></span> <br/>                                                                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="2510a-148">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="2510a-148">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="2510a-149">Criando recursos em ladrilhos</span><span class="sxs-lookup"><span data-stu-id="2510a-149">Creating tiled resources</span></span>](creating-tiled-resources.md)
</dt> </dl>

 

