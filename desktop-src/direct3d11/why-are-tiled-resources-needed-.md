---
title: Por que os recursos do lado do xadrez são necessários
description: Os recursos do lado do ladrilho são necessários, portanto, menos memória de GPU (unidade de processamento gráfico) é desperdiçada armazenando regiões de superfícies que o aplicativo sabe que não será acessado, e o hardware pode entender como filtrar por blocos adjacentes.
ms.assetid: E2179D65-56D3-481F-A5F3-B9C45A11A179
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d42ccccf66a73d224d8bab9a9d10c87cc330be43
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104967176"
---
# <a name="why-are-tiled-resources-needed"></a><span data-ttu-id="ec671-103">Por que os recursos do lado do xadrez são necessários?</span><span class="sxs-lookup"><span data-stu-id="ec671-103">Why are tiled resources needed?</span></span>

<span data-ttu-id="ec671-104">Os recursos do lado do ladrilho são necessários, portanto, menos memória de GPU (unidade de processamento gráfico) é desperdiçada armazenando regiões de superfícies que o aplicativo sabe que não será acessado, e o hardware pode entender como filtrar por blocos adjacentes.</span><span class="sxs-lookup"><span data-stu-id="ec671-104">Tiled resources are needed so less graphics processing unit (GPU) memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles.</span></span>

<span data-ttu-id="ec671-105">Em um sistema de elementos gráficos (ou seja, o sistema operacional, o driver de vídeo e o hardware de gráficos) sem suporte a recursos por lado, o sistema de gráficos gerencia todas as alocações de memória do Direct3D na granularidade do subrecurso.</span><span class="sxs-lookup"><span data-stu-id="ec671-105">In a graphics system (that is, the operating system, display driver, and graphics hardware) without tiled resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span> <span data-ttu-id="ec671-106">Para um [buffer](overviews-direct3d-11-resources-buffers.md), todo o buffer é o subrecurso.</span><span class="sxs-lookup"><span data-stu-id="ec671-106">For a [Buffer](overviews-direct3d-11-resources-buffers.md), the entire Buffer is the subresource.</span></span> <span data-ttu-id="ec671-107">Para uma [textura](overviews-direct3d-11-resources-textures.md) (por exemplo, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), cada nível de MIP é um subrecurso; para uma matriz de textura (por exemplo, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), cada nível de MIP em uma determinada fatia de matriz é um subrecurso.</span><span class="sxs-lookup"><span data-stu-id="ec671-107">For a [Texture](overviews-direct3d-11-resources-textures.md) (for example, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), each mip level is a subresource; for a texture array (for example, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="ec671-108">O sistema gráfico expõe apenas a capacidade de gerenciar o mapeamento de alocações nessa granularidade de sub-recursos.</span><span class="sxs-lookup"><span data-stu-id="ec671-108">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="ec671-109">No contexto de recursos em ladrilho, "Mapping" refere-se à disponibilização dos dados para a GPU.</span><span class="sxs-lookup"><span data-stu-id="ec671-109">In the context of tiled resources, "mapping" refers to making data visible to the GPU.</span></span>

<span data-ttu-id="ec671-110">Suponhamos que um aplicativo saiba que uma operação de renderização específica precise acessar apenas uma pequena parte de uma cadeia de mipmaps de imagem (talvez nem mesmo a área completa de um determinado mipmap).</span><span class="sxs-lookup"><span data-stu-id="ec671-110">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="ec671-111">O ideal seria que o aplicativo pudesse informar o sistema gráfico sobre essa necessidade.</span><span class="sxs-lookup"><span data-stu-id="ec671-111">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="ec671-112">Em seguida, o sistema gráfico se preocuparia apenas em garantir que a memória necessária fosse mapeada para a GPU sem a paginação de muita memória.</span><span class="sxs-lookup"><span data-stu-id="ec671-112">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span> <span data-ttu-id="ec671-113">Na realidade, sem suporte a recursos lado a lado, o sistema de gráficos só pode ser informado sobre a memória que precisa ser mapeada na GPU na granularidade do subrecurso (por exemplo, um intervalo de níveis de mipmap completos que poderiam ser acessados).</span><span class="sxs-lookup"><span data-stu-id="ec671-113">In reality, without tiled resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="ec671-114">Também não há falha de demanda no sistema gráfico. Portanto, provavelmente deve ser usada muita memória da GPU em excesso para mapear sub-recursos completos antes de um comando de renderização que referencie qualquer parte da memória seja executado.</span><span class="sxs-lookup"><span data-stu-id="ec671-114">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="ec671-115">Trata-se de apenas um problema que torna difícil o uso de alocações de memória grandes no Direct3D sem suporte a recursos por lado.</span><span class="sxs-lookup"><span data-stu-id="ec671-115">This is just one issue that makes the use of large memory allocations difficult in Direct3D without tiled resource support.</span></span>

<span data-ttu-id="ec671-116">O Direct3D 11 dá suporte a superfícies de [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) com até 16384 pixels em um determinado lado.</span><span class="sxs-lookup"><span data-stu-id="ec671-116">Direct3D 11 supports [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="ec671-117">Uma imagem de 16384 de largura por 16384 de altura e 4 bytes por pixel consumiria 1 GB de memória de vídeo (e adicionar mipmaps duplicaria essa quantidade).</span><span class="sxs-lookup"><span data-stu-id="ec671-117">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="ec671-118">Na prática, raramente seria necessário referenciar o volume todo de 1 GB em uma única operação de renderização.</span><span class="sxs-lookup"><span data-stu-id="ec671-118">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="ec671-119">Alguns desenvolvedores de jogos modelam superfícies de terreno grandes de até 128 K por 128 K.</span><span class="sxs-lookup"><span data-stu-id="ec671-119">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="ec671-120">Eles fazem isso funcionar nas GPUs existentes dividindo a superfície em blocos que sejam pequenos o suficiente para o hardware processar.</span><span class="sxs-lookup"><span data-stu-id="ec671-120">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="ec671-121">O aplicativo deve descobrir quais blocos podem ser necessário e carregá-los em um cache de texturas na GPU – um sistema de paginação de software.</span><span class="sxs-lookup"><span data-stu-id="ec671-121">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span> <span data-ttu-id="ec671-122">Uma desvantagem significativa dessa abordagem é que o hardware não está sabendo nada sobre a paginação que está acontecendo: quando uma parte de uma imagem precisa ser mostrada na tela que se espalha pelos blocos, o hardware não sabe como executar a filtragem de função fixa (ou seja, eficiente) em blocos.</span><span class="sxs-lookup"><span data-stu-id="ec671-122">A significant downside to this approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="ec671-123">Isso significa que o aplicativo que gerencia o próprio agrupamento lado a lado de software deve recorrer à filtragem de textura manual no código do sombreador (que se torna muito caro se for desejado um filtro anisotrópico de boa qualidade) e/ou desperdiçar memória criando medianizes em torno de blocos que contenham dados de blocos vizinhos para que a filtragem de hardware de função fixa possa continuar a fornecer alguma ajuda.</span><span class="sxs-lookup"><span data-stu-id="ec671-123">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

<span data-ttu-id="ec671-124">Se uma representação em blocos postais de alocações de superfície puder ser um recurso de primeira classe no sistema de gráficos, o aplicativo poderá informar ao hardware quais blocos ficarão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="ec671-124">If a tiled representation of surface allocations could be a first class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="ec671-125">Dessa forma, menos memória da GPU é desperdiçada com o armazenamento de regiões de superfícies que o aplicativo sabe que não serão acessadas, e o hardware pode saber como filtrar blocos adjacentes, diminuindo os problemas enfrentados por desenvolvedores que executam o agrupamento lado a lado de software por conta própria.</span><span class="sxs-lookup"><span data-stu-id="ec671-125">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="ec671-126">Mas, para fornecer uma solução completa, algo deve ser feito para lidar com o fato de que, independentemente de haver suporte para o agrupamento lado a lado em uma superfície, a dimensão máxima de superfície é atualmente 16384 – não chega nem perto dos mais de 128 K que os aplicativos já querem.</span><span class="sxs-lookup"><span data-stu-id="ec671-126">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="ec671-127">Exigir apenas que hardware dê suporte para tamanhos maiores de textura é uma abordagem, mas existem custos e/ou compensações significativos para seguir esse caminho.</span><span class="sxs-lookup"><span data-stu-id="ec671-127">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span> <span data-ttu-id="ec671-128">O caminho do filtro de textura e o caminho de renderização do Direct3D 11 já estão saturados em termos de precisão no suporte a texturas de 16K com os outros requisitos, como extensões do visor de suporte que ficam fora da superfície durante a renderização ou dão suporte à disposição da textura na borda da superfície durante a filtragem.</span><span class="sxs-lookup"><span data-stu-id="ec671-128">Direct3D 11's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="ec671-129">Uma possibilidade é definir uma compensação como, por exemplo, à medida que o tamanho da textura ultrapassa 16 K, a funcionalidade/precisão é renunciada de alguma maneira.</span><span class="sxs-lookup"><span data-stu-id="ec671-129">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="ec671-130">Mesmo com essa concessão, porém, os custos adicionais de hardware podem ser necessários em termos de endereçamento de funcionalidade em todo o sistema de hardware para chegar a tamanhos de textura maiores.</span><span class="sxs-lookup"><span data-stu-id="ec671-130">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

<span data-ttu-id="ec671-131">Um problema que vem à tona quando as texturas ficam muito grandes é que as coordenadas de textura de ponto flutuante de precisão (e os interpoladores associados para dar suporte à rasterização) perdem a precisão para especificar locais na superfície com exatidão.</span><span class="sxs-lookup"><span data-stu-id="ec671-131">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="ec671-132">Pode ocorrer filtragem de textura irregular.</span><span class="sxs-lookup"><span data-stu-id="ec671-132">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="ec671-133">Uma opção cara seria exigir duplo suporte para interpoladores de precisão, embora isso possa ser um exagero visto que há uma alternativa razoável.</span><span class="sxs-lookup"><span data-stu-id="ec671-133">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

<span data-ttu-id="ec671-134">Um nome alternativo para os recursos do lado do xadrez é "textura esparsa".</span><span class="sxs-lookup"><span data-stu-id="ec671-134">An alternate name for tiled resources is "sparse texture."</span></span> <span data-ttu-id="ec671-135">"Esparso" refere-se à natureza lado a lado dos recursos, bem como ao provável motivo principal do agrupamento lado a lado dos recursos: que nem todos eles precisam ser mapeados de uma vez.</span><span class="sxs-lookup"><span data-stu-id="ec671-135">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="ec671-136">Na verdade, um aplicativo poderia criar, de forma intencional, um recurso ao lado do qual nenhum dado foi criado para todas as regiões + MIPS do recurso.</span><span class="sxs-lookup"><span data-stu-id="ec671-136">In fact, an application could conceivably author a tiled resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="ec671-137">Portanto, o próprio conteúdo pode ser esparso e o mapeamento do conteúdo na memória da GPU em um determinado momento seria um subconjunto disso (ainda mais esparso).</span><span class="sxs-lookup"><span data-stu-id="ec671-137">So, the content itself could be sparse, and the mapping of the content in GPU memory at a given time would be a subset of that (even more sparse).</span></span>

<span data-ttu-id="ec671-138">Outro cenário que pode ser servido por recursos ao lado do xadrez é habilitar vários recursos de dimensões/formatos diferentes para compartilhar a mesma memória.</span><span class="sxs-lookup"><span data-stu-id="ec671-138">Another scenario that could be served by tiled resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="ec671-139">Às vezes, os aplicativos têm conjuntos de recursos exclusivos que não são usados ao mesmo tempo ou recursos que são criados apenas para uso muito breve e, em seguida, são destruídos, seguidos pela criação de outros recursos.</span><span class="sxs-lookup"><span data-stu-id="ec671-139">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="ec671-140">Uma forma de generalização que pode cair de "recursos ao lado" é que é possível permitir que o usuário aponte vários recursos diferentes na mesma memória (sobreposição).</span><span class="sxs-lookup"><span data-stu-id="ec671-140">A form of generality that can fall out of "tiled resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="ec671-141">Em outras palavras, a criação e a destruição de "recursos" (que definem uma dimensão/formato e assim por diante) podem ser desvinculadas do gerenciamento da memória subjacente aos recursos do ponto de vista do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="ec671-141">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ec671-142">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="ec671-142">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ec671-143">Recursos em ladrilho</span><span class="sxs-lookup"><span data-stu-id="ec671-143">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 