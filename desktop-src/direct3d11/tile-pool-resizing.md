---
title: Redimensionamento de pool de blocos
description: Use a API ID3D11DeviceContext2 ResizeTilePool para aumentar um pool de blocos se o aplicativo precisar de mais um conjunto de trabalho para o mapeamento de recursos lado-a-quadro ou para reduzir se for necessário menos espaço.
ms.assetid: 529E874E-650B-4BFD-97F6-E66E743564A9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 86368da46f7c2219f42b5ecbc122b79fee19e72c
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "103822336"
---
# <a name="tile-pool-resizing"></a><span data-ttu-id="ea3eb-103">Redimensionamento de pool de blocos</span><span class="sxs-lookup"><span data-stu-id="ea3eb-103">Tile pool resizing</span></span>

<span data-ttu-id="ea3eb-104">Use a API [**ID3D11DeviceContext2:: ResizeTilePool**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool) para aumentar um pool de blocos se o aplicativo precisar de mais um conjunto de trabalho para o mapeamento de recursos lado-a-quadro ou para reduzir se for necessário menos espaço.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-104">Use the [**ID3D11DeviceContext2::ResizeTilePool**](/windows/desktop/api/D3D11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool) API to grow a tile pool if the application needs more working set for the tiled resources mapping into it or to shrink if less space is needed.</span></span> <span data-ttu-id="ea3eb-105">Outra opção para aplicativos é alocar pools de blocos adicionais para novos recursos ao lado.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-105">Another option for applications is to allocate additional tile pools for new tiled resources.</span></span> <span data-ttu-id="ea3eb-106">Mas, se qualquer recurso de lado único precisar de mais espaço do que inicialmente disponível em seu pool de peças, o aumento do pool de blocos é uma boa opção.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-106">But if any single tiled resource needs more space than initially available in its tile pool, growing the tile pool is a good option.</span></span> <span data-ttu-id="ea3eb-107">Um recurso por lado não pode ter mapeamentos em vários pools de blocos ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-107">A tiled resource can't have mappings into multiple tile pools at the same time.</span></span>

<span data-ttu-id="ea3eb-108">Quando um pool de blocos é expandido, blocos adicionais são adicionados ao final por meio de uma ou mais alocações novo pelo driver de vídeo.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-108">When a tile pool is grown, additional tiles are added to the end via one or more new allocations by the display driver.</span></span> <span data-ttu-id="ea3eb-109">Essa divisão em alocações não fica visível para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-109">This breakdown into allocations isn't visible to the application.</span></span> <span data-ttu-id="ea3eb-110">A memória existente no pool de blocos é deixada inalterada, e os mapeamentos de recursos de mosaico existentes nessa memória permanecem intactos.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-110">Existing memory in the tile pool is left untouched, and existing tiled resource mappings into that memory remain intact.</span></span>

<span data-ttu-id="ea3eb-111">Quando um pool de blocos é reduzido, os blocos são removidos do final.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-111">When a tile pool is shrunk, tiles are removed from the end.</span></span> <span data-ttu-id="ea3eb-112">Os blocos são removidos até mesmo abaixo do tamanho de alocação inicial, até 0, o que significa que novos mapeamentos não poderão ser feitos após o novo tamanho.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-112">Tiles are removed even below the initial allocation size, down to 0, which means new mappings can't be made past the new size.</span></span> <span data-ttu-id="ea3eb-113">Porém, os mapeamentos existentes após o final do novo tamanho permanecem intactos e utilizáveis.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-113">But, existing mappings past the end of the new size remain intact and useable.</span></span> <span data-ttu-id="ea3eb-114">O driver de vídeo manterá a memória ativa enquanto permanecerem mapeamentos para qualquer parte das alocações que o driver usa para a memória do pool de blocos.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-114">The display driver will keep the memory around as long as mappings to any part of the allocations that the driver uses for the tile pool memory remains.</span></span> <span data-ttu-id="ea3eb-115">Se, após a redução, parte da memória for mantida ativa porque mapeamentos de blocos são apontando para ela e, em seguida, o pool de blocos for ampliado novamente (em qualquer valor), a memória existente será reutilizada primeiro antes que qualquer alocação adicional ocorra para atender ao tamanho da operação de ampliação.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-115">If after shrinking some memory has been kept alive because tile mappings are pointing to it and then the tile pool is regrown again (by any amount), the existing memory is reused first before any additional allocations occur to service the size of the grow operation.</span></span>

<span data-ttu-id="ea3eb-116">Para poder economizar memória, o aplicativo precisa não só reduzir um pool de blocos, mas também remover/remapear os mapeamentos existentes após o final do novo tamanho de pool de blocos menor.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-116">To be able to save memory, an application has to not only shrink a tile pool but also remove/remap existing mappings past the end of the new smaller tile pool size.</span></span>

<span data-ttu-id="ea3eb-117">O ato de reduzir (e remover mapeamentos) não necessariamente gera economia de memória de imediato.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-117">The act of shrinking (and removing mappings) doesn't necessarily produce immediate memory savings.</span></span> <span data-ttu-id="ea3eb-118">A liberação da memória depende de quão granulares as alocações subjacentes do driver de vídeo são para o pool de blocos.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-118">Freeing of memory depends on how granular the display driver's underlying allocations for the tile pool are.</span></span> <span data-ttu-id="ea3eb-119">Quando a redução é suficiente para fazer uma alocação de driver de vídeo não utilizado, o driver de vídeo pode liberá-la.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-119">When shrinking happens to be enough to make a display driver allocation unused, the display driver can free it.</span></span> <span data-ttu-id="ea3eb-120">Se um pool de blocos foi ampliado, a redução aos tamanhos anteriores (e remover/remapear os mapeamentos de blocos de forma correspondente) tem grandes chances de economizar memória, embora não haja garantia caso os tamanhos não se alinhem exatamente aos tamanhos de alocação subjacentes escolhidos pelo driver de vídeo.</span><span class="sxs-lookup"><span data-stu-id="ea3eb-120">If a tile pool was grown, shrinking to previous sizes (and removing/remapping tile mappings correspondingly) is most likely to yield memory savings, though not guaranteed in the case that the sizes don't exactly align with the underlying allocation sizes chosen by the display driver.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ea3eb-121">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="ea3eb-121">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ea3eb-122">Mapeamentos estão em um pool de blocos</span><span class="sxs-lookup"><span data-stu-id="ea3eb-122">Mappings are into a tile pool</span></span>](mappings-are-into-a-tile-pool.md)
</dt> </dl>

 

 




