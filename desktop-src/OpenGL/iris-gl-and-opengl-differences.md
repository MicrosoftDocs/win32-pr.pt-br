---
title: Diferenças de íris GL e OpenGL
description: Diferenças de íris GL e OpenGL
ms.assetid: 1682bcbb-3bfb-4ea3-9ba9-4f4654238169
keywords:
- Diferenças do OpenGL, íris GL
- Portabilidade do íris GL, diferenças de OpenGL
- portando do íris GL, diferenças de OpenGL
- portando para OpenGL do íris GL, diferenças do íris GL
- Portabilidade OpenGL do íris GL, diferenças de íris GL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6276eb56cf73df6cbdfc115fe67d55452b13bbc
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "104292071"
---
# <a name="iris-gl-and-opengl-differences"></a><span data-ttu-id="1fb65-108">Diferenças de íris GL e OpenGL</span><span class="sxs-lookup"><span data-stu-id="1fb65-108">IRIS GL and OpenGL Differences</span></span>

<span data-ttu-id="1fb65-109">Este apêndice lista as diferenças entre OpenGL e íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-109">This appendix lists the differences between OpenGL and IRIS GL.</span></span> <span data-ttu-id="1fb65-110">Um termo para cada diferença é fornecido, seguido por uma descrição.</span><span class="sxs-lookup"><span data-stu-id="1fb65-110">A term for each difference is given, followed by a description.</span></span>



|                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="1fb65-111">encapsulamento de acumulação</span><span class="sxs-lookup"><span data-stu-id="1fb65-111">accumulation wrapping</span></span>                | <span data-ttu-id="1fb65-112">A operação de buffer de acumulação OpenGL não é definida quando os valores de componente excedem 1,0 ou descartam abaixo de 1,0.</span><span class="sxs-lookup"><span data-stu-id="1fb65-112">The OpenGL accumulation buffer operation is not defined when component values exceed 1.0 or drop below 1.0.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="1fb65-113">linhas AntiAlias</span><span class="sxs-lookup"><span data-stu-id="1fb65-113">antialiased lines</span></span>                    | <span data-ttu-id="1fb65-114">Linhas AntiAlias OpenGL stipples.</span><span class="sxs-lookup"><span data-stu-id="1fb65-114">OpenGL stipples antialiased lines.</span></span> <span data-ttu-id="1fb65-115">O íris GL não.</span><span class="sxs-lookup"><span data-stu-id="1fb65-115">IRIS GL does not.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="1fb65-116">arco</span><span class="sxs-lookup"><span data-stu-id="1fb65-116">arc</span></span>                                  | <span data-ttu-id="1fb65-117">O OpenGL dá suporte a arcos em sua biblioteca de utilitários.</span><span class="sxs-lookup"><span data-stu-id="1fb65-117">OpenGL supports arcs in its utility library.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="1fb65-118">listas de atributos</span><span class="sxs-lookup"><span data-stu-id="1fb65-118">attribute lists</span></span>                      | <span data-ttu-id="1fb65-119">Os atributos enviados pela íris GL pushattributes diferem de qualquer um dos conjuntos de atributos enviados pelo glPushAttrib OpenGL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-119">The attributes pushed by the IRIS GL pushattributes differ from any of the attribute sets pushed by the OpenGL glPushAttrib .</span></span> <span data-ttu-id="1fb65-120">No entanto, como todos os Estados OpenGL podem ser lidos de volta, você pode implementar qualquer semântica de push/pop desejada usando OpenGL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-120">Since all OpenGL states can be read back, however, you can implement any desired push/pop semantics using OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="1fb65-121">dimensionamento automático de textura</span><span class="sxs-lookup"><span data-stu-id="1fb65-121">automatic texture scaling</span></span>            | <span data-ttu-id="1fb65-122">A interface de textura OpenGL não dá suporte ao dimensionamento automático de imagens para poder de duas dimensões.</span><span class="sxs-lookup"><span data-stu-id="1fb65-122">The OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions.</span></span> <span data-ttu-id="1fb65-123">No entanto, o GLU dá suporte ao dimensionamento de imagem.</span><span class="sxs-lookup"><span data-stu-id="1fb65-123">However, the GLU supports image scaling.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="1fb65-124">bbox</span><span class="sxs-lookup"><span data-stu-id="1fb65-124">bbox</span></span>                                 | <span data-ttu-id="1fb65-125">O OpenGL não dá suporte à execução condicional de listas de exibição.</span><span class="sxs-lookup"><span data-stu-id="1fb65-125">OpenGL doesn't support conditional execution of display lists.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="1fb65-126">callfunc</span><span class="sxs-lookup"><span data-stu-id="1fb65-126">callfunc</span></span>                             | <span data-ttu-id="1fb65-127">O OpenGL não dá suporte a retorno de chamada de listas de exibição.</span><span class="sxs-lookup"><span data-stu-id="1fb65-127">OpenGL doesn't support callback from display lists.</span></span> <span data-ttu-id="1fb65-128">Observe que o íris GL não dá suporte a essa funcionalidade, quando o cliente e o servidor estão em plataformas diferentes.</span><span class="sxs-lookup"><span data-stu-id="1fb65-128">Note that IRIS GL doesn't support this functionality either, when client and server are on different platforms.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="1fb65-129">circle</span><span class="sxs-lookup"><span data-stu-id="1fb65-129">circle</span></span>                               | <span data-ttu-id="1fb65-130">O OpenGL dá suporte a círculos com o GLU.</span><span class="sxs-lookup"><span data-stu-id="1fb65-130">OpenGL supports circles with the GLU.</span></span> <span data-ttu-id="1fb65-131">No OpenGL, os círculos e os arcos (discos e discos parciais) podem ter buracos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-131">In OpenGL both circles and arcs (disks and partial disks) can have holes.</span></span> <span data-ttu-id="1fb65-132">Além disso, você pode alterar a subdivisão dos primitivos no OpenGL, cujos Normals de superfície estão disponíveis para iluminação.</span><span class="sxs-lookup"><span data-stu-id="1fb65-132">In addition, you can change subdivision of the primitives in OpenGL, whose surface normals are available for lighting.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="1fb65-133">limpar opções</span><span class="sxs-lookup"><span data-stu-id="1fb65-133">clear options</span></span>                        | <span data-ttu-id="1fb65-134">O OpenGL realmente limpa os buffers.</span><span class="sxs-lookup"><span data-stu-id="1fb65-134">OpenGL actually clears buffers.</span></span> <span data-ttu-id="1fb65-135">Ele não aplica as operações de pixel atualmente especificadas, como blending e logicop, independentemente de seus modos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-135">It doesn't apply currently specified pixel operations, such as blending and logicop, regardless of their modes.</span></span> <span data-ttu-id="1fb65-136">Para limpar o uso de tais recursos, você deve renderizar um polígono de tamanho de janela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-136">To clear using such features, you must render a window-size polygon.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="1fb65-137">linhas fechadas</span><span class="sxs-lookup"><span data-stu-id="1fb65-137">closed lines</span></span>                         | <span data-ttu-id="1fb65-138">O OpenGL renderiza todas as linhas com alias de largura única, de modo que as linhas adjacentes não compartilhem nenhum pixel.</span><span class="sxs-lookup"><span data-stu-id="1fb65-138">OpenGL renders all single-width aliased lines such that abutting lines share no pixels.</span></span> <span data-ttu-id="1fb65-139">Isso significa que o último pixel de uma linha independente não é desenhado.</span><span class="sxs-lookup"><span data-stu-id="1fb65-139">This means that the last pixel of an independent line is not drawn.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="1fb65-140">sinalizador de cor/normal</span><span class="sxs-lookup"><span data-stu-id="1fb65-140">color/normal flag</span></span>                    | <span data-ttu-id="1fb65-141">A iluminação OpenGL está explicitamente habilitada ou desabilitada.</span><span class="sxs-lookup"><span data-stu-id="1fb65-141">OpenGL lighting is explicitly enabled or disabled.</span></span> <span data-ttu-id="1fb65-142">Quando habilitado, ele entra em vigor, independentemente da ordem na qual as cores e os normais são especificados.</span><span class="sxs-lookup"><span data-stu-id="1fb65-142">When enabled, it is effective regardless of the order in which colors and normals are specified.</span></span> <span data-ttu-id="1fb65-143">Não é possível habilitar ou desabilitar a iluminação entre os comandos OpenGL glBegin e glEnd.</span><span class="sxs-lookup"><span data-stu-id="1fb65-143">You cannot enable or disable lighting between OpenGL glBegin and glEnd commands.</span></span> <span data-ttu-id="1fb65-144">Para desabilitar a iluminação entre glBegin e glEnd, especifique a reflexão de material de ambiente zero, difuso e especulação e, em seguida, defina a emissão de material como a cor desejada.</span><span class="sxs-lookup"><span data-stu-id="1fb65-144">To disable lighting between glBegin and glEnd, specify zero ambient, diffuse, and specular material reflectance, and then set the material emission to the desired color.</span></span>                                                                                                                                                                                                                                                            |
| <span data-ttu-id="1fb65-145">polígonos côncavos</span><span class="sxs-lookup"><span data-stu-id="1fb65-145">concave polygons</span></span>                     | <span data-ttu-id="1fb65-146">A API principal do OpenGL não lida com polígonos côncavos, mas o GLU dá suporte à decomposição de contornos côncavos e não autocruzados em triângulos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-146">The core OpenGL API doesn't handle concave polygons, but the GLU supports decomposing concave, non-self-intersecting contours into triangles.</span></span> <span data-ttu-id="1fb65-147">Esses triângulos podem ser desenhados imediatamente ou retornados.</span><span class="sxs-lookup"><span data-stu-id="1fb65-147">These triangles can either be drawn immediately or returned.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="1fb65-148">cor computada atual</span><span class="sxs-lookup"><span data-stu-id="1fb65-148">current computed color</span></span>               | <span data-ttu-id="1fb65-149">O OpenGL não tem equivalente a uma cor computada atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-149">OpenGL has no equivalent to a current computed color.</span></span> <span data-ttu-id="1fb65-150">Se você estiver usando o OpenGL como um mecanismo de iluminação, poderá usar os comentários para obter as cores geradas pelos cálculos de iluminação.</span><span class="sxs-lookup"><span data-stu-id="1fb65-150">If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="1fb65-151">posição de gráficos atual</span><span class="sxs-lookup"><span data-stu-id="1fb65-151">current graphics position</span></span>            | <span data-ttu-id="1fb65-152">O OpenGL não mantém uma posição gráfica atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-152">OpenGL doesn't maintain a current graphics position.</span></span> <span data-ttu-id="1fb65-153">Os comandos da íris GL que dependem da posição de gráficos atual, como linhas relativas e polígonos, não estão incluídos no OpenGL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-153">IRIS GL commands that depend on current graphics position, such as relative lines and polygons, are not included in OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="1fb65-154">curvas</span><span class="sxs-lookup"><span data-stu-id="1fb65-154">curves</span></span>                               | <span data-ttu-id="1fb65-155">O OpenGL não dá suporte a curvas do íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-155">OpenGL does not support IRIS GL curves.</span></span> <span data-ttu-id="1fb65-156">O uso de curvas NURBS é recomendado.</span><span class="sxs-lookup"><span data-stu-id="1fb65-156">Use of NURBS curves is recommended.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="1fb65-157">defs/bindings</span><span class="sxs-lookup"><span data-stu-id="1fb65-157">defs/binds</span></span>                           | <span data-ttu-id="1fb65-158">O OpenGL não tem o conceito de objetos material, Light ou Texture; somente das propriedades material, Light e Texture.</span><span class="sxs-lookup"><span data-stu-id="1fb65-158">OpenGL doesn't have the concept of material, light, or texture objects; only of material, light, and texture properties.</span></span> <span data-ttu-id="1fb65-159">No entanto, você pode usar as listas de exibição para criar seus próprios objetos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-159">You can use display lists to create their own objects, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="1fb65-160">depthcue</span><span class="sxs-lookup"><span data-stu-id="1fb65-160">depthcue</span></span>                             | <span data-ttu-id="1fb65-161">O OpenGL não fornece suporte direto para advertência de profundidade, mas seu suporte de neblina é um recurso mais geral que você pode usar facilmente para emular a função de depthcue íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-161">OpenGL provides no direct support for depth cueing, but its fog support is a more general capability that you can easily use to emulate the IRIS GL depthcue function.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="1fb65-162">edição da lista de exibição</span><span class="sxs-lookup"><span data-stu-id="1fb65-162">display list editing</span></span>                 | <span data-ttu-id="1fb65-163">As listas de exibição OpenGL não podem ser editedonly criadas e destruídas.</span><span class="sxs-lookup"><span data-stu-id="1fb65-163">OpenGL display lists can't be editedonly created and destroyed.</span></span> <span data-ttu-id="1fb65-164">No entanto, como você pode especificar nomes de lista de exibição, é possível redefinir as listas de exibição individuais em uma hierarquia.</span><span class="sxs-lookup"><span data-stu-id="1fb65-164">Because you can specify display list names, however, you can redefine individual display lists in a hierarchy.</span></span> <span data-ttu-id="1fb65-165">As listas de exibição OpenGL são projetadas para o cache de dados, e não para o gerenciamento de banco.</span><span class="sxs-lookup"><span data-stu-id="1fb65-165">OpenGL display lists are designed for data caching, not for database management.</span></span> <span data-ttu-id="1fb65-166">É garantido que eles sejam armazenados no servidor em ambientes de cliente/servidor, portanto, eles não são limitados pela largura de banda da rede durante a execução.</span><span class="sxs-lookup"><span data-stu-id="1fb65-166">They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.</span></span> <span data-ttu-id="1fb65-167">As listas de exibição do OpenGL podem ser chamadas entre os comandos glBegin e glEnd, de modo que a hierarquia da lista de exibição pode ser bem suficiente para que ela possa, na verdade, ser editada.</span><span class="sxs-lookup"><span data-stu-id="1fb65-167">OpenGL display lists can be called between glBegin and glEnd commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.</span></span>                                                                                              |
| <span data-ttu-id="1fb65-168">verificação de erros</span><span class="sxs-lookup"><span data-stu-id="1fb65-168">error checking</span></span>                       | <span data-ttu-id="1fb65-169">O OpenGL verifica se há erros com mais cuidado do que o íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-169">OpenGL checks for errors more carefully than IRIS GL.</span></span> <span data-ttu-id="1fb65-170">Por exemplo, todas as funções OpenGL que não são aceitas entre glBegin e glEnd são detectadas como erros e não têm nenhum outro efeito.</span><span class="sxs-lookup"><span data-stu-id="1fb65-170">For example, all OpenGL functions that are not accepted between glBegin and glEnd are detected as errors, and have no other effect.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="1fb65-171">valores de retorno de erro</span><span class="sxs-lookup"><span data-stu-id="1fb65-171">error return values</span></span>                  | <span data-ttu-id="1fb65-172">Quando um comando OpenGL que retorna um valor detecta um erro, ele sempre retorna zero.</span><span class="sxs-lookup"><span data-stu-id="1fb65-172">When an OpenGL command that returns a value detects an error, it always returns zero.</span></span> <span data-ttu-id="1fb65-173">Comandos OpenGL que retornam dados por meio de ponteiros passados não fazem nenhuma alteração no conteúdo da matriz se um erro for detectado.</span><span class="sxs-lookup"><span data-stu-id="1fb65-173">OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="1fb65-174">efeitos colaterais de erro</span><span class="sxs-lookup"><span data-stu-id="1fb65-174">error side effects</span></span>                   | <span data-ttu-id="1fb65-175">Quando um comando OpenGL resulta em um erro, seu único efeito colateral é atualizar o sinalizador de erro para o valor apropriado.</span><span class="sxs-lookup"><span data-stu-id="1fb65-175">When an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value.</span></span> <span data-ttu-id="1fb65-176">Nenhuma outra alteração de estado é feita.</span><span class="sxs-lookup"><span data-stu-id="1fb65-176">No other state changes are made.</span></span> <span data-ttu-id="1fb65-177">(Uma exceção é a saída \_ De \_ erro de memória, que é fatal.)</span><span class="sxs-lookup"><span data-stu-id="1fb65-177">(An exception is the OUT\_OF\_MEMORY error, which is fatal.)</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="1fb65-178">comentários</span><span class="sxs-lookup"><span data-stu-id="1fb65-178">feedback</span></span>                             | <span data-ttu-id="1fb65-179">Os comentários são padronizados no OpenGL e, portanto, não são alterados de máquina para máquina.</span><span class="sxs-lookup"><span data-stu-id="1fb65-179">Feedback is standardized in OpenGL so it doesn't change from machine to machine.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="1fb65-180">fontes e cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="1fb65-180">fonts and strings</span></span>                    | <span data-ttu-id="1fb65-181">O OpenGL requer que os glifos de caracteres sejam manipulados como listas de exibição individuais.</span><span class="sxs-lookup"><span data-stu-id="1fb65-181">OpenGL requires character glyphs to be manipulated as individual display lists.</span></span> <span data-ttu-id="1fb65-182">Ele fornece uma função de chamada de lista de exibição que aceita uma lista de nomes de lista de exibição, cada nome representado como 1, 2 ou 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="1fb65-182">It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes.</span></span> <span data-ttu-id="1fb65-183">A função glCallLists adiciona um deslocamento especificado separadamente a cada nome de lista de exibição antes da chamada, permitindo que as listas de nomes da lista de exibição sejam tratadas como cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="1fb65-183">The glCallLists function adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings.</span></span> <span data-ttu-id="1fb65-184">Esse mecanismo fornece toda a funcionalidade das fontes do íris GL e consideravelmente mais.</span><span class="sxs-lookup"><span data-stu-id="1fb65-184">This mechanism provides all the functionality of IRIS GL fonts, and considerably more.</span></span> <span data-ttu-id="1fb65-185">Por exemplo, os caracteres compostos de triângulos podem ser facilmente manipulados.</span><span class="sxs-lookup"><span data-stu-id="1fb65-185">For example, characters comprised of triangles can be easily manipulated.</span></span>                                                                                                                  |
| <span data-ttu-id="1fb65-186">frontbuffer</span><span class="sxs-lookup"><span data-stu-id="1fb65-186">frontbuffer</span></span>                          | <span data-ttu-id="1fb65-187">A íris GL tem regras complexas para renderização no buffer frontal no modo de buffer único.</span><span class="sxs-lookup"><span data-stu-id="1fb65-187">IRIS GL has complex rules for rendering to the front buffer in single buffer mode.</span></span> <span data-ttu-id="1fb65-188">O OpenGL lida com a renderização no buffer frontal de maneira simples.</span><span class="sxs-lookup"><span data-stu-id="1fb65-188">OpenGL handles rendering to the front buffer in a straightforward way.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="1fb65-189">polígonos vazios</span><span class="sxs-lookup"><span data-stu-id="1fb65-189">hollow polygons</span></span>                      | <span data-ttu-id="1fb65-190">Você pode usar a capacidade do estêncil OpenGL para renderizar polígonos vazios.</span><span class="sxs-lookup"><span data-stu-id="1fb65-190">You can use the OpenGL stencil capacity to render hollow polygons.</span></span> <span data-ttu-id="1fb65-191">O OpenGL não dá suporte a outros meios para a criação de polígonos vazios.</span><span class="sxs-lookup"><span data-stu-id="1fb65-191">OpenGL doesn't support other means for creating hollow polygons.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="1fb65-192">fixação MSS de índice</span><span class="sxs-lookup"><span data-stu-id="1fb65-192">index clamping</span></span>                       | <span data-ttu-id="1fb65-193">Sempre que possível, o OpenGL trata os índices de cor e de estêncil como campos de bits, em vez de números.</span><span class="sxs-lookup"><span data-stu-id="1fb65-193">Where possible, OpenGL treats color and stencil indexes as bit fields rather than numbers.</span></span> <span data-ttu-id="1fb65-194">Assim, os índices são mascarados, em vez de clamped, para o intervalo com suporte do framebuffer.</span><span class="sxs-lookup"><span data-stu-id="1fb65-194">Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="1fb65-195">cores de inteiro</span><span class="sxs-lookup"><span data-stu-id="1fb65-195">integer colors</span></span>                       | <span data-ttu-id="1fb65-196">Os componentes de cor de inteiro assinados (vermelho, verde, azul ou alfa) são mapeados de forma linear para pontos flutuantes para que o número inteiro mais negativo seja mapeado para 1,0 e o número inteiro mais positivo seja mapeado para 1,0.</span><span class="sxs-lookup"><span data-stu-id="1fb65-196">Signed integer color components (red, green, blue, or alpha) are mapped in linear fashion to floating points so that the most negative integer maps to 1.0 and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="1fb65-197">Esse mapeamento ocorre quando você especifica a cor antes que o OpenGL substitua a cor atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-197">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span> <span data-ttu-id="1fb65-198">Os componentes de cor de inteiro sem sinal são mapeados linearmente para pontos flutuantes para que 0 mapeie para 0,0 e o maior número inteiro seja mapeado para 1,0.</span><span class="sxs-lookup"><span data-stu-id="1fb65-198">Unsigned integer color components are mapped linearly to floating points so that 0 maps to 0.0 and the largest integer maps to 1.0.</span></span> <span data-ttu-id="1fb65-199">Esse mapeamento ocorre quando você especifica a cor antes que o OpenGL substitua a cor atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-199">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span>                                                                                                                                               |
| <span data-ttu-id="1fb65-200">Normals inteiros</span><span class="sxs-lookup"><span data-stu-id="1fb65-200">integer normals</span></span>                      | <span data-ttu-id="1fb65-201">Os componentes normais de inteiros são mapeados como componentes de cores assinados.</span><span class="sxs-lookup"><span data-stu-id="1fb65-201">Integer normal components are mapped just like signed color components.</span></span> <span data-ttu-id="1fb65-202">O número inteiro mais negativo é mapeado para 1,0 e o número inteiro mais positivo é mapeado para 1,0.</span><span class="sxs-lookup"><span data-stu-id="1fb65-202">The most negative integer maps to 1.0, and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="1fb65-203">fragmentos de pixel.</span><span class="sxs-lookup"><span data-stu-id="1fb65-203">pixel fragments.</span></span> <span data-ttu-id="1fb65-204">Os pixels desenhados por glDrawPixels ou glCopyPixels sempre são rasterizados e convertidos em fragmentos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-204">Pixels drawn by glDrawPixels or glCopyPixels are always rasterized and converted to fragments.</span></span> <span data-ttu-id="1fb65-205">Os fragmentos resultantes são texturizados, fogged, profundidade em buffer, misturados e assim por diante, como se fossem gerados a partir de pontos geométricos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-205">The resulting fragments are textured, fogged, depth buffered, blended, and so on, just as if they were generated from geometric points.</span></span> <span data-ttu-id="1fb65-206">Os dados de fragmento que não são fornecidos pelos pixels de origem são aumentados da posição de rasterização atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-206">Fragment data that isn't provided by the source pixels is augmented from the current raster position.</span></span> <span data-ttu-id="1fb65-207">Por exemplo, os pixels RGBA usam a posição de rasterização Z e as coordenadas de textura.</span><span class="sxs-lookup"><span data-stu-id="1fb65-207">For example, RGBA pixels take the raster position Z and texture coordinates.</span></span> <span data-ttu-id="1fb65-208">Pixels de profundidade assumem as coordenadas de cor e de textura da posição de rasterização.</span><span class="sxs-lookup"><span data-stu-id="1fb65-208">Depth pixels take the raster position color and texture coordinates.</span></span> |
| <span data-ttu-id="1fb65-209">invariação</span><span class="sxs-lookup"><span data-stu-id="1fb65-209">invariance</span></span>                           | <span data-ttu-id="1fb65-210">O OpenGL garante uma determinada consistência que o íris GL não.</span><span class="sxs-lookup"><span data-stu-id="1fb65-210">OpenGL guarantees a certain consistency that IRIS GL doesn't.</span></span> <span data-ttu-id="1fb65-211">Por exemplo, o OpenGL garante que sequências de código idênticas enviadas ao mesmo sistema, diferentes somente na função de mesclagem especificada, gerem os mesmos fragmentos de pixel.</span><span class="sxs-lookup"><span data-stu-id="1fb65-211">For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the specified blending function, will generate the same pixel fragments.</span></span> <span data-ttu-id="1fb65-212">(Os fragmentos são diferentes, no entanto, se a mesclagem estiver habilitada e desabilitada.)</span><span class="sxs-lookup"><span data-stu-id="1fb65-212">(The fragments differ, however, if blending is enabled and then disabled.)</span></span>                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="1fb65-213">equação de iluminação</span><span class="sxs-lookup"><span data-stu-id="1fb65-213">lighting equation</span></span>                    | <span data-ttu-id="1fb65-214">A equação de iluminação OpenGL difere ligeiramente da equação do Engl da íris.</span><span class="sxs-lookup"><span data-stu-id="1fb65-214">The OpenGL lighting equation differs slightly from the IRIS GL equation.</span></span> <span data-ttu-id="1fb65-215">O OpenGL dá suporte à atenuação separada para cada fonte de luz, em vez de uma atenuação única para todas as fontes de luz, como íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-215">OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources like IRIS GL.</span></span> <span data-ttu-id="1fb65-216">O OpenGL ajusta a equação para que as contribuições de iluminação ambiente, difusa e especular sejam atenuadas.</span><span class="sxs-lookup"><span data-stu-id="1fb65-216">OpenGL adjusts the equation so that ambient, diffuse, and specular lighting contributions are all attenuated.</span></span> <span data-ttu-id="1fb65-217">Além disso, o OpenGL permite que você especifique cores separadas para as intensidades de ambiente, difusa e especulação de fontes de luz, bem como para a reflexão de materiais, difusa e difuso.</span><span class="sxs-lookup"><span data-stu-id="1fb65-217">Also, OpenGL allows you to specify separate colors for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials.</span></span> <span data-ttu-id="1fb65-218">Todas as cores de luz e material do OpenGL incluem alfa.</span><span class="sxs-lookup"><span data-stu-id="1fb65-218">All OpenGL light and material colors include alpha.</span></span> <span data-ttu-id="1fb65-219">Definir o expoente especular como zero não anula a iluminação especular no OpenGL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-219">Setting the specular exponent to zero does not defeat specular lighting in OpenGL.</span></span>    |
| <span data-ttu-id="1fb65-220">mapw</span><span class="sxs-lookup"><span data-stu-id="1fb65-220">mapw</span></span>                                 | <span data-ttu-id="1fb65-221">Os utilitários OpenGL dão suporte ao mapeamento entre coordenadas de objeto e de janela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-221">OpenGL utilities support mapping between object and window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="1fb65-222">modo de matriz</span><span class="sxs-lookup"><span data-stu-id="1fb65-222">matrix mode</span></span>                          | <span data-ttu-id="1fb65-223">Onde as funções íris GL Ortho, ortho2, Perspective e Window operam em uma matriz específica, todas as operações de matriz OpenGL funcionam na matriz atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-223">Where the IRIS GL ortho, ortho2, perspective, and window functions operate on a particular matrix, all OpenGL matrix operations work on the current matrix.</span></span> <span data-ttu-id="1fb65-224">Todas as operações de matriz OpenGL, exceto glLoadIdentity e glLoadMatrix, multiplicam a matriz atual em vez de substituí-la (como Ortho, ortho2, Perspective e Window no íris GL).</span><span class="sxs-lookup"><span data-stu-id="1fb65-224">All OpenGL matrix operations except glLoadIdentity and glLoadMatrix multiply the current matrix rather than replacing it (as do ortho, ortho2, perspective, and window in the IRIS GL).</span></span>                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="1fb65-225">mipmaps, geração automática</span><span class="sxs-lookup"><span data-stu-id="1fb65-225">mipmaps, automatic generation</span></span>        | <span data-ttu-id="1fb65-226">A interface de textura OpenGL não dá suporte à geração automática de imagens mipmap.</span><span class="sxs-lookup"><span data-stu-id="1fb65-226">The OpenGL texture interface does not support automatic generation of mipmap images.</span></span> <span data-ttu-id="1fb65-227">No entanto, o GLU dá suporte à geração automática de imagens mipmap para texturas 1D e 2D.</span><span class="sxs-lookup"><span data-stu-id="1fb65-227">However, the GLU supports the automatic generation of mipmap images for both 1-D and 2-D textures.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="1fb65-228">mover/desenhar/pmove/pdraw/PCLOS</span><span class="sxs-lookup"><span data-stu-id="1fb65-228">move/draw/pmove/pdraw/pclos</span></span>          | <span data-ttu-id="1fb65-229">O OpenGL dá suporte apenas a gráficos de estilo Begin/End, pois ele não mantém a posição de gráficos atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-229">OpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position.</span></span> <span data-ttu-id="1fb65-230">No entanto, a especificação de parâmetro escalar dos comandos mover/desenhar antigos é aceita pelo OpenGL para todos os comandos relacionados ao vértice.</span><span class="sxs-lookup"><span data-stu-id="1fb65-230">The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="1fb65-231">modo de mprojection</span><span class="sxs-lookup"><span data-stu-id="1fb65-231">mprojection mode</span></span>                     | <span data-ttu-id="1fb65-232">O íris GL não transforma a geometria pela matriz modelview no modo de matriz de projeção.</span><span class="sxs-lookup"><span data-stu-id="1fb65-232">IRIS GL doesn't transform geometry by the modelview matrix while in projection matrix mode.</span></span> <span data-ttu-id="1fb65-233">O OpenGL sempre transforma por modelview e pela matriz de projeção, independentemente do modo de matriz.</span><span class="sxs-lookup"><span data-stu-id="1fb65-233">OpenGL always transforms by both the modelview and the projection matrix, regardless of matrix mode.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="1fb65-234">desenho de vários buffers</span><span class="sxs-lookup"><span data-stu-id="1fb65-234">multi-buffer drawing</span></span>                 | <span data-ttu-id="1fb65-235">O OpenGL é renderizado individualmente para cada buffer de cores, em vez de computar um único valor de cor, novo e com base no conteúdo de um buffer de cor e gravá-lo em todos os buffers de cores habilitados, como a íris GL faz.</span><span class="sxs-lookup"><span data-stu-id="1fb65-235">OpenGL renders to each color buffer individually, rather than computing a single, new, color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL does.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="1fb65-236">NURBS</span><span class="sxs-lookup"><span data-stu-id="1fb65-236">NURBS</span></span>                                | <span data-ttu-id="1fb65-237">O OpenGL dá suporte a NURBS com uma combinação de capacidade principal (avaliadores) e suporte GLU.</span><span class="sxs-lookup"><span data-stu-id="1fb65-237">OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support.</span></span> <span data-ttu-id="1fb65-238">Todos os recursos do íris GL NURBS têm suporte.</span><span class="sxs-lookup"><span data-stu-id="1fb65-238">All IRIS GL NURBS capabilities are supported.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="1fb65-239">modo de polígono antigo</span><span class="sxs-lookup"><span data-stu-id="1fb65-239">old polygon mode</span></span>                     | <span data-ttu-id="1fb65-240">Os polígonos do OpenGL com alias sempre são de amostra de ponto.</span><span class="sxs-lookup"><span data-stu-id="1fb65-240">Aliased OpenGL polygons are always point-sampled.</span></span> <span data-ttu-id="1fb65-241">O modo de compatibilidade de polígono do íris GL, em que os pixels fora do perímetro do polígono são incluídos em sua rasterização, não tem suporte.</span><span class="sxs-lookup"><span data-stu-id="1fb65-241">IRIS GL's polygon compatibility mode, where pixels outside the polygon perimeter are included in its rasterization, is not supported.</span></span> <span data-ttu-id="1fb65-242">Se o seu código usa esse modo de polígono, ele é provavelmente para retângulos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-242">If your code uses this polygon mode, it is probably for rectangles.</span></span> <span data-ttu-id="1fb65-243">Os retângulos de modo de polígono antigos aparecem um pixel de largura e superior.</span><span class="sxs-lookup"><span data-stu-id="1fb65-243">Old polygon mode rectangles appear one pixel wider and higher.</span></span>                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="1fb65-244">formatos de cores empacotados</span><span class="sxs-lookup"><span data-stu-id="1fb65-244">packed color formats</span></span>                 | <span data-ttu-id="1fb65-245">O OpenGL aceita cores como componentes de 8 bits, mas esses componentes são tratados como uma matriz de bytes em vez de como bytes empacotados em palavras maiores.</span><span class="sxs-lookup"><span data-stu-id="1fb65-245">OpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words.</span></span> <span data-ttu-id="1fb65-246">Ao encorajar a indexação de matriz em vez de Shift, o OpenGL promove a programação invariável endian.</span><span class="sxs-lookup"><span data-stu-id="1fb65-246">By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.</span></span> <span data-ttu-id="1fb65-247">Assim como a íris GL aceita cores empacotadas para a renderização geométrica e de pixel, o OpenGL aceita matrizes de componentes de cor para renderização geométrica e de pixel.</span><span class="sxs-lookup"><span data-stu-id="1fb65-247">Just as IRIS GL accepts packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.</span></span>                                                                                                                                                                                                                                                              |
| <span data-ttu-id="1fb65-248">patches</span><span class="sxs-lookup"><span data-stu-id="1fb65-248">patches</span></span>                              | <span data-ttu-id="1fb65-249">O OpenGL não dá suporte a patches do íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-249">OpenGL doesn't support IRIS GL patches.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="1fb65-250">writemask de cor por bit</span><span class="sxs-lookup"><span data-stu-id="1fb65-250">per-bit color writemask</span></span>              | <span data-ttu-id="1fb65-251">OpenGL writemasks para componentes de cores habilitam ou desabilitam alterações em todo o componente (vermelho, verde, azul ou alfa), e não a partes individuais de componentes.</span><span class="sxs-lookup"><span data-stu-id="1fb65-251">OpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components.</span></span> <span data-ttu-id="1fb65-252">No entanto, observe que os writemasks por bit têm suporte para índices de cores e índices de estêncil.</span><span class="sxs-lookup"><span data-stu-id="1fb65-252">Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="1fb65-253">writemask de profundidade por bit</span><span class="sxs-lookup"><span data-stu-id="1fb65-253">per-bit depth writemask</span></span>              | <span data-ttu-id="1fb65-254">OpenGL writemasks para componentes de profundidade habilitam ou desabilitam alterações em todo o componente, não em bits individuais do componente de profundidade.</span><span class="sxs-lookup"><span data-stu-id="1fb65-254">OpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="1fb65-255">dique</span><span class="sxs-lookup"><span data-stu-id="1fb65-255">pick</span></span>                                 | <span data-ttu-id="1fb65-256">A biblioteca do utilitário OpenGL inclui suporte para gerar uma matriz de seleção.</span><span class="sxs-lookup"><span data-stu-id="1fb65-256">The OpenGL Utility library includes support for generating a pick matrix.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="1fb65-257">coordenadas de pixel</span><span class="sxs-lookup"><span data-stu-id="1fb65-257">pixel coordinates</span></span>                    | <span data-ttu-id="1fb65-258">No OpenGL e no íris GL, a origem do sistema de coordenadas de uma janela está no canto inferior esquerdo.</span><span class="sxs-lookup"><span data-stu-id="1fb65-258">In both OpenGL and IRIS GL, the origin of a window's coordinate system is at its lower left corner.</span></span> <span data-ttu-id="1fb65-259">O OpenGL coloca a origem no canto inferior esquerdo desse pixel, no entanto, enquanto a íris GL a coloca no centro do pixel inferior esquerdo.</span><span class="sxs-lookup"><span data-stu-id="1fb65-259">OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL places it at the center of the lower left pixel.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="1fb65-260">zoom de pixel</span><span class="sxs-lookup"><span data-stu-id="1fb65-260">pixel zoom</span></span>                           | <span data-ttu-id="1fb65-261">Fatores de zoom negativos de OpenGL refletem sobre a posição de gráficos atual.</span><span class="sxs-lookup"><span data-stu-id="1fb65-261">OpenGL negative zoom factors reflect about the current graphics position.</span></span> <span data-ttu-id="1fb65-262">A íris GL não define a operação de fatores de zoom negativos e, em vez disso, fornece a direita \_ para a \_ esquerda e a parte superior \_ para o \_ pixmodes de reflexo inferior.</span><span class="sxs-lookup"><span data-stu-id="1fb65-262">IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT\_TO\_LEFT and TOP\_TO\_BOTTOM reflection pixmodes.</span></span> <span data-ttu-id="1fb65-263">Esses modos de reflexão refletem em vigor, em vez de sobre a posição atual da varredura.</span><span class="sxs-lookup"><span data-stu-id="1fb65-263">These reflection modes reflect in place, rather than about the current raster position.</span></span> <span data-ttu-id="1fb65-264">O OpenGL não define modos de reflexão.</span><span class="sxs-lookup"><span data-stu-id="1fb65-264">OpenGL doesn't define reflection modes.</span></span>                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="1fb65-265">pixmode</span><span class="sxs-lookup"><span data-stu-id="1fb65-265">pixmode</span></span>                              | <span data-ttu-id="1fb65-266">As transferências de pixel OpenGL operam em componentes de cores individuais, em vez de em grupos empacotados de componentes de 4 8 bits como o íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-266">OpenGL pixel transfers operate on individual color components, rather than on packed groups of four 8-bit components as does IRIS GL.</span></span> <span data-ttu-id="1fb65-267">Embora o OpenGL forneça um recurso de pixel consideravelmente maior do que o íris GL, ele não dá suporte a construções de cores empacotadas e não permite que componentes de cores sejam reatribuídos (vermelho a verde, vermelho a azul e assim por diante) durante operações de cópia de pixel.</span><span class="sxs-lookup"><span data-stu-id="1fb65-267">While OpenGL provides substantially more pixel capability than IRIS GL, it doesn't support packed color constructs, and it doesn't enable color components to be reassigned (red to green, red to blue, and so on) during pixel copy operations.</span></span>                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="1fb65-268">polf/Polyline</span><span class="sxs-lookup"><span data-stu-id="1fb65-268">polf/poly</span></span>                            | <span data-ttu-id="1fb65-269">O OpenGL não fornece suporte direto para listas de vértices diferentes de listas de exibição.</span><span class="sxs-lookup"><span data-stu-id="1fb65-269">OpenGL provides no direct support for vertex lists other than display lists.</span></span> <span data-ttu-id="1fb65-270">Funções como polf e Polyline podem ser implementadas facilmente usando a API OpenGL, no entanto.</span><span class="sxs-lookup"><span data-stu-id="1fb65-270">Functions like polf and poly can be implemented easily using the OpenGL API, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="1fb65-271">vértice de provocativa do polígono</span><span class="sxs-lookup"><span data-stu-id="1fb65-271">polygon provoking vertex</span></span>             | <span data-ttu-id="1fb65-272">Polígonos de íris de tonalidade simples usam a cor do último vértice especificado, enquanto os polígonos OpenGL assumem a cor do primeiro vértice especificado.</span><span class="sxs-lookup"><span data-stu-id="1fb65-272">Flat shaded IRIS GL polygons take the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="1fb65-273">Stipple de polígono</span><span class="sxs-lookup"><span data-stu-id="1fb65-273">polygon stipple</span></span>                      | <span data-ttu-id="1fb65-274">Com o íris GL, o padrão Stipple de polígono é relativo à tela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-274">With IRIS GL the polygon stipple pattern is relative to the screen.</span></span> <span data-ttu-id="1fb65-275">Com o OpenGL, ele é relativo a uma janela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-275">With OpenGL it is relative to a window.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="1fb65-276">contagem de vértices de polígono</span><span class="sxs-lookup"><span data-stu-id="1fb65-276">polygon vertex count</span></span>                 | <span data-ttu-id="1fb65-277">Não há nenhum limite para o número de vértices entre glBegin e glEnd com OpenGL, mesmo para glBegin (POLYGON).</span><span class="sxs-lookup"><span data-stu-id="1fb65-277">There is no limit to the number of vertices between glBegin and glEnd with OpenGL, even for glBegin(POLYGON ).</span></span> <span data-ttu-id="1fb65-278">Com o íris GL, polígonos são limitados a não mais de 255 vértices.</span><span class="sxs-lookup"><span data-stu-id="1fb65-278">With IRIS GL, polygons are limited to no more than 255 vertices.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="1fb65-279">readdisplay</span><span class="sxs-lookup"><span data-stu-id="1fb65-279">readdisplay</span></span>                          | <span data-ttu-id="1fb65-280">A leitura de pixels fora dos limites de janela é uma funcionalidade de sistema de janela apropriada, em vez de um recurso de renderização.</span><span class="sxs-lookup"><span data-stu-id="1fb65-280">Reading pixels outside window boundaries is properly a window system capability, rather than a rendering capability.</span></span> <span data-ttu-id="1fb65-281">Use as funções do Windows para substituir o comando readdisplay do íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-281">Use Windows functions to replace the IRIS GL readdisplay command.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="1fb65-282">mover/desenhar/pmove/pdraw/PCLOS relativa</span><span class="sxs-lookup"><span data-stu-id="1fb65-282">relative move/draw/pmove/pdraw/pclos</span></span> | <span data-ttu-id="1fb65-283">O OpenGL não mantém uma posição de gráficos atual e, portanto, não oferece suporte a operações de vértice relativas.</span><span class="sxs-lookup"><span data-stu-id="1fb65-283">OpenGL doesn't maintain a current graphics position, and therefore doesn't support relative vertex operations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="1fb65-284">RGBA logicop ()</span><span class="sxs-lookup"><span data-stu-id="1fb65-284">RGBA logicop()</span></span>                       | <span data-ttu-id="1fb65-285">O OpenGL não oferece suporte a operações lógicas em buffers RGBA.</span><span class="sxs-lookup"><span data-stu-id="1fb65-285">OpenGL does not support logical operations on RGBA buffers.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="1fb65-286">sbox()</span><span class="sxs-lookup"><span data-stu-id="1fb65-286">sbox()</span></span>                               | <span data-ttu-id="1fb65-287">SBOX é um primitivo de retângulo do íris GL que é bem definido somente se transformado sem rotação.</span><span class="sxs-lookup"><span data-stu-id="1fb65-287">sbox is an IRIS GL rectangle primitive that is well-defined only if transformed without rotation.</span></span> <span data-ttu-id="1fb65-288">Ele foi projetado para ser renderizado mais rápido que os retângulos padrão.</span><span class="sxs-lookup"><span data-stu-id="1fb65-288">It is designed to be rendered faster than standard rectangles.</span></span> <span data-ttu-id="1fb65-289">Embora o OpenGL não dê suporte a tal primitivo, ele pode ser ajustado para renderizar retângulos muito rapidamente quando as matrizes e outros modos estão em Estados que simplificam os cálculos.</span><span class="sxs-lookup"><span data-stu-id="1fb65-289">While OpenGL doesn't support such a primitive, it can be tuned to render rectangles very quickly when the matrices and other modes are in states that simplify calculations.</span></span>                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="1fb65-290">argumentos escalares</span><span class="sxs-lookup"><span data-stu-id="1fb65-290">scalar arguments</span></span>                     | <span data-ttu-id="1fb65-291">Todos os comandos OpenGL que são aceitos entre glBegin e glEnd têm pontos de entrada que aceitam argumentos escalares.</span><span class="sxs-lookup"><span data-stu-id="1fb65-291">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept scalar arguments.</span></span> <span data-ttu-id="1fb65-292">Por exemplo, glColor4f (vermelho, verde, azul, alfa).</span><span class="sxs-lookup"><span data-stu-id="1fb65-292">For example, glColor4f (red, green, blue, alpha ).</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="1fb65-293">tesoura</span><span class="sxs-lookup"><span data-stu-id="1fb65-293">scissor</span></span>                              | <span data-ttu-id="1fb65-294">A função OpenGL glScissor não rastreia o visor.</span><span class="sxs-lookup"><span data-stu-id="1fb65-294">The OpenGL glScissor function doesn't track the viewport.</span></span> <span data-ttu-id="1fb65-295">O comando do visor da íris GL atualiza automaticamente o scrmask.</span><span class="sxs-lookup"><span data-stu-id="1fb65-295">The IRIS GL viewport command automatically updates the scrmask.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="1fb65-296">scrbox()</span><span class="sxs-lookup"><span data-stu-id="1fb65-296">scrbox()</span></span>                             | <span data-ttu-id="1fb65-297">O OpenGL não dá suporte à computação de caixa delimitadora.</span><span class="sxs-lookup"><span data-stu-id="1fb65-297">OpenGL doesn't support bounding box computation.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="1fb65-298">scrsubdivide()</span><span class="sxs-lookup"><span data-stu-id="1fb65-298">scrsubdivide()</span></span>                       | <span data-ttu-id="1fb65-299">OpenGL não dá suporte à subdivisão de tela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-299">OpenGL doesn't support screen subdivision.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="1fb65-300">modo matriz única</span><span class="sxs-lookup"><span data-stu-id="1fb65-300">single matrix mode</span></span>                   | <span data-ttu-id="1fb65-301">O OpenGL sempre mantém duas matrizes: ModelView e projeção.</span><span class="sxs-lookup"><span data-stu-id="1fb65-301">OpenGL always maintains two matrices: ModelView and Projection.</span></span> <span data-ttu-id="1fb65-302">Embora uma implementação de OpenGL possa consolidar isso em uma única matriz por motivos de desempenho, ela sempre deve apresentar o modelo de duas matrizes ao programador.</span><span class="sxs-lookup"><span data-stu-id="1fb65-302">While an OpenGL implementation can consolidate these into a single matrix for performance reasons, it must always present the two-matrix model to the programmer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| <span data-ttu-id="1fb65-303">modo de subpixel</span><span class="sxs-lookup"><span data-stu-id="1fb65-303">subpixel mode</span></span>                        | <span data-ttu-id="1fb65-304">Toda a renderização OpenGL é o modo positionedsubpixel de subpixel está sempre ativado.</span><span class="sxs-lookup"><span data-stu-id="1fb65-304">All OpenGL rendering is subpixel positionedsubpixel mode is always on.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="1fb65-305">swaptmesh()</span><span class="sxs-lookup"><span data-stu-id="1fb65-305">swaptmesh()</span></span>                          | <span data-ttu-id="1fb65-306">O OpenGL não dá suporte à funcionalidade swaptmesh.</span><span class="sxs-lookup"><span data-stu-id="1fb65-306">OpenGL doesn't support the swaptmesh capability.</span></span> <span data-ttu-id="1fb65-307">Ele oferece dois tipos de malhas de triângulos, no entanto: um que corresponde ao comportamento padrão de "strip" do íris GL e outro que corresponde à chamada de swaptmesh antes do terceiro e de todos os vértices subsequentes ao usar o íris GL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-307">It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling swaptmesh prior to the third and all subsequent vertices when using IRIS GL.</span></span>                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="1fb65-308">argumentos de vetor</span><span class="sxs-lookup"><span data-stu-id="1fb65-308">vector arguments</span></span>                     | <span data-ttu-id="1fb65-309">Todos os comandos OpenGL que são aceitos entre glBegin e glEnd têm pontos de entrada que aceitam argumentos de vetor.</span><span class="sxs-lookup"><span data-stu-id="1fb65-309">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept vector arguments.</span></span> <span data-ttu-id="1fb65-310">Por exemplo, glColor4fv.</span><span class="sxs-lookup"><span data-stu-id="1fb65-310">For example, glColor4fv .</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="1fb65-311">gerenciamento de janela</span><span class="sxs-lookup"><span data-stu-id="1fb65-311">window management</span></span>                    | <span data-ttu-id="1fb65-312">O OpenGL não inclui nenhum comando do sistema de janelas.</span><span class="sxs-lookup"><span data-stu-id="1fb65-312">OpenGL includes no window system commands.</span></span> <span data-ttu-id="1fb65-313">Ele sempre tem suporte como uma extensão para uma janela ou sistema operacional que inclui recursos para o controle de dispositivo e janela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-313">It is always supported as an extension to a window or operating system that includes capability for device and window control.</span></span> <span data-ttu-id="1fb65-314">Cada extensão fornece um mecanismo específico do sistema para criar, destruir e manipular contextos de renderização OpenGL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-314">Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts.</span></span> <span data-ttu-id="1fb65-315">Por exemplo, a extensão OpenGL para o sistema de janelas X (GLX) inclui aproximadamente 10 comandos para essa finalidade.</span><span class="sxs-lookup"><span data-stu-id="1fb65-315">For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.</span></span> <span data-ttu-id="1fb65-316">Os comandos da íris GL, como gconfig e DrawMode, não são implementados pelo OpenGL.</span><span class="sxs-lookup"><span data-stu-id="1fb65-316">IRIS GL commands such as gconfig and drawmode are not implemented by OpenGL.</span></span>                                                                                                                                                                            |
| <span data-ttu-id="1fb65-317">deslocamento da janela</span><span class="sxs-lookup"><span data-stu-id="1fb65-317">window offset</span></span>                        | <span data-ttu-id="1fb65-318">A íris GL retorna as posições de visor e de caractere na tela, em vez de janelas, coordenadas.</span><span class="sxs-lookup"><span data-stu-id="1fb65-318">IRIS GL returns viewport and character positions in screen, rather than window, coordinates.</span></span> <span data-ttu-id="1fb65-319">O OpenGL sempre usa coordenadas de janela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-319">OpenGL always uses window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="1fb65-320">renderização z</span><span class="sxs-lookup"><span data-stu-id="1fb65-320">z rendering</span></span>                          | <span data-ttu-id="1fb65-321">O OpenGL não dá suporte à renderização de cores no buffer de profundidade.</span><span class="sxs-lookup"><span data-stu-id="1fb65-321">OpenGL doesn't support rendering colors to the depth buffer.</span></span> <span data-ttu-id="1fb65-322">Ele permite buffers de cores adicionais, que podem ser implementados usando a mesma memória usada para buffers de profundidade em outras configurações de janela.</span><span class="sxs-lookup"><span data-stu-id="1fb65-322">It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurations.</span></span> <span data-ttu-id="1fb65-323">Mas esses buffers de cores adicionais não podem compartilhar memória com o buffer de profundidade em qualquer configuração única.</span><span class="sxs-lookup"><span data-stu-id="1fb65-323">But these additional color buffers cannot share memory with the depth buffer in any single configuration.</span></span>                                                                                                                                                                                                                                                                                                                                          |



 

 

 




