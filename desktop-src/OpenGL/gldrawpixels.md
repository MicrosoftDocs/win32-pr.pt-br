---
title: função glDrawPixels (GL. h)
description: A função glDrawPixels grava um bloco de pixels no framebuffer.
ms.assetid: c4eda64f-a75e-4e6d-984d-af49414b94d8
keywords:
- função glDrawPixels OpenGL
topic_type:
- apiref
api_name:
- glDrawPixels
api_location:
- opengl32.dll
api_type:
- DllExport
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: e25adc8ad28791086020a37d3a30651e169bfd07
ms.sourcegitcommit: a1494c819bc5200050696e66057f1020f5b142cb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/12/2020
ms.locfileid: "104085323"
---
# <a name="gldrawpixels-function"></a><span data-ttu-id="fee2d-104">função glDrawPixels</span><span class="sxs-lookup"><span data-stu-id="fee2d-104">glDrawPixels function</span></span>

<span data-ttu-id="fee2d-105">A função **glDrawPixels** grava um bloco de pixels no framebuffer.</span><span class="sxs-lookup"><span data-stu-id="fee2d-105">The **glDrawPixels** function writes a block of pixels to the framebuffer.</span></span>

## <a name="syntax"></a><span data-ttu-id="fee2d-106">Sintaxe</span><span class="sxs-lookup"><span data-stu-id="fee2d-106">Syntax</span></span>


```C++
void WINAPI glDrawPixels(
         GLsizei width,
         GLsizei height,
         GLenum  format,
         GLenum  type,
   const GLvoid  *pixels
);
```



## <a name="parameters"></a><span data-ttu-id="fee2d-107">Parâmetros</span><span class="sxs-lookup"><span data-stu-id="fee2d-107">Parameters</span></span>

<dl> <dt>

<span data-ttu-id="fee2d-108">*width*</span><span class="sxs-lookup"><span data-stu-id="fee2d-108">*width*</span></span> 
</dt> <dd>

<span data-ttu-id="fee2d-109">A dimensão de largura do retângulo de pixel que será gravada no framebuffer.</span><span class="sxs-lookup"><span data-stu-id="fee2d-109">The width dimension of the pixel rectangle that will be written into the framebuffer.</span></span>

</dd> <dt>

<span data-ttu-id="fee2d-110">*altura*</span><span class="sxs-lookup"><span data-stu-id="fee2d-110">*height*</span></span> 
</dt> <dd>

<span data-ttu-id="fee2d-111">A dimensão de altura do retângulo de pixel que será gravada no framebuffer.</span><span class="sxs-lookup"><span data-stu-id="fee2d-111">The height dimension of the pixel rectangle that will be written into the framebuffer.</span></span>

</dd> <dt>

<span data-ttu-id="fee2d-112">*format*</span><span class="sxs-lookup"><span data-stu-id="fee2d-112">*format*</span></span> 
</dt> <dd>

<span data-ttu-id="fee2d-113">O formato dos dados de pixel.</span><span class="sxs-lookup"><span data-stu-id="fee2d-113">The format of the pixel data.</span></span> <span data-ttu-id="fee2d-114">As constantes simbólicas aceitáveis são as seguintes.</span><span class="sxs-lookup"><span data-stu-id="fee2d-114">Acceptable symbolic constants are as follows.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="fee2d-115">Valor</span><span class="sxs-lookup"><span data-stu-id="fee2d-115">Value</span></span></th>
<th><span data-ttu-id="fee2d-116">Significado</span><span class="sxs-lookup"><span data-stu-id="fee2d-116">Meaning</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl> <span data-ttu-id="fee2d-117"><dt><strong>GL_COLOR_INDEX</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-117"><dt><strong>GL_COLOR_INDEX</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-118">Cada pixel é um único valor, um índice de cores.</span><span class="sxs-lookup"><span data-stu-id="fee2d-118">Each pixel is a single value, a color index.</span></span> <br/>
<ol>
<li><span data-ttu-id="fee2d-119">A função <strong>glDrawPixels</strong> converte cada pixel em formato de ponto fixo, com um número não especificado de bits à direita do ponto binário, independentemente do tipo de dados de memória.</span><span class="sxs-lookup"><span data-stu-id="fee2d-119">The <strong>glDrawPixels</strong> function converts each pixel to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type.</span></span> <span data-ttu-id="fee2d-120">Os valores de ponto flutuante são convertidos em valores de ponto fixo verdadeiros.</span><span class="sxs-lookup"><span data-stu-id="fee2d-120">Floating-point values convert to true fixed-point values.</span></span> <span data-ttu-id="fee2d-121">A função <strong>glDrawPixels</strong> converte dados inteiros assinados e não assinados com todos os bits de fração definidos como zero.</span><span class="sxs-lookup"><span data-stu-id="fee2d-121">The <strong>glDrawPixels</strong> function converts signed and unsigned integer data with all fraction bits set to zero.</span></span> <span data-ttu-id="fee2d-122">A função converte dados de bitmap para 0,0 ou 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-122">The function converts bitmap data to either 0.0 or 1.0.</span></span></li>
<li><span data-ttu-id="fee2d-123">A função <strong>glDrawPixels</strong> desloca cada índice de ponto fixo à esquerda por GL_INDEX_SHIFT bits e o adiciona ao GL_INDEX_OFFSET.</span><span class="sxs-lookup"><span data-stu-id="fee2d-123">The <strong>glDrawPixels</strong> function shifts each fixed-point index left by GL_INDEX_SHIFT bits and adds it to GL_INDEX_OFFSET.</span></span> <span data-ttu-id="fee2d-124">Se GL_INDEX_SHIFT for negativo, a mudança será à direita.</span><span class="sxs-lookup"><span data-stu-id="fee2d-124">If GL_INDEX_SHIFT is negative, the shift is to the right.</span></span> <span data-ttu-id="fee2d-125">Em ambos os casos, zero bits ocupam locais de bits não especificados no resultado.</span><span class="sxs-lookup"><span data-stu-id="fee2d-125">In either case, zero bits fill otherwise unspecified bit locations in the result.</span></span></li>
<li><span data-ttu-id="fee2d-126">No modo RGBA, <strong>glDrawPixels</strong> converte o índice resultante em um pixel RGBA usando as tabelas GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B e GL_PIXEL_MAP_I_TO_A.</span><span class="sxs-lookup"><span data-stu-id="fee2d-126">When in RGBA mode, <strong>glDrawPixels</strong> converts the resulting index to an RGBA pixel using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables.</span></span> <span data-ttu-id="fee2d-127">Quando estiver no modo de índice de cor e GL_MAP_COLOR for true, o índice será substituído pelo valor que <strong>glDrawPixels</strong> referencia na tabela de pesquisa GL_PIXEL_MAP_I_TO_I.</span><span class="sxs-lookup"><span data-stu-id="fee2d-127">When in the color-index mode and GL_MAP_COLOR is true, the index is replaced with the value that <strong>glDrawPixels</strong> references in lookup table GL_PIXEL_MAP_I_TO_I.</span></span></li>
<li><span data-ttu-id="fee2d-128">Se a substituição da pesquisa do índice for concluída ou não, a parte inteira do índice será <strong>e</strong>Ed com 2<sup>b</sup> - 1, em que <em>b</em> é o número de bits em um buffer de índice de cor.</span><span class="sxs-lookup"><span data-stu-id="fee2d-128">Whether the lookup replacement of the index is done or not, the integer part of the index is <strong>AND</strong>ed with 2<sup>b</sup> - 1, where <em>b</em> is the number of bits in a color-index buffer.</span></span></li>
<li><span data-ttu-id="fee2d-129">Os índices resultantes ou as cores RGBA são então convertidas em fragmentos anexando as coordenadas de coordenadas <em>z</em>e de textura atuais a cada pixel e, em seguida, atribuindo coordenadas de janela <em>x</em> e <em>y</em> ao <em>n</em>º de fragmento como <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-129">The resulting indexes or RGBA colors are then converted to fragments by attaching the current raster position <em>z</em>-coordinate and texture coordinates to each pixel, and then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em>th fragment such that <em>x</em>?</span></span><span data-ttu-id="fee2d-130"> = <em>largura</em> <em>x</em><sub>r</sub> + <em>n</em> mod</span><span class="sxs-lookup"><span data-stu-id="fee2d-130"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="fee2d-131"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-131"><em>y</em>?</span></span><span data-ttu-id="fee2d-132"> = <em>y</em><sub>r</sub> + <em>n/largura</em></span><span class="sxs-lookup"><span data-stu-id="fee2d-132"> = <em>y</em><sub>r</sub> + <em>n/width</em></span></span><br/> <span data-ttu-id="fee2d-133">onde (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) é a posição atual da varredura.</span><span class="sxs-lookup"><span data-stu-id="fee2d-133">where (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) is the current raster position.</span></span><br/></li>
<li><span data-ttu-id="fee2d-134">A função <strong>glDrawPixels</strong> trata esses fragmentos de pixel, assim como os fragmentos gerados pela rasterização de pontos, linhas ou polígonos.</span><span class="sxs-lookup"><span data-stu-id="fee2d-134">The <strong>glDrawPixels</strong> function treats these pixel fragments just like the fragments generated by rasterizing points, lines, or polygons.</span></span> <span data-ttu-id="fee2d-135">Ele aplica o mapeamento de textura, sombra e todas as operações de fragmento antes de gravar os fragmentos no framebuffer.</span><span class="sxs-lookup"><span data-stu-id="fee2d-135">It applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</span></span></li>
</ol></td>
</tr>
<tr class="even">
<td><span id="GL_STENCIL_INDEX"></span><span id="gl_stencil_index"></span><dl> <span data-ttu-id="fee2d-136"><dt><strong>GL_STENCIL_INDEX</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-136"><dt><strong>GL_STENCIL_INDEX</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-137">Cada pixel é um único valor, um índice de estêncil.</span><span class="sxs-lookup"><span data-stu-id="fee2d-137">Each pixel is a single value, a stencil index.</span></span> <br/>
<ol>
<li><span data-ttu-id="fee2d-138">A função <strong>glDrawPixels</strong> converte-o em formato de ponto fixo, com um número não especificado de bits à direita do ponto binário, independentemente do tipo de dados de memória.</span><span class="sxs-lookup"><span data-stu-id="fee2d-138">The <strong>glDrawPixels</strong> function converts it to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type.</span></span> <span data-ttu-id="fee2d-139">Os valores de ponto flutuante são convertidos em valores de ponto fixo verdadeiros.</span><span class="sxs-lookup"><span data-stu-id="fee2d-139">Floating-point values convert to true fixed-point values.</span></span> <span data-ttu-id="fee2d-140">A função <strong>glDrawPixels</strong> converte dados inteiros assinados e não assinados com todos os bits de fração definidos como zero.</span><span class="sxs-lookup"><span data-stu-id="fee2d-140">The <strong>glDrawPixels</strong> function converts signed and unsigned integer data with all fraction bits set to zero.</span></span> <span data-ttu-id="fee2d-141">Os dados de bitmap são convertidos em 0,0 ou 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-141">Bitmap data converts to either 0.0 or 1.0.</span></span></li>
<li><span data-ttu-id="fee2d-142">A função <strong>glDrawPixels</strong> desloca cada índice de ponto fixo à esquerda por GL_INDEX_SHIFT bits e o adiciona ao GL_INDEX_OFFSET.</span><span class="sxs-lookup"><span data-stu-id="fee2d-142">The <strong>glDrawPixels</strong> function shifts each fixed-point index left by GL_INDEX_SHIFT bits, and adds it to GL_INDEX_OFFSET.</span></span> <span data-ttu-id="fee2d-143">Se GL_INDEX_SHIFT for negativo, a mudança será à direita.</span><span class="sxs-lookup"><span data-stu-id="fee2d-143">If GL_INDEX_SHIFT is negative, the shift is to the right.</span></span> <span data-ttu-id="fee2d-144">Em ambos os casos, zero bits ocupam locais de bits não especificados no resultado.</span><span class="sxs-lookup"><span data-stu-id="fee2d-144">In either case, zero bits fill otherwise unspecified bit locations in the result.</span></span></li>
<li><span data-ttu-id="fee2d-145">Se GL_MAP_STENCIL for true, o índice será substituído pelo valor que <strong>glDrawPixels</strong> faz referência na tabela de pesquisa GL_PIXEL_MAP_S_TO_S.</span><span class="sxs-lookup"><span data-stu-id="fee2d-145">If GL_MAP_STENCIL is true, the index is replaced with the value that <strong>glDrawPixels</strong> references in lookup table GL_PIXEL_MAP_S_TO_S.</span></span></li>
<li><span data-ttu-id="fee2d-146">Se a substituição da pesquisa do índice for concluída ou não, a parte inteira do índice será <strong>, então,</strong>Ed com 2<sup>b</sup> - 1, em que <em>b</em> é o número de bits no buffer do estêncil.</span><span class="sxs-lookup"><span data-stu-id="fee2d-146">Whether the lookup replacement of the index is done or not, the integer part of the index is then <strong>AND</strong>ed with 2<sup>b</sup> - 1, where <em>b</em> is the number of bits in the stencil buffer.</span></span> <span data-ttu-id="fee2d-147">Os índices de estêncil resultantes são gravados no buffer de estêncil, de modo que o <em>n</em>º de índice é gravado no local <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-147">The resulting stencil indexes are then written to the stencil buffer such that the <em>n</em>th index is written to location <em>x</em>?</span></span><span data-ttu-id="fee2d-148"> = <em>largura</em> <em>x</em><sub>r</sub> + <em>n</em> mod</span><span class="sxs-lookup"><span data-stu-id="fee2d-148"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="fee2d-149"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-149"><em>y</em>?</span></span><span data-ttu-id="fee2d-150"> = <em>y</em><sub>r</sub> + <em>n/largura</em></span><span class="sxs-lookup"><span data-stu-id="fee2d-150"> = <em>y</em><sub>r</sub> + <em>n/width</em></span></span><br/> <span data-ttu-id="fee2d-151">onde (<em>x</em><sub>r</sub> , <em></em> y<sub>r</sub> ) é a posição atual da varredura.</span><span class="sxs-lookup"><span data-stu-id="fee2d-151">where (<em>x</em><sub>r</sub> ,<em></em>y<sub>r</sub> ) is the current raster position.</span></span> <span data-ttu-id="fee2d-152">Somente o teste de propriedade de pixel, o teste de tesoura e o estêncil writemask afetam essas gravações.</span><span class="sxs-lookup"><span data-stu-id="fee2d-152">Only the pixel ownership test, the scissor test, and the stencil writemask affect these writes.</span></span><br/></li>
</ol></td>
</tr>
<tr class="odd">
<td><span id="GL_DEPTH_COMPONENT"></span><span id="gl_depth_component"></span><dl> <span data-ttu-id="fee2d-153"><dt><strong>GL_DEPTH_COMPONENT</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-153"><dt><strong>GL_DEPTH_COMPONENT</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-154">Cada pixel é um componente de profundidade única.</span><span class="sxs-lookup"><span data-stu-id="fee2d-154">Each pixel is a single-depth component.</span></span> <br/>
<ol>
<li><span data-ttu-id="fee2d-155">A função <strong>glDrawPixels</strong> converte dados de ponto flutuante diretamente em um formato de ponto flutuante interno com precisão não especificada.</span><span class="sxs-lookup"><span data-stu-id="fee2d-155">The <strong>glDrawPixels</strong> function converts floating-point data directly to an internal floating-point format with unspecified precision.</span></span> <span data-ttu-id="fee2d-156">Os dados inteiros assinados são mapeados linearmente para o formato de ponto flutuante interno, de modo que o valor inteiro representável mais positivo seja mapeado para 1,0 e o valor reapresentável mais negativo seja mapeado para-1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-156">Signed integer data is mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0.</span></span> <span data-ttu-id="fee2d-157">Os dados inteiros não assinados são mapeados da mesma forma: o maior valor inteiro é mapeado para 1,0 e zero é mapeado para 0,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-157">Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.</span></span></li>
<li><span data-ttu-id="fee2d-158">A função <strong>glDrawPixels</strong> multiplica o valor de profundidade de ponto flutuante resultante por GL_DEPTH_SCALE e o adiciona ao GL_DEPTH_BIAS.</span><span class="sxs-lookup"><span data-stu-id="fee2d-158">The <strong>glDrawPixels</strong> function multiplies the resulting floating-point depth value by GL_DEPTH_SCALE and adds it to GL_DEPTH_BIAS.</span></span> <span data-ttu-id="fee2d-159">O resultado é clamped para o intervalo [0, 1].</span><span class="sxs-lookup"><span data-stu-id="fee2d-159">The result is clamped to the range [0,1].</span></span></li>
<li><span data-ttu-id="fee2d-160">A função <strong>glDrawPixels</strong> converte os componentes de profundidade resultantes em fragmentos anexando a cor atual da posição de varredura ou as coordenadas de textura e índice de cor a cada pixel e, em seguida, atribuindo coordenadas de janela <em>x</em> e <em>y</em> ao <em>n</em> º de fragmento como <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-160">The <strong>glDrawPixels</strong> function converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, and then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em> th fragment such that <em>x</em>?</span></span><span data-ttu-id="fee2d-161"> = <em></em><em>largura</em> x<sub>r</sub> + <em>n</em> mod</span><span class="sxs-lookup"><span data-stu-id="fee2d-161"> = <em></em>x<sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="fee2d-162"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-162"><em>y</em>?</span></span><span data-ttu-id="fee2d-163"> = <em>y</em><sub>r</sub> + <em>n/largura</em></span><span class="sxs-lookup"><span data-stu-id="fee2d-163"> = <em>y</em><sub>r</sub> + <em>n/width</em></span></span><br/> <span data-ttu-id="fee2d-164">onde ( <em></em> x<sub>r</sub> ,<em>y</em><sub>r</sub> ) é a posição atual da varredura.</span><span class="sxs-lookup"><span data-stu-id="fee2d-164">where (<em></em>x<sub>r</sub> ,<em>y</em><sub>r</sub> ) is the current raster position.</span></span><br/></li>
<li><span data-ttu-id="fee2d-165">Esses fragmentos de pixel são tratados exatamente como os fragmentos gerados pela rasterização de pontos, linhas ou polígonos.</span><span class="sxs-lookup"><span data-stu-id="fee2d-165">These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.</span></span> <span data-ttu-id="fee2d-166">A função <strong>glDrawPixels</strong> aplica o mapeamento de textura, sombra e todas as operações de fragmento antes de gravar os fragmentos no framebuffer.</span><span class="sxs-lookup"><span data-stu-id="fee2d-166">The <strong>glDrawPixels</strong> function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</span></span></li>
</ol></td>
</tr>
<tr class="even">
<td><span id="GL_RGBA"></span><span id="gl_rgba"></span><dl> <span data-ttu-id="fee2d-167"><dt><strong>GL_RGBA</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-167"><dt><strong>GL_RGBA</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-168">Cada pixel é um grupo de quatro componentes nesta ordem: vermelho, verde, azul, alfa.</span><span class="sxs-lookup"><span data-stu-id="fee2d-168">Each pixel is a four-component group in this order: red, green, blue, alpha.</span></span> <br/>
<ol>
<li><span data-ttu-id="fee2d-169">A função <strong>glDrawPixels</strong> converte valores de ponto flutuante diretamente em um formato de ponto flutuante interno com precisão não especificada.</span><span class="sxs-lookup"><span data-stu-id="fee2d-169">The <strong>glDrawPixels</strong> function converts floating-point values directly to an internal floating-point format with unspecified precision.</span></span> <span data-ttu-id="fee2d-170">Valores inteiros assinados são mapeados linearmente para o formato de ponto flutuante interno, de modo que o valor inteiro representável mais positivo seja mapeado para 1,0 e o valor reapresentável mais negativo seja mapeado para-1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-170">Signed integer values are mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0.</span></span> <span data-ttu-id="fee2d-171">Os dados inteiros não assinados são mapeados da mesma forma: o maior valor inteiro é mapeado para 1,0 e zero é mapeado para 0,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-171">Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.</span></span></li>
<li><span data-ttu-id="fee2d-172">A função <strong>glDrawPixels</strong> multiplica os valores de cor de ponto flutuante resultantes por GL_c_SCALE e os adiciona ao GL_c_BIAS, em que <em>c</em> é vermelho, verde, azul e alfa para os respectivos componentes de cor.</span><span class="sxs-lookup"><span data-stu-id="fee2d-172">The <strong>glDrawPixels</strong> function multiplies the resulting floating-point color values by GL_c_SCALE and adds them to GL_c_BIAS, where <em>c</em> is RED, GREEN, BLUE, and ALPHA for the respective color components.</span></span> <span data-ttu-id="fee2d-173">Os resultados são clamped para o intervalo [0, 1].</span><span class="sxs-lookup"><span data-stu-id="fee2d-173">The results are clamped to the range [0,1].</span></span></li>
<li><span data-ttu-id="fee2d-174">Se GL_MAP_COLOR for true, <strong>glDrawPixels</strong> dimensionará cada componente de cor pelo tamanho da tabela de pesquisa GL_PIXEL_MAP_c_TO_c e, em seguida, substituirá o componente pelo valor que ele faz referência a essa tabela; <em>c</em> é R, G, B ou A, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="fee2d-174">If GL_MAP_COLOR is true, <strong>glDrawPixels</strong> scales each color component by the size of lookup table GL_PIXEL_MAP_c_TO_c, and then replaces the component by the value that it references in that table; <em>c</em> is R, G, B, or A, respectively.</span></span></li>
<li><span data-ttu-id="fee2d-175">A função <strong>glDrawPixels</strong> converte as cores de RGBA resultantes em fragmentos anexando as coordenadas de coordenadas <em>z</em>e de textura atuais a cada pixel e, em seguida, atribuindo coordenadas de janela <em>x</em> e <em>y</em> ao <em>n</em>º de fragmento como <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-175">The <strong>glDrawPixels</strong> function converts the resulting RGBA colors to fragments by attaching the current raster position <em>z</em>-coordinate and texture coordinates to each pixel, then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em>th fragment such that <em>x</em>?</span></span><span data-ttu-id="fee2d-176"> = <em>largura</em> <em>x</em><sub>r</sub> + <em>n</em> mod</span><span class="sxs-lookup"><span data-stu-id="fee2d-176"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="fee2d-177"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="fee2d-177"><em>y</em>?</span></span><span data-ttu-id="fee2d-178"> = <em>y</em><sub>r</sub> + <em>n/Width</em></span><span class="sxs-lookup"><span data-stu-id="fee2d-178"> = <em>y</em><sub>r</sub> + <em>n /width</em></span></span><br/> <span data-ttu-id="fee2d-179">onde (<em>x</em><sub>r</sub> ,<em>y</em><sub>r</sub> ) é a posição atual da varredura.</span><span class="sxs-lookup"><span data-stu-id="fee2d-179">where (<em>x</em><sub>r</sub> ,<em>y</em><sub>r</sub> ) is the current raster position.</span></span><br/></li>
<li><span data-ttu-id="fee2d-180">Esses fragmentos de pixel são tratados exatamente como os fragmentos gerados pela rasterização de pontos, linhas ou polígonos.</span><span class="sxs-lookup"><span data-stu-id="fee2d-180">These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.</span></span> <span data-ttu-id="fee2d-181">A função <strong>glDrawPixels</strong> aplica o mapeamento de textura, sombra e todas as operações de fragmento antes de gravar os fragmentos no framebuffer.</span><span class="sxs-lookup"><span data-stu-id="fee2d-181">The <strong>glDrawPixels</strong> function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</span></span></li>
</ol></td>
</tr>
<tr class="odd">
<td><span id="GL_RED"></span><span id="gl_red"></span><dl> <span data-ttu-id="fee2d-182"><dt><strong>GL_RED</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-182"><dt><strong>GL_RED</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-183">Cada pixel é um único componente vermelho.</span><span class="sxs-lookup"><span data-stu-id="fee2d-183">Each pixel is a single red component.</span></span><br/> <span data-ttu-id="fee2d-184">A função <strong>glDrawPixels</strong> converte esse componente no formato de ponto flutuante interno da mesma forma que o componente vermelho de um pixel RGBA e, em seguida, converte-o em um pixel RGBA com verde e azul definido como 0,0 e alfa definido como 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-184">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with green and blue set to 0.0, and alpha set to 1.0.</span></span> <span data-ttu-id="fee2d-185">Após essa conversão, o pixel é tratado da mesma forma como se tivesse sido lido como um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-185">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_GREEN"></span><span id="gl_green"></span><dl> <span data-ttu-id="fee2d-186"><dt><strong>GL_GREEN</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-186"><dt><strong>GL_GREEN</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-187">Cada pixel é um único componente verde.</span><span class="sxs-lookup"><span data-stu-id="fee2d-187">Each pixel is a single green component.</span></span><br/> <span data-ttu-id="fee2d-188">A função <strong>glDrawPixels</strong> converte esse componente no formato de ponto flutuante interno da mesma forma que o componente verde de um pixel RGBA e, em seguida, converte-o em um pixel RGBA com vermelho e azul definido como 0,0 e alfa definido como 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-188">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the green component of an RGBA pixel is, and then converts it to an RGBA pixel with red and blue set to 0.0, and alpha set to 1.0.</span></span> <span data-ttu-id="fee2d-189">Após essa conversão, o pixel é tratado da mesma forma como se tivesse sido lido como um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-189">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_BLUE"></span><span id="gl_blue"></span><dl> <span data-ttu-id="fee2d-190"><dt><strong>GL_BLUE</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-190"><dt><strong>GL_BLUE</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-191">Cada pixel é um único componente azul.</span><span class="sxs-lookup"><span data-stu-id="fee2d-191">Each pixel is a single blue component.</span></span><br/> <span data-ttu-id="fee2d-192">A função <strong>glDrawPixels</strong> converte esse componente no formato de ponto flutuante interno da mesma forma que o componente azul de um pixel RGBA e, em seguida, converte-o em um pixel RGBA com vermelho e verde definido como 0,0 e alfa definido como 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-192">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the blue component of an RGBA pixel is, and then converts it to an RGBA pixel with red and green set to 0.0, and alpha set to 1.0.</span></span> <span data-ttu-id="fee2d-193">Após essa conversão, o pixel é tratado da mesma forma como se tivesse sido lido como um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-193">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_ALPHA"></span><span id="gl_alpha"></span><dl> <span data-ttu-id="fee2d-194"><dt><strong>GL_ALPHA</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-194"><dt><strong>GL_ALPHA</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-195">Cada pixel é um único componente alfa.</span><span class="sxs-lookup"><span data-stu-id="fee2d-195">Each pixel is a single alpha component.</span></span><br/> <span data-ttu-id="fee2d-196">A função <strong>glDrawPixels</strong> converte esse componente no formato de ponto flutuante interno da mesma forma que o componente alfa de um pixel RGBA e, em seguida, converte-o em um pixel RGBA com vermelho, verde e azul definido como 0,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-196">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the alpha component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to 0.0.</span></span> <span data-ttu-id="fee2d-197">Após essa conversão, o pixel é tratado da mesma forma como se tivesse sido lido como um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-197">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_RGB"></span><span id="gl_rgb"></span><dl> <span data-ttu-id="fee2d-198"><dt><strong>GL_RGB</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-198"><dt><strong>GL_RGB</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-199">Cada pixel é um grupo de três componentes nesta ordem: vermelho, verde, azul.</span><span class="sxs-lookup"><span data-stu-id="fee2d-199">Each pixel is a group of three components in this order: red, green, blue.</span></span> <span data-ttu-id="fee2d-200">A função <strong>glDrawPixels</strong> converte cada componente no formato de ponto flutuante interno da mesma forma que os componentes vermelho, verde e azul de um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-200">The <strong>glDrawPixels</strong> function converts each component to the internal floating-point format in the same way that the red, green, and blue components of an RGBA pixel are.</span></span> <span data-ttu-id="fee2d-201">A cor tripla é convertida em um pixel RGBA com alfa definido como 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-201">The color triple is converted to an RGBA pixel with alpha set to 1.0.</span></span> <span data-ttu-id="fee2d-202">Após essa conversão, o pixel é tratado da mesma forma como se tivesse sido lido como um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-202">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_LUMINANCE"></span><span id="gl_luminance"></span><dl> <span data-ttu-id="fee2d-203"><dt><strong>GL_LUMINANCE</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-203"><dt><strong>GL_LUMINANCE</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-204">Cada pixel é um único componente de luminância.</span><span class="sxs-lookup"><span data-stu-id="fee2d-204">Each pixel is a single luminance component.</span></span><br/> <span data-ttu-id="fee2d-205">A função <strong>glDrawPixels</strong> converte esse componente no formato de ponto flutuante interno da mesma forma que o componente vermelho de um pixel RGBA e, em seguida, converte-o em um pixel RGBA com vermelho, verde e azul definido como o valor de luminância convertido e alfa definido como 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-205">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to 1.0.</span></span> <span data-ttu-id="fee2d-206">Após essa conversão, o pixel é tratado da mesma forma como se tivesse sido lido como um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-206">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_LUMINANCE_ALPHA"></span><span id="gl_luminance_alpha"></span><dl> <span data-ttu-id="fee2d-207"><dt><strong>GL_LUMINANCE_ALPHA</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-207"><dt><strong>GL_LUMINANCE_ALPHA</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-208">Cada pixel é um grupo de dois componentes nesta ordem: luminância, alfa.</span><span class="sxs-lookup"><span data-stu-id="fee2d-208">Each pixel is a group of two components in this order: luminance, alpha.</span></span><br/> <span data-ttu-id="fee2d-209">A função <strong>glDrawPixels</strong> converte os dois componentes no formato de ponto flutuante interno da mesma maneira que o componente vermelho de um pixel RGBA e os converte em um pixel RGBA com vermelho, verde e azul definido como o valor de luminância convertido e alfa definido para o valor alfa convertido.</span><span class="sxs-lookup"><span data-stu-id="fee2d-209">The <strong>glDrawPixels</strong> function converts the two components to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts them to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to the converted alpha value.</span></span> <span data-ttu-id="fee2d-210">Após essa conversão, o pixel é tratado da mesma forma como se tivesse sido lido como um pixel RGBA.</span><span class="sxs-lookup"><span data-stu-id="fee2d-210">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_BGR_EXT"></span><span id="gl_bgr_ext"></span><dl> <span data-ttu-id="fee2d-211"><dt><strong>GL_BGR_EXT</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-211"><dt><strong>GL_BGR_EXT</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-212">Cada pixel é um grupo de três componentes nesta ordem: azul, verde e vermelho.</span><span class="sxs-lookup"><span data-stu-id="fee2d-212">Each pixel is a group of three components in this order: blue, green, red.</span></span><br/> <span data-ttu-id="fee2d-213">GL_BGR_EXT fornece um formato que corresponde ao layout de memória dos bitmaps independentes de dispositivo do Windows (DIBs).</span><span class="sxs-lookup"><span data-stu-id="fee2d-213">GL_BGR_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs).</span></span> <span data-ttu-id="fee2d-214">Portanto, seus aplicativos podem usar os mesmos dados com chamadas de função do Windows e chamadas de função de pixel OpenGL.</span><span class="sxs-lookup"><span data-stu-id="fee2d-214">Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_BGRA_EXT"></span><span id="gl_bgra_ext"></span><dl> <span data-ttu-id="fee2d-215"><dt><strong>GL_BGRA_EXT</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="fee2d-215"><dt><strong>GL_BGRA_EXT</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="fee2d-216">Cada pixel é um grupo de quatro componentes nesta ordem: azul, verde, vermelho, alfa.</span><span class="sxs-lookup"><span data-stu-id="fee2d-216">Each pixel is a group of four components in this order: blue, green, red, alpha.</span></span><br/> <span data-ttu-id="fee2d-217">GL_BGRA_EXT fornece um formato que corresponde ao layout de memória dos bitmaps independentes de dispositivo do Windows (DIBs).</span><span class="sxs-lookup"><span data-stu-id="fee2d-217">GL_BGRA_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs).</span></span> <span data-ttu-id="fee2d-218">Portanto, seus aplicativos podem usar os mesmos dados com chamadas de função do Windows e chamadas de função de pixel OpenGL.</span><span class="sxs-lookup"><span data-stu-id="fee2d-218">Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.</span></span><br/></td>
</tr>
</tbody>
</table>



 

</dd> <dt>

<span data-ttu-id="fee2d-219">*tipo*</span><span class="sxs-lookup"><span data-stu-id="fee2d-219">*type*</span></span> 
</dt> <dd>

<span data-ttu-id="fee2d-220">O tipo de dados para *pixels*.</span><span class="sxs-lookup"><span data-stu-id="fee2d-220">The data type for *pixels*.</span></span> <span data-ttu-id="fee2d-221">A seguir estão as constantes simbólicas aceitas e seus significados.</span><span class="sxs-lookup"><span data-stu-id="fee2d-221">The following are the accepted symbolic constants and their meanings.</span></span>



| <span data-ttu-id="fee2d-222">Valor</span><span class="sxs-lookup"><span data-stu-id="fee2d-222">Value</span></span>                                                                                                                                                                      | <span data-ttu-id="fee2d-223">Significado</span><span class="sxs-lookup"><span data-stu-id="fee2d-223">Meaning</span></span>                                           |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| <span id="GL_UNSIGNED_BYTE"></span><span id="gl_unsigned_byte"></span><dl> <span data-ttu-id="fee2d-224"><dt>**\_byte não assinado GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-224"><dt>**GL\_UNSIGNED\_BYTE**</dt></span></span> </dl>    | <span data-ttu-id="fee2d-225">Inteiro de 8 bits sem sinal</span><span class="sxs-lookup"><span data-stu-id="fee2d-225">Unsigned 8-bit integer</span></span><br/>                 |
| <span id="GL_BYTE"></span><span id="gl_byte"></span><dl> <span data-ttu-id="fee2d-226"><dt>**\_byte GL**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-226"><dt>**GL\_BYTE**</dt></span></span> </dl>                                | <span data-ttu-id="fee2d-227">Inteiro de 8 bits com sinal</span><span class="sxs-lookup"><span data-stu-id="fee2d-227">Signed 8-bit integer</span></span><br/>                   |
| <span id="GL_BITMAP"></span><span id="gl_bitmap"></span><dl> <span data-ttu-id="fee2d-228"><dt>**\_bitmap GL**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-228"><dt>**GL\_BITMAP**</dt></span></span> </dl>                          | <span data-ttu-id="fee2d-229">Bits únicos em inteiros de 8 bits não assinados</span><span class="sxs-lookup"><span data-stu-id="fee2d-229">Single bits in unsigned 8-bit integers</span></span><br/> |
| <span id="GL_UNSIGNED_SHORT"></span><span id="gl_unsigned_short"></span><dl> <span data-ttu-id="fee2d-230"><dt>**GL \_ não assinado \_ curto**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-230"><dt>**GL\_UNSIGNED\_SHORT**</dt></span></span> </dl> | <span data-ttu-id="fee2d-231">Inteiro de 16 bits sem sinal</span><span class="sxs-lookup"><span data-stu-id="fee2d-231">Unsigned 16-bit integer</span></span><br/>                |
| <span id="GL_SHORT"></span><span id="gl_short"></span><dl> <span data-ttu-id="fee2d-232"><dt>**GL \_ curto**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-232"><dt>**GL\_SHORT**</dt></span></span> </dl>                             | <span data-ttu-id="fee2d-233">Inteiro de 16 bits com sinal</span><span class="sxs-lookup"><span data-stu-id="fee2d-233">Signed 16-bit integer</span></span><br/>                  |
| <span id="GL_UNSIGNED_INT"></span><span id="gl_unsigned_int"></span><dl> <span data-ttu-id="fee2d-234"><dt>**GL \_ não assinado \_ int**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-234"><dt>**GL\_UNSIGNED\_INT**</dt></span></span> </dl>       | <span data-ttu-id="fee2d-235">Inteiro de 32 bits sem sinal</span><span class="sxs-lookup"><span data-stu-id="fee2d-235">Unsigned 32-bit integer</span></span><br/>                |
| <span id="GL_INT"></span><span id="gl_int"></span><dl> <span data-ttu-id="fee2d-236"><dt>**RAZÃO \_ int**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-236"><dt>**GL\_INT**</dt></span></span> </dl>                                   | <span data-ttu-id="fee2d-237">Inteiro de 32 bits</span><span class="sxs-lookup"><span data-stu-id="fee2d-237">32-bit integer</span></span><br/>                         |
| <span id="GL_FLOAT"></span><span id="gl_float"></span><dl> <span data-ttu-id="fee2d-238"><dt>**GL \_ float**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-238"><dt>**GL\_FLOAT**</dt></span></span> </dl>                             | <span data-ttu-id="fee2d-239">Ponto flutuante de precisão simples</span><span class="sxs-lookup"><span data-stu-id="fee2d-239">Single-precision floating-point</span></span><br/>        |



 

</dd> <dt>

<span data-ttu-id="fee2d-240">*pixels*</span><span class="sxs-lookup"><span data-stu-id="fee2d-240">*pixels*</span></span> 
</dt> <dd>

<span data-ttu-id="fee2d-241">Um ponteiro para os dados de pixel.</span><span class="sxs-lookup"><span data-stu-id="fee2d-241">A pointer to the pixel data.</span></span>

</dd> </dl>

## <a name="return-value"></a><span data-ttu-id="fee2d-242">Retornar valor</span><span class="sxs-lookup"><span data-stu-id="fee2d-242">Return value</span></span>

<span data-ttu-id="fee2d-243">Essa função não retorna um valor.</span><span class="sxs-lookup"><span data-stu-id="fee2d-243">This function does not return a value.</span></span>

## <a name="error-codes"></a><span data-ttu-id="fee2d-244">Códigos do Erro</span><span class="sxs-lookup"><span data-stu-id="fee2d-244">Error codes</span></span>

<span data-ttu-id="fee2d-245">Os códigos de erro a seguir podem ser recuperados pela função [**glGetError**](glgeterror.md) .</span><span class="sxs-lookup"><span data-stu-id="fee2d-245">The following error codes can be retrieved by the [**glGetError**](glgeterror.md) function.</span></span>



| <span data-ttu-id="fee2d-246">Nome</span><span class="sxs-lookup"><span data-stu-id="fee2d-246">Name</span></span>                                                                                                  | <span data-ttu-id="fee2d-247">Significado</span><span class="sxs-lookup"><span data-stu-id="fee2d-247">Meaning</span></span>                                                                                                                                                                                      |
|-------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <dl> <span data-ttu-id="fee2d-248"><dt>**\_valor inválido do GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-248"><dt>**GL\_INVALID\_VALUE**</dt></span></span> </dl>     | <span data-ttu-id="fee2d-249">A *largura* ou a *altura* era negativa.</span><span class="sxs-lookup"><span data-stu-id="fee2d-249">Either *width* or *height* was negative.</span></span><br/>                                                                                                                                          |
| <dl> <span data-ttu-id="fee2d-250"><dt>**GL \_ inválido de \_ enumeração**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-250"><dt>**GL\_INVALID\_ENUM**</dt></span></span> </dl>      | <span data-ttu-id="fee2d-251">O *formato* ou o *tipo* não era um valor aceito.</span><span class="sxs-lookup"><span data-stu-id="fee2d-251">Either *format* or *type* was not an accepted value.</span></span> <br/>                                                                                                                             |
| <dl> <span data-ttu-id="fee2d-252"><dt>**GL \_ operação inválida \_**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-252"><dt>**GL\_INVALID\_OPERATION**</dt></span></span> </dl> | <span data-ttu-id="fee2d-253">*Format* era GL \_ Red, GL \_ verde, GL \_ Blue, GL \_ alfa, GL \_ RGB, GL \_ RGBA, GL \_ BGR \_ ext, GL \_ BGRA \_ ext, GL \_ luminância ou GL de \_ luminância \_ alfa e OpenGL estava no modo de índice de cor.</span><span class="sxs-lookup"><span data-stu-id="fee2d-253">*format* was GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, or GL\_LUMINANCE\_ALPHA, and OpenGL was in color-index mode.</span></span><br/> |
| <dl> <span data-ttu-id="fee2d-254"><dt>**GL \_ inválido de \_ enumeração**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-254"><dt>**GL\_INVALID\_ENUM**</dt></span></span> </dl>      | <span data-ttu-id="fee2d-255">o *tipo* era \_ o bitmap GL e o *formato* não era um índice de cores GL \_ ou o \_ \_ Index de estêncil GL \_ .</span><span class="sxs-lookup"><span data-stu-id="fee2d-255">*type* was GL\_BITMAP and *format* was not either GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX.</span></span><br/>                                                                                         |
| <dl> <span data-ttu-id="fee2d-256"><dt>**GL \_ operação inválida \_**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-256"><dt>**GL\_INVALID\_OPERATION**</dt></span></span> </dl> | <span data-ttu-id="fee2d-257">o *formato* era \_ \_ um índice de estêncil GL e não havia um buffer de estêncil.</span><span class="sxs-lookup"><span data-stu-id="fee2d-257">*format* was GL\_STENCIL\_INDEX and there was no stencil buffer.</span></span><br/>                                                                                                                  |
| <dl> <span data-ttu-id="fee2d-258"><dt>**GL \_ operação inválida \_**</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-258"><dt>**GL\_INVALID\_OPERATION**</dt></span></span> </dl> | <span data-ttu-id="fee2d-259">A função foi chamada entre uma chamada para [**glBegin**](glbegin.md) e a chamada correspondente para [**glEnd**](glend.md).</span><span class="sxs-lookup"><span data-stu-id="fee2d-259">The function was called between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md).</span></span><br/>                                                        |


## <a name="remarks"></a><span data-ttu-id="fee2d-260">Comentários</span><span class="sxs-lookup"><span data-stu-id="fee2d-260">Remarks</span></span>

<span data-ttu-id="fee2d-261">A função **glDrawPixels** lê dados de pixel da memória e grava-os em framebuffer em relação à posição de rasterização atual.</span><span class="sxs-lookup"><span data-stu-id="fee2d-261">The **glDrawPixels** function reads pixel data from memory and writes it into the framebuffer relative to the current raster position.</span></span> <span data-ttu-id="fee2d-262">Use [**glRasterPos**](glrasterpos-functions.md) para definir a posição atual da varredura e use [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) com o argumento \_ GL \_ posição de varredura atual \_ para consultar a posição da rasterização.</span><span class="sxs-lookup"><span data-stu-id="fee2d-262">Use [**glRasterPos**](glrasterpos-functions.md) to set the current raster position, and use [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION to query the raster position.</span></span>

<span data-ttu-id="fee2d-263">Vários parâmetros definem a codificação dos dados de pixel na memória e controlam o processamento dos dados de pixel antes de serem colocados no framebuffer.</span><span class="sxs-lookup"><span data-stu-id="fee2d-263">Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the framebuffer.</span></span> <span data-ttu-id="fee2d-264">Esses parâmetros são definidos com quatro funções: [**glPixelStore**](glpixelstore-functions.md), [**glPixelTransfer**](glpixeltransfer.md), [**glPixelMap**](glpixelmap.md)e [**glPixelZoom**](glpixelzoom.md).</span><span class="sxs-lookup"><span data-stu-id="fee2d-264">These parameters are set with four functions: [**glPixelStore**](glpixelstore-functions.md), [**glPixelTransfer**](glpixeltransfer.md), [**glPixelMap**](glpixelmap.md), and [**glPixelZoom**](glpixelzoom.md).</span></span> <span data-ttu-id="fee2d-265">Este tópico descreve os efeitos sobre **glDrawPixels** de muitos, mas não todos, dos parâmetros especificados por essas quatro funções.</span><span class="sxs-lookup"><span data-stu-id="fee2d-265">This topic describes the effects on **glDrawPixels** of many, but not all, of the parameters specified by these four functions.</span></span>

<span data-ttu-id="fee2d-266">Os dados são lidos a partir de *pixels* como uma sequência de bytes assinados ou sem sinal, inteiros assinados ou sem sinal, inteiro assinado ou não assinado ou valores de ponto flutuante de precisão única, dependendo do *tipo*.</span><span class="sxs-lookup"><span data-stu-id="fee2d-266">Data is read from *pixels* as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on *type*.</span></span> <span data-ttu-id="fee2d-267">Cada um desses bytes, shorts, inteiros ou valores de ponto flutuante é interpretado como um componente de cor ou profundidade, ou um índice, dependendo do *formato*.</span><span class="sxs-lookup"><span data-stu-id="fee2d-267">Each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on *format*.</span></span> <span data-ttu-id="fee2d-268">Os índices são sempre tratados individualmente.</span><span class="sxs-lookup"><span data-stu-id="fee2d-268">Indexes are always treated individually.</span></span> <span data-ttu-id="fee2d-269">Os componentes de cor são tratados como grupos de um, dois, três ou quatro valores, novamente com base no *formato*.</span><span class="sxs-lookup"><span data-stu-id="fee2d-269">Color components are treated as groups of one, two, three, or four values, again based on *format*.</span></span> <span data-ttu-id="fee2d-270">Os índices individuais e os grupos de componentes são chamados de pixels.</span><span class="sxs-lookup"><span data-stu-id="fee2d-270">Both individual indexes and groups of components are referred to as pixels.</span></span> <span data-ttu-id="fee2d-271">Se o *tipo* for um \_ bitmap GL, os dados deverão ser bytes não assinados e o *formato* deverá ser um índice de \_ cores GL \_ ou \_ Index de estêncil GL \_ .</span><span class="sxs-lookup"><span data-stu-id="fee2d-271">If *type* is GL\_BITMAP, the data must be unsigned bytes, and *format* must be either GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX.</span></span> <span data-ttu-id="fee2d-272">Cada byte não assinado é tratado como pixels de 8 1 bits, com ordenação de bits determinada por GL \_ Unpack \_ LSB \_ First (consulte [**glPixelStore**](glpixelstore-functions.md)).</span><span class="sxs-lookup"><span data-stu-id="fee2d-272">Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by GL\_UNPACK\_LSB\_FIRST (see [**glPixelStore**](glpixelstore-functions.md)).</span></span>

<span data-ttu-id="fee2d-273">A *largura* por pixels de *altura* é lida da memória, começando em *pixels* de localização.</span><span class="sxs-lookup"><span data-stu-id="fee2d-273">The *width* by *height* pixels are read from memory, starting at location *pixels*.</span></span> <span data-ttu-id="fee2d-274">Por padrão, esses pixels são retirados de locais de memória adjacentes, exceto que depois que todos os pixels de *largura* são lidos, o ponteiro de leitura é avançado para o próximo limite de 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="fee2d-274">By default, these pixels are taken from adjacent memory locations, except that after all *width* pixels are read, the read pointer is advanced to the next 4-byte boundary.</span></span> <span data-ttu-id="fee2d-275">A função **glPixelStore** especifica o alinhamento de linha de 4 bytes com o \_ alinhamento de descompactação do argumento GL \_ , e você pode defini-lo como 1, 2, 4 ou 8 bytes.</span><span class="sxs-lookup"><span data-stu-id="fee2d-275">The **glPixelStore** function specifies the 4-byte row alignment with argument GL\_UNPACK\_ALIGNMENT, and you can set it to 1, 2, 4, or 8 bytes.</span></span> <span data-ttu-id="fee2d-276">Outros parâmetros de armazenamento de pixel especificam avanços de ponteiro de leitura diferentes, antes de o primeiro pixel ser lido e depois que todos os pixels de *largura* são lidos.</span><span class="sxs-lookup"><span data-stu-id="fee2d-276">Other pixel store parameters specify different read pointer advancements, both before the first pixel is read, and after all *width* pixels are read.</span></span> <span data-ttu-id="fee2d-277">A função **glPixelStore** opera em cada um dos pixels de *largura por altura* que ele lê da memória da mesma maneira, com base nos valores de vários parâmetros especificados por [**glPixelTransfer**](glpixeltransfer.md) e [**glPixelMap**](glpixelmap.md).</span><span class="sxs-lookup"><span data-stu-id="fee2d-277">The **glPixelStore** function operates on each of the *width-by-height* pixels that it reads from memory in the same way, based on the values of several parameters specified by [**glPixelTransfer**](glpixeltransfer.md) and [**glPixelMap**](glpixelmap.md).</span></span> <span data-ttu-id="fee2d-278">Os detalhes dessas operações, bem como o buffer de destino no qual os pixels são desenhados, são específicos ao formato dos pixels, conforme especificado por *formato*.</span><span class="sxs-lookup"><span data-stu-id="fee2d-278">The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by *format*.</span></span>

<span data-ttu-id="fee2d-279">A rasterização descrita até o momento pressupõe fatores de zoom de pixel de 1,0.</span><span class="sxs-lookup"><span data-stu-id="fee2d-279">The rasterization described thus far assumes pixel zoom factors of 1.0.</span></span> <span data-ttu-id="fee2d-280">Se você usar [**glPixelZoom**](glpixelzoom.md) para alterar os fatores de zoom *x* e *y* pixel, os pixels serão convertidos em fragmentos da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="fee2d-280">If you use [**glPixelZoom**](glpixelzoom.md) to change the *x* and *y* pixel zoom factors, pixels are converted to fragments as follows.</span></span> <span data-ttu-id="fee2d-281">Se (*XR, ano*) for a posição atual da varredura e um determinado pixel estiver na coluna *n*-th e *m* th do retângulo de pixel, os fragmentos serão gerados para os pixels cujos centros estão no retângulo com os cantos em</span><span class="sxs-lookup"><span data-stu-id="fee2d-281">If (*xr,yr*) is the current raster position, and a given pixel is in the *n* th column and *m* th row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at</span></span>

<span data-ttu-id="fee2d-282">(*x*<sub>r</sub>  +  *aplicar zoom*? *n*, *y*<sub>r</sub>  +  *zoom*<sub>y</sub> *m*)</span><span class="sxs-lookup"><span data-stu-id="fee2d-282">(*x*<sub>r</sub> + *zoom*? *n*, *y*<sub>r</sub> + *zoom*<sub>y</sub> *m*)</span></span>

<span data-ttu-id="fee2d-283">(*x*<sub>r</sub>  +  *aplicar zoom*?</span><span class="sxs-lookup"><span data-stu-id="fee2d-283">(*x*<sub>r</sub> + *zoom*?</span></span> <span data-ttu-id="fee2d-284">(*n* + 1), *y*<sub>r</sub>  +  *zoom*<sub>y</sub> (*m* + 1))</span><span class="sxs-lookup"><span data-stu-id="fee2d-284">(*n* + 1), *y*<sub>r</sub> + *zoom*<sub>y</sub> (*m* + 1))</span></span>

<span data-ttu-id="fee2d-285">onde *aplicar zoom*? é o valor de GL \_ zoom \_ X e *zoom*<sub>y</sub> é o valor de GL \_ zoom \_ y.</span><span class="sxs-lookup"><span data-stu-id="fee2d-285">where *zoom*? is the value of GL\_ZOOM\_X and *zoom*<sub>y</sub> is the value of GL\_ZOOM\_Y.</span></span>

<span data-ttu-id="fee2d-286">As funções a seguir recuperam informações relacionadas ao **glDrawPixels**:</span><span class="sxs-lookup"><span data-stu-id="fee2d-286">The following functions retrieve information related to **glDrawPixels**:</span></span>

<span data-ttu-id="fee2d-287">[**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) com o argumento \_ GL \_ posição de rasterização atual \_</span><span class="sxs-lookup"><span data-stu-id="fee2d-287">[**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION</span></span>

<span data-ttu-id="fee2d-288">**glGet** com Argument GL \_ \_ posição de rasterização atual \_ \_ válida</span><span class="sxs-lookup"><span data-stu-id="fee2d-288">**glGet** with argument GL\_CURRENT\_RASTER\_POSITION\_VALID</span></span>

## <a name="requirements"></a><span data-ttu-id="fee2d-289">Requisitos</span><span class="sxs-lookup"><span data-stu-id="fee2d-289">Requirements</span></span>



| <span data-ttu-id="fee2d-290">Requisito</span><span class="sxs-lookup"><span data-stu-id="fee2d-290">Requirement</span></span> | <span data-ttu-id="fee2d-291">Valor</span><span class="sxs-lookup"><span data-stu-id="fee2d-291">Value</span></span> |
|-------------------------------------|-----------------------------------------------------------------------------------------|
| <span data-ttu-id="fee2d-292">Cliente mínimo com suporte</span><span class="sxs-lookup"><span data-stu-id="fee2d-292">Minimum supported client</span></span><br/> | <span data-ttu-id="fee2d-293">Windows 2000 Professional \[somente aplicativos da área de trabalho\]</span><span class="sxs-lookup"><span data-stu-id="fee2d-293">Windows 2000 Professional \[desktop apps only\]</span></span><br/>                              |
| <span data-ttu-id="fee2d-294">Servidor mínimo com suporte</span><span class="sxs-lookup"><span data-stu-id="fee2d-294">Minimum supported server</span></span><br/> | <span data-ttu-id="fee2d-295">Windows 2000 Server \[somente aplicativos da área de trabalho\]</span><span class="sxs-lookup"><span data-stu-id="fee2d-295">Windows 2000 Server \[desktop apps only\]</span></span><br/>                                    |
| <span data-ttu-id="fee2d-296">Cabeçalho</span><span class="sxs-lookup"><span data-stu-id="fee2d-296">Header</span></span><br/>                   | <dl> <span data-ttu-id="fee2d-297"><dt>GL. h</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-297"><dt>Gl.h</dt></span></span> </dl>         |
| <span data-ttu-id="fee2d-298">Biblioteca</span><span class="sxs-lookup"><span data-stu-id="fee2d-298">Library</span></span><br/>                  | <dl> <span data-ttu-id="fee2d-299"><dt>Opengl32. lib</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-299"><dt>Opengl32.lib</dt></span></span> </dl> |
| <span data-ttu-id="fee2d-300">DLL</span><span class="sxs-lookup"><span data-stu-id="fee2d-300">DLL</span></span><br/>                      | <dl> <span data-ttu-id="fee2d-301"><dt>Opengl32.dll</dt></span><span class="sxs-lookup"><span data-stu-id="fee2d-301"><dt>Opengl32.dll</dt></span></span> </dl> |



## <a name="see-also"></a><span data-ttu-id="fee2d-302">Confira também</span><span class="sxs-lookup"><span data-stu-id="fee2d-302">See also</span></span>

<dl> <dt>

[<span data-ttu-id="fee2d-303">**glAlphaFunc**</span><span class="sxs-lookup"><span data-stu-id="fee2d-303">**glAlphaFunc**</span></span>](glalphafunc.md)
</dt> <dt>

[<span data-ttu-id="fee2d-304">**glBegin**</span><span class="sxs-lookup"><span data-stu-id="fee2d-304">**glBegin**</span></span>](glbegin.md)
</dt> <dt>

[<span data-ttu-id="fee2d-305">**glBlendFunc**</span><span class="sxs-lookup"><span data-stu-id="fee2d-305">**glBlendFunc**</span></span>](glblendfunc.md)
</dt> <dt>

[<span data-ttu-id="fee2d-306">**glCopyPixels**</span><span class="sxs-lookup"><span data-stu-id="fee2d-306">**glCopyPixels**</span></span>](glcopypixels.md)
</dt> <dt>

[<span data-ttu-id="fee2d-307">**glDepthFunc**</span><span class="sxs-lookup"><span data-stu-id="fee2d-307">**glDepthFunc**</span></span>](gldepthfunc.md)
</dt> <dt>

[<span data-ttu-id="fee2d-308">**glEnd**</span><span class="sxs-lookup"><span data-stu-id="fee2d-308">**glEnd**</span></span>](glend.md)
</dt> <dt>

[<span data-ttu-id="fee2d-309">**glGet**</span><span class="sxs-lookup"><span data-stu-id="fee2d-309">**glGet**</span></span>](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md)
</dt> <dt>

[<span data-ttu-id="fee2d-310">**glLogicOp**</span><span class="sxs-lookup"><span data-stu-id="fee2d-310">**glLogicOp**</span></span>](gllogicop.md)
</dt> <dt>

[<span data-ttu-id="fee2d-311">**glPixelMap**</span><span class="sxs-lookup"><span data-stu-id="fee2d-311">**glPixelMap**</span></span>](glpixelmap.md)
</dt> <dt>

[<span data-ttu-id="fee2d-312">**glPixelStore**</span><span class="sxs-lookup"><span data-stu-id="fee2d-312">**glPixelStore**</span></span>](glpixelstore-functions.md)
</dt> <dt>

[<span data-ttu-id="fee2d-313">**glPixelTransfer**</span><span class="sxs-lookup"><span data-stu-id="fee2d-313">**glPixelTransfer**</span></span>](glpixeltransfer.md)
</dt> <dt>

[<span data-ttu-id="fee2d-314">**glPixelZoom**</span><span class="sxs-lookup"><span data-stu-id="fee2d-314">**glPixelZoom**</span></span>](glpixelzoom.md)
</dt> <dt>

[<span data-ttu-id="fee2d-315">**glRasterPos**</span><span class="sxs-lookup"><span data-stu-id="fee2d-315">**glRasterPos**</span></span>](glrasterpos-functions.md)
</dt> <dt>

[<span data-ttu-id="fee2d-316">**glReadPixels**</span><span class="sxs-lookup"><span data-stu-id="fee2d-316">**glReadPixels**</span></span>](glreadpixels.md)
</dt> <dt>

[<span data-ttu-id="fee2d-317">**glScissor**</span><span class="sxs-lookup"><span data-stu-id="fee2d-317">**glScissor**</span></span>](glscissor.md)
</dt> <dt>

[<span data-ttu-id="fee2d-318">**glStencilFunc**</span><span class="sxs-lookup"><span data-stu-id="fee2d-318">**glStencilFunc**</span></span>](glstencilfunc.md)
</dt> </dl>

 

 





