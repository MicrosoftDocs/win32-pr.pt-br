---
title: Projetando interfaces remotas
description: Com o advento do modelo de objeto de componente distribuído, é importante que sua interface personalizada seja remota, mesmo que você pretenda usá-la somente em processo.
ms.assetid: 2ee4d950-dfd5-4965-bd77-a600e878be59
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3502604d62e6a5129ca3e3538761722909c0198f
ms.sourcegitcommit: 85688bbfbe5b121bc05ddf112d54c23a469dfbc0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/29/2020
ms.locfileid: "103823537"
---
# <a name="designing-remotable-interfaces"></a><span data-ttu-id="5b6b6-103">Projetando interfaces remotas</span><span class="sxs-lookup"><span data-stu-id="5b6b6-103">Designing Remotable Interfaces</span></span>

<span data-ttu-id="5b6b6-104">Com o advento do modelo de objeto de componente distribuído, é importante que sua interface personalizada seja remota, mesmo que você pretenda usá-la somente em processo.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-104">With the advent of the distributed component object model, it is important that your custom interface be remotable, even if you intend to use it in-process only.</span></span>

<span data-ttu-id="5b6b6-105">MIDL é mais do que apenas uma maneira de gerar arquivos de cabeçalho para suas interfaces.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-105">MIDL is more than just a way to generate header files for your interfaces.</span></span> <span data-ttu-id="5b6b6-106">É uma linguagem de programação para comunicação remota que permite que você use suas interfaces em limites de máquina, processo e thread.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-106">It is a programming language for remoting that allows you to use your interfaces across machine, process, and thread boundaries.</span></span> <span data-ttu-id="5b6b6-107">Isso significa que você precisa verificar o comportamento de suas interfaces definidas pelo MIDL sob essas condições antes de liberar seu programa para os clientes.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-107">This means that you need to verify the behavior of your MIDL-defined interfaces under those conditions before you release your program to customers.</span></span> <span data-ttu-id="5b6b6-108">Se você cometer um erro em sua IDL e a interface não for remota corretamente, poderá ser difícil corrigir esse erro.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-108">If you made a mistake in your IDL and the interface is not remoted correctly, it can be difficult to remedy that mistake.</span></span> <span data-ttu-id="5b6b6-109">Você precisa revisar sua interface com um novo IID e deixar o antigo no para compatibilidade com versões anteriores ou você precisa converter cada cliente e cada computador do servidor em qualquer lugar ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-109">Either you have to revise your interface with a new IID and leave the old one in for backward compatibility or you have to convert every client and every server machine everywhere at the same time.</span></span>

<span data-ttu-id="5b6b6-110">Mesmo que sua interface nunca seja usada fora do processo, ela pode ser usada entre threads.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-110">Even if your interface will never be used out-of-process, it may be used cross-thread.</span></span> <span data-ttu-id="5b6b6-111">O pior problema para um arquivo IDL não verificado pode surgir em servidores em processo que não dão suporte a vários [Apartments de thread único](single-threaded-apartments.md)).</span><span class="sxs-lookup"><span data-stu-id="5b6b6-111">The worst problem for an unchecked IDL file can arise for in-process servers that do not support multiple [single-threaded apartments](single-threaded-apartments.md)).</span></span> <span data-ttu-id="5b6b6-112">Um servidor que não especifica um modelo de threading é implicitamente de thread único.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-112">A server that does not specify a threading model is implicitly single-threaded.</span></span> <span data-ttu-id="5b6b6-113">Tudo marcado como single-thread é forçado para o thread que primeiro chamou [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) ou [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="5b6b6-113">Everything marked single-threaded is forced over to the thread that first called [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) or [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="5b6b6-114">Se algum outro thread fosse aquele que ativou o objeto, todas as interfaces nesse servidor de thread único devem ser remotas de volta para o thread de ativação, o que pode resultar em um retorno de REGDB \_ E \_ IIDNOTREG em resposta a uma chamada para [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))).</span><span class="sxs-lookup"><span data-stu-id="5b6b6-114">If some other thread was the one that activated the object, all the interfaces on that single-threaded server must be remoted back to the activating thread, which can result in a return of REGDB\_E\_IIDNOTREG in response to a call to [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))).</span></span> <span data-ttu-id="5b6b6-115">A menos que você possa declarar absolutamente que sua interface está em processo e sempre será chamada no mesmo thread, você será remoto em algum momento.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-115">Unless you can absolutely assert that your interface is both in-process and always going to be called on the same thread, you will get remoted at some time.</span></span>

<span data-ttu-id="5b6b6-116">Por fim, como um designer de interface, você precisa considerar como os aplicativos cliente usarão sua interface.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-116">Finally, as an interface designer, you need to consider how client applications will use your interface.</span></span> <span data-ttu-id="5b6b6-117">Duas coisas, juntas, determinam se uma interface será eficiente entre os limites do processo e da máquina: a frequência das chamadas de método entre o limite da interface e a quantidade de dados a serem transferidos em uma determinada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-117">Two things, together, determine whether an interface will be efficient across process and machine boundaries: the frequency of method calls across the interface boundary, and the amount of data to be transferred in a given method call.</span></span> <span data-ttu-id="5b6b6-118">Embora o COM faça chamadas entre processos e entre redes transparentes para programas, ele não pode fazer chamadas de alta frequência e alta largura de banda eficientes em espaços de endereço.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-118">Although COM makes cross-process and cross-network calls transparent to programs, it cannot make high-frequency and high-bandwidth calls efficient across address spaces.</span></span> <span data-ttu-id="5b6b6-119">Em alguns casos, é mais apropriado criar interfaces que normalmente serão implementadas apenas como servidores em processo, enquanto outras interfaces são mais apropriadas para uso remoto.</span><span class="sxs-lookup"><span data-stu-id="5b6b6-119">In some cases, it is more appropriate to design interfaces that will normally be implemented only as in-process servers while other interfaces are more appropriate for remote use.</span></span>

 

 




