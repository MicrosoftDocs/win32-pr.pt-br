---
title: Apartments multithread
description: Apartments multithread
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "105758150"
---
# <a name="multithreaded-apartments"></a><span data-ttu-id="8d6f9-103">Apartments multithread</span><span class="sxs-lookup"><span data-stu-id="8d6f9-103">Multithreaded Apartments</span></span>

<span data-ttu-id="8d6f9-104">Em um modelo de apartamento multi-threaded, todos os threads no processo que foram inicializados como de thread livre residem em um único apartamento.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-104">In a multithreaded apartment model, all the threads in the process that have been initialized as free-threaded reside in a single apartment.</span></span> <span data-ttu-id="8d6f9-105">Portanto, não há necessidade de realizar marshaling entre threads.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-105">Therefore, there is no need to marshal between threads.</span></span> <span data-ttu-id="8d6f9-106">Os threads não precisam recuperar e despachar mensagens porque o COM não usa mensagens de janela neste modelo.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-106">The threads need not retrieve and dispatch messages because COM does not use window messages in this model.</span></span>

<span data-ttu-id="8d6f9-107">Chamadas para métodos de objetos no apartamento multithread podem ser executadas em qualquer thread no apartamento.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-107">Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment.</span></span> <span data-ttu-id="8d6f9-108">Não há nenhuma serialização de chamadas; muitas chamadas podem ocorrer no mesmo método ou no mesmo objeto simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-108">There is no serialization of calls; many calls may occur to the same method or to the same object simultaneously.</span></span> <span data-ttu-id="8d6f9-109">Os objetos criados no apartamento multithread devem ser capazes de lidar com chamadas em seus métodos de outros threads a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-109">Objects created in the multithreaded apartment must be able to handle calls on their methods from other threads at any time.</span></span>

<span data-ttu-id="8d6f9-110">Como as chamadas para objetos não são serializadas de nenhuma forma, a simultaneidade do objeto multithread oferece o melhor desempenho e aproveita a vantagem do hardware de multiprocessador para a chamada entre threads, processos cruzados e chamadas entre computadores.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-110">Because calls to objects are not serialized in any way, multithreaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling.</span></span> <span data-ttu-id="8d6f9-111">No entanto, isso significa que o código para objetos deve fornecer sincronização em suas implementações de interface, normalmente por meio do uso de primitivos de sincronização, como objetos de evento, seções críticas, mutexes ou semáforos, que são descritos posteriormente nesta seção.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-111">This means, however, that the code for objects must provide synchronization in their interface implementations, typically through the use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores, which are described later in this section.</span></span> <span data-ttu-id="8d6f9-112">Além disso, como o objeto não controla o tempo de vida dos threads que estão acessando, nenhum estado específico do thread pode ser armazenado no objeto (no armazenamento local do thread).</span><span class="sxs-lookup"><span data-stu-id="8d6f9-112">In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage).</span></span>

<span data-ttu-id="8d6f9-113">A seguir estão algumas considerações importantes sobre a sincronização para Apartments multithread:</span><span class="sxs-lookup"><span data-stu-id="8d6f9-113">Following are some important considerations regarding synchronization for multithreaded apartments:</span></span>

-   <span data-ttu-id="8d6f9-114">O COM fornece sincronização de chamadas somente para Apartments de thread único.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-114">COM provides call synchronization for single-threaded apartments only.</span></span>
-   <span data-ttu-id="8d6f9-115">Apartments multithread não recebem chamadas ao fazer chamadas (no mesmo thread).</span><span class="sxs-lookup"><span data-stu-id="8d6f9-115">Multithreaded apartments do not receive calls while making calls (on the same thread).</span></span>
-   <span data-ttu-id="8d6f9-116">Apartments multithread não podem fazer chamadas com sincronização de entrada.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-116">Multithreaded apartments cannot make input-synchronized calls.</span></span>
-   <span data-ttu-id="8d6f9-117">As chamadas assíncronas são convertidas em chamadas síncronas em Apartments multithread.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-117">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span>
-   <span data-ttu-id="8d6f9-118">O filtro de mensagem não é chamado para nenhum thread em um apartamento multithread.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-118">The message filter is not called for any thread in a multithreaded apartment.</span></span>

<span data-ttu-id="8d6f9-119">Para inicializar um thread como livre de threads, chame [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), especificando o coinit \_ multi-threaded.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-119">To initialize a thread as free-threaded, call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specifying COINIT\_MULTITHREADED.</span></span> <span data-ttu-id="8d6f9-120">Para obter informações sobre threads de servidor em processo, consulte [problemas de thread de servidor em processo](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="8d6f9-120">For information on in-process server threading, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="8d6f9-121">Vários clientes podem chamar simultaneamente, de threads diferentes, um objeto que dá suporte a threads livres.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-121">Multiple clients can simultaneously call, from different threads, an object that supports free-threading.</span></span> <span data-ttu-id="8d6f9-122">Em servidores de fora de processo de thread livre, COM, por meio do subsistema RPC, o cria um pool de threads no processo do servidor e uma chamada de cliente (ou várias chamadas de cliente) pode ser entregue por qualquer um desses threads a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-122">In free-threaded out-of-process servers, COM, through the RPC subsystem, creates a pool of threads in the server process and a client call (or multiple client calls) can be delivered by any of these threads at any time.</span></span> <span data-ttu-id="8d6f9-123">Um servidor fora do processo também deve implementar a sincronização em sua fábrica de classes.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-123">An out-of-process server must also implement synchronization in its class factory.</span></span> <span data-ttu-id="8d6f9-124">Os objetos de thread livre, em processo, podem receber chamadas diretas de vários threads do cliente.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-124">Free-threaded, in-process objects can receive direct calls from multiple threads of the client.</span></span>

<span data-ttu-id="8d6f9-125">O cliente pode fazer COM trabalho em vários threads.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-125">The client can do COM work in multiple threads.</span></span> <span data-ttu-id="8d6f9-126">Todos os threads pertencem ao mesmo apartamento multi-threaded.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-126">All threads belong to the same multithreaded apartment.</span></span> <span data-ttu-id="8d6f9-127">Os ponteiros de interface são passados diretamente do thread para o thread em um apartamento multithread, portanto, os ponteiros de interface não são empacotados entre seus threads.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-127">Interface pointers are passed directly from thread to thread within a multithreaded apartment, so interface pointers are not marshaled between its threads.</span></span> <span data-ttu-id="8d6f9-128">Os filtros de mensagem (implementações de [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) não são usados em Apartments multithread.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-128">Message filters (implementations of [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) are not used in multithreaded apartments.</span></span> <span data-ttu-id="8d6f9-129">O thread do cliente será suspenso quando fizer uma chamada COM para objetos fora do apartamento e será retomado quando a chamada retornar.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-129">The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns.</span></span> <span data-ttu-id="8d6f9-130">As chamadas entre os processos ainda são manipuladas pelo RPC.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-130">Calls between processes are still handled by RPC.</span></span>

<span data-ttu-id="8d6f9-131">Os threads inicializados com o modelo de thread livre devem implementar sua própria sincronização.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-131">Threads initialized with the free-threaded model must implement their own synchronization.</span></span> <span data-ttu-id="8d6f9-132">Conforme mencionado anteriormente nesta seção, o Windows permite essa implementação por meio dos primitivos de sincronização a seguir:</span><span class="sxs-lookup"><span data-stu-id="8d6f9-132">As mentioned earlier in this section, Windows enables this implementation through the following synchronization primitives:</span></span>

-   <span data-ttu-id="8d6f9-133">Os objetos de evento fornecem uma maneira de sinalizar um ou mais threads que um evento ocorreu.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-133">Event objects provide a way of signaling one or more threads that an event has occurred.</span></span> <span data-ttu-id="8d6f9-134">Qualquer thread dentro de um processo pode criar um objeto de evento.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-134">Any thread within a process can create an event object.</span></span> <span data-ttu-id="8d6f9-135">Um identificador para o evento é retornado pela função de criação de evento, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span><span class="sxs-lookup"><span data-stu-id="8d6f9-135">A handle to the event is returned by the event-creating function, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span></span> <span data-ttu-id="8d6f9-136">Depois que um objeto de evento é criado, os threads com um identificador para o objeto podem aguardar nele antes de continuar a execução.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-136">Once an event object has been created, threads with a handle to the object can wait on it before continuing execution.</span></span>
-   <span data-ttu-id="8d6f9-137">As seções críticas são usadas para uma seção de código que requer acesso exclusivo a alguns conjuntos de dados compartilhados antes que ele possa ser executado e que é usado somente pelos threads em um único processo.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-137">Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed and that is used only by the threads within a single process.</span></span> <span data-ttu-id="8d6f9-138">Uma seção crítica é como uma borboleta através da qual apenas um thread de cada vez pode passar, funcionando da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="8d6f9-138">A critical section is like a turnstile through which only one thread at a time may pass, working as follows:</span></span>
    -   <span data-ttu-id="8d6f9-139">Para garantir que nenhum mais de um thread acesse dados compartilhados, o thread primário de um processo aloca uma estrutura de dados de seção crítica global \_ e inicializa seus membros.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-139">To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL\_SECTION data structure and initializes its members.</span></span> <span data-ttu-id="8d6f9-140">Um thread que insere uma seção crítica chama a função [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) e modifica os membros da estrutura de dados.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-140">A thread entering a critical section calls the [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) function and modifies the data structure's members.</span></span>
    -   <span data-ttu-id="8d6f9-141">Um thread que tenta inserir uma seção crítica chama [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) que verifica se a estrutura de dados da \_ seção crítica foi modificada.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-141">A thread attempting to enter a critical section calls [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) which checks to see whether the CRITICAL\_SECTION data structure has been modified.</span></span> <span data-ttu-id="8d6f9-142">Nesse caso, outro thread está atualmente na seção crítica e o thread subsequente é colocado no modo de suspensão.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-142">If so, another thread is currently in the critical section and the subsequent thread is put to sleep.</span></span> <span data-ttu-id="8d6f9-143">Um thread que deixa uma seção crítica chama [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), que redefine a estrutura de dados.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-143">A thread leaving a critical section calls [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), which resets the data structure.</span></span> <span data-ttu-id="8d6f9-144">Quando um thread deixa uma seção crítica, o sistema ativa um dos threads em suspensão, que, em seguida, entra na seção crítica.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-144">When a thread leaves a critical section, the system wakes one of the sleeping threads, which then enters the critical section.</span></span>
-   <span data-ttu-id="8d6f9-145">Os mutexs executam a mesma função que uma seção crítica, exceto que o mutex é acessível para threads em execução em processos diferentes.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-145">Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes.</span></span> <span data-ttu-id="8d6f9-146">Possuir um objeto mutex é como ter o andar em um debate.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-146">Owning a mutex object is like having the floor in a debate.</span></span> <span data-ttu-id="8d6f9-147">Um processo cria um objeto mutex chamando a função [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) , que retorna um identificador.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-147">A process creates a mutex object by calling the [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) function, which returns a handle.</span></span> <span data-ttu-id="8d6f9-148">O primeiro thread solicitando um objeto mutex Obtém a propriedade dele.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-148">The first thread requesting a mutex object obtains ownership of it.</span></span> <span data-ttu-id="8d6f9-149">Quando o thread termina com o mutex, a propriedade passa para outros threads de acordo com a primeira base fornecida pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-149">When the thread has finished with the mutex, ownership passes to other threads on a first-come, first-served basis.</span></span>
-   <span data-ttu-id="8d6f9-150">Os semáforos são usados para manter uma contagem de referência em algum recurso disponível.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-150">Semaphores are used to maintain a reference count on some available resource.</span></span> <span data-ttu-id="8d6f9-151">Um thread cria um semáforo para um recurso chamando a função [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) e passando um ponteiro para o recurso, uma contagem de recursos inicial e a contagem máxima de recursos.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-151">A thread creates a semaphore for a resource by calling the [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) function and passing a pointer to the resource, an initial resource count, and the maximum resource count.</span></span> <span data-ttu-id="8d6f9-152">Essa função retorna um identificador.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-152">This function returns a handle.</span></span> <span data-ttu-id="8d6f9-153">Um thread solicitando um recurso passa seu identificador de semáforo em uma chamada para a função [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="8d6f9-153">A thread requesting a resource passes its semaphore handle in a call to the [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function.</span></span> <span data-ttu-id="8d6f9-154">O objeto Semaphore pesquisa o recurso para determinar se ele está disponível.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-154">The semaphore object polls the resource to determine whether it is available.</span></span> <span data-ttu-id="8d6f9-155">Nesse caso, o semáforo decrementa a contagem de recursos e ativa o thread em espera.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-155">If so, the semaphore decrements the resource count and wakes the waiting thread.</span></span> <span data-ttu-id="8d6f9-156">Se a contagem for zero, o thread permanecerá em suspensão até que outro thread Libere um recurso, fazendo com que o semáforo aumente a contagem para um.</span><span class="sxs-lookup"><span data-stu-id="8d6f9-156">If the count is zero, the thread remains asleep until another thread releases a resource, causing the semaphore to increment the count to one.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8d6f9-157">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="8d6f9-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8d6f9-158">Acessando interfaces em Apartments</span><span class="sxs-lookup"><span data-stu-id="8d6f9-158">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="8d6f9-159">Escolhendo o modelo de Threading</span><span class="sxs-lookup"><span data-stu-id="8d6f9-159">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="8d6f9-160">Problemas de Threading do servidor em processo</span><span class="sxs-lookup"><span data-stu-id="8d6f9-160">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="8d6f9-161">Processos, threads e Apartments</span><span class="sxs-lookup"><span data-stu-id="8d6f9-161">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="8d6f9-162">Comunicação de thread único e multithread</span><span class="sxs-lookup"><span data-stu-id="8d6f9-162">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="8d6f9-163">Apartments de thread único</span><span class="sxs-lookup"><span data-stu-id="8d6f9-163">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 