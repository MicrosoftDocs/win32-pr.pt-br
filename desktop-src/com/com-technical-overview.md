---
title: Visão geral técnica COM
ms.assetid: 519c87cc-b442-4187-af2a-124a1e4e8b49
description: 'Saiba mais sobre: visão geral técnica COM'
keywords:
- Visão geral técnica com
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: be5dc95ffae5166d86cd8110cab1a6b90e6ffa5c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "104089140"
---
# <a name="com-technical-overview"></a><span data-ttu-id="3a6ea-104">Visão geral técnica COM</span><span class="sxs-lookup"><span data-stu-id="3a6ea-104">COM Technical Overview</span></span>

<span data-ttu-id="3a6ea-105">Este tópico fornece uma visão geral do Microsoft Component Object Model (COM):</span><span class="sxs-lookup"><span data-stu-id="3a6ea-105">This topic provides an overview of the Microsoft Component Object Model (COM):</span></span>

-   [<span data-ttu-id="3a6ea-106">Introdução ao COM</span><span class="sxs-lookup"><span data-stu-id="3a6ea-106">Introduction to COM</span></span>](#introduction-to-com)
-   [<span data-ttu-id="3a6ea-107">Objetos e interfaces</span><span class="sxs-lookup"><span data-stu-id="3a6ea-107">Objects and Interfaces</span></span>](#objects-and-interfaces)
-   [<span data-ttu-id="3a6ea-108">Implementação de interface</span><span class="sxs-lookup"><span data-stu-id="3a6ea-108">Interface implementation</span></span>](#interface-implementation)
-   [<span data-ttu-id="3a6ea-109">A interface IUnknown</span><span class="sxs-lookup"><span data-stu-id="3a6ea-109">The IUnknown Interface</span></span>](#the-iunknown-interface)
-   [<span data-ttu-id="3a6ea-110">O modelo de cliente/servidor</span><span class="sxs-lookup"><span data-stu-id="3a6ea-110">The Client/Server Model</span></span>](#the-clientserver-model)
-   [<span data-ttu-id="3a6ea-111">Gerenciador de Controle de Serviço</span><span class="sxs-lookup"><span data-stu-id="3a6ea-111">Service Control Manager</span></span>](#service-control-manager)
-   [<span data-ttu-id="3a6ea-112">Reutilização</span><span class="sxs-lookup"><span data-stu-id="3a6ea-112">Reusability</span></span>](#reusability)
-   [<span data-ttu-id="3a6ea-113">Objetos de armazenamento e fluxo</span><span class="sxs-lookup"><span data-stu-id="3a6ea-113">Storage and Stream Objects</span></span>](#storage-and-stream-objects)
-   [<span data-ttu-id="3a6ea-114">Transferência de Dados</span><span class="sxs-lookup"><span data-stu-id="3a6ea-114">Data Transfer</span></span>](#data-transfer)
-   [<span data-ttu-id="3a6ea-115">Comunicação remota</span><span class="sxs-lookup"><span data-stu-id="3a6ea-115">Remoting</span></span>](#remoting)
-   [<span data-ttu-id="3a6ea-116">Segurança</span><span class="sxs-lookup"><span data-stu-id="3a6ea-116">Security</span></span>](#security)
-   [<span data-ttu-id="3a6ea-117">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="3a6ea-117">Related topics</span></span>](#related-topics)

## <a name="introduction-to-com"></a><span data-ttu-id="3a6ea-118">Introdução ao COM</span><span class="sxs-lookup"><span data-stu-id="3a6ea-118">Introduction to COM</span></span>

<span data-ttu-id="3a6ea-119">O Microsoft Component Object Model (COM) define um padrão de interoperabilidade binária para a criação de bibliotecas de software reutilizáveis que interagem em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-119">The Microsoft Component Object Model (COM) defines a binary interoperability standard for creating reusable software libraries that interact at run time.</span></span> <span data-ttu-id="3a6ea-120">Você pode usar bibliotecas COM sem a necessidade de compilá-las em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-120">You can use COM libraries without the requirement of compiling them into your application.</span></span> <span data-ttu-id="3a6ea-121">O COM é a base para uma série de produtos e tecnologias da Microsoft, como o Windows Media Player e o Windows Server.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-121">COM is the foundation for a number of Microsoft products and technologies, such as Windows Media Player and Windows Server.</span></span>

<span data-ttu-id="3a6ea-122">COM define um padrão binário que se aplica a muitos sistemas operacionais e plataformas de hardware.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-122">COM defines a binary standard that applies to many operating systems and hardware platforms.</span></span> <span data-ttu-id="3a6ea-123">Para a computação em rede, COM define um formato de conexão padrão e um protocolo para interação entre objetos que são executados em diferentes plataformas de hardware.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-123">For network computing, COM defines a standard wire format and protocol for interaction among objects that run on different hardware platforms.</span></span> <span data-ttu-id="3a6ea-124">O COM é independente da linguagem de implementação, o que significa que você pode criar bibliotecas COM usando diferentes linguagens de programação, como C++ e aquelas na .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-124">COM is independent of implementation language, which means that you can create COM libraries by using different programming languages, such as C++ and those in the .NET Framework.</span></span>

<span data-ttu-id="3a6ea-125">A especificação COM fornece todos os conceitos fundamentais que permitem a reutilização de software entre plataformas:</span><span class="sxs-lookup"><span data-stu-id="3a6ea-125">The COM specification provides all of the fundamental concepts that enable cross-platform software reuse:</span></span>

-   <span data-ttu-id="3a6ea-126">Um padrão binário para chamadas de função entre componentes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-126">A binary standard for function calls between components.</span></span>
-   <span data-ttu-id="3a6ea-127">Uma provisão para agrupamentos fortemente tipados de funções em interfaces.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-127">A provision for strongly-typed groupings of functions into interfaces.</span></span>
-   <span data-ttu-id="3a6ea-128">Uma interface base que fornece polimorfismo, descoberta de recursos e acompanhamento do tempo de vida do objeto.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-128">A base interface that provides polymorphism, feature discovery, and object lifetime tracking.</span></span>
-   <span data-ttu-id="3a6ea-129">Um mecanismo que identifica exclusivamente os componentes e suas interfaces.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-129">A mechanism that uniquely identifies components and their interfaces.</span></span>
-   <span data-ttu-id="3a6ea-130">Um carregador de componente que cria instâncias de componente de uma implantação.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-130">A component loader that creates component instances from a deployment.</span></span>

<span data-ttu-id="3a6ea-131">O COM tem várias partes que trabalham em conjunto para permitir a criação de aplicativos criados a partir de componentes reutilizáveis:</span><span class="sxs-lookup"><span data-stu-id="3a6ea-131">COM has a number of parts that work together to enable the creation of applications that are built from reusable components:</span></span>

-   <span data-ttu-id="3a6ea-132">Um *sistema de host* que fornece um ambiente de tempo de execução que está em conformidade com a especificação com.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-132">A *host system* that provides a run-time environment that conforms to the COM specification.</span></span>
-   <span data-ttu-id="3a6ea-133">*Interfaces* que definem contratos de recursos e *componentes* que implementam interfaces.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-133">*Interfaces* that define feature contracts, and *components* that implement interfaces.</span></span>
-   <span data-ttu-id="3a6ea-134">*Servidores* que fornecem componentes para o sistema e *clientes* que usam os recursos fornecidos pelos componentes do.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-134">*Servers* that provide components to the system, and *clients* that use the features provided by components.</span></span>
-   <span data-ttu-id="3a6ea-135">Um *registro* que controla onde os componentes são implantados em hosts locais e remotos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-135">A *registry* that tracks where components are deployed on local and remote hosts.</span></span>
-   <span data-ttu-id="3a6ea-136">Um *Gerenciador de controle de serviço* que localiza componentes em hosts locais e remotos e conecta servidores a clientes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-136">A *Service Control Manager* that locates components on local and remote hosts and connects servers to clients.</span></span>
-   <span data-ttu-id="3a6ea-137">Um protocolo de *armazenamento estruturado* que define como navegar o conteúdo dos arquivos no sistema de arquivos do host.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-137">A *structured storage* protocol that defines how to navigate the contents of files on the host's file system.</span></span>

<span data-ttu-id="3a6ea-138">Habilitar o reuso de código em hosts e plataformas é fundamental para COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-138">Enabling code re-use across hosts and platforms is central to COM.</span></span> <span data-ttu-id="3a6ea-139">Uma implementação de interface reutilizável é chamada de *componente*, um *objeto de componente* ou um *objeto com*.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-139">A reusable interface implementation is named a *component*, a *component object*, or a *COM object*.</span></span> <span data-ttu-id="3a6ea-140">Um componente implementa uma ou mais interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-140">A component implements one or more COM interfaces.</span></span>

<span data-ttu-id="3a6ea-141">Você define uma biblioteca COM personalizada criando as interfaces que sua biblioteca implementa.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-141">You define a custom COM library by designing the interfaces that your library implements.</span></span> <span data-ttu-id="3a6ea-142">Os consumidores da sua biblioteca podem descobrir e usar seus recursos sem qualquer conhecimento dos detalhes de implantação e implementação da biblioteca.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-142">Consumers of your library can discover and use its features without any knowledge of your library's deployment and implementation details.</span></span>

## <a name="objects-and-interfaces"></a><span data-ttu-id="3a6ea-143">Objetos e interfaces</span><span class="sxs-lookup"><span data-stu-id="3a6ea-143">Objects and Interfaces</span></span>

<span data-ttu-id="3a6ea-144">Um objeto COM expõe seus recursos por meio de uma *interface*, que é uma coleção de funções de membro.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-144">A COM object exposes its features through an *interface*, which is a collection of member functions.</span></span> <span data-ttu-id="3a6ea-145">Uma interface COM define o comportamento e as responsabilidades esperados de um componente e especifica um contrato fortemente tipado que fornece um pequeno conjunto de operações relacionadas.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-145">A COM interface defines the expected behavior and responsibilities of a component, and it specifies a strongly-typed contract that provides a small set of related operations.</span></span> <span data-ttu-id="3a6ea-146">Toda a comunicação entre componentes COM ocorre por meio de interfaces, e todos os serviços oferecidos por um componente são expostos por meio de sua interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-146">All communication among COM components occurs through interfaces, and all services offered by a component are exposed through its interface.</span></span> <span data-ttu-id="3a6ea-147">Um chamador pode acessar apenas as funções de membro de interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-147">A caller can access only the interface member functions.</span></span> <span data-ttu-id="3a6ea-148">O estado interno não está disponível para um chamador, a menos que seja exposto na interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-148">Internal state is unavailable to a caller unless it is exposed in the interface.</span></span>

<span data-ttu-id="3a6ea-149">As interfaces são fortemente tipadas.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-149">Interfaces are strongly typed.</span></span> <span data-ttu-id="3a6ea-150">Cada interface tem seu próprio identificador de interface exclusivo, chamado de IID, que elimina colisões que podem ocorrer com nomes legíveis.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-150">Every interface has its own unique interface identifier, named an IID, which eliminates collisions that could occur with human-readable names.</span></span> <span data-ttu-id="3a6ea-151">O IID é um GUID (identificador global exclusivo), que é o mesmo que o UUID (ID universalmente exclusivo) definido pelo DCE (ambiente de computação distribuída) do uso (Open Software Foundation).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-151">The IID is a globally unique identifier (GUID), which is the same as the Universally Unique ID (UUID) defined by the Open Software Foundation (OSF) Distributed Computing Environment (DCE).</span></span> <span data-ttu-id="3a6ea-152">Ao criar uma nova interface, você deve criar um novo identificador para essa interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-152">When you create a new interface, you must create a new identifier for that interface.</span></span> <span data-ttu-id="3a6ea-153">Quando um chamador usa uma interface, ele deve usar o identificador exclusivo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-153">When a caller uses an interface, it must use the unique identifier.</span></span> <span data-ttu-id="3a6ea-154">Essa identificação explícita melhora a robustez ao eliminar conflitos de nomenclatura que resultariam em falha de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-154">This explicit identification improves robustness by eliminating naming conflicts that would result in run-time failure.</span></span>

<span data-ttu-id="3a6ea-155">Ao definir uma nova interface, você pode criar uma definição de interface usando o IDL (Interface Definition Language).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-155">When you define a new interface, you can create an interface definition by using the interface definition language (IDL).</span></span> <span data-ttu-id="3a6ea-156">A partir dessa definição de interface, o compilador Microsoft IDL gera arquivos de cabeçalho para uso por aplicativos usando a interface e o código-fonte para lidar com chamadas de procedimento remoto.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-156">From this interface definition, the Microsoft IDL compiler generates header files for use by applications using the interface, and source code to handle remote procedure calls.</span></span> <span data-ttu-id="3a6ea-157">A IDL fornecida pela Microsoft baseia-se em extensões simples para o DCE IDL, um padrão do setor para a computação distribuída baseada em RPC (chamada de procedimento remoto).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-157">The IDL supplied by Microsoft is based on simple extensions to DCE IDL, an industry standard for Remote Procedure Call (RPC)-based distributed computing.</span></span> <span data-ttu-id="3a6ea-158">IDL é uma ferramenta para a conveniência do designer de interface e não é central para a interoperabilidade COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-158">IDL is a tool for the convenience of the interface designer and is not central to COM interoperability.</span></span> <span data-ttu-id="3a6ea-159">Com o IDL, você não precisa criar arquivos de cabeçalho manualmente para cada ambiente de programação.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-159">With IDL, you do not need to create header files manually for each programming environment.</span></span> <span data-ttu-id="3a6ea-160">Para obter mais informações, consulte [definindo interfaces com](defining-com-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-160">For more information, see [Defining COM Interfaces](defining-com-interfaces.md).</span></span>

<span data-ttu-id="3a6ea-161">A herança é usada COM moderação em interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-161">Inheritance is used sparingly in COM interfaces.</span></span> <span data-ttu-id="3a6ea-162">COM dá suporte à herança de interface somente para reutilizar um contrato associado a uma interface base.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-162">COM supports interface inheritance only to reuse a contract associated with a base interface.</span></span> <span data-ttu-id="3a6ea-163">COM não oferece suporte à herança seletiva; Portanto, se uma interface herdar de outra, ela incluirá todas as funções que a interface base define.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-163">COM does not support selective inheritance; therefore, if one interface inherits from another, it includes all of the functions that the base interface defines.</span></span> <span data-ttu-id="3a6ea-164">Além disso, as interfaces usam apenas uma única herança, em vez de várias heranças, para obter funções de uma interface base.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-164">In addition, interfaces use only single inheritance, instead of multiple inheritance, to obtain functions from a base interface.</span></span>

## <a name="interface-implementation"></a><span data-ttu-id="3a6ea-165">Implementação de interface</span><span class="sxs-lookup"><span data-stu-id="3a6ea-165">Interface implementation</span></span>

<span data-ttu-id="3a6ea-166">Você não pode criar uma instância de uma interface COM por si só.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-166">You cannot create an instance of a COM interface by itself.</span></span> <span data-ttu-id="3a6ea-167">Em vez disso, você cria uma instância de uma classe que implementa a interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-167">Instead, you create an instance of a class that implements the interface.</span></span> <span data-ttu-id="3a6ea-168">Em C++, uma interface COM é modelada como uma *classe base abstrata*, o que significa que a interface é uma classe C++ que contém apenas funções de membro virtual puras.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-168">In C++, a COM interface is modeled as an *abstract base class*, which means that the interface is a C++ class that contains only pure virtual member functions.</span></span> <span data-ttu-id="3a6ea-169">Uma biblioteca C++ implementa objetos COM herdando as assinaturas de função de membro de uma ou mais interfaces, substituindo cada função de membro e fornecendo uma implementação para cada função.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-169">A C++ library implements COM objects by inheriting the member function signatures from one or more interfaces, overriding each member function, and providing an implementation for each function.</span></span>

<span data-ttu-id="3a6ea-170">Você pode usar qualquer linguagem de programação que dê suporte ao conceito de ponteiros de função para implementar uma interface COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-170">You can use any programming language that supports the concept of function pointers to implement a COM interface.</span></span> <span data-ttu-id="3a6ea-171">Por exemplo, em C, uma interface é uma estrutura que contém um ponteiro para uma tabela de ponteiros de função, uma para cada método na interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-171">For example, in C, an interface is a structure containing a pointer to a table of function pointers, one for each method in the interface.</span></span>

<span data-ttu-id="3a6ea-172">Quando você implementa uma interface, sua classe deve fornecer uma implementação para cada função na interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-172">When you implement an interface, your class must provide an implementation for every function in the interface.</span></span> <span data-ttu-id="3a6ea-173">Se a classe não tiver nenhum trabalho a ser feito em uma função de interface, a implementação poderá ser uma única instrução de retorno.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-173">If the class has no work to do in an interface function, the implementation may be a single return statement.</span></span>

<span data-ttu-id="3a6ea-174">Uma classe COM é identificada usando um CLSID (ID de classe) de 128 bits exclusivo que associa uma classe a uma implantação específica no sistema de arquivos, que para o Windows é uma DLL ou um EXE.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-174">A COM class is identified by using a unique 128-bit Class ID (CLSID) that associates a class with a particular deployment in the file system, which for Windows is a DLL or EXE.</span></span> <span data-ttu-id="3a6ea-175">Um CLSID é um GUID, o que significa que nenhuma outra classe tem o mesmo CLSID.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-175">A CLSID is a GUID, which means that no other class has the same CLSID.</span></span> <span data-ttu-id="3a6ea-176">O uso de identificadores de classe exclusivos impede colisões de nome entre classes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-176">The use of unique class identifiers prevents name collisions among classes.</span></span> <span data-ttu-id="3a6ea-177">Por exemplo, dois fornecedores diferentes podem escrever uma classe chamada CStack, mas ambas as classes têm um CLSID exclusivo, portanto, qualquer possibilidade de uma colisão é evitada.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-177">For example, two different vendors can write a class named CStack, but both classes have a unique CLSID, so any possibility of a collision is avoided.</span></span>

<span data-ttu-id="3a6ea-178">Você Obtém um novo CLSID usando a função [**falha em CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) ou usando uma ferramenta de criação com, como o Visual Studio, que chama essa função internamente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-178">You obtain a new CLSID by using the [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) function or by using a COM authoring tool, such as Visual Studio, that calls this function internally.</span></span>

## <a name="the-iunknown-interface"></a><span data-ttu-id="3a6ea-179">A interface IUnknown</span><span class="sxs-lookup"><span data-stu-id="3a6ea-179">The IUnknown Interface</span></span>

<span data-ttu-id="3a6ea-180">Todas as interfaces COM herdam da interface [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-180">All COM interfaces inherit from the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="3a6ea-181">A interface **IUnknown** contém as operações com fundamentais para o gerenciamento de tempo de vida de polimorfismo e instância.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-181">The **IUnknown** interface contains the fundamental COM operations for polymorphism and instance lifetime management.</span></span> <span data-ttu-id="3a6ea-182">A interface **IUnknown** tem três funções de membro, chamadas [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-182">The **IUnknown** interface has three member functions, named [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref), and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span></span> <span data-ttu-id="3a6ea-183">Todos os objetos COM são necessários para implementar a interface **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-183">All COM objects are required to implement the **IUnknown** interface.</span></span>

<span data-ttu-id="3a6ea-184">A função de membro [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) fornece POLIMORFISMO para com.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-184">The [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) member function provides polymorphism for COM.</span></span> <span data-ttu-id="3a6ea-185">Chame **QueryInterface** para determinar em tempo de execução se um objeto com dá suporte a uma interface específica.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-185">Call **QueryInterface** to determine at run time whether a COM object supports a particular interface.</span></span> <span data-ttu-id="3a6ea-186">O objeto COM retorna um ponteiro de interface no `ppvObject` parâmetro se ele implementa a interface solicitada; caso contrário, ele retorna `NULL` .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-186">The COM object returns an interface pointer in the `ppvObject` parameter if it implements the requested interface, otherwise it returns `NULL`.</span></span> <span data-ttu-id="3a6ea-187">A função de membro **QueryInterface** permite a navegação entre todas as interfaces às quais um objeto com dá suporte.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-187">The **QueryInterface** member function enables navigation among all of the interfaces that a COM object supports.</span></span>

<span data-ttu-id="3a6ea-188">O tempo de vida de uma instância de objeto COM é controlado por sua *contagem de referência*.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-188">The lifetime of a COM object instance is controlled by its *reference count*.</span></span> <span data-ttu-id="3a6ea-189">As funções de membro [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) de [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) controlam a contagem.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-189">The [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) member functions [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) control the count.</span></span> <span data-ttu-id="3a6ea-190">O **AddRef** incrementa a contagem e a **versão** decrementa a contagem.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-190">**AddRef** increments the count and **Release** decrements the count.</span></span> <span data-ttu-id="3a6ea-191">Quando a contagem de referência chega a zero, a função de membro de **liberação** pode liberar a instância, pois nenhum chamador a está usando.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-191">When the reference count reaches zero, the **Release** member function may free the instance, because no callers are using it.</span></span>

## <a name="the-clientserver-model"></a><span data-ttu-id="3a6ea-192">O modelo de cliente/servidor</span><span class="sxs-lookup"><span data-stu-id="3a6ea-192">The Client/Server Model</span></span>

<span data-ttu-id="3a6ea-193">Uma classe COM implementa um número de interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-193">A COM class implements a number of COM interfaces.</span></span> <span data-ttu-id="3a6ea-194">A implementação consiste em binários que são executados quando um chamador interage com uma instância da classe COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-194">The implementation consists of binaries that run when a caller interacts with an instance of the COM class.</span></span> <span data-ttu-id="3a6ea-195">O COM permite o uso de uma classe em aplicativos diferentes, incluindo aplicativos escritos sem conhecimento de uma classe específica.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-195">COM enables using a class in different applications, including applications written without knowledge of a particular class.</span></span> <span data-ttu-id="3a6ea-196">Em uma plataforma Windows, as classes existem em uma DLL (biblioteca vinculada dinâmica) ou em outro aplicativo (EXE).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-196">On a Windows platform, classes exist either in a dynamic-linked library (DLL) or in another application (EXE).</span></span>

<span data-ttu-id="3a6ea-197">Em seu sistema host, o COM mantém um banco de dados de registro de todos os CLSIDs para os objetos COM instalados no sistema.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-197">On its host system, COM maintains a registration database of all the CLSIDs for the COM objects installed on the system.</span></span> <span data-ttu-id="3a6ea-198">O banco de dados de registro é um mapeamento entre cada CLSID e o local da DLL ou EXE que hospeda a classe correspondente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-198">The registration database is a mapping between each CLSID and the location of the DLL or EXE that houses the corresponding class.</span></span> <span data-ttu-id="3a6ea-199">COM consulta esse banco de dados sempre que um chamador quiser criar uma instância de uma classe COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-199">COM queries this database whenever a caller wants to create an instance of a COM class.</span></span> <span data-ttu-id="3a6ea-200">O chamador precisa saber apenas o CLSID para solicitar uma nova instância da classe.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-200">The caller needs to know only the CLSID to request a new instance of the class.</span></span>

<span data-ttu-id="3a6ea-201">A interação entre um objeto COM e seus chamadores é modelada como uma relação de cliente/servidor.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-201">The interaction between a COM object and its callers is modeled as a client/server relationship.</span></span> <span data-ttu-id="3a6ea-202">O cliente é o chamador que solicita um objeto COM do sistema e o servidor é o módulo que hospeda objetos COM que fornece serviços aos clientes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-202">The client is the caller that requests a COM object from the system, and the server is the module that houses COM objects that provides services to clients.</span></span>

<span data-ttu-id="3a6ea-203">Um cliente COM é qualquer chamador que passe um CLSID para o sistema para solicitar uma instância de um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-203">A COM client is any caller that passes a CLSID to the system to request an instance of a COM object.</span></span> <span data-ttu-id="3a6ea-204">A maneira mais simples de criar uma instância é chamar a função COM, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-204">The simplest way to create an instance is to call the COM function, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

<span data-ttu-id="3a6ea-205">A função [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) cria uma instância do CLSID especificado e retorna um ponteiro de interface do tipo solicitado pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-205">The [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function creates one instance of the specified CLSID and returns an interface pointer of the type requested by the client.</span></span> <span data-ttu-id="3a6ea-206">O cliente é responsável por gerenciar o tempo de vida da instância chamando sua função de [**liberação**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) quando o cliente termina de usá-la.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-206">The client is responsible for managing the lifetime of the instance by calling its [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) function when the client has finished using it.</span></span> <span data-ttu-id="3a6ea-207">Para criar vários objetos com base em um único CLSID, chame a função [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-207">To create multiple objects based on a single CLSID, call the [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) function.</span></span> <span data-ttu-id="3a6ea-208">Para se conectar a um objeto que já está criado e em execução, chame a função [**GetActiveObject**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-208">To connect to an object that is already created and running, call the [**GetActiveObject**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) function.</span></span>

<span data-ttu-id="3a6ea-209">Um servidor COM fornece uma implementação COM para o sistema.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-209">A COM server provides a COM implementation to the system.</span></span> <span data-ttu-id="3a6ea-210">Um servidor associa um CLSID a uma classe COM, hospeda a implementação da classe, implementa uma fábrica de classes para criar instâncias da classe e fornece o descarregamento do servidor.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-210">A server associates a CLSID with a COM class, houses the implementation of the class, implements a class factory for creating instances of the class, and provides for unloading the server.</span></span>

> [!Note]  
> <span data-ttu-id="3a6ea-211">Um servidor COM não é o mesmo que o objeto COM que ele fornece ao sistema.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-211">A COM server is not the same as the COM object that it provides to the system.</span></span>

 

<span data-ttu-id="3a6ea-212">Para habilitar a criação de um objeto COM, um servidor COM deve fornecer uma implementação da interface [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-212">To enable creating a COM object, a COM server must provide an implementation of the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface.</span></span> <span data-ttu-id="3a6ea-213">Os clientes podem chamar o método [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) para solicitar uma nova instância de um objeto com, mas geralmente essas solicitações são encapsuladas na função [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-213">Clients can call the [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) method to request a new instance of a COM object, but usually such requests are encapsulated in the [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function.</span></span>

<span data-ttu-id="3a6ea-214">Você pode implantar um servidor COM como uma biblioteca compartilhada que é carregada no processo do cliente em tempo de execução (DLL em plataformas Windows) ou como um módulo executável (EXE em plataformas Windows).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-214">You can deploy a COM server either as a shared library that is loaded into the client's process at run time (DLL on Windows platforms) or as an executable module (EXE on Windows platforms).</span></span> <span data-ttu-id="3a6ea-215">Para obter mais informações, consulte [registrando aplicativos com](registering-com-applications.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-215">For more information, see [Registering COM Applications](registering-com-applications.md).</span></span>

## <a name="service-control-manager"></a><span data-ttu-id="3a6ea-216">Gerenciador de Controle de Serviço</span><span class="sxs-lookup"><span data-stu-id="3a6ea-216">Service Control Manager</span></span>

<span data-ttu-id="3a6ea-217">O SCM (Gerenciador de controle de serviço) manipula a solicitação do cliente para uma instância de um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-217">The Service Control Manager (SCM) handles the client request for an instance of a COM object.</span></span> <span data-ttu-id="3a6ea-218">A lista a seguir mostra a sequência de eventos:</span><span class="sxs-lookup"><span data-stu-id="3a6ea-218">The following list shows the sequence of events:</span></span>

-   <span data-ttu-id="3a6ea-219">Um cliente solicita um ponteiro de interface para um objeto COM da biblioteca COM chamando uma função como [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) com o CLSID do objeto com.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-219">A client requests an interface pointer to a COM object from the COM Library by calling a function such as [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) with the CLSID of the COM object.</span></span>
-   <span data-ttu-id="3a6ea-220">A biblioteca COM consulta o SCM para localizar o servidor que corresponde ao CLSID solicitado.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-220">The COM Library queries the SCM to find the server that corresponds with the requested CLSID.</span></span>
-   <span data-ttu-id="3a6ea-221">O SCM localiza o servidor e solicita a criação do objeto COM da fábrica de classes fornecida pelo servidor.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-221">The SCM locates the server and requests the creation of the COM object from the class factory that is provided by the server.</span></span>
-   <span data-ttu-id="3a6ea-222">Se for bem-sucedida, a biblioteca COM retornará um ponteiro de interface para o cliente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-222">If successful, the COM Library returns an interface pointer to the client.</span></span>

<span data-ttu-id="3a6ea-223">Depois que o sistema COM conecta um objeto de servidor a um cliente, o cliente e o objeto se comunicam diretamente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-223">After the COM system connects a server object to a client, the client and object communicate directly.</span></span> <span data-ttu-id="3a6ea-224">Não há nenhuma sobrecarga adicional de chamar por meio de um tempo de execução intermediário.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-224">There is no added overhead from calling through an intermediary run time.</span></span>

<span data-ttu-id="3a6ea-225">Ao registrar um servidor com com o sistema host, você pode especificar diferentes maneiras para o servidor ser ativado.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-225">When you register a COM server with the host system, you can specify different ways for the server to be activated.</span></span> <span data-ttu-id="3a6ea-226">A lista a seguir mostra as três maneiras que o SCM pode ativar um servidor COM:</span><span class="sxs-lookup"><span data-stu-id="3a6ea-226">The following list shows the three ways that the SCM can activate a COM server:</span></span>

-   <span data-ttu-id="3a6ea-227">Em processo: o SCM retorna o caminho do arquivo da DLL que contém a implementação do servidor de objetos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-227">In-process: The SCM returns the file path of the DLL that contains the object server implementation.</span></span> <span data-ttu-id="3a6ea-228">A biblioteca COM carrega a DLL e a consulta para seu ponteiro de interface de fábrica de classes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-228">The COM Library loads the DLL and queries it for its class factory interface pointer.</span></span>
-   <span data-ttu-id="3a6ea-229">Local: o SCM inicia o executável local que registra uma fábrica de classes na inicialização e seu ponteiro de interface está disponível para o sistema e os clientes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-229">Local: The SCM starts the local executable which registers a class factory on startup, and its interface pointer is available to the system and clients.</span></span>
-   <span data-ttu-id="3a6ea-230">Remoto: o SCM local adquire um ponteiro de interface de fábrica de classe do SCM que está sendo executado em um computador remoto.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-230">Remote: The local SCM acquires a class factory interface pointer from the SCM that is running on a remote computer.</span></span>

<span data-ttu-id="3a6ea-231">Quando um cliente solicita um objeto COM, a biblioteca COM entra em contato com o SCM no host local.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-231">When a client requests a COM object, the COM Library contacts the SCM on the local host.</span></span> <span data-ttu-id="3a6ea-232">O SCM localiza o servidor COM apropriado, que pode ser local ou remoto, e o servidor retorna um ponteiro de interface para a fábrica de classes do servidor.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-232">The SCM locates the appropriate COM server, which may be local or remote, and the server returns an interface pointer to the server's class factory.</span></span> <span data-ttu-id="3a6ea-233">Quando a fábrica de classes estiver disponível, a biblioteca COM ou o cliente poderá usar a fábrica de classes para criar o objeto solicitado.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-233">When the class factory is available, the COM Library or the client can use the class factory to create the requested object.</span></span> <span data-ttu-id="3a6ea-234">Para obter mais informações, consulte [implementando IClassFactory](implementing-iclassfactory.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-234">For more information, see [Implementing IClassFactory](implementing-iclassfactory.md).</span></span>

## <a name="reusability"></a><span data-ttu-id="3a6ea-235">Capacidade de reutilização</span><span class="sxs-lookup"><span data-stu-id="3a6ea-235">Reusability</span></span>

<span data-ttu-id="3a6ea-236">O COM dá suporte à *reutilização de caixa preta*, o que significa que os detalhes de implementação de um componente reutilizável não são expostos aos clientes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-236">COM supports *black-box reusability*, which means that the implementation details of a reusable component are not exposed to clients.</span></span> <span data-ttu-id="3a6ea-237">Para obter a reutilização de caixa preta, o COM dá suporte a dois mecanismos por meio dos quais um objeto pode reutilizar outro.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-237">To achieve black-box reusability, COM supports two mechanisms through which one object may reuse another.</span></span> <span data-ttu-id="3a6ea-238">As duas formas de reutilização são chamadas de *contenção* e *agregação*.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-238">The two forms of reuse are named *containment* and *aggregation*.</span></span> <span data-ttu-id="3a6ea-239">Por convenção, o objeto que está sendo reutilizado é chamado de *objeto interno* e o objeto que está fazendo uso do objeto interno é denominado *objeto externo*.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-239">By convention, the object being reused is named the *inner object*, and the object that is making use of the inner object is named the *outer object*.</span></span>

<span data-ttu-id="3a6ea-240">Em confinamento, o objeto externo se comporta como um cliente do objeto interno.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-240">In containment, the outer object behaves as a client of the inner object.</span></span> <span data-ttu-id="3a6ea-241">O objeto externo é um contêiner lógico para o objeto interno e, quando o objeto externo usa os serviços do objeto interno, o objeto externo delega a implementação para as interfaces do objeto interno.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-241">The outer object is a logical container for the inner object, and when the outer object uses the services of the inner object, the outer object delegates implementation to the inner object's interfaces.</span></span> <span data-ttu-id="3a6ea-242">Isso significa que o objeto externo é implementado em termos dos serviços do objeto interno.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-242">This means that the outer object is implemented in terms of the inner object's services.</span></span> <span data-ttu-id="3a6ea-243">O objeto externo pode não dar suporte às mesmas interfaces que o objeto interno, e o objeto externo pode usar uma interface de objeto interno para ajudar na implementação de partes de uma interface diferente no objeto externo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-243">The outer object may not support the same interfaces as the inner object, and the outer object may use an inner object's interface to help with implementing parts of a different interface on the outer object.</span></span>

<span data-ttu-id="3a6ea-244">Na agregação, o objeto externo expõe interfaces do objeto interno como se elas estivessem implementadas no objeto externo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-244">In aggregation, the outer object exposes interfaces from the inner object as if they were implemented on the outer object.</span></span> <span data-ttu-id="3a6ea-245">Isso é útil quando o objeto externo sempre Delega cada chamada em uma de suas interfaces para a mesma interface do objeto interno.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-245">This is useful when the outer object would always delegate every call on one of its interfaces to the same interface of the inner object.</span></span> <span data-ttu-id="3a6ea-246">A agregação é uma conveniência que permite que o objeto externo Evite sobrecarga de implementação extra.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-246">Aggregation is a convenience that enables the outer object to avoid extra implementation overhead.</span></span>

<span data-ttu-id="3a6ea-247">Para obter mais informações, consulte [reutilizando objetos](reusing-objects.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-247">For more information, see [Reusing Objects](reusing-objects.md).</span></span>

## <a name="storage-and-stream-objects"></a><span data-ttu-id="3a6ea-248">Objetos de armazenamento e fluxo</span><span class="sxs-lookup"><span data-stu-id="3a6ea-248">Storage and Stream Objects</span></span>

<span data-ttu-id="3a6ea-249">Objetos COM salvam o estado em um arquivo usando o *armazenamento estruturado*, que é uma forma de armazenamento persistente que permite a navegação do conteúdo de um arquivo usando a semântica do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-249">COM objects save state to a file by using *structured storage*, which is a form of persistent storage that enables navigation of a file's contents by using file system semantics.</span></span> <span data-ttu-id="3a6ea-250">Tratar o conteúdo de um arquivo dessa maneira habilita recursos como acesso incremental, transações e compartilhamento entre processos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-250">Treating a file's contents in this manner enables features such as incremental access, transactions, and sharing among processes.</span></span>

<span data-ttu-id="3a6ea-251">A especificação de armazenamento persistente de COM fornece dois tipos de elementos de armazenamento: objetos de armazenamento e objetos de fluxo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-251">The COM persistent storage specification provides for two types of storage elements: storage objects and stream objects.</span></span> <span data-ttu-id="3a6ea-252">Esses objetos são implementados pela biblioteca COM e os aplicativos de usuário raramente implementam esses elementos de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-252">These objects are implemented by the COM Library, and user applications rarely implement these storage elements.</span></span> <span data-ttu-id="3a6ea-253">Os objetos de armazenamento implementam a interface [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) e os objetos de fluxo implementam a interface [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-253">Storage objects implement the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, and stream objects implement the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface.</span></span>

<span data-ttu-id="3a6ea-254">Um objeto de fluxo contém dados e é conceitualmente semelhante a um único arquivo em um sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-254">A stream object contains data and is conceptually similar to a single file in a file system.</span></span> <span data-ttu-id="3a6ea-255">Cada fluxo tem direitos de acesso e um único ponteiro de busca.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-255">Each stream has access rights and a single seek pointer.</span></span> <span data-ttu-id="3a6ea-256">Por meio da interface [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) , você pode ler, gravar, buscar e executar outras operações nos dados subjacentes do fluxo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-256">Through the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface, you can read, write, seek, and perform other operations on the stream's underlying data.</span></span> <span data-ttu-id="3a6ea-257">Um fluxo é nomeado usando uma cadeia de texto.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-257">A stream is named by using a text string.</span></span> <span data-ttu-id="3a6ea-258">Ele pode conter qualquer estrutura interna, pois é um fluxo simples de bytes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-258">It can contain any internal structure, because it is a flat stream of bytes.</span></span> <span data-ttu-id="3a6ea-259">Além disso, as funções na interface **IStream** são semelhantes às funções baseadas em identificador de arquivo padrão, como aquelas na biblioteca de tempo de execução ANSI C.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-259">In addition, the functions in the **IStream** interface are similar to standard file-handle based functions, such as those in the ANSI C run-time library.</span></span>

<span data-ttu-id="3a6ea-260">Um objeto de armazenamento é conceitualmente semelhante a um diretório em um sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-260">A storage object is conceptually similar to a directory in a file system.</span></span> <span data-ttu-id="3a6ea-261">Cada armazenamento pode conter qualquer número de objetos de subarmazenamento e qualquer quantidade de fluxos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-261">Each storage can contain any number of sub-storage objects and any number of streams.</span></span> <span data-ttu-id="3a6ea-262">Cada armazenamento tem seus próprios direitos de acesso.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-262">Each storage has its own access rights.</span></span> <span data-ttu-id="3a6ea-263">Por meio da interface [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , você pode executar operações como enumerar, mover, copiar, renomear, criar e excluir elementos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-263">Through the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, you can perform operations such as enumerating, moving, copying, renaming, creating, and deleting elements.</span></span> <span data-ttu-id="3a6ea-264">Um objeto de armazenamento não armazena dados definidos pelo aplicativo, mas armazena implicitamente os nomes dos elementos (armazenamentos e fluxos) que ele contém.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-264">A storage object does not store application-defined data, but it stores implicitly the names of the elements (storages and streams) that it contains.</span></span>

<span data-ttu-id="3a6ea-265">Os objetos de armazenamento e de fluxo podem ser compartilhados entre processos quando são implementados de acordo com a especificação COM em uma plataforma de host.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-265">Storage and stream objects are sharable among processes when they are implemented according to the COM specification on a host platform.</span></span> <span data-ttu-id="3a6ea-266">Isso permite que os objetos que estão executando em processo ou fora do processo tenham acesso incremental igual ao seu armazenamento de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-266">This enables objects that are running in-process or out-of-process to have equal incremental access to their file storage.</span></span> <span data-ttu-id="3a6ea-267">Como o COM é carregado em cada processo separadamente, ele usa mecanismos de memória compartilhada com suporte do sistema operacional para comunicar o estado dos elementos abertos e seus modos de acesso entre os processos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-267">Because COM is loaded into each process separately, it uses operating-system supported shared memory mechanisms to communicate the state of opened elements and their access modes between processes.</span></span>

<span data-ttu-id="3a6ea-268">Cada objeto de armazenamento e fluxo em um arquivo estruturado tem um nome para identificá-lo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-268">Every storage and stream object in a structured file has a name to identify it.</span></span> <span data-ttu-id="3a6ea-269">O nome é uma cadeia de caracteres que segue uma convenção específica.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-269">The name is a string that follows a particular convention.</span></span> <span data-ttu-id="3a6ea-270">Para obter mais informações, consulte [convenções de nomenclatura de objeto de armazenamento](/windows/desktop/Stg/storage-object-naming-conventions).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-270">For more information, see [Storage Object Naming Conventions](/windows/desktop/Stg/storage-object-naming-conventions).</span></span> <span data-ttu-id="3a6ea-271">O nome é passado para funções [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) para especificar em qual elemento no armazenamento operar.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-271">The name is passed to [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) functions to specify which element in the storage to operate on.</span></span> <span data-ttu-id="3a6ea-272">Os nomes dos objetos de armazenamento raiz são os mesmos que os nomes de arquivo no sistema de arquivos subjacente, e esses nomes devem seguir as convenções e restrições do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-272">Names of root storage objects are the same as file names in the underlying file system, and these names must follow the file system's conventions and restrictions.</span></span> <span data-ttu-id="3a6ea-273">Cadeias de caracteres passadas para funções relacionadas ao armazenamento que os arquivos de nome passam para o sistema de arquivos sem interpretação ou alterações.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-273">Strings passed to storage-related functions which name files are passed through to the file system without interpretation or changes.</span></span>

<span data-ttu-id="3a6ea-274">Os nomes dos elementos contidos nos objetos de armazenamento são gerenciados pela implementação do objeto de armazenamento específico em questão.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-274">Names of elements that are contained within storage objects are managed by the implementation of the particular storage object in question.</span></span> <span data-ttu-id="3a6ea-275">Todas as implementações de objetos de armazenamento devem dar suporte a nomes de elementos com 32 caracteres de comprimento e algumas implementações podem dar suporte a nomes mais longos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-275">All implementations of storage objects must support element names that are 32 characters in length, and some implementations may support longer names.</span></span> <span data-ttu-id="3a6ea-276">Os nomes são armazenados com o caso preservado, mas são comparados como não diferenciam maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-276">Names are stored with case preserved, but they are compared as case-insensitive.</span></span> <span data-ttu-id="3a6ea-277">Os aplicativos que definem nomes de elementos de armazenamento devem escolher nomes que funcionem em qualquer situação.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-277">Applications that define storage element names must choose names that work in either situation.</span></span>

<span data-ttu-id="3a6ea-278">Você acessa todos os elementos em um arquivo de armazenamento estruturado usando funções e interfaces implementadas pelo COM.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-278">You access every element in a structured storage file by using functions and interfaces that are implemented by COM.</span></span> <span data-ttu-id="3a6ea-279">Isso significa que outros aplicativos podem procurar o arquivo navegando com as funções da interface [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) que fornecem serviços do tipo diretório.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-279">This means that other applications can browse the file by navigating with the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface functions that provide directory-like services.</span></span> <span data-ttu-id="3a6ea-280">Além disso, outros aplicativos podem usar os dados do arquivo, sem precisar executar o aplicativo que escreveu o arquivo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-280">Also, other applications can use the file's data, without having to run the application that wrote the file.</span></span> <span data-ttu-id="3a6ea-281">Quando um aplicativo COM acessa os arquivos de armazenamento estruturados de outro aplicativo, direitos de acesso padrão do Windows se aplicam e o aplicativo deve ter privilégios suficientes.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-281">When a COM application accesses the structured storage files of another application, standard Windows access rights apply, and the application must have sufficient privileges.</span></span>

<span data-ttu-id="3a6ea-282">Um objeto COM pode ler e gravar em um armazenamento persistente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-282">A COM object can read and write itself to persistent storage.</span></span> <span data-ttu-id="3a6ea-283">Um cliente consulta uma das interfaces relacionadas à persistência no objeto COM, dependendo do contexto da operação.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-283">A client queries for one of the persistence-related interfaces on the COM object, depending on the context of the operation.</span></span> <span data-ttu-id="3a6ea-284">Objetos COM podem implementar qualquer combinação das seguintes interfaces:</span><span class="sxs-lookup"><span data-stu-id="3a6ea-284">COM objects can implement any combination of the following interfaces:</span></span>

-   <span data-ttu-id="3a6ea-285">[**IPersistStorage**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): o objeto com lê e grava seu estado persistente em um objeto de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-285">[**IPersistStorage**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): The COM object reads and writes its persistent state to a storage object.</span></span> <span data-ttu-id="3a6ea-286">O cliente fornece o objeto com um ponteiro [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) por meio desta interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-286">The client provides the object with an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) pointer through this interface.</span></span> <span data-ttu-id="3a6ea-287">Essa é a única interface de persistência que inclui a semântica para acesso incremental.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-287">This is the only persistence interface that includes semantics for incremental access.</span></span>
-   <span data-ttu-id="3a6ea-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): o objeto com lê e grava seu estado persistente em um objeto de fluxo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): The COM object reads and writes its persistent state to a stream object.</span></span> <span data-ttu-id="3a6ea-289">O cliente fornece o objeto com um ponteiro de [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) por meio desta interface.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-289">The client provides the object with an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) pointer through this interface.</span></span>
-   <span data-ttu-id="3a6ea-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): o objeto com lê e grava seu estado persistente diretamente em um arquivo no sistema subjacente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): The COM object reads and writes its persistent state directly to a file on the underlying system.</span></span> <span data-ttu-id="3a6ea-291">Essa interface não envolve [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) ou [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) , a menos que o arquivo subjacente seja acessado por meio dessas interfaces, mas a interface **IPersistFile** não tem nenhuma semântica para armazenamentos e fluxos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-291">This interface does not involve [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) unless the underlying file is accessed through these interfaces, but the **IPersistFile** interface has no semantics for storages and streams.</span></span> <span data-ttu-id="3a6ea-292">O cliente fornece o objeto com um nome de arquivo e chama as funções [**salvar**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) ou [**carregar**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-292">The client provides the object with a file name and calls the [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) or [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) functions.</span></span>

## <a name="data-transfer"></a><span data-ttu-id="3a6ea-293">Transferência de dados</span><span class="sxs-lookup"><span data-stu-id="3a6ea-293">Data Transfer</span></span>

<span data-ttu-id="3a6ea-294">O armazenamento estruturado fornece a base para troca de dados entre objetos COM e processos, que é chamada de *transferência de dados uniforme*.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-294">Structured storage provides the basis for data exchange between COM objects and processes, which is named *uniform data transfer*.</span></span> <span data-ttu-id="3a6ea-295">Antes de o COM ter sido implementado no OLE 2, a transferência de dados no Windows foi especificada por *protocolos de transferência*, como os protocolos de arrastar e soltar da área de transferência.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-295">Before COM was implemented in OLE 2, data transfer on Windows was specified by *transfer protocols*, such as the clipboard and drag-drop protocols.</span></span> <span data-ttu-id="3a6ea-296">Cada protocolo de transferência tinha seu próprio conjunto de funções que vincularam o protocolo à consulta, e o código específico era necessário para lidar com cada protocolo diferente e o procedimento do Exchange.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-296">Each transfer protocol had its own set of functions that bound the protocol to the query, and specific code was required to handle each different protocol and exchange procedure.</span></span> <span data-ttu-id="3a6ea-297">A transferência de dados uniforme representa todas as transferências de dados usando a interface [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) , que separa as operações de troca de dados comuns do protocolo de transferência.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-297">Uniform data transfer represents all data transfers by using the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface, which separates common data exchange operations from the transfer protocol.</span></span>

<span data-ttu-id="3a6ea-298">A interface [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) encapsula as operações padrão Get e set em dados, consultas e enumerações e notificações que detectam quando os dados são alterados em um objeto.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-298">The [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface encapsulates the standard get and set operations on data, queries and enumerations, and notifications that detect when data changes in an object.</span></span> <span data-ttu-id="3a6ea-299">A transferência de dados uniforme permite descrições avançadas de formatos de dados, bem como o uso de diferentes mídias de armazenamento para a transferência de dados.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-299">Uniform data transfer enables rich descriptions of data formats, as well as the use of different storage media for the data transfer.</span></span>

<span data-ttu-id="3a6ea-300">Durante a transferência de dados uniforme, todos os protocolos trocam um ponteiro para uma interface [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-300">During uniform data transfer, all protocols exchange a pointer to an [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="3a6ea-301">O servidor é a origem dos dados e implementa um objeto de dados, que pode ser usado em qualquer protocolo de troca de dados.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-301">The server is the source of the data and implements one data object, which is usable in any data exchange protocol.</span></span> <span data-ttu-id="3a6ea-302">O cliente consome os dados e solicita dados de um objeto de dados quando recebe um ponteiro **IDataObject** de qualquer protocolo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-302">The client consumes the data and requests data from a data object when it receives an **IDataObject** pointer from any protocol.</span></span> <span data-ttu-id="3a6ea-303">Depois que a troca do ponteiro ocorre, ambos os lados lidam com a troca de dados de maneira uniforme, por meio da interface **IDataObject** .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-303">After the pointer exchange has occurred, both sides handle data exchange in a uniform fashion, through the **IDataObject** interface.</span></span>

<span data-ttu-id="3a6ea-304">COM define duas estruturas de dados que habilitam a transferência uniforme de dados.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-304">COM defines two data structures that enable uniform data transfer.</span></span> <span data-ttu-id="3a6ea-305">A estrutura [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) representa um formato de área de transferência generalizado e a estrutura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) representa o meio de transferência como um identificador de memória.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-305">The [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure represents a generalized clipboard format, and the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure represents the transfer medium as a memory handle.</span></span>

<span data-ttu-id="3a6ea-306">O cliente cria uma estrutura [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) para indicar o tipo de dados que ele solicita de uma fonte de dados e é usado pela fonte de dados para descrever quais formatos ele fornece.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-306">The client creates a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to indicate the type of data that it requests from a data source, and it is used by the data source to describe what formats it provides.</span></span> <span data-ttu-id="3a6ea-307">O cliente consulta uma fonte de dados em busca de seus formatos disponíveis solicitando sua interface [**IEnumFORMATETC**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-307">The client queries a data source for its available formats by requesting its [**IEnumFORMATETC**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) interface.</span></span> <span data-ttu-id="3a6ea-308">Para obter mais informações, consulte [a estrutura FORMATETC](the-formatetc-structure.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-308">For more information, see [The FORMATETC Structure](the-formatetc-structure.md).</span></span>

<span data-ttu-id="3a6ea-309">O cliente cria uma estrutura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) e a passa para o método [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) , e o objeto de dados retorna os dados na estrutura **STGMEDIUM** fornecida.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-309">The client creates a [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure and passes it to the [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) method, and the data object returns the data in the provided **STGMEDIUM** structure.</span></span>

<span data-ttu-id="3a6ea-310">A estrutura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) permite que clientes e fontes de dados escolham o meio de troca mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-310">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure enables both clients and data sources to choose the most efficient exchange medium.</span></span> <span data-ttu-id="3a6ea-311">Por exemplo, se os dados a serem trocados forem muito grandes, a fonte de dados poderá indicar uma mídia baseada em disco como seu formato preferencial, em vez da memória principal.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-311">For example, if the data to be exchanged is very large, the data source can indicate a disk-based medium as its preferred format, instead of main memory.</span></span> <span data-ttu-id="3a6ea-312">Essa flexibilidade permite trocas de dados eficientes que podem ser tão rápidas quanto passar um ponteiro para um [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) ou um [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-312">This flexibility enables efficient data exchanges that can be as fast as passing a pointer to an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream).</span></span> <span data-ttu-id="3a6ea-313">Para obter mais informações, consulte [a estrutura STGMEDIUM](the-stgmedium-structure.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-313">For more information, see [The STGMEDIUM Structure](the-stgmedium-structure.md).</span></span>

<span data-ttu-id="3a6ea-314">Um cliente de uma fonte de dados pode exigir notificação quando os dados são alterados.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-314">A client of a data source may require notification when the data changes.</span></span> <span data-ttu-id="3a6ea-315">O COM manipula notificações de alteração de dados usando um objeto de *coletor de aviso* , que implementa a interface [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-315">COM handles data-change notifications by using an *advise sink* object, which implements the [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) interface.</span></span> <span data-ttu-id="3a6ea-316">O objeto de coletor de aviso e a interface **IAdviseSink** são implementados pelo cliente, que passa um ponteiro **IAdviseSink** para a fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-316">The advise sink object and the **IAdviseSink** interface are implemented by the client, which passes an **IAdviseSink** pointer to the data source.</span></span> <span data-ttu-id="3a6ea-317">Quando a fonte de dados detecta uma alteração nos dados subjacentes, ela chama um método **IAdviseSink** para notificar o cliente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-317">When the data source detects a change in the underlying data, it calls an **IAdviseSink** method to notify the client.</span></span> <span data-ttu-id="3a6ea-318">Para obter mais informações, consulte [Data Notification](data-notification.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-318">For more information, see [Data Notification](data-notification.md).</span></span>

## <a name="remoting"></a><span data-ttu-id="3a6ea-319">Comunicação remota</span><span class="sxs-lookup"><span data-stu-id="3a6ea-319">Remoting</span></span>

<span data-ttu-id="3a6ea-320">O COM permite a computação remota e distribuída.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-320">COM enables remote and distributed computation.</span></span> <span data-ttu-id="3a6ea-321">A *interface de comunicação remota* permite que uma função de membro retorne um ponteiro de interface para um objeto com que está em um processo diferente ou em um computador host diferente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-321">*Interface remoting* enables a member function to return an interface pointer to a COM object that is in a different process or on a different host computer.</span></span> <span data-ttu-id="3a6ea-322">A infraestrutura que executa a interface de comunicação remota é transparente para o cliente e o servidor de objetos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-322">The infrastructure that performs the interface remoting is transparent to both the client and the object server.</span></span> <span data-ttu-id="3a6ea-323">Nem o cliente nem o servidor precisam de um outro detalhes de implantação para se comunicar por meio de uma interface remota.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-323">Neither the client nor the server need one another's deployment details to communicate through a remoted interface.</span></span> <span data-ttu-id="3a6ea-324">Um cliente chama funções de membro na mesma interface para se comunicar com um objeto COM que está em processo, fora de processo no host local ou em um computador remoto.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-324">A client calls member functions on the same interface to communicate with a COM object that is in-process, out-of-process on the local host, or on a remote computer.</span></span> <span data-ttu-id="3a6ea-325">As chamadas locais e remotas na mesma interface são indistinguíveis para o cliente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-325">Local and remote calls on the same interface are indistinguishable to the client.</span></span>

<span data-ttu-id="3a6ea-326">Para se comunicar com um objeto COM, um cliente sempre chama uma implementação em processo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-326">To communicate with a COM object, a client always calls an in-process implementation.</span></span> <span data-ttu-id="3a6ea-327">Se o objeto COM estiver em processo, a chamada será direta.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-327">If the COM object is in-process, the call is direct.</span></span> <span data-ttu-id="3a6ea-328">Se o objeto COM estiver fora do processo ou remoto, COM fornecerá uma implementação de *proxy* que encaminha a chamada para o objeto usando o Protocolo RPC (chamada de procedimento remoto).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-328">If the COM object is out-of-process or remote, COM provides a *proxy* implementation that forwards the call to the object by using the Remote Procedure Call (RPC) protocol.</span></span>

<span data-ttu-id="3a6ea-329">Um objeto COM sempre recebe chamadas de um cliente por meio de uma implementação em processo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-329">A COM object always receives calls from a client through an in-process implementation.</span></span> <span data-ttu-id="3a6ea-330">Se o chamador estiver em processo, a chamada será direta.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-330">If the caller is in-process, the call is direct.</span></span> <span data-ttu-id="3a6ea-331">Se o chamador estiver fora do processo ou remoto, o COM fornecerá uma implementação de *stub* que recebe a chamada de procedimento remoto do proxy no processo do cliente.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-331">If the caller is out-of-process or remote, COM provides a *stub* implementation that receives the remote procedure call from the proxy in the client process.</span></span>

<span data-ttu-id="3a6ea-332">O *marshaling* é o procedimento para empacotar a pilha de chamadas para transmissão de proxy para stub.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-332">*Marshaling* is the procedure for packaging the call stack for transmission from proxy to stub.</span></span> <span data-ttu-id="3a6ea-333">O *desempacotamento* é o desempacotamento que ocorre na extremidade de recebimento.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-333">*Unmarshaling* is the unpackaging that occurs at the receiving end.</span></span> <span data-ttu-id="3a6ea-334">Os valores de retorno são empacotados e desempacotados do stub para o proxy.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-334">Return values are marshaled and unmarshaled from the stub to the proxy.</span></span> <span data-ttu-id="3a6ea-335">Esse tipo de comunicação também é conhecido como enviar uma chamada *pela conexão*.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-335">This kind of communication is also referred to as sending a call *over the wire*.</span></span>

<span data-ttu-id="3a6ea-336">Cada tipo de dados diferente tem regras para marshaling.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-336">Each different data type has rules for marshaling.</span></span> <span data-ttu-id="3a6ea-337">Os ponteiros de interface também têm um protocolo de marshaling, que é encapsulado na função [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-337">Interface pointers also have a marshaling protocol, which is encapsulated in the [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) function.</span></span> <span data-ttu-id="3a6ea-338">Na maioria dos casos, o *empacotamento de interface padrão*, que é fornecido pelo sistema, é suficiente, mas um objeto com, opcionalmente, pode implementar o *empacotamento de interface personalizada* para controlar a criação de proxies de objeto remoto para si mesmo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-338">In most cases, *standard interface marshaling*, which is provided by the system, is sufficient, but a COM object optionally may implement *custom interface marshaling* to control the creation of remote object proxies to itself.</span></span> <span data-ttu-id="3a6ea-339">Para obter mais informações, consulte [comunicação entre objetos](inter-object-communication.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-339">For more information, see [Inter-Object Communication](inter-object-communication.md).</span></span>

## <a name="security"></a><span data-ttu-id="3a6ea-340">Segurança</span><span class="sxs-lookup"><span data-stu-id="3a6ea-340">Security</span></span>

<span data-ttu-id="3a6ea-341">O COM fornece duas formas de segurança de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-341">COM provides two forms of application security.</span></span> <span data-ttu-id="3a6ea-342">Uma é a *segurança de ativação*, que especifica como novos objetos são criados, como os clientes se conectam a objetos novos e existentes e como determinados serviços públicos, como a tabela de classes e a tabela de objetos em execução, são protegidos.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-342">One is *activation security*, which specifies how new objects are created, how clients connect to new and existing objects, and how certain public services, such as the Class Table and the Running Object Table are secured.</span></span> <span data-ttu-id="3a6ea-343">A outra é *chamar segurança*, que especifica como a segurança opera em uma conexão estabelecida entre um cliente para um objeto com.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-343">The other is *call security*, which specifies how security operates in an established connection between a client to a COM object.</span></span>

<span data-ttu-id="3a6ea-344">A segurança de ativação é aplicada automaticamente pelo SCM (Gerenciador de controle de serviço).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-344">Activation security is applied automatically by the Service Control Manager (SCM).</span></span> <span data-ttu-id="3a6ea-345">Quando o SCM recebe uma solicitação para recuperar um objeto COM, ele verifica a solicitação em relação às informações de segurança armazenadas no registro.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-345">When the SCM receives a request to retrieve a COM object, it checks the request against security information that is stored in the registry.</span></span>

<span data-ttu-id="3a6ea-346">As implementações do SCM geralmente oferecem configuração controlada pelo registro para administrar classes implantadas e para contas de usuário específicas no host.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-346">SCM implementations usually offer registry-driven configuration for administering deployed classes and for specific user accounts on the host.</span></span> <span data-ttu-id="3a6ea-347">Para obter mais informações, consulte [Activation Security](activation-security.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-347">For more information, see [Activation Security](activation-security.md).</span></span>

<span data-ttu-id="3a6ea-348">A segurança da chamada é aplicada automaticamente ou imposta pelo aplicativo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-348">Call security is applied automatically or is enforced by the application.</span></span> <span data-ttu-id="3a6ea-349">Se o aplicativo fornecer informações de instalação, o COM executará as verificações necessárias para proteger o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-349">If the application provides setup information, COM performs the necessary checks to secure the application.</span></span>

<span data-ttu-id="3a6ea-350">O mecanismo automático verifica a segurança para o processo, mas não para objetos ou métodos individuais.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-350">The automatic mechanism checks security for the process, but not for individual objects or methods.</span></span> <span data-ttu-id="3a6ea-351">Se um aplicativo exigir segurança mais refinada, o COM fornecerá funções que os aplicativos podem usar para fazer sua própria verificação de segurança.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-351">If an application requires more fine-grained security, COM provides functions that applications may use do their own security checking.</span></span>

<span data-ttu-id="3a6ea-352">Os mecanismos automáticos e personalizados podem ser usados juntos, de modo que um aplicativo pode pedir ao COM para executar a verificação de segurança automática e, em seguida, executar seu próprio.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-352">The automatic and custom mechanisms can be used together, so an application may ask COM to perform automatic security checking and then perform its own.</span></span>

<span data-ttu-id="3a6ea-353">Os serviços de segurança de chamada COM são divididos nas seguintes categorias:</span><span class="sxs-lookup"><span data-stu-id="3a6ea-353">COM call security services are divided into the following categories:</span></span>

-   <span data-ttu-id="3a6ea-354">Funções gerais que são chamadas por clientes e servidores, que permitem que o mecanismo de segurança automática seja inicializado e os serviços de autenticação automática sejam registrados.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-354">General functions that are called by both clients and servers, which enable the automatic security mechanism to be initialized and automatic authentication services to be registered.</span></span> <span data-ttu-id="3a6ea-355">As APIs de segurança de chamada geral são as funções [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) e [**CoQueryAuthenticationServices**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) .</span><span class="sxs-lookup"><span data-stu-id="3a6ea-355">The general call security APIs are the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) and [**CoQueryAuthenticationServices**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) functions.</span></span>
-   <span data-ttu-id="3a6ea-356">Interfaces em proxies de cliente, que permitem que o cliente controle a segurança em chamadas para interfaces individuais.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-356">Interfaces on client proxies, which enable the client to control the security on calls to individual interfaces.</span></span> <span data-ttu-id="3a6ea-357">A interface [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) e as funções [**CoQueryProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)e [**CoCopyProxy**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) fornecem segurança de chamada em um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-357">The [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface and the [**CoQueryProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket), and [**CoCopyProxy**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) functions provide call security on a remote object.</span></span>
-   <span data-ttu-id="3a6ea-358">Funções do lado do servidor e interfaces de contexto de chamada, que permitem que o servidor recupere informações de segurança sobre uma chamada e represente o chamador.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-358">Server-side functions and call-context interfaces, which enable the server to retrieve security information about a call and to impersonate the caller.</span></span> <span data-ttu-id="3a6ea-359">A interface [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) e as funções [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**CoImpersonateClient**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient)e [**CoRevertToSelf**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) fornecem segurança de chamada no lado do servidor.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-359">The [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface and the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**CoImpersonateClient**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient), and [**CoRevertToSelf**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) functions provide server-side call security.</span></span>

<span data-ttu-id="3a6ea-360">Geralmente, o cliente consulta o objeto COM para a interface [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) , que é implementada localmente pela camada de comunicação remota.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-360">Often, the client queries the COM object for the [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface, which is implemented locally by the remoting layer.</span></span> <span data-ttu-id="3a6ea-361">O cliente usa essa interface para controlar a segurança de proxies de interface individuais no objeto COM antes de fazer uma chamada em uma das interfaces.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-361">The client uses this interface to control the security of individual interface proxies on the COM object before making a call on one of the interfaces.</span></span>

<span data-ttu-id="3a6ea-362">Quando uma chamada chega ao servidor, o servidor pode chamar a função [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) para recuperar uma interface [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) , que permite que o servidor Verifique a autenticação do cliente e represente o cliente, se necessário.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-362">When a call arrives at the server, the server may call the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) function to retrieve an [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface, which allows the server to check the client's authentication and to impersonate the client, if necessary.</span></span> <span data-ttu-id="3a6ea-363">O objeto **IServerSecurity** é válido para a duração da chamada.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-363">The **IServerSecurity** object is valid for the duration of the call.</span></span>

<span data-ttu-id="3a6ea-364">Chame a função [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) para inicializar a camada de segurança e defina os valores especificados como o padrão de segurança.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-364">Call the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) function to initialize the security layer and set the specified values as the security default.</span></span> <span data-ttu-id="3a6ea-365">Se um processo não chamar **CoInitializeSecurity**, o com o chamará automaticamente na primeira vez que uma interface for empacotada ou desempacotada, registrando a segurança padrão do sistema.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-365">If a process does not call **CoInitializeSecurity**, COM calls it automatically the first time an interface is marshaled or unmarshaled, registering the system default security.</span></span> <span data-ttu-id="3a6ea-366">A função **CoInitializeSecurity** permite que o cliente estabeleça a segurança de chamada padrão para o processo, o que evita o uso de [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) em proxies individuais.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-366">The **CoInitializeSecurity** function allows the client to establish default call security for the process, which avoids the use of [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) on individual proxies.</span></span> <span data-ttu-id="3a6ea-367">A função **CoInitializeSecurity** permite que um servidor Registre serviços de autenticação automática para o processo.</span><span class="sxs-lookup"><span data-stu-id="3a6ea-367">The **CoInitializeSecurity** function enables a server to register automatic authentication services for the process.</span></span> <span data-ttu-id="3a6ea-368">Para obter mais informações, consulte [definindo Process-Wide segurança com CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span><span class="sxs-lookup"><span data-stu-id="3a6ea-368">For more information, see [Setting Process-Wide Security with CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="3a6ea-369">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="3a6ea-369">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3a6ea-370">Clientes e servidores COM</span><span class="sxs-lookup"><span data-stu-id="3a6ea-370">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="3a6ea-371">Definição de interfaces COM</span><span class="sxs-lookup"><span data-stu-id="3a6ea-371">Defining COM Interfaces</span></span>](defining-com-interfaces.md)
</dt> <dt>

[<span data-ttu-id="3a6ea-372">Registrando aplicativos COM</span><span class="sxs-lookup"><span data-stu-id="3a6ea-372">Registering COM Applications</span></span>](registering-com-applications.md)
</dt> <dt>

[<span data-ttu-id="3a6ea-373">Segurança em COM</span><span class="sxs-lookup"><span data-stu-id="3a6ea-373">Security in COM</span></span>](security-in-com.md)
</dt> <dt>

[<span data-ttu-id="3a6ea-374">Processos, threads e Apartments</span><span class="sxs-lookup"><span data-stu-id="3a6ea-374">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> </dl>

 

 
