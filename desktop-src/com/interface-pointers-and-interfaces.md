---
title: Ponteiros de interface e interfaces
description: Ponteiros de interface e interfaces
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/24/2019
ms.locfileid: "105807905"
---
# <a name="interface-pointers-and-interfaces"></a><span data-ttu-id="f6216-103">Ponteiros de interface e interfaces</span><span class="sxs-lookup"><span data-stu-id="f6216-103">Interface Pointers and Interfaces</span></span>

<span data-ttu-id="f6216-104">Uma instância de uma implementação de interface é, na verdade, um ponteiro para uma matriz de ponteiros para métodos, ou seja, uma tabela de funções que se refere a uma implementação de todos os métodos especificados na interface.</span><span class="sxs-lookup"><span data-stu-id="f6216-104">An instance of an interface implementation is actually a pointer to an array of pointers to methods - that is, a function table that refers to an implementation of all of the methods specified in the interface.</span></span> <span data-ttu-id="f6216-105">Objetos com várias interfaces podem fornecer ponteiros para mais de uma tabela de funções.</span><span class="sxs-lookup"><span data-stu-id="f6216-105">Objects with multiple interfaces can provide pointers to more than one function table.</span></span> <span data-ttu-id="f6216-106">Qualquer código que tenha um ponteiro pelo qual ele possa acessar a matriz pode chamar os métodos nessa interface.</span><span class="sxs-lookup"><span data-stu-id="f6216-106">Any code that has a pointer through which it can access the array can call the methods in that interface.</span></span>

<span data-ttu-id="f6216-107">Falar precisamente sobre esse indireção não é conveniente, então, em vez disso, o ponteiro para a tabela de funções de interface que outro objeto deve ter para chamar seus métodos é chamado simplesmente de um *ponteiro de interface*.</span><span class="sxs-lookup"><span data-stu-id="f6216-107">Speaking precisely about this multiple indirection is inconvenient, so instead, the pointer to the interface function table that another object must have to call its methods is called simply an *interface pointer*.</span></span> <span data-ttu-id="f6216-108">Você pode criar manualmente tabelas de funções em um aplicativo C ou quase automaticamente usando Visual C++ (ou outras linguagens orientadas a objeto que dão suporte a COM).</span><span class="sxs-lookup"><span data-stu-id="f6216-108">You can manually create function tables in a C application or almost automatically by using Visual C++ (or other object-oriented languages that support COM).</span></span>

<span data-ttu-id="f6216-109">Com o suporte de compilador apropriado (que é inerente em C e C++), um cliente pode chamar um método de interface por meio de seu nome, não sua posição na matriz.</span><span class="sxs-lookup"><span data-stu-id="f6216-109">With appropriate compiler support (which is inherent in C and C++), a client can call an interface method through its name, not its position in the array.</span></span> <span data-ttu-id="f6216-110">Como uma interface é um tipo, o compilador, dado os nomes dos métodos, pode verificar os tipos de parâmetros e retornar valores de cada chamada de método de interface.</span><span class="sxs-lookup"><span data-stu-id="f6216-110">Because an interface is a type, the compiler, given the names of methods, can check the types of parameters and return values of each interface method call.</span></span> <span data-ttu-id="f6216-111">Por outro lado, se um cliente usar um esquema de chamada baseado em posição, tal verificação de tipo não estará disponível, mesmo em C ou C++.</span><span class="sxs-lookup"><span data-stu-id="f6216-111">In contrast, if a client uses a position-based calling scheme, such type-checking is not available, even in C or C++.</span></span>

<span data-ttu-id="f6216-112">Cada interface é um contrato imutável de um grupo funcional de métodos.</span><span class="sxs-lookup"><span data-stu-id="f6216-112">Each interface is an immutable contract of a functional group of methods.</span></span> <span data-ttu-id="f6216-113">Você faz referência a uma interface em tempo de execução com um IID (identificador de interface globalmente exclusivo).</span><span class="sxs-lookup"><span data-stu-id="f6216-113">You reference an interface at run time with a globally unique interface identifier (IID).</span></span> <span data-ttu-id="f6216-114">Essa IID, que é uma instância específica de um GUID (identificador global exclusivo) com suporte do COM, permite que um cliente pergunte a um objeto precisamente se ele dá suporte à semântica da interface, sem sobrecarga desnecessária e sem a confusão que pode surgir em um sistema de ter várias versões da mesma interface com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="f6216-114">This IID, which is a specific instance of a globally unique identifier (GUID) supported by COM, allows a client to ask an object precisely whether it supports the semantics of the interface, without unnecessary overhead and without the confusion that could arise in a system from having multiple versions of the same interface with the same name.</span></span>

<span data-ttu-id="f6216-115">Para resumir, é importante entender o que é uma interface COM e não é:</span><span class="sxs-lookup"><span data-stu-id="f6216-115">To summarize, it is important to understand what a COM interface is, and is not:</span></span>

-   <span data-ttu-id="f6216-116">Uma interface COM não é a mesma que uma classe C++.</span><span class="sxs-lookup"><span data-stu-id="f6216-116">A COM interface is not the same as a C++ class.</span></span> <span data-ttu-id="f6216-117">A definição virtual pura não transporta nenhuma implementação.</span><span class="sxs-lookup"><span data-stu-id="f6216-117">The pure virtual definition carries no implementation.</span></span> <span data-ttu-id="f6216-118">Se você for um programador de C++, poderá definir a implementação de uma interface como uma classe, mas isso se enquadrará no cabeçalho dos detalhes da implementação, que COM não especifica.</span><span class="sxs-lookup"><span data-stu-id="f6216-118">If you are a C++ programmer, you can define your implementation of an interface as a class, but this falls under the heading of implementation details, which COM does not specify.</span></span> <span data-ttu-id="f6216-119">Uma instância de um objeto que implementa uma interface deve ser criada para que a interface realmente exista.</span><span class="sxs-lookup"><span data-stu-id="f6216-119">An instance of an object that implements an interface must be created for the interface actually to exist.</span></span> <span data-ttu-id="f6216-120">Além disso, classes de objeto diferentes podem implementar uma interface de forma diferente, ainda que seja usada de maneira intercambiável em formato binário, desde que o comportamento esteja de acordo com a definição da interface.</span><span class="sxs-lookup"><span data-stu-id="f6216-120">Furthermore, different object classes may implement an interface differently yet be used interchangeably in binary form, as long as the behavior conforms to the interface definition.</span></span>
-   <span data-ttu-id="f6216-121">Uma interface COM não é um objeto.</span><span class="sxs-lookup"><span data-stu-id="f6216-121">A COM interface is not an object.</span></span> <span data-ttu-id="f6216-122">Ele é simplesmente um grupo de funções relacionado e é o padrão binário por meio do qual os clientes e objetos se comunicam.</span><span class="sxs-lookup"><span data-stu-id="f6216-122">It is simply a related group of functions and is the binary standard through which clients and objects communicate.</span></span> <span data-ttu-id="f6216-123">Desde que ele possa fornecer ponteiros para métodos de interface, o objeto pode ser implementado em qualquer linguagem com qualquer representação de estado interno.</span><span class="sxs-lookup"><span data-stu-id="f6216-123">As long as it can provide pointers to interface methods, the object can be implemented in any language with any internal state representation.</span></span>
-   <span data-ttu-id="f6216-124">Interfaces COM são fortemente tipadas.</span><span class="sxs-lookup"><span data-stu-id="f6216-124">COM interfaces are strongly typed.</span></span> <span data-ttu-id="f6216-125">Cada interface tem seu próprio identificador de interface (um GUID), o que elimina a possibilidade de duplicação que pode ocorrer com qualquer outro esquema de nomenclatura.</span><span class="sxs-lookup"><span data-stu-id="f6216-125">Every interface has its own interface identifier (a GUID), which eliminates the possibility of duplication that could occur with any other naming scheme.</span></span>
-   <span data-ttu-id="f6216-126">Interfaces COM são imutáveis.</span><span class="sxs-lookup"><span data-stu-id="f6216-126">COM interfaces are immutable.</span></span> <span data-ttu-id="f6216-127">Você não pode definir uma nova versão de uma interface antiga e dar a ela o mesmo identificador.</span><span class="sxs-lookup"><span data-stu-id="f6216-127">You cannot define a new version of an old interface and give it the same identifier.</span></span> <span data-ttu-id="f6216-128">Adicionar ou remover métodos de uma interface ou alterar a semântica cria uma nova interface, não uma nova versão de uma interface antiga.</span><span class="sxs-lookup"><span data-stu-id="f6216-128">Adding or removing methods of an interface or changing semantics creates a new interface, not a new version of an old interface.</span></span> <span data-ttu-id="f6216-129">Portanto, uma nova interface não pode entrar em conflito com uma interface antiga.</span><span class="sxs-lookup"><span data-stu-id="f6216-129">Therefore, a new interface cannot conflict with an old interface.</span></span> <span data-ttu-id="f6216-130">No entanto, os objetos podem dar suporte a várias interfaces simultaneamente e podem expor interfaces que são revisões sucessivas de uma interface, com identificadores diferentes.</span><span class="sxs-lookup"><span data-stu-id="f6216-130">However, objects can support multiple interfaces simultaneously and can expose interfaces that are successive revisions of an interface, with different identifiers.</span></span> <span data-ttu-id="f6216-131">Portanto, cada interface é um contrato separado, e os objetos de todo o âmbito não precisam se preocupar se a versão da interface que eles estão chamando é a esperada.</span><span class="sxs-lookup"><span data-stu-id="f6216-131">Thus, each interface is a separate contract, and systemwide objects need not be concerned about whether the version of the interface they are calling is the one they expect.</span></span> <span data-ttu-id="f6216-132">A ID de interface (IID) define o contrato de interface de forma explícita e exclusiva.</span><span class="sxs-lookup"><span data-stu-id="f6216-132">The interface ID (IID) defines the interface contract explicitly and uniquely.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f6216-133">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="f6216-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f6216-134">Objetos e interfaces COM</span><span class="sxs-lookup"><span data-stu-id="f6216-134">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




