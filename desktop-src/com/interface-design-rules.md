---
title: Regras de design de interface
description: Esta seção fornece um breve resumo das regras e diretrizes de design de interface.
ms.assetid: c43fc385-bcd6-45fc-91b2-ad9827fdb15c
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5c1cde73527ac79a2e4442910e3053ed96748337
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104084915"
---
# <a name="interface-design-rules"></a><span data-ttu-id="3031a-103">Regras de design de interface</span><span class="sxs-lookup"><span data-stu-id="3031a-103">Interface Design Rules</span></span>

<span data-ttu-id="3031a-104">Esta seção fornece um breve resumo das regras e diretrizes de design de interface.</span><span class="sxs-lookup"><span data-stu-id="3031a-104">This section provides a short summary of interface design rules and guidelines.</span></span> <span data-ttu-id="3031a-105">Algumas dessas regras são específicas para a arquitetura COM, enquanto outras são restrições impostas pela linguagem de design da interface, MIDL.</span><span class="sxs-lookup"><span data-stu-id="3031a-105">Some of these rules are specific to the COM architecture, while others are restrictions imposed by the interface design language, MIDL.</span></span> <span data-ttu-id="3031a-106">Para obter detalhes do design da interface COM, consulte [anatomia de um arquivo IDL](anatomy-of-an-idl-file.md).</span><span class="sxs-lookup"><span data-stu-id="3031a-106">For details of COM interface design, see [Anatomy of an IDL File](anatomy-of-an-idl-file.md).</span></span>

<span data-ttu-id="3031a-107">Por definição, um objeto não é um objeto COM, a menos que ele implemente a interface [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) ou uma interface derivada de **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="3031a-107">By definition, an object is not a COM object unless it implements either the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface or an interface that is derived from **IUnknown**.</span></span> <span data-ttu-id="3031a-108">Além disso, as seguintes regras se aplicam a todas as interfaces implementadas em um objeto COM:</span><span class="sxs-lookup"><span data-stu-id="3031a-108">In addition, the following rules apply to all interfaces implemented on a COM object:</span></span>

-   <span data-ttu-id="3031a-109">Eles devem ter um IID (identificador de interface exclusivo).</span><span class="sxs-lookup"><span data-stu-id="3031a-109">They must have a unique interface identifier (IID).</span></span>
-   <span data-ttu-id="3031a-110">Eles devem ser imutáveis.</span><span class="sxs-lookup"><span data-stu-id="3031a-110">They must be immutable.</span></span> <span data-ttu-id="3031a-111">Depois que eles são criados e publicados, nenhuma parte de sua definição pode ser alterada.</span><span class="sxs-lookup"><span data-stu-id="3031a-111">Once they are created and published, no part of their definition may change.</span></span>
-   <span data-ttu-id="3031a-112">Todos os métodos de interface devem retornar um valor **HRESULT** para que as partes do sistema que manipulam o processamento remoto possam relatar erros de RPC.</span><span class="sxs-lookup"><span data-stu-id="3031a-112">All interface methods must return an **HRESULT** value so that the portions of the system that handle remote processing can report RPC errors.</span></span>
-   <span data-ttu-id="3031a-113">Todos os parâmetros de cadeia de caracteres em métodos de interface devem ser Unicode.</span><span class="sxs-lookup"><span data-stu-id="3031a-113">All string parameters in interface methods must be Unicode.</span></span>
-   <span data-ttu-id="3031a-114">Seus tipos de dados devem ser remotos.</span><span class="sxs-lookup"><span data-stu-id="3031a-114">Your data types must be remotable.</span></span> <span data-ttu-id="3031a-115">Se não for possível converter um tipo de dados em um tipo remoto, você precisará criar suas próprias rotinas de empacotamento e desempacotamento.</span><span class="sxs-lookup"><span data-stu-id="3031a-115">If you cannot convert a data type to a remotable type, you will have to create your own marshaling and unmarshaling routines.</span></span> <span data-ttu-id="3031a-116">Além disso, **LPVOID**, **ou \* void**, não tem significado em um computador remoto.</span><span class="sxs-lookup"><span data-stu-id="3031a-116">Also, **LPVOID**, or **void \***, has no meaning on a remote computer.</span></span> <span data-ttu-id="3031a-117">Use um ponteiro para [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), se necessário.</span><span class="sxs-lookup"><span data-stu-id="3031a-117">Use a pointer to [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), if necessary.</span></span>

> [!Note]  
> <span data-ttu-id="3031a-118">A implementação atual do MIDL não trata da sobrecarga de função ou de várias heranças.</span><span class="sxs-lookup"><span data-stu-id="3031a-118">The current implementation of MIDL does not handle function overloading or multiple inheritance.</span></span>

 

## <a name="other-interface-design-considerations"></a><span data-ttu-id="3031a-119">Outras considerações de design de interface</span><span class="sxs-lookup"><span data-stu-id="3031a-119">Other Interface Design Considerations</span></span>

<span data-ttu-id="3031a-120">Use ponteiros para dados com muito cuidado.</span><span class="sxs-lookup"><span data-stu-id="3031a-120">Use pointers to data very carefully.</span></span> <span data-ttu-id="3031a-121">Para recriar os dados no espaço de endereço do processo que é chamado, o tempo de execução de RPC deve saber o tamanho exato dos dados.</span><span class="sxs-lookup"><span data-stu-id="3031a-121">To re-create the data in the address space of the process that is called, the RPC run time must know the exact size of the data.</span></span> <span data-ttu-id="3031a-122">Se, por exemplo, um **parâmetro \* Char** apontar para um buffer de caracteres em vez de um único caractere, os dados não poderão ser recriados corretamente.</span><span class="sxs-lookup"><span data-stu-id="3031a-122">If, for example, a **CHAR \*** parameter points to a buffer of characters rather than to a single character, the data cannot be correctly re-created.</span></span> <span data-ttu-id="3031a-123">Use a sintaxe disponível com MIDL para descrever com precisão as estruturas de dados representadas pelas suas definições de tipo.</span><span class="sxs-lookup"><span data-stu-id="3031a-123">Use the syntax available with MIDL to accurately describe the data structures represented by your type definitions.</span></span>

<span data-ttu-id="3031a-124">A inicialização é essencial para ponteiros inseridos em matrizes e estruturas e passadas entre limites de processo.</span><span class="sxs-lookup"><span data-stu-id="3031a-124">Initialization is essential for pointers that are embedded in arrays and structures and passed across process boundaries.</span></span> <span data-ttu-id="3031a-125">Ponteiros não inicializados podem funcionar quando passados para um programa no mesmo espaço de processo, mas proxies e stubs supõem que todos os ponteiros são inicializados com endereços válidos ou são nulos.</span><span class="sxs-lookup"><span data-stu-id="3031a-125">Uninitialized pointers may work when passed to a program in the same process space, but proxies and stubs assume that all pointers are initialized with valid addresses or are null.</span></span>

<span data-ttu-id="3031a-126">Tenha cuidado ao fazer o alias de ponteiros (permitindo que os ponteiros apontem para a mesma parte da memória).</span><span class="sxs-lookup"><span data-stu-id="3031a-126">Be careful when aliasing pointers (allowing pointers to point to the same piece of memory).</span></span> <span data-ttu-id="3031a-127">Se a alias for intencional, esses ponteiros devem ser declarados com alias no arquivo IDL.</span><span class="sxs-lookup"><span data-stu-id="3031a-127">If the aliasing is intentional, these pointers should be declared aliased in the IDL file.</span></span> <span data-ttu-id="3031a-128">Ponteiros declarados como sem alias nunca devem ser alias uns aos outros.</span><span class="sxs-lookup"><span data-stu-id="3031a-128">Pointers declared as nonaliased should never alias each other.</span></span>

<span data-ttu-id="3031a-129">Preste atenção em como alocar e liberar memória.</span><span class="sxs-lookup"><span data-stu-id="3031a-129">Pay attention to how you allocate and free memory.</span></span> <span data-ttu-id="3031a-130">Lembre-se de que, a menos que você explicitamente diga a um objeto COM (usando o atributo [**ALLOCATE**](/windows/desktop/Midl/allocate) ) para não liberar uma estrutura de dados que foi criada durante uma chamada fora do processo, essa estrutura será destruída quando a chamada for concluída.</span><span class="sxs-lookup"><span data-stu-id="3031a-130">Remember that, unless you explicitly tell a COM object (by using the [**allocate**](/windows/desktop/Midl/allocate) attribute) not to free a data structure that was created during an out-of-process call, that structure will be destroyed when the call completes.</span></span> <span data-ttu-id="3031a-131">Além disso, considere a sobrecarga potencialmente destrutiva criada por alocação ineficiente de estruturas de dados que agora precisam ser empacotadas e desempacotadas.</span><span class="sxs-lookup"><span data-stu-id="3031a-131">Also, consider the potentially destructive overhead created by inefficient allocation of data structures that now need to be marshaled and unmarshaled.</span></span>

<span data-ttu-id="3031a-132">Por fim, tenha cuidado ao definir os valores de retorno de **HRESULT** para que você não crie códigos de erro que estejam em conflito com os códigos de ITF de recursos definidos pelo com \_ (os valores entre 0x0000 e 0x01FF são reservados) ou que estejam em conflito com outros valores **HRESULT** com o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="3031a-132">Finally, be careful when defining your **HRESULT** return values so that you don't create error codes that conflict with COM-defined FACILITY\_ITF codes (values between 0x0000 and 0x01FF are reserved) or that conflict with other **HRESULT** values with the same value.</span></span> <span data-ttu-id="3031a-133">Sempre que possível, use os valores de retorno COM êxito e falha do universal COM e use um parâmetro [**out**](/windows/desktop/Midl/out-idl) , em vez de um **HRESULT**, para retornar informações específicas para a chamada de função.</span><span class="sxs-lookup"><span data-stu-id="3031a-133">Whenever possible, use the universal COM success and failure return values, and use an [**out**](/windows/desktop/Midl/out-idl) parameter, rather than an **HRESULT**, to return information specific to the function call.</span></span>

<span data-ttu-id="3031a-134">Para mais informações, consulte os seguintes tópicos:</span><span class="sxs-lookup"><span data-stu-id="3031a-134">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="3031a-135">Projetando interfaces remotas</span><span class="sxs-lookup"><span data-stu-id="3031a-135">Designing Remotable Interfaces</span></span>](designing-remotable-interfaces.md)
-   [<span data-ttu-id="3031a-136">Usando uma interface COM</span><span class="sxs-lookup"><span data-stu-id="3031a-136">Using a COM Interface</span></span>](using-a-com-interface.md)

## <a name="related-topics"></a><span data-ttu-id="3031a-137">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="3031a-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3031a-138">Definições de interface e bibliotecas de tipos</span><span class="sxs-lookup"><span data-stu-id="3031a-138">Interface Definitions and Type Libraries</span></span>](/windows/desktop/Midl/interface-definitions-and-type-libraries)
</dt> </dl>

 

 