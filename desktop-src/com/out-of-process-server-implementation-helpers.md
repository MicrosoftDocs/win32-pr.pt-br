---
title: Auxiliares de implementação do servidor fora do processo
description: Auxiliares de implementação do servidor fora do processo
ms.assetid: 18641a84-56f8-4d27-9ddb-fa64011ac8ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 264d3f26b179b3ecb659ef93785c8c223b6c524e
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104366769"
---
# <a name="out-of-process-server-implementation-helpers"></a><span data-ttu-id="003fc-103">Auxiliares de implementação do servidor fora do processo</span><span class="sxs-lookup"><span data-stu-id="003fc-103">Out-of-Process Server Implementation Helpers</span></span>

<span data-ttu-id="003fc-104">Quatro funções auxiliares que podem ser chamadas por servidores fora do processo estão disponíveis para simplificar o trabalho de escrever código de servidor.</span><span class="sxs-lookup"><span data-stu-id="003fc-104">Four helper functions that can be called by out-of-process servers are available to simplify the job of writing server code.</span></span> <span data-ttu-id="003fc-105">Os clientes COM e os servidores em processo normalmente não os chamaria.</span><span class="sxs-lookup"><span data-stu-id="003fc-105">COM clients and COM in-process servers typically would not call them.</span></span> <span data-ttu-id="003fc-106">Essas funções foram projetadas para ajudar a evitar condições de corrida na ativação do servidor quando os servidores tiverem vários objetos Apartments ou várias classes.</span><span class="sxs-lookup"><span data-stu-id="003fc-106">These functions are designed to help prevent race conditions in server activation when the servers have multiple apartments or multiple class objects.</span></span> <span data-ttu-id="003fc-107">No entanto, eles também podem ser usados facilmente para servidores de objeto de classe única e de thread único.</span><span class="sxs-lookup"><span data-stu-id="003fc-107">They can also, however, as easily be used for single-threaded and single class object servers.</span></span> <span data-ttu-id="003fc-108">As funções são as seguintes:</span><span class="sxs-lookup"><span data-stu-id="003fc-108">The functions are as follows:</span></span>

-   [<span data-ttu-id="003fc-109">**CoAddRefServerProcess**</span><span class="sxs-lookup"><span data-stu-id="003fc-109">**CoAddRefServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess)
-   [<span data-ttu-id="003fc-110">**CoReleaseServerProcess**</span><span class="sxs-lookup"><span data-stu-id="003fc-110">**CoReleaseServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)
-   [<span data-ttu-id="003fc-111">**CoSuspendClassObjects**</span><span class="sxs-lookup"><span data-stu-id="003fc-111">**CoSuspendClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)
-   [<span data-ttu-id="003fc-112">**CoResumeClassObjects**</span><span class="sxs-lookup"><span data-stu-id="003fc-112">**CoResumeClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)

<span data-ttu-id="003fc-113">Para desligar corretamente, um servidor COM deve controlar quantas instâncias de objeto ele criou e quantas vezes seu método [**IClassFactory:: LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) foi chamado.</span><span class="sxs-lookup"><span data-stu-id="003fc-113">To shut down properly, a COM server must keep track of how many object instances it has instantiated and how many times its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method has been called.</span></span> <span data-ttu-id="003fc-114">Somente quando ambas as contagens atingem zero, um servidor é desligado.</span><span class="sxs-lookup"><span data-stu-id="003fc-114">Only when both of these counts reach zero can a server shut down.</span></span> <span data-ttu-id="003fc-115">Em servidores COM de thread único, a decisão de desligar foi coordenada com solicitações de ativação de entrada, que foram serializadas pela fila de mensagens.</span><span class="sxs-lookup"><span data-stu-id="003fc-115">In single-threaded COM servers, the decision to shut down was coordinated with incoming activation requests, which were serialized by the message queue.</span></span> <span data-ttu-id="003fc-116">O servidor, após receber uma versão em sua instância de objeto final e decidir desligar, revogaria seus objetos de classe antes de qualquer solicitação de ativação ser expedida.</span><span class="sxs-lookup"><span data-stu-id="003fc-116">The server, upon receiving a release on its final object instance and deciding to shut down, would revoke its class objects before any more activation requests were dispatched.</span></span> <span data-ttu-id="003fc-117">Se uma solicitação de ativação chegasse depois desse ponto, o COM reconheceria que os objetos de classe foram revogados e retornariam um erro ao SCM (Gerenciador de controle de serviço), o que faria com que uma nova instância do processo do servidor local fosse executada.</span><span class="sxs-lookup"><span data-stu-id="003fc-117">If an activation request did come in after this point, COM would recognize that the class objects were revoked and would return an error to the Service Control Manager (SCM), which would then cause a new instance of the local server process to be run.</span></span>

<span data-ttu-id="003fc-118">No entanto, em um servidor de modelo de apartamento, no qual objetos de classe diferentes são registrados em diferentes Apartments, e em todos os servidores de thread livre, essa decisão para desligar deve ser coordenada com solicitações de ativação em vários threads para que um thread do servidor não decida desligar enquanto outro thread do servidor estiver ocupado a distribuir objetos de classe ou instâncias de objeto.</span><span class="sxs-lookup"><span data-stu-id="003fc-118">However, in an apartment model server, in which different class objects are registered on different apartments, and in all free-threaded servers, this decision to shut down must be coordinated with activation requests across multiple threads so that one thread of the server does not decide to shut down while another thread of the server is busy handing out class objects or object instances.</span></span> <span data-ttu-id="003fc-119">Uma abordagem clássica, mas complicada, de resolver isso é ter o servidor, depois de revogar seus objetos de classe, verificar sua contagem de instâncias e permanecer ativa até que todas as instâncias tenham sido liberadas.</span><span class="sxs-lookup"><span data-stu-id="003fc-119">One classical but cumbersome approach to solving this is to have the server, after it has revoked its class objects, recheck its instance count and stay alive until all instances have been released.</span></span>

<span data-ttu-id="003fc-120">Para tornar mais fácil para os gravadores de servidor lidar com esses tipos de condições de corrida, o COM fornece duas funções de contagem de referência:</span><span class="sxs-lookup"><span data-stu-id="003fc-120">To make it easier for server writers to handle these types of race conditions, COM provides two reference counting functions:</span></span>

-   <span data-ttu-id="003fc-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) incrementa uma contagem de referência global por processo.</span><span class="sxs-lookup"><span data-stu-id="003fc-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) increments a global per-process reference count.</span></span>
-   <span data-ttu-id="003fc-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrementa a contagem de referência global por processo.</span><span class="sxs-lookup"><span data-stu-id="003fc-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrements the global per-process reference count.</span></span>

<span data-ttu-id="003fc-123">Quando a contagem de referência global por processo atinge zero, o COM chama automaticamente [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), o que impede a entrada de novas solicitações de ativação.</span><span class="sxs-lookup"><span data-stu-id="003fc-123">When the global per-process reference count reaches zero, COM automatically calls [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), which prevents any new activation requests from coming in.</span></span> <span data-ttu-id="003fc-124">O servidor pode então cancelar o registro de seus vários objetos de classe de seus vários threads a lazer sem se preocupar que outra solicitação de ativação pode vir.</span><span class="sxs-lookup"><span data-stu-id="003fc-124">The server can then deregister its various class objects from its various threads at leisure without worry that another activation request may come in.</span></span> <span data-ttu-id="003fc-125">Todas as novas solicitações de ativação são daqui em diante tratadas pelo SCM que inicia uma nova instância do processo do servidor local.</span><span class="sxs-lookup"><span data-stu-id="003fc-125">All new activation requests are henceforth handled by the SCM launching a new instance of the local server process.</span></span>

<span data-ttu-id="003fc-126">A maneira mais simples de um aplicativo de servidor local fazer uso dessas funções é chamar [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) no construtor para cada um de seus objetos de instância e em cada um de seus métodos [**IClassFactory:: LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) quando o parâmetro *Flock* é **true**.</span><span class="sxs-lookup"><span data-stu-id="003fc-126">The simplest way for a local server application to make use of these functions is to call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) in the constructor for each of its instance objects and in each of its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) methods when the *fLock* parameter is **TRUE**.</span></span> <span data-ttu-id="003fc-127">O aplicativo de servidor também deve chamar [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) no destruidor de cada um de seus objetos de instância e em cada um de seus métodos IClassFactory::**LockServer** quando o parâmetro *Flock* é **false**.</span><span class="sxs-lookup"><span data-stu-id="003fc-127">The server application should also call [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) in the destructor of each of its instance objects and in each of its IClassFactory::**LockServer** methods when the *fLock* parameter is **FALSE**.</span></span>

<span data-ttu-id="003fc-128">Por fim, o aplicativo de servidor deve prestar atenção ao código de retorno de [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)e, se ele retornar 0, o aplicativo de servidor deverá iniciar sua limpeza, que, para um servidor com vários threads, normalmente significa que ele deve sinalizar seus vários threads para sair de seus loops de mensagem e chamar [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) e [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span><span class="sxs-lookup"><span data-stu-id="003fc-128">Finally, the server application should pay attention to the return code from [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) and [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span></span> <span data-ttu-id="003fc-129">Se as funções de gerenciamento de tempo de vida do processo do servidor forem usadas, elas deverão ser usadas nas duas instâncias de objeto e no método [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) ; caso contrário, o aplicativo de servidor pode ser desligado prematuramente.</span><span class="sxs-lookup"><span data-stu-id="003fc-129">If the server process lifetime management functions are used, they must be used in both the object instances and the [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method; otherwise, the server application may be shut down prematurely.</span></span>

<span data-ttu-id="003fc-130">Quando uma solicitação [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) é feita, o com contata o servidor, realiza marshaling da interface [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) do objeto Class, retorna ao processo do cliente, desempacota a interface **IClassFactory** e retorna isso ao cliente.</span><span class="sxs-lookup"><span data-stu-id="003fc-130">When a [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) request is made, COM contacts the server, marshals the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface of the class object, returns to the client process, unmarshals the **IClassFactory** interface, and returns this to the client.</span></span> <span data-ttu-id="003fc-131">Neste ponto, os clientes normalmente chamam [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) com **true** para impedir que o processo do servidor seja desligado.</span><span class="sxs-lookup"><span data-stu-id="003fc-131">At this point, clients typically call [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) with **TRUE** to prevent the server process from shutting down.</span></span> <span data-ttu-id="003fc-132">No entanto, há uma janela de tempo entre quando o objeto de classe é empacotado e quando o cliente chama **LockServer** em que outro cliente pode se conectar ao mesmo servidor, obter uma instância e liberar essa instância, fazendo com que o servidor seja desligado e deixando o primeiro cliente alto e seco com um ponteiro **IClassFactory** desconectado.</span><span class="sxs-lookup"><span data-stu-id="003fc-132">However, there is a window of time between when the class object is marshaled and when the client calls **LockServer** in which another client could connect to the same server, get an instance, and release that instance, thus causing the server to shut down and leaving the first client high and dry with a disconnected **IClassFactory** pointer.</span></span> <span data-ttu-id="003fc-133">Para evitar essa condição de corrida, COM adiciona uma chamada implícita para **LockServer** com **true** para o objeto de classe quando ele realiza marshaling da interface **IClassFactory** e uma chamada implícita para **LockServer** com **false** quando o cliente libera a interface **IClassFactory** .</span><span class="sxs-lookup"><span data-stu-id="003fc-133">To prevent this race condition, COM adds an implicit call to **LockServer** with **TRUE** to the class object when it marshals the **IClassFactory** interface and an implicit call to **LockServer** with **FALSE** when the client releases the **IClassFactory** interface.</span></span> <span data-ttu-id="003fc-134">Portanto, não é necessário fazer chamadas de **LockServer** remotas para o servidor e o proxy para **LockServer** simplesmente retorna S \_ OK sem realmente fazer a chamada de forma remota.</span><span class="sxs-lookup"><span data-stu-id="003fc-134">Therefore, it is not necessary to remote **LockServer** calls back to the server, and the proxy for **LockServer** simply returns S\_OK without actually remoting the call.</span></span>

<span data-ttu-id="003fc-135">Há outra condição de corrida relacionada à ativação durante a inicialização de um processo de servidor fora do processo.</span><span class="sxs-lookup"><span data-stu-id="003fc-135">There is another activation-related race condition during initialization of an out-of-process server process.</span></span> <span data-ttu-id="003fc-136">Um servidor COM que registra várias classes normalmente chama [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) com o \_ servidor local REGCLS \_ para cada CLSID compatível.</span><span class="sxs-lookup"><span data-stu-id="003fc-136">A COM server that registers multiple classes typically calls [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER for each CLSID it supports.</span></span> <span data-ttu-id="003fc-137">Depois de fazer isso para todas as classes, o servidor entra em seu loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="003fc-137">After it has done this for all classes, the server enters its message loop.</span></span> <span data-ttu-id="003fc-138">Para um servidor COM de thread único, todas as solicitações de ativação são bloqueadas até que o servidor insira o loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="003fc-138">For a single-threaded COM server, all activation requests are blocked until the server enters the message loop.</span></span> <span data-ttu-id="003fc-139">No entanto, para um servidor de modelo de apartamento que registra objetos de classe diferentes em diferentes Apartments e para todos os servidores de thread livre, as solicitações de ativação podem chegar antes disso.</span><span class="sxs-lookup"><span data-stu-id="003fc-139">However, for an apartment model server that registers different class objects in different apartments and for all free-threaded servers, activation requests can arrive earlier than this.</span></span> <span data-ttu-id="003fc-140">No caso de servidores de modelo de apartamento, as solicitações de ativação podem chegar assim que um thread tiver inserido seu loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="003fc-140">In the case of apartment model servers, activation requests could arrive as soon as any one thread has entered its message loop.</span></span> <span data-ttu-id="003fc-141">No caso de servidores de thread livre, uma solicitação de ativação pode chegar assim que o primeiro objeto de classe é registrado.</span><span class="sxs-lookup"><span data-stu-id="003fc-141">In the case of free-threaded servers, an activation request could arrive as soon as the first class object is registered.</span></span> <span data-ttu-id="003fc-142">Como uma ativação pode ocorrer no início, também é possível que a versão final ocorra (e, portanto, fazer com que o servidor comece a ser desligado) antes que o restante do servidor tenha a chance de concluir a inicialização.</span><span class="sxs-lookup"><span data-stu-id="003fc-142">Since an activation can happen this early, it is also possible for the final release to occur (and therefore cause the server to begin shutting down) before the rest of the server has had a chance to finish initializing.</span></span>

<span data-ttu-id="003fc-143">Para eliminar essas condições de corrida e simplificar o trabalho do Server Writer, qualquer servidor que queira registrar vários objetos de classe com com deve chamar [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) com o \_ servidor local REGCLS \_ \| REGCLS \_ suspenso para cada CLSID diferente ao qual o servidor dá suporte.</span><span class="sxs-lookup"><span data-stu-id="003fc-143">To eliminate these race conditions and simplify the job of the server writer, any server that wants to register multiple class objects with COM should call [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER \| REGCLS\_SUSPENDED for each different CLSID the server supports.</span></span> <span data-ttu-id="003fc-144">Depois que todas as classes tiverem sido registradas e o processo do servidor estiver pronto para aceitar solicitações de ativação de entrada, o servidor deverá fazer uma chamada para [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span><span class="sxs-lookup"><span data-stu-id="003fc-144">After all classes have been registered and the server process is ready to accept incoming activation requests, the server should make one call to [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span></span> <span data-ttu-id="003fc-145">Essa função informa ao COM para informar ao SCM sobre todas as classes registradas e começa a permitir que as solicitações de ativação no processo do servidor.</span><span class="sxs-lookup"><span data-stu-id="003fc-145">This function tells COM to inform the SCM about all the registered classes, and it begins letting activation requests into the server process.</span></span> <span data-ttu-id="003fc-146">O uso dessas funções oferece as seguintes vantagens:</span><span class="sxs-lookup"><span data-stu-id="003fc-146">Using these functions provides the following advantages:</span></span>

-   <span data-ttu-id="003fc-147">Apenas uma chamada é feita ao SCM, independentemente de quantos CLSIDs são registrados, reduzindo assim o tempo de registro geral (e, portanto, o tempo de inicialização do aplicativo de servidor).</span><span class="sxs-lookup"><span data-stu-id="003fc-147">Only one call is made to the SCM, regardless of how many CLSIDs are registered, thus reducing the overall registration time (and hence startup time of the server application).</span></span>
-   <span data-ttu-id="003fc-148">Se o servidor tiver vários Apartments e CLSIDs diferentes forem registrados em diferentes Apartments, ou se o servidor for um servidor de thread livre, nenhuma solicitação de ativação será exibida até que o servidor chame [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), dando ao servidor uma oportunidade de registrar todos os seus CLSIDs e configurá-los corretamente antes de ter que lidar com solicitações de ativação e possíveis solicitações de desligamento.</span><span class="sxs-lookup"><span data-stu-id="003fc-148">If the server has multiple apartments and different CLSIDs are registered in different apartments, or if the server is a free-threaded server, no activation requests will come in until the server calls [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), giving the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests and possible shut down requests.</span></span>

## <a name="related-topics"></a><span data-ttu-id="003fc-149">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="003fc-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="003fc-150">Responsabilidades do servidor COM</span><span class="sxs-lookup"><span data-stu-id="003fc-150">COM Server Responsibilities</span></span>](com-server-responsibilities.md)
</dt> </dl>

 

 