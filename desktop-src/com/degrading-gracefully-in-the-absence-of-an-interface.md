---
title: Degradar normalmente na ausência de uma interface
description: Como um controle pode não dar suporte a qualquer interface diferente de IUnknown, um contêiner precisa degradar normalmente quando encontra a ausência de qualquer interface específica.
ms.assetid: 1b833900-2357-4b39-b88d-5ee6321f488e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 26618e00f2d959cccfd7ab4d2948fac9c1a3f020
ms.sourcegitcommit: 85688bbfbe5b121bc05ddf112d54c23a469dfbc0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/29/2020
ms.locfileid: "105763300"
---
# <a name="degrading-gracefully-in-the-absence-of-an-interface"></a>Degradar normalmente na ausência de uma interface

Como um controle pode não dar suporte a qualquer interface diferente de [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), um contêiner precisa degradar normalmente quando encontra a ausência de qualquer interface específica.

Uma delas pode questionar a utilidade de um controle sem nada mais do que [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown). Mas considere as vantagens que um controle recebe do ambiente de programação visual de um contêiner (como VB) quando o contêiner reconhece o objeto como um controle:

-   Um botão para o objeto aparece em uma caixa de ferramentas.
-   É possível criar um objeto arrastando-o da caixa de ferramentas para um formulário.
-   É possível dar ao objeto um nome reconhecido no ambiente de programação visual.
-   O mesmo nome em (3) acima pode ser usado imediatamente ao escrever qualquer outro código para controles no mesmo formulário (ou até mesmo em um formulário diferente).
-   O contêiner pode fornecer automaticamente pontos de entrada de código para todos os eventos disponíveis desse objeto.
-   O contêiner fornece sua própria interface do usuário de navegação para qualquer propriedade disponível.

Quando um objeto não é reconhecido como um controle, ele potencialmente perde todos esses recursos de integração muito poderosos e benéficos. Por exemplo, no Visual Basic 4,0 é muito difícil integrar realmente um objeto aleatório que não é um controle no sentido completo, mas que ainda pode ter propriedades e eventos. Como Visual Basic ideia de 4 de um controle é muito restritiva, o objeto não tem nenhum dos recursos de integração acima. Mas mesmo um controle com [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), em que a mera vida útil do controle determina a existência de algum recurso, deve ser capaz de obter os recursos de integração descritos acima.

Como as ferramentas atuais exigem um grande conjunto de interfaces de controle para obter qualquer vantagem, os controles geralmente levaram à sobreimplementação, de forma que eles contêm mais códigos do que realmente precisam. Os controles que poderiam ser 7K podem acabar sendo 25K, o que é um grande problema de desempenho em áreas como a Internet. Isso também levou à percepção de que um só pode implementar um controle com uma ferramenta como o CDK devido à complexidade da implementação de todas as interfaces, e isso tem implicações quando uma DLL grande, como OC30.DLL, é necessária para tal controle, aumentando o conjunto de trabalho. Se nem todas as interfaces forem necessárias, isso abrirá muitos desenvolvedores para escrever controles muito pequenos e leves com OLE direto ou também com outras ferramentas, minimizando a sobrecarga de cada controle.

É por isso que este apêndice reconhece um controle como qualquer objeto com um CLSID e uma interface [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) . Mesmo com nada mais do que IUnknown, um contêiner com um ambiente de programação deve ser capaz de fornecer pelo menos recursos \# 3 e) entrada do registro, ele ganha \# 1 e \# 2. Se o objeto fornecer [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer) (e [**IProvideClassInfo**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo) geralmente) para algum conjunto de eventos, ele ganha \# 5 e, se ele der suporte a **IDispatch** para propriedades e métodos, ele ganha \# 6, bem como a melhor integração de código no contêiner.

Em suma, um objeto deve ser capaz de implementar tão pouco quanto **IDispatch** e um conjunto de eventos exposto por meio de [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer) para obter todos esses recursos visuais acima.

Com isso em mente, a tabela a seguir descreve o que um contêiner pode fazer na ausência de qualquer interface possível. Observe que somente essas interfaces são listadas para que o contêiner seja obtido diretamente por meio de [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)). Outras interfaces, como [**IOleInPlaceActiveObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleinplaceactiveobject), são obtidas por meio de outros meios.



| Interface                                                                                                             | Significado da ausência de interface                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)<br/>                                                                       | O controle não tem visuais que serão desempates, portanto não tem nenhuma extensão definitiva para fornecer. Em tempo de execução, o contêiner simplesmente não tenta desenhar nada quando essa interface está ausente. Em tempo de design, o contêiner deve, pelo menos, desenhar algum tipo de retângulo padrão com um nome para tal controle, de modo que um usuário em um ambiente de programação Visual possa selecionar o objeto e verificar suas propriedades, métodos e eventos existentes. Lidar com a ausência de [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) é essencial para um bom suporte à programação visual.<br/> |
| [**IOleObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleobject)<br/>                                                                           | O controle não precisa do site qualquer, nem faz parte de qualquer negociação de layout de objeto incorporado. Todas as informações (como extensões de controle) que um contêiner pode esperar dessa interface devem ser preenchidas com padrões fornecidos por contêiner.<br/>                                                                                                                                                                                                                                                                                                       |
| [**IOleInPlaceObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleinplaceobject)<br/>                                                             | O controle não é ativo no local (como um rótulo) e, portanto, nunca tenta fazer a ativação dessa maneira. Sua única ativação pode ser suas páginas de propriedades.<br/>                                                                                                                                                                                                                                                                                                                                                                                                            |
| [**IOleControl**](/windows/desktop/api/OCIdl/nn-ocidl-iolecontrol)<br/>                                                                         | O controle não tem mnemônicos e nenhum uso de propriedades de ambiente e não se importa se o contêiner ignora eventos. Na ausência dessa interface, o contêiner simplesmente não chama seus métodos.<br/>                                                                                                                                                                                                                                                                                                                                                                         |
| [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject)<br/>                                                                         | O controle não fornece nenhum conjunto de propriedades nem qualquer renderização visual que pudesse ser armazenada em cache, portanto, o contêiner optaria por armazenar em cache alguma apresentação padrão na ausência dessa interface (suporte para o CF \_ METAFILEPICT, especificamente) e desabilitar qualquer funcionalidade relacionada ao conjunto de propriedades.<br/>                                                                                                                                                                                                                                                                            |
| **IDispatch**<br/>                                                                                              | O controle não tem propriedades ou métodos personalizados. O contêiner não precisa tentar mostrar nenhuma propriedade de controle nesse caso e deve proibir qualquer chamada de método personalizado que o contêiner não reconheça como pertencente a seus próprios controles estendidos (que podem dar suporte a métodos e propriedades). Como controles estendidos geralmente delegam determinadas chamadas **IDispatch** ao controle, um controle estendido não deve esperar que o controle tenha **IDispatch** .<br/>                                                                                          |
| [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer)<br/>                                             | O controle não tem eventos, portanto, o contêiner não precisa pensar em lidar com nenhum.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [**IProvideClassInfo**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo)<br/> [**IProvideClassInfo2**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo2)<br/> | O controle não tem informações de tipo ou eventos, ou o contêiner precisa entrar nas informações de tipo do controle por meio das entradas de registro do controle. A existência dessa interface é uma otimização.<br/>                                                                                                                                                                                                                                                                                                                                            |
| [**ISpecifyPropertyPages**](/windows/desktop/api/OCIdl/nn-ocidl-ispecifypropertypages)<br/>                                                     | O controle não tem páginas de propriedades, portanto, se o contêiner tiver qualquer interface do usuário que as invoque, o contêiner deverá desabilitar essa interface do usuário.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| [**IPerPropertyBrowsing**](/windows/desktop/api/OCIdl/nn-ocidl-iperpropertybrowsing)<br/>                                                       | O controle não tem nenhum nome de exibição, nenhuma cadeia de caracteres e valores predeterminados e nenhuma propriedade para mapeamento de página. Essa interface é quase sempre usada para gerar a interface do usuário de contêiner, de modo que esses elementos da interface de usuário seriam desabilitados na ausência dessa interface.<br/>                                                                                                                                                                                                                                                                                                 |
| IPersist\*<br/>                                                                                                 | O controle não tem nenhum estado persistente para falar de, portanto, o contêiner não precisa se preocupar em salvar dados específicos de controle. O contêiner, é claro, salvar suas próprias informações sobre o controle em seu próprio formulário ou documento, mas o próprio controle não tem nada para contribuir com essas informações.<br/>                                                                                                                                                                                                                                                        |
| [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache)<br/> [**IOleCache2**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache2)<br/>                                 | O objeto não dá suporte a cache. Um contêiner ainda pode dar suporte a cache criando apenas um cache de dados usando [**CreateDataCache**](/windows/desktop/api/ObjBase/nf-objbase-createdatacache).<br/>                                                                                                                                                                                                                                                                                                                                                                                                    |



 

## <a name="related-topics"></a>Tópicos relacionados

<dl> <dt>

[Contêineres](containers.md)
</dt> </dl>

 

 





