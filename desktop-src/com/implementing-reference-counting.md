---
title: Implementando a contagem de referência
description: Implementando a contagem de referência
ms.assetid: d4fd98c9-afa4-4c5c-a3c9-44d34881cbdb
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a0d4dfe2b0faf2fc6557d1b089e33ae6ce4b98cb
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "105815440"
---
# <a name="implementing-reference-counting"></a><span data-ttu-id="04760-103">Implementando a contagem de referência</span><span class="sxs-lookup"><span data-stu-id="04760-103">Implementing Reference Counting</span></span>

<span data-ttu-id="04760-104">A contagem de referência requer trabalho na parte do implementador de uma classe e dos clientes que usam objetos dessa classe.</span><span class="sxs-lookup"><span data-stu-id="04760-104">Reference counting requires work on the part of both the implementor of a class and the clients who use objects of that class.</span></span> <span data-ttu-id="04760-105">Ao implementar uma classe, você deve implementar os métodos [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) como parte da interface [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) .</span><span class="sxs-lookup"><span data-stu-id="04760-105">When you implement a class, you must implement the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods as part of the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="04760-106">Esses dois métodos têm as seguintes implementações simples:</span><span class="sxs-lookup"><span data-stu-id="04760-106">These two methods have the following simple implementations:</span></span>

-   <span data-ttu-id="04760-107">O [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) incrementa a contagem de referência interna do objeto.</span><span class="sxs-lookup"><span data-stu-id="04760-107">[**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) increments the object's internal reference count.</span></span>
-   <span data-ttu-id="04760-108">A [**versão**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) diminuir primeiro decrementa a contagem de referência interna do objeto e verifica se a contagem de referência caiu para zero.</span><span class="sxs-lookup"><span data-stu-id="04760-108">[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) first decrements the object's internal reference count, and then it checks whether the reference count has fallen to zero.</span></span> <span data-ttu-id="04760-109">Se tiver, isso significa que ninguém está usando o objeto por mais tempo, portanto, a função de **liberação** desalocará o objeto.</span><span class="sxs-lookup"><span data-stu-id="04760-109">If it has, that means no one is using the object any longer, so the **Release** function deallocates the object.</span></span>

<span data-ttu-id="04760-110">Uma abordagem de implementação comum para a maioria dos objetos é ter apenas uma implementação desses métodos (juntamente com [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))), que é compartilhada entre todas as interfaces e, portanto, uma contagem de referência que se aplica ao objeto inteiro.</span><span class="sxs-lookup"><span data-stu-id="04760-110">A common implementation approach for most objects is to have only one implementation of these methods (along with [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))), which is shared between all interfaces, and therefore a reference count that applies to the entire object.</span></span> <span data-ttu-id="04760-111">No entanto, do ponto de vista do cliente, a contagem de referência é estritamente e claramente uma noção de ponteiro por interface e, portanto, os objetos que aproveitam esse recurso criando dinamicamente, destruindo, carregando ou descarregando partes de sua funcionalidade com base nos ponteiros de interface existentes no momento podem ser implementados.</span><span class="sxs-lookup"><span data-stu-id="04760-111">However, from a client's perspective, reference counting is strictly and clearly a per-interface-pointer notion, and therefore objects that take advantage of this capability by dynamically constructing, destroying, loading, or unloading portions of their functionality based on the currently extant interface pointers may be implemented.</span></span> <span data-ttu-id="04760-112">Essas são coloquialmente chamadas *de interfaces de divisão*.</span><span class="sxs-lookup"><span data-stu-id="04760-112">These are colloquially called *tear-off interfaces*.</span></span>

<span data-ttu-id="04760-113">Sempre que um cliente chama um método (ou função de API), como [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), que retorna um novo ponteiro de interface, o método que está sendo chamado é responsável por incrementar a contagem de referência por meio do ponteiro retornado.</span><span class="sxs-lookup"><span data-stu-id="04760-113">Whenever a client calls a method (or API function), such as [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), that returns a new interface pointer, the method being called is responsible for incrementing the reference count through the returned pointer.</span></span> <span data-ttu-id="04760-114">Por exemplo, quando um cliente cria um objeto pela primeira vez, ele recebe um ponteiro de interface para um objeto que, do ponto de vista do cliente, tem uma contagem de referência de um.</span><span class="sxs-lookup"><span data-stu-id="04760-114">For example, when a client first creates an object, it receives an interface pointer to an object that, from the client's point of view, has a reference count of one.</span></span> <span data-ttu-id="04760-115">Se o cliente chamar [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) no ponteiro de interface, a contagem de referência se tornará duas.</span><span class="sxs-lookup"><span data-stu-id="04760-115">If the client then calls [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the interface pointer, the reference count becomes two.</span></span> <span data-ttu-id="04760-116">O cliente deve chamar [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) duas vezes no ponteiro de interface para descartar todas as suas referências ao objeto.</span><span class="sxs-lookup"><span data-stu-id="04760-116">The client must call [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) twice on the interface pointer to drop all of its references to the object.</span></span>

<span data-ttu-id="04760-117">Um exemplo de como as contagens de referência são estritamente por interface – o ponteiro ocorre quando um cliente chama [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) no primeiro ponteiro para uma nova interface ou para a mesma interface.</span><span class="sxs-lookup"><span data-stu-id="04760-117">An example of how reference counts are strictly per-interface-pointer occurs when a client calls [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) on the first pointer for either a new interface or the same interface.</span></span> <span data-ttu-id="04760-118">Em qualquer um desses casos, o cliente precisa chamar [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) uma vez para cada ponteiro.</span><span class="sxs-lookup"><span data-stu-id="04760-118">In either of these cases, the client is required to call [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) once for each pointer.</span></span> <span data-ttu-id="04760-119">COM não exige que um objeto retorne o mesmo ponteiro quando solicitado pela mesma interface várias vezes.</span><span class="sxs-lookup"><span data-stu-id="04760-119">COM does not require that an object return the same pointer when asked for the same interface multiple times.</span></span> <span data-ttu-id="04760-120">(A única exceção a isso é uma consulta para [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), que identifica um objeto para com.) Isso permite que a implementação do objeto gerencie recursos com eficiência.</span><span class="sxs-lookup"><span data-stu-id="04760-120">(The only exception to this is a query to [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), which identifies an object to COM.) This allows the object implementation to manage resources efficiently.</span></span>

<span data-ttu-id="04760-121">A segurança de threads também é um problema importante na implementação de [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span><span class="sxs-lookup"><span data-stu-id="04760-121">Thread-safety is also an important issue in implementing [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span></span> <span data-ttu-id="04760-122">Para obter mais informações, consulte [processos, threads e Apartments](processes--threads--and-apartments.md).</span><span class="sxs-lookup"><span data-stu-id="04760-122">For more information, see [Processes, Threads, and Apartments](processes--threads--and-apartments.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="04760-123">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="04760-123">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="04760-124">Gerenciando tempos de vida de objeto por meio de contagem de referência</span><span class="sxs-lookup"><span data-stu-id="04760-124">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 