---
title: Inter-Object comunicação
description: O COM foi projetado para permitir que os clientes se comuniquem de forma transparente com objetos, independentemente de onde esses objetos estão sendo executados no mesmo processo, no mesmo computador ou em um computador diferente.
ms.assetid: dd4adafb-a7e4-44ba-ae4a-80585875ecb6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9356ba2bcb9dd3a6a56ac16c354f3abcb752d717
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104084916"
---
# <a name="inter-object-communication"></a><span data-ttu-id="57e6b-103">Inter-Object comunicação</span><span class="sxs-lookup"><span data-stu-id="57e6b-103">Inter-Object Communication</span></span>

<span data-ttu-id="57e6b-104">O COM foi projetado para permitir que os clientes se comuniquem de forma transparente com objetos, independentemente de onde esses objetos são runningâs, no mesmo processo, no mesmo computador ou em um computador diferente.</span><span class="sxs-lookup"><span data-stu-id="57e6b-104">COM is designed to allow clients to communicate transparently with objects, regardless of where those objects are runningâ€”in the same process, on the same computer, or on a different computer.</span></span> <span data-ttu-id="57e6b-105">Isso fornece um único modelo de programação para todos os tipos de objetos e para clientes de objeto e servidores de objetos.</span><span class="sxs-lookup"><span data-stu-id="57e6b-105">This provides a single programming model for all types of objects, and for both object clients and object servers.</span></span>

<span data-ttu-id="57e6b-106">Do ponto de vista de um cliente, todos os objetos são acessados por meio de ponteiros de interface.</span><span class="sxs-lookup"><span data-stu-id="57e6b-106">From a client's point of view, all objects are accessed through interface pointers.</span></span> <span data-ttu-id="57e6b-107">Um ponteiro deve estar em processo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-107">A pointer must be in-process.</span></span> <span data-ttu-id="57e6b-108">Na verdade, qualquer chamada para uma função de interface sempre alcança parte do código em processo primeiro.</span><span class="sxs-lookup"><span data-stu-id="57e6b-108">In fact, any call to an interface function always reaches some piece of in-process code first.</span></span> <span data-ttu-id="57e6b-109">Se o objeto estiver em processo, a chamada o atingirá diretamente, sem código de infraestrutura de sistema intermediário.</span><span class="sxs-lookup"><span data-stu-id="57e6b-109">If the object is in-process, the call reaches it directly, with no intervening system-infrastructure code.</span></span> <span data-ttu-id="57e6b-110">Se o objeto estiver fora do processo, a chamada primeiro atingirá o que é chamado de objeto de "proxy" fornecido pelo COM ou pelo objeto (se o implementador quiser).</span><span class="sxs-lookup"><span data-stu-id="57e6b-110">If the object is out-of-process, the call first reaches what is called a "proxy" object provided either by COM or by the object (if the implementor wishes).</span></span> <span data-ttu-id="57e6b-111">Os pacotes de proxy chamam parâmetros (incluindo qualquer ponteiro de interface) e geram a chamada de procedimento remoto apropriada (ou outro mecanismo de comunicação no caso de proxies gerados personalizados) para o outro processo ou para o outro computador no qual a implementação do objeto está localizada.</span><span class="sxs-lookup"><span data-stu-id="57e6b-111">The proxy packages call parameters (including any interface pointers) and generate the appropriate remote procedure call (or other communication mechanism in the case of custom generated proxies) to the other process or the other computer where the object implementation is located.</span></span> <span data-ttu-id="57e6b-112">Esse processo de empacotamento de ponteiros para transmissão entre limites de processo é chamado de *marshaling*.</span><span class="sxs-lookup"><span data-stu-id="57e6b-112">This process of packaging pointers for transmission across process boundaries is called *marshaling*.</span></span>

<span data-ttu-id="57e6b-113">Do ponto de vista de um servidor, todas as chamadas para as funções de interface de um objeto são feitas por meio de um ponteiro para essa interface.</span><span class="sxs-lookup"><span data-stu-id="57e6b-113">From a server's point of view, all calls to an object's interface functions are made through a pointer to that interface.</span></span> <span data-ttu-id="57e6b-114">Novamente, um ponteiro tem contexto apenas em um único processo, e o chamador sempre deve ser parte do código em processo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-114">Again, a pointer has context only in a single process, and the caller must always be some piece of in-process code.</span></span> <span data-ttu-id="57e6b-115">Se o objeto estiver em processo, o chamador será o próprio cliente.</span><span class="sxs-lookup"><span data-stu-id="57e6b-115">If the object is in-process, the caller is the client itself.</span></span> <span data-ttu-id="57e6b-116">Caso contrário, o chamador é um objeto "stub" fornecido pelo COM ou pelo próprio objeto.</span><span class="sxs-lookup"><span data-stu-id="57e6b-116">Otherwise, the caller is a "stub" object provided either by COM or by the object itself.</span></span> <span data-ttu-id="57e6b-117">O stub recebe a chamada de procedimento remoto (ou outro mecanismo de comunicação no caso de proxies gerados personalizados) do "proxy" no processo do cliente, desempacota os parâmetros e chama a interface apropriada no objeto de servidor.</span><span class="sxs-lookup"><span data-stu-id="57e6b-117">The stub receives the remote procedure call (or other communication mechanism in the case of custom generated proxies) from the "proxy" in the client process, unmarshals the parameters, and calls the appropriate interface on the server object.</span></span> <span data-ttu-id="57e6b-118">A partir dos pontos de vista de clientes e servidores, eles sempre se comunicam diretamente com algum outro código em processo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-118">From the points of view of both clients and servers, they always communicate directly with some other in-process code.</span></span>

<span data-ttu-id="57e6b-119">O COM fornece uma implementação de marshaling, conhecida como *marshaling padrão*.</span><span class="sxs-lookup"><span data-stu-id="57e6b-119">COM provides an implementation of marshaling, referred to as *standard marshaling*.</span></span> <span data-ttu-id="57e6b-120">Essa implementação funciona muito bem para a maioria dos objetos e reduz significativamente os requisitos de programação, tornando o processo de marshaling efetivamente transparente.</span><span class="sxs-lookup"><span data-stu-id="57e6b-120">This implementation works very well for most objects and greatly reduces programming requirements, making the marshaling process effectively transparent.</span></span>

<span data-ttu-id="57e6b-121">No entanto, a separação clara da interface da implementação da transparência do processo do COM pode ser obtida no caminho em algumas situações.</span><span class="sxs-lookup"><span data-stu-id="57e6b-121">The clear separation of interface from implementation of COM's process transparency can, however, get in the way in some situations.</span></span> <span data-ttu-id="57e6b-122">O design de uma interface que se concentra em sua função do ponto de vista do cliente pode, às vezes, levar a decisões de design que entram em conflito com a implementação eficiente dessa interface em uma rede.</span><span class="sxs-lookup"><span data-stu-id="57e6b-122">The design of an interface that focuses on its function from the client's point of view can sometimes lead to design decisions that conflict with efficient implementation of that interface across a network.</span></span> <span data-ttu-id="57e6b-123">Em casos como esse, o que é necessário não é uma transparência de processo pura, mas "transparência do processo, a menos que você precise se preocupar".</span><span class="sxs-lookup"><span data-stu-id="57e6b-123">In cases like this, what is needed is not pure process transparency but "process transparency, unless you need to care."</span></span> <span data-ttu-id="57e6b-124">COM fornece esse recurso, permitindo que um implementador de objeto dê suporte ao *marshaling personalizado* (também chamado de marshaling [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) ).</span><span class="sxs-lookup"><span data-stu-id="57e6b-124">COM provides this capability by allowing an object implementor to support *custom marshaling* (also called [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) marshaling).</span></span> <span data-ttu-id="57e6b-125">O marshaling padrão é, na verdade, uma instância de marshaling personalizado; é a implementação padrão usada quando um objeto não requer marshaling personalizado.</span><span class="sxs-lookup"><span data-stu-id="57e6b-125">Standard marshaling is, in fact, an instance of custom marshaling; it is the default implementation used when an object does not require custom marshaling.</span></span>

<span data-ttu-id="57e6b-126">Você pode implementar o marshaling personalizado para permitir que um objeto execute ações diferentes quando usado por meio de uma rede do que é necessário no acesso local e ele é completamente transparente para o cliente.</span><span class="sxs-lookup"><span data-stu-id="57e6b-126">You can implement custom marshaling to allow an object to take different actions when used from across a network than it takes under local access and it is completely transparent to the client.</span></span> <span data-ttu-id="57e6b-127">Essa arquitetura possibilita o design de interfaces de cliente/objeto sem considerar os problemas de desempenho de rede e, posteriormente, resolver problemas de desempenho de rede sem interromper o design estabelecido.</span><span class="sxs-lookup"><span data-stu-id="57e6b-127">This architecture makes it possible to design client/object interfaces without regard to network performance issues and then later to address network performance issues without disrupting the established design.</span></span>

<span data-ttu-id="57e6b-128">COM não especifica como os componentes são estruturados; Ele especifica como eles interagem.</span><span class="sxs-lookup"><span data-stu-id="57e6b-128">COM does not specify how components are structured; it specifies how they interact.</span></span> <span data-ttu-id="57e6b-129">COM deixa a preocupação sobre a estrutura interna de um componente para a programação de linguagens e ambientes de desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="57e6b-129">COM leaves the concern about the internal structure of a component to programming languages and development environments.</span></span> <span data-ttu-id="57e6b-130">Por outro lado, os ambientes de programação não têm padrões definidos para trabalhar com objetos fora do aplicativo imediato.</span><span class="sxs-lookup"><span data-stu-id="57e6b-130">Conversely, programming environments have no set standards for working with objects outside of the immediate application.</span></span> <span data-ttu-id="57e6b-131">Microsoft Visual C++, por exemplo, funciona muito bem para manipular objetos dentro de um aplicativo, mas não tem suporte para trabalhar com objetos fora do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-131">Microsoft Visual C++, for example, works extremely well for manipulating objects inside an application but has no support for working with objects outside the application.</span></span> <span data-ttu-id="57e6b-132">Em geral, todas as outras linguagens de programação são as mesmas nesse aspecto.</span><span class="sxs-lookup"><span data-stu-id="57e6b-132">Generally, all other programming languages are the same in this regard.</span></span> <span data-ttu-id="57e6b-133">Portanto, para fornecer interoperabilidade do networkwide, COM, por meio de interfaces independentes de linguagem, o escolhe onde as linguagens de programação deixam.</span><span class="sxs-lookup"><span data-stu-id="57e6b-133">Therefore, to provide networkwide interoperability, COM, through language-independent interfaces, picks up where programming languages leave off.</span></span>

<span data-ttu-id="57e6b-134">O indireção duplo da estrutura VTBL significa que os ponteiros na tabela de ponteiros de função não precisam apontar diretamente para a implementação real no objeto real.</span><span class="sxs-lookup"><span data-stu-id="57e6b-134">The double indirection of the vtbl structure means that the pointers in the table of function pointers do not need to point directly to the real implementation in the real object.</span></span> <span data-ttu-id="57e6b-135">Esse é o coração da transparência do processo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-135">This is the heart of process transparency.</span></span>

<span data-ttu-id="57e6b-136">Para servidores em processo, em que o objeto é carregado diretamente no processo do cliente, os ponteiros de função na tabela apontam diretamente para a implementação real.</span><span class="sxs-lookup"><span data-stu-id="57e6b-136">For in-process servers, where the object is loaded directly into the client process, the function pointers in the table point directly to the actual implementation.</span></span> <span data-ttu-id="57e6b-137">Nesse caso, uma chamada de função do cliente para um método de interface transfere diretamente o controle de execução para o método.</span><span class="sxs-lookup"><span data-stu-id="57e6b-137">In this case, a function call from the client to an interface method directly transfers execution control to the method.</span></span> <span data-ttu-id="57e6b-138">No entanto, isso não pode funcionar para objetos remotos e autônomos, pois os ponteiros para a memória não podem ser compartilhados entre processos.</span><span class="sxs-lookup"><span data-stu-id="57e6b-138">However, this cannot work for local, let alone remote, objects because pointers to memory cannot be shared between processes.</span></span> <span data-ttu-id="57e6b-139">No entanto, o cliente deve ser capaz de chamar métodos de interface como se estivesse chamando a implementação real.</span><span class="sxs-lookup"><span data-stu-id="57e6b-139">Nevertheless, the client must be able to call interface methods as if it were calling the actual implementation.</span></span> <span data-ttu-id="57e6b-140">Portanto, o cliente transfere uniformemente o controle para um método em algum objeto fazendo a chamada.</span><span class="sxs-lookup"><span data-stu-id="57e6b-140">Thus, the client uniformly transfers control to a method in some object by making the call.</span></span>

<span data-ttu-id="57e6b-141">Um cliente sempre chama métodos de interface em algum objeto em processo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-141">A client always calls interface methods in some in-process object.</span></span> <span data-ttu-id="57e6b-142">Se o objeto real for local ou remoto, a chamada será feita a um objeto proxy, que então faz uma chamada de procedimento remoto para o objeto real.</span><span class="sxs-lookup"><span data-stu-id="57e6b-142">If the actual object is local or remote, the call is made to a proxy object, which then makes a remote procedure call to the actual object.</span></span>

<span data-ttu-id="57e6b-143">Então, qual método é realmente executado?</span><span class="sxs-lookup"><span data-stu-id="57e6b-143">So what method is actually executed?</span></span> <span data-ttu-id="57e6b-144">A resposta é que sempre que houver uma chamada para uma interface fora do processo, cada método de interface é implementado por um objeto proxy.</span><span class="sxs-lookup"><span data-stu-id="57e6b-144">The answer is that whenever there is a call to an out-of-process interface, each interface method is implemented by a proxy object.</span></span> <span data-ttu-id="57e6b-145">O objeto proxy sempre é um objeto em processo que age em nome do objeto que está sendo chamado.</span><span class="sxs-lookup"><span data-stu-id="57e6b-145">The proxy object is always an in-process object that acts on behalf of the object being called.</span></span> <span data-ttu-id="57e6b-146">Esse objeto proxy sabe que o objeto real está sendo executado em um servidor local ou remoto.</span><span class="sxs-lookup"><span data-stu-id="57e6b-146">This proxy object knows that the actual object is running in a local or remote server.</span></span>

<span data-ttu-id="57e6b-147">O objeto proxy empacota os parâmetros de função em alguns pacotes de dados e gera uma chamada RPC para o objeto local ou remoto.</span><span class="sxs-lookup"><span data-stu-id="57e6b-147">The proxy object packages up the function parameters in some data packets and generates an RPC call to the local or remote object.</span></span> <span data-ttu-id="57e6b-148">Esse pacote é selecionado por um objeto stub no processo do servidor no local ou em um computador remoto, que desempacota os parâmetros e faz a chamada para a implementação real do método.</span><span class="sxs-lookup"><span data-stu-id="57e6b-148">That packet is picked up by a stub object in the server's process on the local or a remote computer, which unpacks the parameters and makes the call to the real implementation of the method.</span></span> <span data-ttu-id="57e6b-149">Quando essa função retorna, o stub empacota todos os parâmetros de saída e o valor de retorno e o envia de volta ao proxy, que os desempacota e os retorna ao cliente original.</span><span class="sxs-lookup"><span data-stu-id="57e6b-149">When that function returns, the stub packages up any out-parameters and the return value and sends it back to the proxy, which unpacks them and returns them to the original client.</span></span>

<span data-ttu-id="57e6b-150">Portanto, o cliente e o servidor sempre falam uns com os outros como se tudo estivesse em processo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-150">Thus, client and server always talk to each other as if everything was in-process.</span></span> <span data-ttu-id="57e6b-151">Todas as chamadas do cliente e todas as chamadas para o servidor são, em algum momento, em processo.</span><span class="sxs-lookup"><span data-stu-id="57e6b-151">All calls from the client and all calls to the server are, at some point, in-process.</span></span> <span data-ttu-id="57e6b-152">Mas como a estrutura VTBL permite que algum agente, como COM, intercepte todas as chamadas de função e todos os retornos de funções, esse agente pode redirecionar essas chamadas para uma chamada RPC, conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="57e6b-152">But because the vtbl structure allows some agent, like COM, to intercept all function calls and all returns from functions, that agent can redirect those calls to an RPC call as necessary.</span></span> <span data-ttu-id="57e6b-153">Embora as chamadas em processo sejam mais rápidas do que as chamadas fora do processo, as diferenças do processo são completamente transparentes para o cliente e o servidor.</span><span class="sxs-lookup"><span data-stu-id="57e6b-153">Although in-process calls are faster than out-of-process calls, the process differences are completely transparent to the client and server.</span></span>

<span data-ttu-id="57e6b-154">Para mais informações, consulte os seguintes tópicos:</span><span class="sxs-lookup"><span data-stu-id="57e6b-154">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="57e6b-155">Detalhes de marshaling</span><span class="sxs-lookup"><span data-stu-id="57e6b-155">Marshaling Details</span></span>](marshaling-details.md)
-   [<span data-ttu-id="57e6b-156">Proxy</span><span class="sxs-lookup"><span data-stu-id="57e6b-156">Proxy</span></span>](proxy.md)
-   [<span data-ttu-id="57e6b-157">Gerenciador</span><span class="sxs-lookup"><span data-stu-id="57e6b-157">Stub</span></span>](stub.md)
-   [<span data-ttu-id="57e6b-158">Channel</span><span class="sxs-lookup"><span data-stu-id="57e6b-158">Channel</span></span>](channel.md)
-   [<span data-ttu-id="57e6b-159">RPC da Microsoft</span><span class="sxs-lookup"><span data-stu-id="57e6b-159">Microsoft RPC</span></span>](microsoft-rpc.md)

## <a name="related-topics"></a><span data-ttu-id="57e6b-160">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="57e6b-160">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="57e6b-161">Clientes e servidores COM</span><span class="sxs-lookup"><span data-stu-id="57e6b-161">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="57e6b-162">Empacotamento de interface</span><span class="sxs-lookup"><span data-stu-id="57e6b-162">Interface Marshaling</span></span>](interface-marshaling.md)
</dt> </dl>

 

 