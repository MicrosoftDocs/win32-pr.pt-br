---
title: Single-Threaded Apartments
description: Single-Threaded Apartments
ms.assetid: 2f345ae2-8314-4067-a6d6-5a0275941ed4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0f0a8cb1422b6866d9e0d043fdd46c895e6d335b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104366750"
---
# <a name="single-threaded-apartments"></a><span data-ttu-id="ee137-103">Single-Threaded Apartments</span><span class="sxs-lookup"><span data-stu-id="ee137-103">Single-Threaded Apartments</span></span>

<span data-ttu-id="ee137-104">O uso de Apartments de thread único (o processo de modelo de apartamento) oferece um paradigma baseado em mensagem para lidar com vários objetos executados simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="ee137-104">Using single-threaded apartments (the apartment model process) offers a message-based paradigm for dealing with multiple objects running concurrently.</span></span> <span data-ttu-id="ee137-105">Ele permite que você escreva código mais eficiente, permitindo um thread, enquanto ele aguarda a conclusão de uma operação demorada, para permitir que outro thread seja executado.</span><span class="sxs-lookup"><span data-stu-id="ee137-105">It enables you to write more efficient code by allowing a thread, while it waits for some time-consuming operation to complete, to allow another thread to be executed.</span></span>

<span data-ttu-id="ee137-106">Cada thread em um processo que é inicializado como um processo de modelo de apartamento, e que recupera e despacha mensagens de janela, é um thread apartment de thread único.</span><span class="sxs-lookup"><span data-stu-id="ee137-106">Each thread in a process that is initialized as an apartment model process, and that retrieves and dispatches window messages, is a single-threaded apartment thread.</span></span> <span data-ttu-id="ee137-107">Cada thread reside em seu próprio apartamento.</span><span class="sxs-lookup"><span data-stu-id="ee137-107">Each thread lives within its own apartment.</span></span> <span data-ttu-id="ee137-108">Em um apartamento, os ponteiros de interface podem ser passados sem marshaling e, portanto, todos os objetos em um thread apartment de thread único se comunicam diretamente.</span><span class="sxs-lookup"><span data-stu-id="ee137-108">Within an apartment, interface pointers can be passed without marshaling, and therefore, all objects in one single-threaded apartment thread communicate directly.</span></span>

<span data-ttu-id="ee137-109">Um agrupamento lógico de objetos relacionados que todos executam no mesmo thread e, portanto, deve ter execução síncrona, pode residir no mesmo thread apartment de thread único.</span><span class="sxs-lookup"><span data-stu-id="ee137-109">A logical grouping of related objects that all execute on the same thread, and therefore must have synchronous execution, could live on the same single-threaded apartment thread.</span></span> <span data-ttu-id="ee137-110">No entanto, um objeto de modelo de apartamento não pode residir em mais de um thread.</span><span class="sxs-lookup"><span data-stu-id="ee137-110">However, an apartment model object cannot reside on more than one thread.</span></span> <span data-ttu-id="ee137-111">As chamadas para objetos em outros threads devem ser feitas dentro do contexto do thread proprietário, portanto, os threads de comutadores COM distribuídos para você automaticamente quando você chama em um proxy.</span><span class="sxs-lookup"><span data-stu-id="ee137-111">Calls to objects in other threads must be made within the context of the owning thread, so distributed COM switches threads for you automatically when you call on a proxy.</span></span>

<span data-ttu-id="ee137-112">Os modelos entre processos e interthread são semelhantes.</span><span class="sxs-lookup"><span data-stu-id="ee137-112">The interprocess and interthread models are similar.</span></span> <span data-ttu-id="ee137-113">Quando é necessário passar um ponteiro de interface para um objeto em outro apartamento (em outro thread) dentro do mesmo processo, você usa o mesmo modelo de marshaling que os objetos em processos diferentes usam para passar ponteiros entre limites de processo.</span><span class="sxs-lookup"><span data-stu-id="ee137-113">When it is necessary to pass an interface pointer to an object in another apartment (on another thread) within the same process, you use the same marshaling model that objects in different processes use to pass pointers across process boundaries.</span></span> <span data-ttu-id="ee137-114">Ao obter um ponteiro para o objeto de marshaling padrão, você pode realizar marshaling de ponteiros de interface entre limites de thread (entre Apartments) da mesma maneira que faz entre processos.</span><span class="sxs-lookup"><span data-stu-id="ee137-114">By getting a pointer to the standard marshaling object, you can marshal interface pointers across thread boundaries (between apartments) in the same way you do between processes.</span></span> <span data-ttu-id="ee137-115">(Os ponteiros de interface devem ser empacotados quando passados entre Apartments.)</span><span class="sxs-lookup"><span data-stu-id="ee137-115">(Interface pointers must be marshaled when passed between apartments.)</span></span>

<span data-ttu-id="ee137-116">Regras para Apartments de thread único são simples, mas é importante segui-las com cuidado:</span><span class="sxs-lookup"><span data-stu-id="ee137-116">Rules for single-threaded apartments are simple, but it is important to follow them carefully:</span></span>

-   <span data-ttu-id="ee137-117">Cada objeto deve residir em apenas um thread (dentro de um apartamento de thread único).</span><span class="sxs-lookup"><span data-stu-id="ee137-117">Every object should live on only one thread (within a single-threaded apartment).</span></span>
-   <span data-ttu-id="ee137-118">Inicialize a biblioteca COM para cada thread.</span><span class="sxs-lookup"><span data-stu-id="ee137-118">Initialize the COM library for each thread.</span></span>
-   <span data-ttu-id="ee137-119">Realize marshaling de todos os ponteiros para objetos ao passá-los entre Apartments.</span><span class="sxs-lookup"><span data-stu-id="ee137-119">Marshal all pointers to objects when passing them between apartments.</span></span>
-   <span data-ttu-id="ee137-120">Cada apartamento de thread único deve ter um loop de mensagem para manipular chamadas de outros processos e Apartments dentro do mesmo processo.</span><span class="sxs-lookup"><span data-stu-id="ee137-120">Each single-threaded apartment must have a message loop to handle calls from other processes and apartments within the same process.</span></span> <span data-ttu-id="ee137-121">Apartments de thread único sem objetos (somente cliente) também precisam de um loop de mensagem para enviar as mensagens de difusão que alguns aplicativos usam.</span><span class="sxs-lookup"><span data-stu-id="ee137-121">Single-threaded apartments without objects (client only) also need a message loop to dispatch the broadcast messages that some applications use.</span></span>
-   <span data-ttu-id="ee137-122">Os objetos baseados em DLL ou em processo não chamam as funções de inicialização de COM; em vez disso, eles registram seu modelo de Threading com o **ThreadingModel** chamado-value na chave [InprocServer32](inprocserver32.md) no registro.</span><span class="sxs-lookup"><span data-stu-id="ee137-122">DLL-based or in-process objects do not call the COM initialization functions; instead, they register their threading model with the **ThreadingModel** named-value under the [InprocServer32](inprocserver32.md) key in the registry.</span></span> <span data-ttu-id="ee137-123">Os objetos com reconhecimento de apartamento também devem gravar pontos de entrada de DLL com cuidado.</span><span class="sxs-lookup"><span data-stu-id="ee137-123">Apartment-aware objects must also write DLL entry points carefully.</span></span> <span data-ttu-id="ee137-124">Há considerações especiais que se aplicam aos servidores de Threading em processo.</span><span class="sxs-lookup"><span data-stu-id="ee137-124">There are special considerations that apply to threading in-process servers.</span></span> <span data-ttu-id="ee137-125">Para obter mais informações, consulte [problemas de thread de servidor em processo](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="ee137-125">For more information, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="ee137-126">Embora vários objetos possam residir em um único thread, nenhum objeto de modelo Apartment pode residir em mais de um thread.</span><span class="sxs-lookup"><span data-stu-id="ee137-126">While multiple objects can live on a single thread, no apartment model object can live on more than one thread.</span></span>

<span data-ttu-id="ee137-127">Cada thread de um processo de cliente ou servidor fora do processo deve chamar [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), ou chamar [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) e especificar \_ APARTMENTTHREADED para o parâmetro *dwCoInit* .</span><span class="sxs-lookup"><span data-stu-id="ee137-127">Each thread of a client process or out-of-process server must call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), or call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) and specify COINIT\_APARTMENTTHREADED for the *dwCoInit* parameter.</span></span> <span data-ttu-id="ee137-128">O apartamento principal é o thread que chama **CoInitializeEx** primeiro.</span><span class="sxs-lookup"><span data-stu-id="ee137-128">The main apartment is the thread that calls **CoInitializeEx** first.</span></span> <span data-ttu-id="ee137-129">Para obter informações sobre servidores em processo, consulte [problemas de Threading do servidor em processo](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="ee137-129">For information on in-process servers, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="ee137-130">Todas as chamadas para um objeto devem ser feitas em seu thread (dentro de seu apartamento).</span><span class="sxs-lookup"><span data-stu-id="ee137-130">All calls to an object must be made on its thread (within its apartment).</span></span> <span data-ttu-id="ee137-131">É proibido chamar um objeto diretamente de outro thread; usar objetos dessa maneira de thread livre pode causar problemas para aplicativos.</span><span class="sxs-lookup"><span data-stu-id="ee137-131">It is forbidden to call an object directly from another thread; using objects in this free-threaded manner could cause problems for applications.</span></span> <span data-ttu-id="ee137-132">A implicação dessa regra é que todos os ponteiros para objetos devem ser empacotados quando passados entre Apartments.</span><span class="sxs-lookup"><span data-stu-id="ee137-132">The implication of this rule is that all pointers to objects must be marshaled when passed between apartments.</span></span> <span data-ttu-id="ee137-133">COM fornece as duas funções a seguir para essa finalidade:</span><span class="sxs-lookup"><span data-stu-id="ee137-133">COM provides the following two functions for this purpose:</span></span>

-   <span data-ttu-id="ee137-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) empacota uma interface em um objeto de fluxo que é retornado para o chamador.</span><span class="sxs-lookup"><span data-stu-id="ee137-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) marshals an interface into a stream object that is returned to the caller.</span></span>
-   <span data-ttu-id="ee137-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) desempacota um ponteiro de interface de um objeto de fluxo e o libera.</span><span class="sxs-lookup"><span data-stu-id="ee137-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) unmarshals an interface pointer from a stream object and releases it.</span></span>

<span data-ttu-id="ee137-136">Essas funções encapsulam chamadas para as funções [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) e [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) , que exigem o uso do \_ sinalizador InProc MSHCTX.</span><span class="sxs-lookup"><span data-stu-id="ee137-136">These functions wrap calls to [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) and [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) functions, which require the use of the MSHCTX\_INPROC flag.</span></span>

<span data-ttu-id="ee137-137">Em geral, o marshaling é realizado automaticamente pelo COM.</span><span class="sxs-lookup"><span data-stu-id="ee137-137">In general, the marshaling is accomplished automatically by COM.</span></span> <span data-ttu-id="ee137-138">Por exemplo, ao passar um ponteiro de interface como um parâmetro em uma chamada de método em um proxy para um objeto em outro apartamento, ou ao chamar [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), com faz o marshaling automaticamente.</span><span class="sxs-lookup"><span data-stu-id="ee137-138">For example, when passing an interface pointer as a parameter in a method call on a proxy to an object in another apartment, or when calling [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), COM does the marshaling automatically.</span></span> <span data-ttu-id="ee137-139">No entanto, em alguns casos especiais, em que o gravador de aplicativos está passando ponteiros de interface entre Apartments sem usar os mecanismos COM normais, o gravador deve tratar o marshaling manualmente.</span><span class="sxs-lookup"><span data-stu-id="ee137-139">However, in some special cases, where the application writer is passing interface pointers between apartments without using the normal COM mechanisms, the writer must handle the marshaling manually.</span></span>

<span data-ttu-id="ee137-140">Se um apartamento (apartamento 1) em um processo tiver um ponteiro de interface e outro apartamento (apartamento 2) exigir seu uso, o apartamento 1 deverá chamar [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) para realizar marshaling da interface.</span><span class="sxs-lookup"><span data-stu-id="ee137-140">If one apartment (Apartment 1) in a process has an interface pointer and another apartment (Apartment 2) requires its use, Apartment 1 must call [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) to marshal the interface.</span></span> <span data-ttu-id="ee137-141">O fluxo criado por essa função é thread-safe e deve ser armazenado em uma variável acessível pelo apartamento 2.</span><span class="sxs-lookup"><span data-stu-id="ee137-141">The stream that is created by this function is thread-safe and must be stored in a variable that is accessible by Apartment 2.</span></span> <span data-ttu-id="ee137-142">O apartamento 2 deve passar esse fluxo para [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) para desempacotar a interface e receberá um ponteiro para um proxy por meio do qual ele pode acessar a interface.</span><span class="sxs-lookup"><span data-stu-id="ee137-142">Apartment 2 must pass this stream to [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) to unmarshal the interface and will get back a pointer to a proxy through which it can access the interface.</span></span> <span data-ttu-id="ee137-143">O apartamento principal deve permanecer ativo até que o cliente tenha concluído todo o trabalho COM (porque alguns objetos em processo são carregados no apartamento principal, conforme descrito em [problemas de threading de servidor em processo](in-process-server-threading-issues.md)).</span><span class="sxs-lookup"><span data-stu-id="ee137-143">The main apartment must remain alive until the client has completed all COM work (because some in-process objects are loaded in the main apartment, as described in [In-Process Server Threading Issues](in-process-server-threading-issues.md)).</span></span> <span data-ttu-id="ee137-144">Depois que um objeto é passado entre threads dessa maneira, é muito fácil passar ponteiros de interface como parâmetros.</span><span class="sxs-lookup"><span data-stu-id="ee137-144">After one object has been passed between threads in this manner, it is very easy to pass interface pointers as parameters.</span></span> <span data-ttu-id="ee137-145">Dessa forma, Distributed COM faz o marshaling e a alternância de threads para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="ee137-145">That way, distributed COM does the marshaling and thread switching for the application.</span></span>

<span data-ttu-id="ee137-146">Para lidar com chamadas de outros processos e Apartments no mesmo processo, cada apartamento de thread único deve ter um loop de mensagem.</span><span class="sxs-lookup"><span data-stu-id="ee137-146">To handle calls from other processes and apartments within the same process, each single-threaded apartment must have a message loop.</span></span> <span data-ttu-id="ee137-147">Isso significa que a função de trabalho do thread deve ter um loop GetMessage/DispatchMessage.</span><span class="sxs-lookup"><span data-stu-id="ee137-147">This means that the thread's work function must have a GetMessage/DispatchMessage loop.</span></span> <span data-ttu-id="ee137-148">Se outros primitivos de sincronização estiverem sendo usados para comunicação entre threads, a função [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) poderá ser usada para aguardar as mensagens e os eventos de sincronização de thread.</span><span class="sxs-lookup"><span data-stu-id="ee137-148">If other synchronization primitives are being used to communicate between threads, the [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) function can be used to wait both for messages and for thread synchronization events.</span></span> <span data-ttu-id="ee137-149">A documentação para essa função tem um exemplo desse tipo de loop de combinação.</span><span class="sxs-lookup"><span data-stu-id="ee137-149">The documentation for this function has an example of this sort of combination loop.</span></span>

<span data-ttu-id="ee137-150">COM cria uma janela oculta usando a classe do Windows "OleMainThreadWndClass" em cada apartamento de thread único.</span><span class="sxs-lookup"><span data-stu-id="ee137-150">COM creates a hidden window using the Windows class "OleMainThreadWndClass" in each single-threaded apartment.</span></span> <span data-ttu-id="ee137-151">Uma chamada para um objeto é recebida como uma mensagem de janela para esta janela oculta.</span><span class="sxs-lookup"><span data-stu-id="ee137-151">A call to an object is received as a window message to this hidden window.</span></span> <span data-ttu-id="ee137-152">Quando o apartamento do objeto recupera e despacha a mensagem, a janela oculta a receberá.</span><span class="sxs-lookup"><span data-stu-id="ee137-152">When the object's apartment retrieves and dispatches the message, the hidden window will receive it.</span></span> <span data-ttu-id="ee137-153">O procedimento de janela Então chamará o método de interface correspondente do objeto.</span><span class="sxs-lookup"><span data-stu-id="ee137-153">The window procedure will then call the corresponding interface method of the object.</span></span>

<span data-ttu-id="ee137-154">Quando vários clientes chamarem um objeto, as chamadas serão enfileiradas na fila de mensagens e o objeto receberá uma chamada cada vez que seu apartamento recuperar e enviar mensagens.</span><span class="sxs-lookup"><span data-stu-id="ee137-154">When multiple clients call an object, the calls are queued in the message queue and the object will receive a call each time its apartment retrieves and dispatches messages.</span></span> <span data-ttu-id="ee137-155">Como as chamadas são sincronizadas pelo COM e as chamadas são sempre entregues pelo thread que pertence ao apartamento do objeto, as implementações de interface do objeto não precisam fornecer sincronização.</span><span class="sxs-lookup"><span data-stu-id="ee137-155">Because the calls are synchronized by COM and the calls are always delivered by the thread that belongs to the object's apartment, the object's interface implementations need not provide synchronization.</span></span> <span data-ttu-id="ee137-156">Apartments de thread único podem implementar [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) para permitir que eles cancelem chamadas ou recebam mensagens de janela quando necessário.</span><span class="sxs-lookup"><span data-stu-id="ee137-156">Single-threaded apartments can implement [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) to permit them to cancel calls or receive window messages when necessary.</span></span>

<span data-ttu-id="ee137-157">O objeto poderá ser reinserido se uma de suas implementações de método de interface recuperar e despachar mensagens ou fizer uma chamada ORPC para outro thread, fazendo com que outra chamada seja entregue ao objeto (pelo mesmo apartamento).</span><span class="sxs-lookup"><span data-stu-id="ee137-157">The object can be reentered if one of its interface method implementations retrieves and dispatches messages or makes an ORPC call to another thread, thereby causing another call to be delivered to the object (by the same apartment).</span></span> <span data-ttu-id="ee137-158">O OLE não impede a reentrância no mesmo thread, mas pode ajudar a fornecer segurança de thread.</span><span class="sxs-lookup"><span data-stu-id="ee137-158">OLE does not prevent reentrancy on the same thread, but it can help provide thread safety.</span></span> <span data-ttu-id="ee137-159">Isso é idêntico ao modo como um procedimento de janela pode ser reinserido se recuperar e despachar mensagens durante o processamento de uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="ee137-159">This is identical to the way in which a window procedure can be reentered if it retrieves and dispatches messages while processing a message.</span></span> <span data-ttu-id="ee137-160">No entanto, chamar um servidor Apartment de thread único fora do processo que chama outro servidor Apartment de thread único permitirá que o primeiro servidor seja reinserido.</span><span class="sxs-lookup"><span data-stu-id="ee137-160">However, calling an out-of-process single-threaded apartment server that calls another single-threaded apartment server will allow the first server to be reentered.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ee137-161">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="ee137-161">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ee137-162">Acessando interfaces em Apartments</span><span class="sxs-lookup"><span data-stu-id="ee137-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="ee137-163">Escolhendo o modelo de Threading</span><span class="sxs-lookup"><span data-stu-id="ee137-163">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="ee137-164">Apartments multithread</span><span class="sxs-lookup"><span data-stu-id="ee137-164">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="ee137-165">Problemas de Threading do servidor em processo</span><span class="sxs-lookup"><span data-stu-id="ee137-165">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="ee137-166">Processos, threads e Apartments</span><span class="sxs-lookup"><span data-stu-id="ee137-166">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="ee137-167">Comunicação de thread único e multithread</span><span class="sxs-lookup"><span data-stu-id="ee137-167">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> </dl>

 

 