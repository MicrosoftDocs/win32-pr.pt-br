---
title: Regras de gerenciamento de memória
description: Regras de gerenciamento de memória
ms.assetid: 769127a1-1a14-4ed4-9d38-7cf3e571b661
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 56e7ad2483b794ec5c2e9c325bca8e469ff4ae0b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104084943"
---
# <a name="memory-management-rules"></a><span data-ttu-id="8d23b-103">Regras de gerenciamento de memória</span><span class="sxs-lookup"><span data-stu-id="8d23b-103">Memory Management Rules</span></span>

<span data-ttu-id="8d23b-104">O tempo de vida de ponteiros para interfaces é sempre gerenciado por meio dos métodos [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) em cada interface com.</span><span class="sxs-lookup"><span data-stu-id="8d23b-104">The lifetime of pointers to interfaces is always managed through the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods on every COM interface.</span></span> <span data-ttu-id="8d23b-105">Para obter mais informações, consulte [regras para gerenciar contagens de referência](rules-for-managing-reference-counts.md).</span><span class="sxs-lookup"><span data-stu-id="8d23b-105">For more information, see [Rules for Managing Reference Counts](rules-for-managing-reference-counts.md).</span></span>

<span data-ttu-id="8d23b-106">Para todos os outros parâmetros, é importante aderir a determinadas regras para gerenciar a memória.</span><span class="sxs-lookup"><span data-stu-id="8d23b-106">For all other parameters, it is important to adhere to certain rules for managing memory.</span></span> <span data-ttu-id="8d23b-107">As regras a seguir se aplicam a todos os parâmetros da interface methodsâ € ", incluindo o retorno valueâ €" que não são passados pelo valor:</span><span class="sxs-lookup"><span data-stu-id="8d23b-107">The following rules apply to all parameters of interface methodsâ€”including the return valueâ€”that are not passed by value:</span></span>

-   <span data-ttu-id="8d23b-108">Os parâmetros in-devem ser alocados e liberados pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="8d23b-108">In-parameters must be allocated and freed by the caller.</span></span>
-   <span data-ttu-id="8d23b-109">Os parâmetros out devem ser alocados por um chamado; Eles são liberados pelo chamador usando o alocador de memória de tarefa COM padrão.</span><span class="sxs-lookup"><span data-stu-id="8d23b-109">Out-parameters must be allocated by the one called; they are freed by the caller using the standard COM task memory allocator.</span></span> <span data-ttu-id="8d23b-110">Consulte [o alocador de memória OLE](the-ole-memory-allocator.md) para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="8d23b-110">See [The OLE Memory Allocator](the-ole-memory-allocator.md) for more information.</span></span>
-   <span data-ttu-id="8d23b-111">Os parâmetros in/out são alocados inicialmente pelo chamador e, em seguida, liberados e realocados por um chamado, se necessário.</span><span class="sxs-lookup"><span data-stu-id="8d23b-111">In/out-parameters are initially allocated by the caller, and then freed and reallocated by the one called, if necessary.</span></span> <span data-ttu-id="8d23b-112">Como é verdadeiro para parâmetros de saída, o chamador é responsável por liberar o valor retornado final.</span><span class="sxs-lookup"><span data-stu-id="8d23b-112">As is true for out parameters, the caller is responsible for freeing the final returned value.</span></span> <span data-ttu-id="8d23b-113">O alocador de memória COM padrão deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="8d23b-113">The standard COM memory allocator must be used.</span></span>

<span data-ttu-id="8d23b-114">Nos dois últimos casos, em que uma parte do código aloca a memória e uma parte diferente do código a libera, usar o alocador de COM garante que as duas partes do código estejam usando os mesmos métodos de alocação.</span><span class="sxs-lookup"><span data-stu-id="8d23b-114">In the latter two cases, where one piece of code allocates the memory and a different piece of code frees it, using the COM allocator ensures that the two pieces of code are using the same allocation methods.</span></span>

<span data-ttu-id="8d23b-115">Outra área que precisa de atenção especial é o tratamento de parâmetros de saída e de entrada em condições de falha.</span><span class="sxs-lookup"><span data-stu-id="8d23b-115">Another area that needs special attention is the treatment of out and in-out parameters in failure conditions.</span></span> <span data-ttu-id="8d23b-116">Se uma função retornar um código de falha, o chamador normalmente não terá como limpar os parâmetros out ou out.</span><span class="sxs-lookup"><span data-stu-id="8d23b-116">If a function returns a failure code, the caller typically has no way to clean up the out or in-out parameters.</span></span> <span data-ttu-id="8d23b-117">Isso leva às seguintes regras adicionais:</span><span class="sxs-lookup"><span data-stu-id="8d23b-117">This leads to the following additional rules:</span></span>

-   <span data-ttu-id="8d23b-118">No caso de uma condição de erro, os parâmetros devem ser sempre definidos de forma confiável para um valor que será limpo sem nenhuma ação pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="8d23b-118">In case of an error condition, parameters must always be reliably set to a value that will be cleaned up without any action by the caller.</span></span>
-   <span data-ttu-id="8d23b-119">Todos os parâmetros de ponteiro de saída devem ser definidos explicitamente como **NULL**.</span><span class="sxs-lookup"><span data-stu-id="8d23b-119">All out pointer parameters must explicitly be set to **NULL**.</span></span> <span data-ttu-id="8d23b-120">Normalmente, eles são passados em um parâmetro ponteiro para ponteiro, mas também podem ser passados como membros de uma estrutura que o chamador aloca e o código chamado é preenchido.</span><span class="sxs-lookup"><span data-stu-id="8d23b-120">These are usually passed in a pointer-to-pointer parameter but can also be passed as members of a structure that the caller allocates and the called code fills.</span></span> <span data-ttu-id="8d23b-121">A maneira mais simples de garantir que isso seja (em parte) definir esses valores como **NULL** na entrada da função.</span><span class="sxs-lookup"><span data-stu-id="8d23b-121">The most straightforward way to ensure this is (in part) to set these values to **NULL** on function entry.</span></span> <span data-ttu-id="8d23b-122">Essa regra é importante porque promove uma interoperabilidade de aplicativo mais robusta.</span><span class="sxs-lookup"><span data-stu-id="8d23b-122">This rule is important because it promotes more robust application interoperability.</span></span>
-   <span data-ttu-id="8d23b-123">Em condições de erro, todos os parâmetros de entrada devem ser mantidos sozinhos pelo código chamado (assim, permanecendo no valor para o qual foram inicializados pelo chamador) ou definidos explicitamente, como no caso de retorno de erro de parâmetro out.</span><span class="sxs-lookup"><span data-stu-id="8d23b-123">Under error conditions, all in-out parameters must either be left alone by the code called (thus remaining at the value to which they were initialized by the caller) or be explicitly set, as in the out parameter error return case.</span></span>

<span data-ttu-id="8d23b-124">Lembre-se de que essas convenções de gerenciamento de memória para aplicativos COM aplicam-se apenas às interfaces públicas e APIsâ €. não há nenhum requisito para que a alocação de memória estritamente interna a um aplicativo COM precise ser feita usando esses mecanismos.</span><span class="sxs-lookup"><span data-stu-id="8d23b-124">Remember that these memory management conventions for COM applications apply only across public interfaces and APIsâ€”there is no requirement at all that memory allocation strictly internal to a COM application need be done using these mechanisms.</span></span>

<span data-ttu-id="8d23b-125">O COM internamente usa RPC (chamadas de procedimento remoto) para se comunicar entre clientes e servidores.</span><span class="sxs-lookup"><span data-stu-id="8d23b-125">COM internally uses Remote Procedure Calls (RPC) to communicate between clients and servers.</span></span> <span data-ttu-id="8d23b-126">Para obter mais informações sobre como gerenciar a memória em stubs de servidor RPC, consulte o tópico [Gerenciamento de memória de stub de servidor](../rpc/server-stub-memory-management.md) .</span><span class="sxs-lookup"><span data-stu-id="8d23b-126">For more information about managing memory in RPC server stubs, see the [Server-stub Memory Management](../rpc/server-stub-memory-management.md) topic.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8d23b-127">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="8d23b-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8d23b-128">Gerenciando a alocação de memória</span><span class="sxs-lookup"><span data-stu-id="8d23b-128">Managing Memory Allocation</span></span>](managing-memory-allocation.md)
</dt> </dl>

 

 