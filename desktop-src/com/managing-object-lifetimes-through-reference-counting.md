---
title: Gerenciando tempos de vida de objeto por meio de contagem de referência
description: Gerenciando tempos de vida de objeto por meio de contagem de referência
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/17/2020
ms.locfileid: "105751029"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a><span data-ttu-id="6c8f2-103">Gerenciando tempos de vida de objeto por meio de contagem de referência</span><span class="sxs-lookup"><span data-stu-id="6c8f2-103">Managing Object Lifetimes Through Reference Counting</span></span>

<span data-ttu-id="6c8f2-104">Em sistemas de objetos tradicionais, o ciclo de vida dos objetos – ou seja, os problemas que envolvem a criação e a exclusão de objetos — é tratado implicitamente pelo idioma (ou pelo tempo de execução do idioma) ou explicitamente pelos programadores de aplicativos.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-104">In traditional object systems, the life cycle of objects—that is, the issues surrounding the creation and deletion of objects—is handled implicitly by the language (or the language run time) or explicitly by application programmers.</span></span>

<span data-ttu-id="6c8f2-105">Em um sistema em evolução, desconstruído de forma descentralizada composto por componentes reutilizados, não é mais verdade que qualquer cliente, ou mesmo qualquer programador, sempre "sabe" como lidar com o tempo de vida de um componente.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-105">In an evolving, decentrally constructed system made up of reused components, it is no longer true that any client, or even any programmer, always "knows" how to deal with a component's lifetime.</span></span> <span data-ttu-id="6c8f2-106">Para um cliente com os privilégios de segurança certos, ainda é relativamente fácil criar objetos por meio de uma solicitação simples, mas a exclusão do objeto é totalmente diferente.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-106">For a client with the right security privileges, it is still relatively easy to create objects through a simple request, but object deletion is another matter entirely.</span></span> <span data-ttu-id="6c8f2-107">Não é necessariamente claro quando um objeto não é mais necessário e deve ser excluído.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-107">It is not necessarily clear when an object is no longer needed and should be deleted.</span></span> <span data-ttu-id="6c8f2-108">(Os leitores familiarizados com os ambientes de programação de lixo, como Java, podem discordar; no entanto, os objetos Java não abrangem limites de máquina ou até mesmo de processos e, portanto, a coleta de lixo é restrita a objetos que vivem em um espaço de processo único.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-108">(Readers familiar with garbage-collected programming environments, such as Java, may disagree; however, Java objects do not span machine or even process boundaries, and therefore the garbage collection is restricted to objects living within a single-process space.</span></span> <span data-ttu-id="6c8f2-109">Além disso, o Java força o uso de uma única linguagem de programação.) Mesmo quando o cliente original é concluído com o objeto, ele não pode simplesmente desligar o objeto, porque algum outro cliente ou clientes ainda podem ter uma referência a ele.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-109">In addition, Java forces the use of a single programming language.) Even when the original client is done with the object, it cannot simply shut the object down, because some other client or clients might still have a reference to it.</span></span>

<span data-ttu-id="6c8f2-110">Uma maneira de garantir que um objeto não seja mais necessário é depender inteiramente de um canal de comunicação subjacente para informar o sistema quando todas as conexões com um objeto entre processos ou entre canais tiverem desaparecido.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-110">One way to ensure that an object is no longer needed is to depend entirely on an underlying communication channel to inform the system when all connections to a cross-process or cross-channel object have disappeared.</span></span> <span data-ttu-id="6c8f2-111">No entanto, os esquemas que usam esse método são inaceitáveis por vários motivos.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-111">However, schemes that use this method are unacceptable for several reasons.</span></span> <span data-ttu-id="6c8f2-112">Um problema é que ele pode exigir uma grande diferença entre o modelo de programação entre processos/várias redes e o modelo de programação de processo único.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-112">One problem is that it could require a major difference between the cross-process/cross-network programming model and the single-process programming model.</span></span> <span data-ttu-id="6c8f2-113">No modelo de programação entre processos/rede cruzada, o sistema de comunicação forneceria os ganchos necessários para o gerenciamento de tempo de vida do objeto, enquanto no modelo de programação de processo único, os objetos são conectados diretamente sem nenhum canal de comunicação intermediário.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-113">In the cross-process/cross-network programming model, the communication system would provide the hooks necessary for object lifetime management, while in the single-process programming model, objects are directly connected without any intervening communications channel.</span></span> <span data-ttu-id="6c8f2-114">Outro problema é que esse esquema também poderia resultar em uma camada de software fornecido pelo sistema que iria interferir no desempenho do componente no caso do processo.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-114">Another problem is that this scheme could also result in a layer of system-provided software that would interfere with component performance in the in-process case.</span></span> <span data-ttu-id="6c8f2-115">Além disso, um mecanismo baseado em monitoramento explícito não tende a ser dimensionado em direção a muitos milhares ou milhões de objetos.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-115">Furthermore, a mechanism based on explicit monitoring would not tend to scale toward many thousands or millions of objects.</span></span>

<span data-ttu-id="6c8f2-116">O COM oferece uma abordagem escalonável e distribuída para esse conjunto de problemas.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-116">COM offers a scalable and distributed approach to this set of problems.</span></span> <span data-ttu-id="6c8f2-117">Os clientes informam um objeto quando estão usando-o e quando são concluídos, e os próprios objetos são excluídos quando não são mais necessários.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-117">Clients tell an object when they are using it and when they are done, and objects delete themselves when they are no longer needed.</span></span> <span data-ttu-id="6c8f2-118">Essa abordagem exige que todos os objetos contem referências a si mesmos.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-118">This approach mandates that all objects count references to themselves.</span></span> <span data-ttu-id="6c8f2-119">Linguagens de programação como Java, que inerentemente têm seus próprios esquemas de gerenciamento de tempo de vida, como a coleta de lixo, podem usar a contagem de referência de COM para implementar e usar objetos COM internamente, permitindo que o programador Evite lidar com ele.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-119">Programming languages such as Java, which inherently have their own lifetime management schemes, such as garbage collection, can use COM's reference counting to implement and use COM objects internally, allowing the programmer to avoid dealing with it.</span></span>

<span data-ttu-id="6c8f2-120">Assim como um aplicativo deve liberar memória alocada quando essa memória não está mais em uso, um cliente de um objeto é responsável por liberar suas referências para o objeto quando esse objeto não é mais necessário.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-120">Just as an application must free memory it has allocated once that memory is no longer in use, a client of an object is responsible for freeing its references to the object when that object is no longer needed.</span></span> <span data-ttu-id="6c8f2-121">Em um sistema orientado a objeto, o cliente pode fazer isso apenas dando ao objeto uma instrução para se liberar.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-121">In an object-oriented system, the client can do this only by giving the object an instruction to free itself.</span></span>

<span data-ttu-id="6c8f2-122">É importante que um objeto seja desalocado quando ele não estiver mais sendo usado.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-122">It is important that an object be deallocated when it is no longer being used.</span></span> <span data-ttu-id="6c8f2-123">A dificuldade está em determinar quando é apropriado para desalocar um objeto.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-123">The difficulty lies in determining when it is appropriate to deallocate an object.</span></span> <span data-ttu-id="6c8f2-124">Isso é fácil com variáveis automáticas (aquelas alocadas na pilha) — elas não podem ser usadas fora do bloco no qual estão declaradas, portanto, o compilador as desaloca quando o final do bloco é atingido.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-124">This is easy with automatic variables (those allocated on the stack)—they cannot be used outside the block in which they're declared, so the compiler deallocates them when the end of the block is reached.</span></span> <span data-ttu-id="6c8f2-125">Para objetos COM, que são alocados dinamicamente, cabe aos clientes de um objeto decidir quando eles não precisam mais usar o objeto — especialmente objetos locais ou remotos que podem estar em uso por vários clientes ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-125">For COM objects, which are dynamically allocated, it is up to the clients of an object to decide when they no longer need to use the object—especially local or remote objects that might be in use by multiple clients at the same time.</span></span> <span data-ttu-id="6c8f2-126">O objeto deve aguardar até que todos os clientes sejam concluídos com ele antes de se liberar.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-126">The object must wait until all clients are finished with it before freeing itself.</span></span> <span data-ttu-id="6c8f2-127">Como objetos COM são manipulados por meio de ponteiros de interface e podem ser usados por objetos em diferentes processos ou em outros computadores, o sistema não pode controlar os clientes de um objeto.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-127">Because COM objects are manipulated through interface pointers and can be used by objects in different processes or on other machines, the system cannot keep track of an object's clients.</span></span>

<span data-ttu-id="6c8f2-128">O método de COM de determinar quando é apropriado desalocar um objeto é a contagem de referência manual.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-128">COM's method of determining when it is appropriate to deallocate an object is manual reference counting.</span></span> <span data-ttu-id="6c8f2-129">Cada objeto mantém uma contagem de referência que acompanha quantos clientes estão conectados a ele, ou seja, quantos ponteiros existem para qualquer uma de suas interfaces em qualquer cliente.</span><span class="sxs-lookup"><span data-stu-id="6c8f2-129">Each object maintains a reference count that tracks how many clients are connected to it - that is, how many pointers exist to any of its interfaces in any client.</span></span>

<span data-ttu-id="6c8f2-130">Para mais informações, consulte os seguintes tópicos:</span><span class="sxs-lookup"><span data-stu-id="6c8f2-130">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="6c8f2-131">Implementando a contagem de referência</span><span class="sxs-lookup"><span data-stu-id="6c8f2-131">Implementing Reference Counting</span></span>](implementing-reference-counting.md)
-   [<span data-ttu-id="6c8f2-132">Regras para gerenciar contagens de referência</span><span class="sxs-lookup"><span data-stu-id="6c8f2-132">Rules for Managing Reference Counts</span></span>](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a><span data-ttu-id="6c8f2-133">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="6c8f2-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6c8f2-134">Usando e implementando IUnknown</span><span class="sxs-lookup"><span data-stu-id="6c8f2-134">Using and Implementing IUnknown</span></span>](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




