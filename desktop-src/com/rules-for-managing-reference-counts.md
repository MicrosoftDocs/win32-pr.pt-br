---
title: Regras para gerenciar contagens de referência
description: Usar uma contagem de referência para gerenciar o tempo de vida de um objeto permite que vários clientes obtenham e liberem o acesso a um único objeto sem precisar coordenar um ao outro no gerenciamento do tempo de vida do objeto.
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104366743"
---
# <a name="rules-for-managing-reference-counts"></a><span data-ttu-id="e9153-103">Regras para gerenciar contagens de referência</span><span class="sxs-lookup"><span data-stu-id="e9153-103">Rules for Managing Reference Counts</span></span>

<span data-ttu-id="e9153-104">Usar uma contagem de referência para gerenciar o tempo de vida de um objeto permite que vários clientes obtenham e liberem o acesso a um único objeto sem precisar coordenar um ao outro no gerenciamento do tempo de vida do objeto.</span><span class="sxs-lookup"><span data-stu-id="e9153-104">Using a reference count to manage an object's lifetime allows multiple clients to obtain and release access to a single object without having to coordinate with one another in managing the object's lifetime.</span></span> <span data-ttu-id="e9153-105">Desde que o objeto cliente esteja em conformidade com determinadas regras de uso, o objeto, em vigor, fornece esse gerenciamento.</span><span class="sxs-lookup"><span data-stu-id="e9153-105">As long as the client object conforms to certain rules of use, the object, in effect, provides this management.</span></span> <span data-ttu-id="e9153-106">Essas regras especificam como gerenciar referências entre objetos.</span><span class="sxs-lookup"><span data-stu-id="e9153-106">These rules specify how to manage references between objects.</span></span> <span data-ttu-id="e9153-107">(COM não especifica implementações internas de objetos, embora essas regras sejam um ponto de partida razoável para uma política dentro de um objeto.)</span><span class="sxs-lookup"><span data-stu-id="e9153-107">(COM does not specify internal implementations of objects, although these rules are a reasonable starting point for a policy within an object.)</span></span>

<span data-ttu-id="e9153-108">Conceitualmente, os ponteiros de interface podem ser considerados como residentes em variáveis de ponteiro que incluem todo o estado de computação interno que mantém um ponteiro de interface.</span><span class="sxs-lookup"><span data-stu-id="e9153-108">Conceptually, interface pointers can be thought of as residing within pointer variables that include all the internal computation state that holds an interface pointer.</span></span> <span data-ttu-id="e9153-109">Isso incluiria variáveis em locais de memória, em registros de processador internos e em ambas as variáveis geradas pelo programador e por compilador.</span><span class="sxs-lookup"><span data-stu-id="e9153-109">This would include variables in memory locations, in internal processor registers, and both programmer-generated and compiler-generated variables.</span></span> <span data-ttu-id="e9153-110">A atribuição ou a inicialização de uma variável de ponteiro envolve a criação de uma nova cópia de um ponteiro já existente.</span><span class="sxs-lookup"><span data-stu-id="e9153-110">Assignment to or initialization of a pointer variable involves creating a new copy of an already existing pointer.</span></span> <span data-ttu-id="e9153-111">Quando houve uma cópia do ponteiro em alguma variável (o valor usado na atribuição/inicialização), agora há duas.</span><span class="sxs-lookup"><span data-stu-id="e9153-111">Where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there are now two.</span></span> <span data-ttu-id="e9153-112">Uma atribuição a uma variável de ponteiro destrói a cópia do ponteiro no momento na variável, assim como faz a destruição da própria variável.</span><span class="sxs-lookup"><span data-stu-id="e9153-112">An assignment to a pointer variable destroys the pointer copy presently in the variable, as does the destruction of the variable itself.</span></span> <span data-ttu-id="e9153-113">(Ou seja, o escopo no qual a variável é encontrada, como o quadro de pilha, é destruído.)</span><span class="sxs-lookup"><span data-stu-id="e9153-113">(That is, the scope in which the variable is found, such as the stack frame, is destroyed.)</span></span>

<span data-ttu-id="e9153-114">Da perspectiva de um cliente COM, a contagem de referência é sempre feita para cada interface.</span><span class="sxs-lookup"><span data-stu-id="e9153-114">From a COM client's perspective, reference counting is always done for each interface.</span></span> <span data-ttu-id="e9153-115">Os clientes nunca devem supor que um objeto usa o mesmo contador para todas as interfaces.</span><span class="sxs-lookup"><span data-stu-id="e9153-115">Clients should never assume that an object uses the same counter for all interfaces.</span></span>

<span data-ttu-id="e9153-116">O caso padrão é que [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) deve ser chamado para cada nova cópia de um ponteiro de interface e [**versão**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) deve ser chamada para cada destruição de um ponteiro de interface, exceto quando as seguintes regras permitirem o contrário:</span><span class="sxs-lookup"><span data-stu-id="e9153-116">The default case is that [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) must be called for every new copy of an interface pointer and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) must be called for every destruction of an interface pointer, except where the following rules permit otherwise:</span></span>

-   <span data-ttu-id="e9153-117">**Parâmetros de entrada para o functions.**</span><span class="sxs-lookup"><span data-stu-id="e9153-117">**In-out parameters to functions.**</span></span> <span data-ttu-id="e9153-118">O chamador deve chamar [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) no parâmetro porque ele será liberado (com uma chamada para [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) no código de implementação quando o valor out for armazenado sobre ele.</span><span class="sxs-lookup"><span data-stu-id="e9153-118">The caller must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the parameter because it will be released (with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) in the implementing code when the out value is stored on top of it.</span></span>
-   <span data-ttu-id="e9153-119">**Buscando uma variável global.**</span><span class="sxs-lookup"><span data-stu-id="e9153-119">**Fetching a global variable.**</span></span> <span data-ttu-id="e9153-120">Ao criar uma cópia local de um ponteiro de interface de uma cópia existente do ponteiro em uma variável global, você deve chamar [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) na cópia local porque outra função pode destruir a cópia na variável global enquanto a cópia local ainda é válida.</span><span class="sxs-lookup"><span data-stu-id="e9153-120">When creating a local copy of an interface pointer from an existing copy of the pointer in a global variable, you must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the local copy because another function might destroy the copy in the global variable while the local copy is still valid.</span></span>
-   <span data-ttu-id="e9153-121">**Novos ponteiros sintetizados fora de "ar fino".**</span><span class="sxs-lookup"><span data-stu-id="e9153-121">**New pointers synthesized out of "thin air."**</span></span> <span data-ttu-id="e9153-122">Uma função que sintetiza um ponteiro de interface usando conhecimento interno especial em vez de obtê-lo de alguma outra fonte deve chamar [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) inicialmente no ponteiro recentemente sintetizado.</span><span class="sxs-lookup"><span data-stu-id="e9153-122">A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initially on the newly synthesized pointer.</span></span> <span data-ttu-id="e9153-123">Exemplos importantes dessas rotinas incluem rotinas de criação de instância, implementações de [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="e9153-123">Important examples of such routines include instance creation routines, implementations of [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), and so on.</span></span>
-   <span data-ttu-id="e9153-124">**Recuperando uma cópia de um ponteiro armazenado internamente.**</span><span class="sxs-lookup"><span data-stu-id="e9153-124">**Retrieving a copy of an internally stored pointer.**</span></span> <span data-ttu-id="e9153-125">Quando uma função recupera uma cópia de um ponteiro armazenado internamente pelo objeto chamado, o código desse objeto deve chamar [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) no ponteiro antes que a função retorne.</span><span class="sxs-lookup"><span data-stu-id="e9153-125">When a function retrieves a copy of a pointer that is stored internally by the object called, that object's code must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the pointer before the function returns.</span></span> <span data-ttu-id="e9153-126">Depois que o ponteiro for recuperado, o objeto de origem não terá nenhuma outra maneira de determinar como seu tempo de vida se relaciona com o da cópia armazenada internamente do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="e9153-126">Once the pointer has been retrieved, the originating object has no other way of determining how its lifetime relates to that of the internally stored copy of the pointer.</span></span>

<span data-ttu-id="e9153-127">As únicas exceções ao caso padrão exigem que o código de gerenciamento Conheça as relações dos tempos de vida de duas ou mais cópias de um ponteiro para a mesma interface em um objeto e simplesmente certifique-se de que o objeto não seja destruído, permitindo que sua contagem de referência vá para zero.</span><span class="sxs-lookup"><span data-stu-id="e9153-127">The only exceptions to the default case require that the managing code know the relationships of the lifetimes of two or more copies of a pointer to the same interface on an object and simply ensure that the object is not destroyed by allowing its reference count to go to zero.</span></span> <span data-ttu-id="e9153-128">Em geral, há dois casos, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="e9153-128">There are generally two cases, as follows:</span></span>

-   <span data-ttu-id="e9153-129">Quando uma cópia de um ponteiro já existe e um segundo é criado posteriormente e, em seguida, é destruído enquanto a primeira cópia ainda existe, as chamadas para [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)para a segunda cópia podem ser omitidas.</span><span class="sxs-lookup"><span data-stu-id="e9153-129">When one copy of a pointer already exists and a second is created subsequently and then is destroyed while the first copy still exists, calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)for the second copy can be omitted.</span></span>
-   <span data-ttu-id="e9153-130">Quando existe uma cópia de um ponteiro e um segundo é criado e o primeiro é destruído antes do segundo, as chamadas para [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)para a segunda cópia e para [**liberação**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) da primeira cópia podem ser omitidas.</span><span class="sxs-lookup"><span data-stu-id="e9153-130">When one copy of a pointer exists and a second is created and then the first is destroyed before the second, the calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)for the second copy and to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) for the first copy can be omitted.</span></span>

<span data-ttu-id="e9153-131">Veja a seguir exemplos específicos dessas situações, as duas primeiras são especialmente comuns:</span><span class="sxs-lookup"><span data-stu-id="e9153-131">The following are specific examples of these situations, the first two being especially common:</span></span>

-   <span data-ttu-id="e9153-132">**Em parâmetros para funções.**</span><span class="sxs-lookup"><span data-stu-id="e9153-132">**In parameters to functions.**</span></span> <span data-ttu-id="e9153-133">O tempo de vida da cópia de um ponteiro de interface passado como um parâmetro para uma função é aninhado no ponteiro usado para inicializar o valor, portanto, não há necessidade de uma contagem de referência separada no parâmetro.</span><span class="sxs-lookup"><span data-stu-id="e9153-133">The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value, so there is no need for a separate reference count on the parameter.</span></span>
-   <span data-ttu-id="e9153-134">**Parâmetros de saída das funções, incluindo valores de retorno.**</span><span class="sxs-lookup"><span data-stu-id="e9153-134">**Out parameters from functions, including return values.**</span></span> <span data-ttu-id="e9153-135">Para definir o parâmetro out, a função deve ter uma cópia estável do ponteiro de interface.</span><span class="sxs-lookup"><span data-stu-id="e9153-135">To set the out parameter, the function must have a stable copy of the interface pointer.</span></span> <span data-ttu-id="e9153-136">No retorno, o chamador é responsável por liberar o ponteiro.</span><span class="sxs-lookup"><span data-stu-id="e9153-136">On return, the caller is responsible for releasing the pointer.</span></span> <span data-ttu-id="e9153-137">Portanto, o parâmetro out não precisa de uma contagem de referência separada.</span><span class="sxs-lookup"><span data-stu-id="e9153-137">Therefore, the out parameter does not need a separate reference count.</span></span>
-   <span data-ttu-id="e9153-138">**Variáveis locais.**</span><span class="sxs-lookup"><span data-stu-id="e9153-138">**Local variables.**</span></span> <span data-ttu-id="e9153-139">Uma implementação de método tem controle dos tempos de vida de cada uma das variáveis de ponteiro alocadas no quadro de pilha e pode usá-la para determinar como omitir pares de liberação [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)redundantes / [](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) .</span><span class="sxs-lookup"><span data-stu-id="e9153-139">A method implementation has control of the lifetimes of each of the pointer variables allocated on the stack frame and can use this to determine how to omit redundant [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)/[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pairs.</span></span>
-   <span data-ttu-id="e9153-140">**Pontos de extremidade.**</span><span class="sxs-lookup"><span data-stu-id="e9153-140">**Backpointers.**</span></span> <span data-ttu-id="e9153-141">Algumas estruturas de dados contêm dois objetos, cada um com um ponteiro para o outro.</span><span class="sxs-lookup"><span data-stu-id="e9153-141">Some data structures contain two objects, each with a pointer to the other.</span></span> <span data-ttu-id="e9153-142">Se o tempo de vida do primeiro objeto for conhecido por conter o tempo de vida do segundo, não será necessário ter uma contagem de referência no ponteiro do segundo objeto para o primeiro objeto.</span><span class="sxs-lookup"><span data-stu-id="e9153-142">If the lifetime of the first object is known to contain the lifetime of the second, it is not necessary to have a reference count on the second object's pointer to the first object.</span></span> <span data-ttu-id="e9153-143">Muitas vezes, evitar esse ciclo é importante para manter o comportamento de desalocação apropriado.</span><span class="sxs-lookup"><span data-stu-id="e9153-143">Often, avoiding this cycle is important in maintaining the appropriate deallocation behavior.</span></span> <span data-ttu-id="e9153-144">No entanto, os ponteiros sem desconto devem ser usados com extrema cautela, pois a parte do sistema operacional que lida com o processamento remoto não tem como saber mais sobre essa relação.</span><span class="sxs-lookup"><span data-stu-id="e9153-144">However, uncounted pointers should be used with extreme caution because the portion of the operating system that handles remote processing has no way of knowing about this relationship.</span></span> <span data-ttu-id="e9153-145">Portanto, em quase todos os casos, ter o ponto de extremidade vê um segundo, o objeto "Friend" do primeiro ponteiro (evitando, portanto, a circularidade) é a solução preferida.</span><span class="sxs-lookup"><span data-stu-id="e9153-145">Therefore, in almost all cases, having the backpointer see a second, "friend" object of the first pointer (thus avoiding the circularity) is the preferred solution.</span></span> <span data-ttu-id="e9153-146">A arquitetura de objetos conectáveis do COM, por exemplo, usa essa abordagem.</span><span class="sxs-lookup"><span data-stu-id="e9153-146">COM's connectable objects architecture, for example, uses this approach.</span></span>

<span data-ttu-id="e9153-147">Ao implementar ou usar objetos de referência contados, pode ser útil aplicar *contagens de referência artificial*, que garantem a estabilidade do objeto durante o processamento de uma função.</span><span class="sxs-lookup"><span data-stu-id="e9153-147">When implementing or using reference-counted objects, it may be useful to apply *artificial reference counts*, which guarantee object stability during processing of a function.</span></span> <span data-ttu-id="e9153-148">Ao implementar um método de uma interface, você pode chamar funções que têm a chance de decrementar sua contagem de referência para um objeto, causando uma liberação prematura do objeto e a falha da implementação.</span><span class="sxs-lookup"><span data-stu-id="e9153-148">In implementing a method of an interface, you might call functions that have a chance of decrementing your reference count to an object, causing a premature release of the object and failure of the implementation.</span></span> <span data-ttu-id="e9153-149">Uma maneira robusta de evitar isso é inserir uma chamada para [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) no início da implementação do método e emparelhar isso com uma chamada para [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) logo antes do retorno do método.</span><span class="sxs-lookup"><span data-stu-id="e9153-149">A robust way to avoid this is to insert a call to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) at the beginning of the method implementation and pair it with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) just before the method returns.</span></span>

<span data-ttu-id="e9153-150">Em algumas situações, os valores de retorno de [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) podem ser instáveis e não devem ser dependentes; Eles devem ser usados somente para fins de depuração ou diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="e9153-150">In some situations, the return values of [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) may be unstable and should not be relied upon; they should be used only for debugging or diagnostic purposes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e9153-151">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="e9153-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e9153-152">Gerenciando tempos de vida de objeto por meio de contagem de referência</span><span class="sxs-lookup"><span data-stu-id="e9153-152">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 