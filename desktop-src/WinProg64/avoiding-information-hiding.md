---
title: Evitando a ocultação de informações
description: Ocasionalmente, os programas deliberadamente ou inadvertidamente ocultam informações do mecanismo de marshaling RPC.
ms.assetid: 016b9221-092d-4c25-a396-4f41dcdfb3cf
keywords:
- compatibilidade com versões anteriores programação de 64 bits do Windows
- problemas de compatibilidade de programação de 64 bits do Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2f4b9e4ba7ed5165378beb93005243af03f9e469
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104366276"
---
# <a name="avoiding-information-hiding"></a><span data-ttu-id="620c0-105">Evitando a ocultação de informações</span><span class="sxs-lookup"><span data-stu-id="620c0-105">Avoiding Information Hiding</span></span>

<span data-ttu-id="620c0-106">Ocasionalmente, os programas deliberadamente ou inadvertidamente ocultam informações do mecanismo de marshaling RPC.</span><span class="sxs-lookup"><span data-stu-id="620c0-106">Occasionally, programs deliberately or inadvertently hide information from the RPC marshaling engine.</span></span> <span data-ttu-id="620c0-107">Alguns exemplos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="620c0-107">Some examples are as follows:</span></span>

-   <span data-ttu-id="620c0-108">Enviando uma estrutura de dados como um bloco de bytes não diferenciado</span><span class="sxs-lookup"><span data-stu-id="620c0-108">Sending a data structure as an undifferentiated block of bytes</span></span>
-   <span data-ttu-id="620c0-109">Aproveitando o desempenho usando um efeito colateral de um método para canalizar dados adicionais pela conexão</span><span class="sxs-lookup"><span data-stu-id="620c0-109">Leveraging performance by using a side effect from a method to channel additional data across the wire</span></span>
-   <span data-ttu-id="620c0-110">Tentando disfarçar um identificador passando-o como um **DWORD** ou um **ULONG**</span><span class="sxs-lookup"><span data-stu-id="620c0-110">Attempting to disguise a handle by passing it as a **DWORD** or a **ULONG**</span></span>

<span data-ttu-id="620c0-111">Essas técnicas são quase Garantidas de introduzir problemas de compatibilidade mesmo antes de você portar seu aplicativo para o Windows de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="620c0-111">These techniques are almost guaranteed to introduce compatibility problems even before you port your application to 64-bit Windows.</span></span>

<span data-ttu-id="620c0-112">Em vez de enviar um contexto de servidor como um **DWORD** em uma chamada de procedimento remoto padrão, use um identificador de contexto para fornecer um identificador opaco para um contexto de servidor que é mantido em nome de um cliente.</span><span class="sxs-lookup"><span data-stu-id="620c0-112">Instead of sending a server context as a **DWORD** in a standard remote procedure call, use a context handle to provide an opaque handle to a server context that is held on behalf of a client.</span></span> <span data-ttu-id="620c0-113">Os contextos são identificados por GUIDs definidos pelo tempo de execução de RPC quando um servidor cria um identificador de contexto para um cliente.</span><span class="sxs-lookup"><span data-stu-id="620c0-113">Contexts are identified by GUIDs defined by the RPC run time when a server creates a context handle for a client.</span></span> <span data-ttu-id="620c0-114">Nenhum ponteiro é usado pela transmissão e a operação é completamente transparente entre os limites de 32 ou 64 bits.</span><span class="sxs-lookup"><span data-stu-id="620c0-114">No pointer is used over the wire and the operation is completely transparent across 32- or 64-bit boundaries.</span></span> <span data-ttu-id="620c0-115">Para obter mais informações sobre como usar identificadores de contexto, consulte [identificadores de contexto](/windows/desktop/Rpc/context-handles).</span><span class="sxs-lookup"><span data-stu-id="620c0-115">For more information on using context handles, see [Context Handles](/windows/desktop/Rpc/context-handles).</span></span>

<span data-ttu-id="620c0-116">As interfaces DCOM não podem usar identificadores de contexto porque o COM fornece seu próprio gerenciamento de contexto.</span><span class="sxs-lookup"><span data-stu-id="620c0-116">DCOM interfaces cannot use context handles because COM provides its own context management.</span></span> <span data-ttu-id="620c0-117">Em vez de criar um identificador de contexto, você pode passar um ponteiro de interface para o objeto COM.</span><span class="sxs-lookup"><span data-stu-id="620c0-117">Instead of creating a context handle, you can pass an interface pointer to the COM object.</span></span> <span data-ttu-id="620c0-118">Em seguida, você pode chamar os métodos diretamente por meio do ponteiro de interface ou posicionar o ponteiro dentro de outras chamadas.</span><span class="sxs-lookup"><span data-stu-id="620c0-118">Then you can call the methods directly through the interface pointer or place the pointer inside other calls.</span></span> <span data-ttu-id="620c0-119">Para liberar o objeto Server, o cliente chama o método **Release** da interface por meio do ponteiro de interface.</span><span class="sxs-lookup"><span data-stu-id="620c0-119">To release the server object, the client calls the interface's **Release** method through the interface pointer.</span></span>

<span data-ttu-id="620c0-120">Novamente, pode haver ocasiões em que você não pode alterar o design original do código que está sendo portado.</span><span class="sxs-lookup"><span data-stu-id="620c0-120">Again, there may be times when you cannot change the original design of the code that you are porting.</span></span> <span data-ttu-id="620c0-121">Se não houver nenhuma maneira de evitar o envio de um ponteiro pela conexão como um **DWORD**, você precisará implementar alguma forma de mapeamento do lado do servidor entre os valores **DWORD** e os ponteiros.</span><span class="sxs-lookup"><span data-stu-id="620c0-121">If there is no way to avoid sending a pointer across the wire as a **DWORD**, you will have to implement some form of server-side mapping between **DWORD** values and pointers.</span></span> <span data-ttu-id="620c0-122">Uma maneira de fazer isso é alterar os ponteiros no aplicativo do lado do cliente para tipos de precisão de ponteiro, como **ULONG \_ PTR** ou **DWORD \_ PTR**.</span><span class="sxs-lookup"><span data-stu-id="620c0-122">One way to do this is to change the pointers in the client side application to pointer-precision types, such as **ULONG\_PTR** or **DWORD\_PTR**.</span></span> <span data-ttu-id="620c0-123">Em seguida, use a \[ [**chamada MIDL \_ como**](/windows/desktop/Midl/call-as) \] atributo para colocar os ponteiros na transmissão como valores **DWORD** .</span><span class="sxs-lookup"><span data-stu-id="620c0-123">Then use the MIDL \[[**call\_as**](/windows/desktop/Midl/call-as)\] attribute to put the pointers on the wire as **DWORD** values.</span></span> <span data-ttu-id="620c0-124">O wrapper do lado do cliente precisa passar apenas os argumentos.</span><span class="sxs-lookup"><span data-stu-id="620c0-124">The client-side wrapper need only pass the arguments along.</span></span> <span data-ttu-id="620c0-125">O wrapper do lado do servidor manipula o mapeamento entre os dois tipos.</span><span class="sxs-lookup"><span data-stu-id="620c0-125">The server-side wrapper handles the mapping between both types.</span></span> <span data-ttu-id="620c0-126">De forma semelhante, você pode usar o \[ atributo [**transmitir \_ como**](/windows/desktop/Midl/transmit-as) \] ou o \[ atributo [**representar \_ como**](/windows/desktop/Midl/represent-as) \] para converter seus dados em um formato compatível com versões anteriores para a representação de transmissão.</span><span class="sxs-lookup"><span data-stu-id="620c0-126">In a similar way, you can use either the \[[**transmit\_as**](/windows/desktop/Midl/transmit-as)\] attribute or the \[[**represent\_as**](/windows/desktop/Midl/represent-as)\] attribute to convert your data to a backward-compatible format for wire representation.</span></span>

<span data-ttu-id="620c0-127">Se a compatibilidade de conexão reversa não for um problema ou se o identificador não for usado para chamadas remotas e você tiver certeza de que as chamadas remotas entre os processos de 32 e 64 bits nunca acontecerão, você poderá redefinir um argumento como um **ULONG64**.</span><span class="sxs-lookup"><span data-stu-id="620c0-127">If backward-wire compatibility is not an issue or if the handle is not used for remote calls and you are sure that remote calls between 32- and 64-bit processes will never happen, you can redefine an argument as a **ULONG64**.</span></span> <span data-ttu-id="620c0-128">Se necessário, você pode modificar o aplicativo de 32 bits para passar um **DWORD** para o usuário.</span><span class="sxs-lookup"><span data-stu-id="620c0-128">If necessary, you can modify the 32-bit application to pass a **DWORD** to the user.</span></span> <span data-ttu-id="620c0-129">Como alternativa, você pode criar stubs separados de arquivos IDL separados para cada plataforma usando um **DWORD** em janelas de 32 bits e um **ULONG64** no Windows de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="620c0-129">Alternatively, you can build separate stubs from separate IDL files for each platform using a **DWORD** on 32-bit Windows and a **ULONG64** on 64-bit Windows.</span></span>

 

 