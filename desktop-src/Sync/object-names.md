---
description: Os objetos nomeados fornecem uma maneira fácil para os processos compartilharem identificadores de objeto.
ms.assetid: 00a00227-45fc-49a1-8ff5-aeccb172d16a
title: Nomes de objeto
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ee746150a41f335a4073cb4b5ba282d17ad706f9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "105749192"
---
# <a name="object-names"></a><span data-ttu-id="734c3-103">Nomes de objeto</span><span class="sxs-lookup"><span data-stu-id="734c3-103">Object Names</span></span>

<span data-ttu-id="734c3-104">Os objetos nomeados fornecem uma maneira fácil para os processos compartilharem identificadores de objeto.</span><span class="sxs-lookup"><span data-stu-id="734c3-104">Named objects provide an easy way for processes to share object handles.</span></span> <span data-ttu-id="734c3-105">Depois que um processo tiver criado um evento nomeado, mutex, semáforo ou objeto de timer, outros processos poderão usar o nome para chamar a função apropriada ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew)ou [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) para abrir um identificador para o objeto.</span><span class="sxs-lookup"><span data-stu-id="734c3-105">After a process has created a named event, mutex, semaphore, or timer object, other processes can use the name to call the appropriate function ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew), or [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) to open a handle to the object.</span></span> <span data-ttu-id="734c3-106">A comparação de nomes diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="734c3-106">Name comparison is case sensitive.</span></span>

<span data-ttu-id="734c3-107">Os nomes de evento, semáforo, mutex, timer de espera, mapeamento de arquivo e objetos de trabalho compartilham o mesmo namespace.</span><span class="sxs-lookup"><span data-stu-id="734c3-107">The names of event, semaphore, mutex, waitable timer, file-mapping, and job objects share the same namespace.</span></span> <span data-ttu-id="734c3-108">Se você tentar criar um objeto usando um nome que está sendo usado por um objeto de outro tipo, a função falhará e [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) retornará **um \_ \_ identificador inválido de erro**.</span><span class="sxs-lookup"><span data-stu-id="734c3-108">If you try to create an object using a name that is in use by an object of another type, the function fails and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_INVALID\_HANDLE**.</span></span> <span data-ttu-id="734c3-109">Portanto, ao criar objetos nomeados, use nomes exclusivos e certifique-se de verificar valores de retorno de função para erros de nome duplicado.</span><span class="sxs-lookup"><span data-stu-id="734c3-109">Therefore, when creating named objects, use unique names and be sure to check function return values for duplicate-name errors.</span></span>

<span data-ttu-id="734c3-110">Se você tentar criar um objeto usando um nome que está sendo usado por um objeto do mesmo tipo, a função terá sucesso, retornando um identificador para o objeto existente e o erro de retorno de [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) **\_ já \_ existirá**.</span><span class="sxs-lookup"><span data-stu-id="734c3-110">If you try to create an object using a name that is in use by an object of same type, the function succeeds, returning a handle to the existing object, and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_ALREADY\_EXISTS**.</span></span> <span data-ttu-id="734c3-111">Por exemplo, se o nome especificado em uma chamada para a função [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) corresponder ao nome de um objeto mutex existente, a função retornará um identificador para o objeto existente.</span><span class="sxs-lookup"><span data-stu-id="734c3-111">For example, if the name specified in a call to the [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) function matches the name of an existing mutex object, the function returns a handle to the existing object.</span></span> <span data-ttu-id="734c3-112">Nesse caso, a chamada para **CreateMutex** é equivalente a uma chamada para a função [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) .</span><span class="sxs-lookup"><span data-stu-id="734c3-112">In this case, the call to **CreateMutex** is equivalent to a call to the [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) function.</span></span> <span data-ttu-id="734c3-113">Ter vários processos usam **CreateMutex** para o mesmo mutex é, portanto, equivalente a ter um processo que chama **CreateMutex** enquanto os outros processos chamam **OpenMutex**, exceto pelo fato de que ele elimina a necessidade de garantir que o processo de criação seja iniciado primeiro.</span><span class="sxs-lookup"><span data-stu-id="734c3-113">Having multiple processes use **CreateMutex** for the same mutex is therefore equivalent to having one process that calls **CreateMutex** while the other processes call **OpenMutex**, except that it eliminates the need to ensure that the creating process is started first.</span></span> <span data-ttu-id="734c3-114">No entanto, ao usar essa técnica para objetos mutex, nenhum dos processos de chamada deve solicitar a propriedade imediata do mutex.</span><span class="sxs-lookup"><span data-stu-id="734c3-114">When using this technique for mutex objects, however, none of the calling processes should request immediate ownership of the mutex.</span></span> <span data-ttu-id="734c3-115">Se vários processos solicitarem a propriedade imediata, poderá ser difícil prever qual processo realmente Obtém a propriedade inicial.</span><span class="sxs-lookup"><span data-stu-id="734c3-115">If multiple processes do request immediate ownership, it can be difficult to predict which process actually gets the initial ownership.</span></span>

<span data-ttu-id="734c3-116">Um ambiente de serviços de terminal tem um namespace global para eventos, semáforos, exclusões mútuas, temporizadores esperados, objetos de mapeamento de arquivos e objetos de trabalho.</span><span class="sxs-lookup"><span data-stu-id="734c3-116">A Terminal Services environment has a global namespace for events, semaphores, mutexes, waitable timers, file-mapping objects, and job objects.</span></span> <span data-ttu-id="734c3-117">Além disso, cada sessão de cliente dos serviços de terminal tem seu próprio namespace separado para esses objetos.</span><span class="sxs-lookup"><span data-stu-id="734c3-117">In addition, each Terminal Services client session has its own separate namespace for these objects.</span></span> <span data-ttu-id="734c3-118">Os processos de cliente dos serviços de terminal podem usar nomes de objeto com um prefixo "global \\ " ou "local \\ " para criar explicitamente um objeto no namespace global ou de sessão.</span><span class="sxs-lookup"><span data-stu-id="734c3-118">Terminal Services client processes can use object names with a "Global\\" or "Local\\" prefix to explicitly create an object in the global or session namespace.</span></span> <span data-ttu-id="734c3-119">Para obter mais informações, consulte [namespaces de objeto kernel](../termserv/kernel-object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="734c3-119">For more information, see [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span></span> <span data-ttu-id="734c3-120">A troca rápida de usuário é implementada usando sessões de serviços de terminal (cada usuário faz logon em uma sessão diferente).</span><span class="sxs-lookup"><span data-stu-id="734c3-120">Fast user switching is implemented using Terminal Services sessions (each user logs into a different session).</span></span> <span data-ttu-id="734c3-121">Os nomes de objeto de kernel devem seguir as diretrizes descritas para os serviços de terminal para que os aplicativos possam dar suporte a vários usuários.</span><span class="sxs-lookup"><span data-stu-id="734c3-121">Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</span></span>

<span data-ttu-id="734c3-122">Os objetos de sincronização podem ser criados em um namespace privado.</span><span class="sxs-lookup"><span data-stu-id="734c3-122">Synchronization objects can be created in a private namespace.</span></span> <span data-ttu-id="734c3-123">Para obter mais informações, consulte [namespaces de objeto](object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="734c3-123">For more information, see [Object Namespaces](object-namespaces.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="734c3-124">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="734c3-124">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="734c3-125">Usando objetos nomeados</span><span class="sxs-lookup"><span data-stu-id="734c3-125">Using Named Objects</span></span>](using-named-objects.md)
</dt> </dl>

 

 
