---
description: Uma APC (chamada de procedimento assíncrono) é uma função que é executada de forma assíncrona no contexto de um thread específico.
ms.assetid: 0197d78e-a4dc-414b-88ba-c5ec5f2ed614
title: Chamadas de procedimento assíncrono
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dd95e9afd663e2a462335b3c47bfe99462b449e7
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "103922228"
---
# <a name="asynchronous-procedure-calls"></a><span data-ttu-id="904eb-103">Chamadas de procedimento assíncrono</span><span class="sxs-lookup"><span data-stu-id="904eb-103">Asynchronous Procedure Calls</span></span>

<span data-ttu-id="904eb-104">Uma APC ( *chamada de procedimento assíncrono* ) é uma função que é executada de forma assíncrona no contexto de um thread específico.</span><span class="sxs-lookup"><span data-stu-id="904eb-104">An *asynchronous procedure call* (APC) is a function that executes asynchronously in the context of a particular thread.</span></span> <span data-ttu-id="904eb-105">Quando uma APC é enfileirada em um thread, o sistema emite uma interrupção de software.</span><span class="sxs-lookup"><span data-stu-id="904eb-105">When an APC is queued to a thread, the system issues a software interrupt.</span></span> <span data-ttu-id="904eb-106">Na próxima vez em que o thread for agendado, ele executará a função APC.</span><span class="sxs-lookup"><span data-stu-id="904eb-106">The next time the thread is scheduled, it will run the APC function.</span></span> <span data-ttu-id="904eb-107">Uma APC gerada pelo sistema é chamada de *APC de modo kernel*.</span><span class="sxs-lookup"><span data-stu-id="904eb-107">An APC generated by the system is called a *kernel-mode APC*.</span></span> <span data-ttu-id="904eb-108">Uma APC gerada por um aplicativo é chamada de *APC (modo de usuário*).</span><span class="sxs-lookup"><span data-stu-id="904eb-108">An APC generated by an application is called a *user-mode APC*.</span></span> <span data-ttu-id="904eb-109">Um thread deve estar em um estado de alerta para executar uma APC de modo de usuário.</span><span class="sxs-lookup"><span data-stu-id="904eb-109">A thread must be in an alertable state to run a user-mode APC.</span></span>

<span data-ttu-id="904eb-110">Cada thread tem sua própria fila da APC.</span><span class="sxs-lookup"><span data-stu-id="904eb-110">Each thread has its own APC queue.</span></span> <span data-ttu-id="904eb-111">Um aplicativo enfileira uma APC em um thread chamando a função [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) .</span><span class="sxs-lookup"><span data-stu-id="904eb-111">An application queues an APC to a thread by calling the [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) function.</span></span> <span data-ttu-id="904eb-112">O thread de chamada especifica o endereço de uma função da APC na chamada para **QueueUserAPC**.</span><span class="sxs-lookup"><span data-stu-id="904eb-112">The calling thread specifies the address of an APC function in the call to **QueueUserAPC**.</span></span> <span data-ttu-id="904eb-113">O enfileiramento de uma APC é uma solicitação para que o thread chame a função APC.</span><span class="sxs-lookup"><span data-stu-id="904eb-113">The queuing of an APC is a request for the thread to call the APC function.</span></span>

<span data-ttu-id="904eb-114">Quando um APC de modo de usuário é enfileirado, o thread no qual ele é enfileirado não é direcionado para chamar a função APC, a menos que esteja em um estado de alerta.</span><span class="sxs-lookup"><span data-stu-id="904eb-114">When a user-mode APC is queued, the thread to which it is queued is not directed to call the APC function unless it is in an alertable state.</span></span> <span data-ttu-id="904eb-115">Um thread entra em um estado alertado quando chama a função [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex)ou [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) .</span><span class="sxs-lookup"><span data-stu-id="904eb-115">A thread enters an alertable state when it calls the [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex), or [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) function.</span></span> <span data-ttu-id="904eb-116">Se a espera for satisfeita antes que a APC seja enfileirada, o thread não estará mais em um estado de espera alertado, de modo que a função APC não será executada.</span><span class="sxs-lookup"><span data-stu-id="904eb-116">If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed.</span></span> <span data-ttu-id="904eb-117">No entanto, a APC ainda está na fila, portanto, a função APC será executada quando o thread chamar outra função de espera alertável.</span><span class="sxs-lookup"><span data-stu-id="904eb-117">However, the APC is still queued, so the APC function will be executed when the thread calls another alertable wait function.</span></span>

<span data-ttu-id="904eb-118">As funções [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex)e [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) são implementadas usando uma APC como o mecanismo de retorno de chamada de notificação de conclusão.</span><span class="sxs-lookup"><span data-stu-id="904eb-118">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions are implemented using an APC as the completion notification callback mechanism.</span></span>

<span data-ttu-id="904eb-119">Se você estiver usando um [pool de threads](../procthread/thread-pools.md), observe que o APCs não funciona bem como outros mecanismos de sinalização porque o sistema controla o tempo de vida dos threads do pool de threads, de modo que é possível que um thread seja encerrado antes que a notificação seja entregue.</span><span class="sxs-lookup"><span data-stu-id="904eb-119">If you are using a [thread pool](../procthread/thread-pools.md), note that APCs do not work as well as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span> <span data-ttu-id="904eb-120">Em vez de usar um mecanismo de sinalização baseado em APC, como o parâmetro *pfnCompletionRoutine* de [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) ou [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use um objeto de espera, como um temporizador criado com [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span><span class="sxs-lookup"><span data-stu-id="904eb-120">Instead of using an APC-based signaling mechanism such as the *pfnCompletionRoutine* parameter of [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) or [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use a waitable object such as a timer created with [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span></span> <span data-ttu-id="904eb-121">Para e/s, use um objeto de conclusão de e/s criado com [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) ou uma estrutura [**sobreposta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) baseada em *hEvent*, em que o evento pode ser passado para a função [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) .</span><span class="sxs-lookup"><span data-stu-id="904eb-121">For I/O, use an I/O completion object created with [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) or an *hEvent*-based [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure where the event can be passed to the [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) function.</span></span>

## <a name="synchronization-internals"></a><span data-ttu-id="904eb-122">Internos de sincronização</span><span class="sxs-lookup"><span data-stu-id="904eb-122">Synchronization Internals</span></span>

<span data-ttu-id="904eb-123">Quando uma solicitação de e/s é emitida, uma estrutura é alocada para representar a solicitação.</span><span class="sxs-lookup"><span data-stu-id="904eb-123">When an I/O request is issued, a structure is allocated to represent the request.</span></span> <span data-ttu-id="904eb-124">Essa estrutura é chamada de pacote de solicitação de e/s (IRP).</span><span class="sxs-lookup"><span data-stu-id="904eb-124">This structure is called an I/O request packet (IRP).</span></span> <span data-ttu-id="904eb-125">Com e/s síncrona, o thread cria o IRP, envia-o para a pilha do dispositivo e aguarda o kernel para que o IRP seja concluído.</span><span class="sxs-lookup"><span data-stu-id="904eb-125">With synchronous I/O, the thread builds the IRP, sends it to the device stack, and waits in the kernel for the IRP to complete.</span></span> <span data-ttu-id="904eb-126">Com e/s assíncrona, o thread cria o IRP e o envia para a pilha do dispositivo.</span><span class="sxs-lookup"><span data-stu-id="904eb-126">With asynchronous I/O, the thread builds the IRP and sends it to the device stack.</span></span> <span data-ttu-id="904eb-127">A pilha pode concluir o IRP imediatamente ou pode retornar um status pendente indicando que a solicitação está em andamento.</span><span class="sxs-lookup"><span data-stu-id="904eb-127">The stack might complete the IRP immediately, or it might return a pending status indicating that the request is in progress.</span></span> <span data-ttu-id="904eb-128">Quando isso acontece, o IRP ainda está associado ao thread, portanto, ele será cancelado se o thread terminar ou chamar uma função como [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span><span class="sxs-lookup"><span data-stu-id="904eb-128">When this happens, the IRP is still associated with the thread, so it will be canceled if the thread terminates or calls a function such as [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span></span> <span data-ttu-id="904eb-129">Enquanto isso, o thread pode continuar executando outras tarefas enquanto a pilha de dispositivos continua a processar o IRP.</span><span class="sxs-lookup"><span data-stu-id="904eb-129">In the meantime, the thread can continue to perform other tasks while the device stack continues to process the IRP.</span></span>

<span data-ttu-id="904eb-130">Há várias maneiras pelas quais o sistema pode indicar que o IRP foi concluído:</span><span class="sxs-lookup"><span data-stu-id="904eb-130">There are several ways that the system can indicate that the IRP has completed:</span></span>

-   <span data-ttu-id="904eb-131">Atualize a estrutura sobreposta com o resultado da operação para que o thread possa sondar para determinar se a operação foi concluída.</span><span class="sxs-lookup"><span data-stu-id="904eb-131">Update the overlapped structure with the result of the operation so the thread can poll to determine whether the operation has completed.</span></span>
-   <span data-ttu-id="904eb-132">Sinalizar o evento na estrutura sobreposta para que um thread possa ser sincronizado no evento e seja ativadosdo quando a operação for concluída.</span><span class="sxs-lookup"><span data-stu-id="904eb-132">Signal the event in the overlapped structure so a thread can synchronize on the event and be woken when the operation completes.</span></span>
-   <span data-ttu-id="904eb-133">Enfileirar o IRP para a APC pendente do thread para que o thread execute a rotina da APC quando entrar em um estado de espera alertado e retorne da operação de espera com um status indicando que ele executou uma ou mais rotinas da APC.</span><span class="sxs-lookup"><span data-stu-id="904eb-133">Queue the IRP to the thread's pending APC so that the thread will execute the APC routine when it enters an alertable wait state and return from the wait operation with a status indicating that it executed one or more APC routines.</span></span>
-   <span data-ttu-id="904eb-134">Enfileirar o IRP para uma porta de conclusão de e/s, onde ele será executado pelo próximo thread que aguarda na porta de conclusão.</span><span class="sxs-lookup"><span data-stu-id="904eb-134">Queue the IRP to an I/O completion port, where it will be executed by the next thread that waits on the completion port.</span></span>

<span data-ttu-id="904eb-135">Os threads que esperam em uma porta de conclusão de e/s não esperam em um estado de alerta.</span><span class="sxs-lookup"><span data-stu-id="904eb-135">Threads that wait on an I/O completion port do not wait in an alertable state.</span></span> <span data-ttu-id="904eb-136">Portanto, se esses threads emitirem IRPs que estão definidos para serem concluídos como APCs para o thread, as conclusões do IPC não ocorrerão em tempo hábil; Eles ocorrerão somente se o thread escolher uma solicitação da porta de conclusão de e/s e, em seguida, ocorrer uma espera alerta.</span><span class="sxs-lookup"><span data-stu-id="904eb-136">Therefore, if those threads issue IRPs that are set to complete as APCs to the thread, those IPC completions will not occur in a timely manner; they will occur only if the thread picks up a request from the I/O completion port and then happens to enter an alertable wait.</span></span>

## <a name="related-topics"></a><span data-ttu-id="904eb-137">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="904eb-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="904eb-138">Usando um temporizador de espera com uma chamada de procedimento assíncrono</span><span class="sxs-lookup"><span data-stu-id="904eb-138">Using a Waitable Timer with an Asynchronous Procedure Call</span></span>](using-a-waitable-timer-with-an-asynchronous-procedure-call.md)
</dt> </dl>

 

 
