---
description: Um objeto de timer de espera é um objeto de sincronização cujo estado é definido como sinalizado quando o tempo de espera especificado chega.
ms.assetid: 5d39ada0-ea31-40d7-b075-aeb657ee508c
title: Objetos de timer que esperam
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2b9597617705fcd78bb71f63e33a475e3bca78e3
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "105756354"
---
# <a name="waitable-timer-objects"></a><span data-ttu-id="64878-103">Objetos de timer que esperam</span><span class="sxs-lookup"><span data-stu-id="64878-103">Waitable Timer Objects</span></span>

<span data-ttu-id="64878-104">Um *objeto de timer de espera* é um objeto de sincronização cujo estado é definido como sinalizado quando o tempo de espera especificado chega.</span><span class="sxs-lookup"><span data-stu-id="64878-104">A *waitable timer object* is a synchronization object whose state is set to signaled when the specified due time arrives.</span></span> <span data-ttu-id="64878-105">Há dois tipos de temporizadores esperados que podem ser criados: redefinição manual e sincronização.</span><span class="sxs-lookup"><span data-stu-id="64878-105">There are two types of waitable timers that can be created: manual-reset and synchronization.</span></span> <span data-ttu-id="64878-106">Um temporizador de qualquer tipo também pode ser um temporizador periódico.</span><span class="sxs-lookup"><span data-stu-id="64878-106">A timer of either type can also be a periodic timer.</span></span>



| <span data-ttu-id="64878-107">Objeto</span><span class="sxs-lookup"><span data-stu-id="64878-107">Object</span></span>                | <span data-ttu-id="64878-108">Descrição</span><span class="sxs-lookup"><span data-stu-id="64878-108">Description</span></span>                                                                                                                                                                                             |
|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="64878-109">temporizador de redefinição manual</span><span class="sxs-lookup"><span data-stu-id="64878-109">manual-reset timer</span></span>    | <span data-ttu-id="64878-110">Um temporizador cujo estado permanece sinalizado até que [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) seja chamado para estabelecer um novo tempo de conclusão.</span><span class="sxs-lookup"><span data-stu-id="64878-110">A timer whose state remains signaled until [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) is called to establish a new due time.</span></span>                                                                          |
| <span data-ttu-id="64878-111">temporizador de sincronização</span><span class="sxs-lookup"><span data-stu-id="64878-111">synchronization timer</span></span> | <span data-ttu-id="64878-112">Um temporizador cujo estado permanece sinalizado até que um thread conclua uma operação de espera no objeto de timer.</span><span class="sxs-lookup"><span data-stu-id="64878-112">A timer whose state remains signaled until a thread completes a wait operation on the timer object.</span></span>                                                                                                     |
| <span data-ttu-id="64878-113">temporizador periódico</span><span class="sxs-lookup"><span data-stu-id="64878-113">periodic timer</span></span>        | <span data-ttu-id="64878-114">Um temporizador que é reativado cada vez que o período especificado expira, até que o temporizador seja redefinido ou cancelado.</span><span class="sxs-lookup"><span data-stu-id="64878-114">A timer that is reactivated each time the specified period expires, until the timer is reset or canceled.</span></span> <span data-ttu-id="64878-115">Um temporizador periódico é um temporizador periódico de redefinição manual ou um temporizador de sincronização periódico.</span><span class="sxs-lookup"><span data-stu-id="64878-115">A periodic timer is either a periodic manual-reset timer or a periodic synchronization timer.</span></span> |



 

> [!Note]  
> <span data-ttu-id="64878-116">Quando um temporizador é sinalizado, o processador deve executar para processar as instruções associadas.</span><span class="sxs-lookup"><span data-stu-id="64878-116">When a timer is signaled, the processor must run to process the associated instructions.</span></span> <span data-ttu-id="64878-117">Temporizadores periódicos de alta frequência mantêm o processador continuamente ocupado, o que impede que o sistema permaneça em um [estado de energia](../power/system-power-states.md) menor para qualquer quantidade significativa de tempo.</span><span class="sxs-lookup"><span data-stu-id="64878-117">High-frequency periodic timers keep the processor continually busy, which prevents the system from remaining in a lower [power state](../power/system-power-states.md) for any meaningful amount of time.</span></span> <span data-ttu-id="64878-118">Isso pode causar um impacto negativo na vida útil da bateria do computador portátil e nos cenários que dependem do gerenciamento de energia efetivo, como data centers grandes.</span><span class="sxs-lookup"><span data-stu-id="64878-118">This can have a negative impact on portable computer battery life and scenarios that depend on effective power management, such as large datacenters.</span></span> <span data-ttu-id="64878-119">Para obter maior eficiência de energia, considere o uso de notificações baseadas em eventos em vez de notificações baseadas em tempo em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="64878-119">For greater energy efficiency, consider using event-based notifications instead of time-based notifications in your application.</span></span> <span data-ttu-id="64878-120">Se um temporizador for necessário, use um temporizador que seja sinalizado uma vez em vez de um temporizador periódico ou defina o intervalo como um valor maior que um segundo.</span><span class="sxs-lookup"><span data-stu-id="64878-120">If a timer is necessary, use a timer that is signaled once rather than a periodic timer, or set the interval to a value greater than one second.</span></span>

 

<span data-ttu-id="64878-121">Um thread usa a função [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) ou [**CreateWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) para criar um objeto de temporizador.</span><span class="sxs-lookup"><span data-stu-id="64878-121">A thread uses the [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) or [**CreateWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) function to create a timer object.</span></span> <span data-ttu-id="64878-122">O thread de criação especifica se o temporizador é um temporizador de redefinição manual ou um temporizador de sincronização.</span><span class="sxs-lookup"><span data-stu-id="64878-122">The creating thread specifies whether the timer is a manual-reset timer or a synchronization timer.</span></span> <span data-ttu-id="64878-123">O thread de criação pode especificar um nome para o objeto de timer.</span><span class="sxs-lookup"><span data-stu-id="64878-123">The creating thread can specify a name for the timer object.</span></span> <span data-ttu-id="64878-124">Os threads em outros processos podem abrir um identificador para um temporizador existente especificando seu nome em uma chamada para a função [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) .</span><span class="sxs-lookup"><span data-stu-id="64878-124">Threads in other processes can open a handle to an existing timer by specifying its name in a call to the [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) function.</span></span> <span data-ttu-id="64878-125">Qualquer thread com um identificador para um objeto de timer pode usar uma das [funções Wait](wait-functions.md) para aguardar que o estado do timer seja definido como signaled.</span><span class="sxs-lookup"><span data-stu-id="64878-125">Any thread with a handle to a timer object can use one of the [wait functions](wait-functions.md) to wait for the timer state to be set to signaled.</span></span>

-   <span data-ttu-id="64878-126">O thread chama a função [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) para ativar o temporizador.</span><span class="sxs-lookup"><span data-stu-id="64878-126">The thread calls the [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) function to activate the timer.</span></span> <span data-ttu-id="64878-127">Observe o uso dos seguintes parâmetros para **SetWaitableTimer**:</span><span class="sxs-lookup"><span data-stu-id="64878-127">Note the use of the following parameters for **SetWaitableTimer**:</span></span>
-   <span data-ttu-id="64878-128">Use o parâmetro *lpDueTime* para especificar a hora em que o temporizador deve ser definido para o estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="64878-128">Use the *lpDueTime* parameter to specify the time at which the timer is to be set to the signaled state.</span></span> <span data-ttu-id="64878-129">Quando um temporizador de redefinição manual é definido como o estado sinalizado, ele permanece nesse estado até que [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) estabeleça um novo tempo de conclusão.</span><span class="sxs-lookup"><span data-stu-id="64878-129">When a manual-reset timer is set to the signaled state, it remains in this state until [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) establishes a new due time.</span></span> <span data-ttu-id="64878-130">Quando um temporizador de sincronização é definido como o estado sinalizado, ele permanece nesse estado até que um thread conclua uma operação de espera no objeto de timer.</span><span class="sxs-lookup"><span data-stu-id="64878-130">When a synchronization timer is set to the signaled state, it remains in this state until a thread completes a wait operation on the timer object.</span></span>
-   <span data-ttu-id="64878-131">Use o parâmetro *lPeriod* da função [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) para especificar o período do temporizador.</span><span class="sxs-lookup"><span data-stu-id="64878-131">Use the *lPeriod* parameter of the [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) function to specify the timer period.</span></span> <span data-ttu-id="64878-132">Se o período não for zero, o temporizador será um temporizador periódico; Ele é reativado toda vez que o período expira, até que o temporizador seja redefinido ou cancelado.</span><span class="sxs-lookup"><span data-stu-id="64878-132">If the period is not zero, the timer is a periodic timer; it is reactivated each time the period expires, until the timer is reset or canceled.</span></span> <span data-ttu-id="64878-133">Se o período for zero, o temporizador não será um temporizador periódico; Ela é sinalizada uma vez e, em seguida, desativada.</span><span class="sxs-lookup"><span data-stu-id="64878-133">If the period is zero, the timer is not a periodic timer; it is signaled once and then deactivated.</span></span>

<span data-ttu-id="64878-134">Um thread pode usar a função [**CancelWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer) para definir o temporizador para o estado inativo.</span><span class="sxs-lookup"><span data-stu-id="64878-134">A thread can use the [**CancelWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer) function to set the timer to the inactive state.</span></span> <span data-ttu-id="64878-135">Para redefinir o temporizador, chame [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer).</span><span class="sxs-lookup"><span data-stu-id="64878-135">To reset the timer, call [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer).</span></span> <span data-ttu-id="64878-136">Quando terminar com o objeto de timer, chame [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) para fechar o identificador para o objeto de timer.</span><span class="sxs-lookup"><span data-stu-id="64878-136">When you are finished with the timer object, call [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) to close the handle to the timer object.</span></span>

<span data-ttu-id="64878-137">O comportamento de um temporizador de espera pode ser resumido da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="64878-137">The behavior of a waitable timer can be summarized as follows:</span></span>

-   <span data-ttu-id="64878-138">Quando um temporizador é definido, ele é cancelado se já estava ativo, o estado do temporizador não é sinalizado e o temporizador é colocado na fila de timer do kernel.</span><span class="sxs-lookup"><span data-stu-id="64878-138">When a timer is set, it is canceled if it was already active, the state of the timer is nonsignaled, and the timer is placed in the kernel timer queue.</span></span>
-   <span data-ttu-id="64878-139">Quando um temporizador expira, o temporizador é definido como o estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="64878-139">When a timer expires, the timer is set to the signaled state.</span></span> <span data-ttu-id="64878-140">Se o temporizador tiver uma rotina de conclusão, ela será enfileirada para o thread que define o temporizador.</span><span class="sxs-lookup"><span data-stu-id="64878-140">If the timer has a completion routine, it is queued to the thread that set the timer.</span></span> <span data-ttu-id="64878-141">A rotina de conclusão permanece na fila da APC ( [chamada de procedimento assíncrono](asynchronous-procedure-calls.md) ) do thread até que o thread Insira um estado de espera de alerta.</span><span class="sxs-lookup"><span data-stu-id="64878-141">The completion routine remains in the [asynchronous procedure call](asynchronous-procedure-calls.md) (APC) queue of the thread until the thread enters an alertable wait state.</span></span> <span data-ttu-id="64878-142">Nesse momento, a APC é despachada e a rotina de conclusão é chamada.</span><span class="sxs-lookup"><span data-stu-id="64878-142">At that time, the APC is dispatched and the completion routine is called.</span></span> <span data-ttu-id="64878-143">Se o temporizador for periódico, ele será colocado de volta na fila de timer do kernel.</span><span class="sxs-lookup"><span data-stu-id="64878-143">If the timer is periodic, it is placed back in the kernel timer queue.</span></span>
-   <span data-ttu-id="64878-144">Quando um temporizador é cancelado, ele é removido da fila de timer do kernel se ele estava pendente.</span><span class="sxs-lookup"><span data-stu-id="64878-144">When a timer is canceled, it is removed from the kernel timer queue if it was pending.</span></span> <span data-ttu-id="64878-145">Se o temporizador tiver expirado e ainda houver uma APC na fila para o thread que definiu o temporizador, a APC será removida da fila da APC do thread.</span><span class="sxs-lookup"><span data-stu-id="64878-145">If the timer had expired and there is still an APC queued to the thread that set the timer, the APC is removed from the thread's APC queue.</span></span> <span data-ttu-id="64878-146">O estado sinalizado do temporizador não é afetado.</span><span class="sxs-lookup"><span data-stu-id="64878-146">The signaled state of the timer is not affected.</span></span>

## <a name="related-topics"></a><span data-ttu-id="64878-147">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="64878-147">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="64878-148">Chamadas de procedimento assíncrono</span><span class="sxs-lookup"><span data-stu-id="64878-148">Asynchronous Procedure Calls</span></span>](asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="64878-149">Usando objetos de timer de espera</span><span class="sxs-lookup"><span data-stu-id="64878-149">Using Waitable Timer Objects</span></span>](using-waitable-timer-objects.md)
</dt> </dl>

 

 
