---
title: Diferenças entre implementações autônomas e de arquivo composto
description: A implementação autônoma das interfaces do conjunto de propriedades e a implementação do arquivo composto diferem de algumas maneiras.
ms.assetid: 650d4759-a58a-47a4-922d-5757e356cf56
keywords:
- IPropertyStorage Strctd STG, implementações
- IPropertyStorage Strctd STG, implementações, diferenças
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 988f8a9cfdaca0a131bedf98cd8ff10ae8b89525
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "103822533"
---
# <a name="differences-between-stand-alone-and-compound-file-implementations"></a><span data-ttu-id="2d4f2-105">Diferenças entre implementações autônomas e de arquivo composto</span><span class="sxs-lookup"><span data-stu-id="2d4f2-105">Differences between Stand-alone and Compound File Implementations</span></span>

<span data-ttu-id="2d4f2-106">A implementação autônoma das interfaces do conjunto de propriedades e a implementação do arquivo composto diferem de algumas maneiras.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-106">The stand-alone implementation of the property set interfaces and the compound file implementation differ in some ways.</span></span> <span data-ttu-id="2d4f2-107">Na implementação de arquivo composto de fluxo, armazenamento, conjunto de propriedades e objetos de armazenamento de propriedades, as várias interfaces são coordenadas entre si porque compartilham uma implementação comum.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-107">In the compound-file implementation of stream, storage, property set storage, and property storage objects, the various interfaces coordinate with each another because they share a common implementation.</span></span> <span data-ttu-id="2d4f2-108">Na implementação autônoma, as implementações de interface são distintas.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-108">In the stand-alone implementation, the interface implementations are distinct.</span></span>

<span data-ttu-id="2d4f2-109">Como resultado, a implementação de arquivo composto lida com problemas de simultaneidade e sincroniza o objeto de conjunto de propriedades com o objeto de armazenamento ou de fluxo.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-109">As a result, the compound-file implementation handles concurrency issues and synchronizes the property set object with the storage or stream object.</span></span> <span data-ttu-id="2d4f2-110">Com a implementação autônoma, o cliente é responsável por lidar com problemas de simultaneidade e sincronização entre o objeto de armazenamento ou de fluxo e o conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-110">With the stand-alone implementation, the client is responsible for handling concurrency and synchronization issues between the storage or stream object and the property set.</span></span> <span data-ttu-id="2d4f2-111">Um cliente pode atender a esses requisitos seguindo duas regras simples.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-111">A client can meet these requirements by following two simple rules.</span></span> <span data-ttu-id="2d4f2-112">Primeiro, nunca manipule um conjunto de propriedades usando seu fluxo ou suas interfaces de armazenamento enquanto um objeto de armazenamento de propriedades está aberto nele.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-112">First, never manipulate a property set using its stream or storage interfaces while a property storage object is open on it.</span></span> <span data-ttu-id="2d4f2-113">Em segundo lugar, sempre chame **Commit** em um objeto de armazenamento de propriedade antes de chamar **CopyTo**, **MoveElementTo** ou **Commit** em um objeto de armazenamento ancestral.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-113">Second, always call **Commit** on a property storage object before calling **CopyTo**, **MoveElementTo**, or **Commit** on an ancestor storage object.</span></span> <span data-ttu-id="2d4f2-114">Especificamente, os seguintes itens exigem a atenção do cliente:</span><span class="sxs-lookup"><span data-stu-id="2d4f2-114">Specifically, the following items require client attention:</span></span>

-   <span data-ttu-id="2d4f2-115">Na implementação de arquivo composto, um único mecanismo fornece proteção de simultaneidade para o objeto de armazenamento e seus objetos de conjunto de propriedades associados.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-115">In the compound-file implementation, a single mechanism provides concurrency protection for the storage object and its associated property set objects.</span></span> <span data-ttu-id="2d4f2-116">No entanto, na implementação autônoma, a implementação do objeto de armazenamento é separada da implementação do conjunto de propriedades e cada uma fornece seus próprios mecanismos de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-116">However, in the stand-alone implementation, the storage object implementation is separate from the property set implementation and each provides its own concurrency mechanisms.</span></span> <span data-ttu-id="2d4f2-117">Assim, na implementação autônoma, o cliente é responsável por manter a proteção de simultaneidade entre as duas implementações por meio de um mecanismo de exclusão mútua.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-117">Thus, in the stand-alone implementation, the client is responsible for maintaining concurrency protection between the two implementations through a mechanism of mutual exclusion.</span></span>
-   <span data-ttu-id="2d4f2-118">Na implementação do arquivo composto, as alterações nos conjuntos de propriedades são armazenadas em buffer em um cache de conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-118">In the compound file implementation, changes to property sets are buffered in a property-set cache.</span></span> <span data-ttu-id="2d4f2-119">Em seguida, quando o método [**IStorage:: Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) é chamado no objeto de armazenamento, a implementação dos arquivos compostos libera automaticamente as alterações do conjunto de propriedades do buffer do conjunto de propriedades antes que o objeto de armazenamento seja confirmado.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-119">Then, when the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method is called on the storage object, the compound files implementation automatically flushes the property-set changes from the property-set buffer before the storage object is committed.</span></span> <span data-ttu-id="2d4f2-120">Portanto, as alterações de conjunto de propriedades são tornadas visíveis como parte da transação que está sendo confirmada.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-120">Thus, the property-set changes are made visible as part of the transaction being committed.</span></span>

    <span data-ttu-id="2d4f2-121">Na implementação autônoma, o cliente deve liberar explicitamente o buffer de conjunto de propriedades chamando [**IPropertyStorage:: Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) antes de chamar o método [**IStorage:: Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) no armazenamento.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-121">In the stand-alone implementation, the client must explicitly flush the property-set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method on the storage.</span></span> <span data-ttu-id="2d4f2-122">Como alternativa, o cliente pode usar o novo \_ valor sem buffer PROPSETFLAG na implementação autônoma para gravar diretamente no conjunto de propriedades, em vez de armazenar em cache as alterações no buffer interno do conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-122">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value in the stand-alone implementation to write directly to the property set instead of caching changes to the property set's internal buffer.</span></span> <span data-ttu-id="2d4f2-123">Se PROPSETFLAG sem \_ buffer for usado, as responsabilidades do cliente serão automaticamente atendidas.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-123">If PROPSETFLAG\_UNBUFFERED is used, the client's responsibilities are automatically met.</span></span> <span data-ttu-id="2d4f2-124">A implementação do arquivo composto não oferece suporte ao \_ valor sem buffer PROPSETFLAG.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-124">The compound file implementation does not support the PROPSETFLAG\_UNBUFFERED value.</span></span> <span data-ttu-id="2d4f2-125">Para obter mais informações, consulte [**constantes PROPSETFLAG**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="2d4f2-125">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

-   <span data-ttu-id="2d4f2-126">Assim como ocorre com os armazenamentos transacionados, a implementação do arquivo composto atualiza o conjunto de propriedades liberando seu buffer interno antes de executar uma chamada para [**IStorage:: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) ou [**IStorage:: MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="2d4f2-126">As with transacted storages, the compound file implementation updates the property set by flushing its internal buffer before executing a call to [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="2d4f2-127">Assim, as alterações no conjunto de propriedades são refletidas no elemento de armazenamento copiado ou movido.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-127">Thus, changes to the property set are reflected in the copied or moved storage element.</span></span>

    <span data-ttu-id="2d4f2-128">Na implementação autônoma, o cliente deve liberar explicitamente o buffer do conjunto de propriedades chamando [**IPropertyStorage:: Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) antes de chamar [**IStorage:: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) ou [**IStorage:: MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="2d4f2-128">In the stand-alone implementation, the client must explicitly flush the property set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="2d4f2-129">Como alternativa, o cliente pode usar o novo \_ valor sem buffer PROPSETFLAG para gravar diretamente no conjunto de propriedades em vez de armazenar em cache as alterações no buffer do conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="2d4f2-129">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value to write directly to the property set instead of caching changes to the property set buffer.</span></span> <span data-ttu-id="2d4f2-130">Para obter mais informações, consulte [**constantes PROPSETFLAG**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="2d4f2-130">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

 

 




