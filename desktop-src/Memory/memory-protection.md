---
description: A memória que pertence a um processo é protegida implicitamente pelo seu espaço de endereço virtual privado.
ms.assetid: 70ded07a-7be6-4189-a1ae-281917f42a1e
title: Proteção de memória
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bd30df8084c91a62c28414f4a8142397ee777e52
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104091814"
---
# <a name="memory-protection"></a><span data-ttu-id="6d2d4-103">Proteção de memória</span><span class="sxs-lookup"><span data-stu-id="6d2d4-103">Memory Protection</span></span>

<span data-ttu-id="6d2d4-104">A memória que pertence a um processo é protegida implicitamente pelo seu espaço de endereço virtual privado.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-104">Memory that belongs to a process is implicitly protected by its private virtual address space.</span></span> <span data-ttu-id="6d2d4-105">Além disso, o Windows fornece proteção de memória usando o hardware de memória virtual.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-105">In addition, Windows provides memory protection by using the virtual memory hardware.</span></span> <span data-ttu-id="6d2d4-106">A implementação dessa proteção varia de acordo com o processador, por exemplo, as páginas de código no espaço de endereço de um processo podem ser marcadas como somente leitura e protegidas contra modificações feitas por threads de modo de usuário.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-106">The implementation of this protection varies with the processor, for example, code pages in the address space of a process can be marked read-only and protected from modification by user-mode threads.</span></span>

<span data-ttu-id="6d2d4-107">Para obter a lista completa de atributos, consulte [constantes de proteção de memória](memory-protection-constants.md).</span><span class="sxs-lookup"><span data-stu-id="6d2d4-107">For the complete list of attributes, see [Memory Protection Constants](memory-protection-constants.md).</span></span>

## <a name="copy-on-write-protection"></a><span data-ttu-id="6d2d4-108">Proteção de cópia em gravação</span><span class="sxs-lookup"><span data-stu-id="6d2d4-108">Copy-on-Write Protection</span></span>

<span data-ttu-id="6d2d4-109">A proteção de cópia em gravação é uma otimização que permite que vários processos mapeiem seus espaços de endereço virtual, de forma que eles compartilhem uma página física até que um dos processos modifique a página.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-109">Copy-on-write protection is an optimization that allows multiple processes to map their virtual address spaces such that they share a physical page until one of the processes modifies the page.</span></span> <span data-ttu-id="6d2d4-110">Isso faz parte de uma técnica chamada *avaliação lenta*, que permite ao sistema conservar a memória física e o tempo, não executando uma operação até que seja absolutamente necessário.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-110">This is part of a technique called *lazy evaluation*, which allows the system to conserve physical memory and time by not performing an operation until absolutely necessary.</span></span>

<span data-ttu-id="6d2d4-111">Por exemplo, suponha que dois processos carreguem páginas da mesma DLL em seus espaços de memória virtual.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-111">For example, suppose two processes load pages from the same DLL into their virtual memory spaces.</span></span> <span data-ttu-id="6d2d4-112">Essas páginas de memória virtual são mapeadas para as mesmas páginas de memória física para ambos os processos.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-112">These virtual memory pages are mapped to the same physical memory pages for both processes.</span></span> <span data-ttu-id="6d2d4-113">Desde que nenhum processo grave nessas páginas, eles poderão mapear e compartilhar, as mesmas páginas físicas, conforme mostrado no diagrama a seguir.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-113">As long as neither process writes to these pages, they can map to and share, the same physical pages, as shown in the following diagram.</span></span>

![caixas e setas das páginas do processo 1 e 2 mapeadas para a mesma memória física](images/mem1.png)

<span data-ttu-id="6d2d4-115">Se o processo 1 gravar em uma dessas páginas, o conteúdo da página física será copiado para outra página física e o mapa de memória virtual será atualizado para o processo 1.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-115">If Process 1 writes to one of these pages, the contents of the physical page are copied to another physical page and the virtual memory map is updated for Process 1.</span></span> <span data-ttu-id="6d2d4-116">Ambos os processos agora têm sua própria instância da página na memória física.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-116">Both processes now have their own instance of the page in physical memory.</span></span> <span data-ttu-id="6d2d4-117">Portanto, não é possível que um processo grave em uma página física compartilhada e que o outro processo Veja as alterações.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-117">Therefore, it is not possible for one process to write to a shared physical page and for the other process to see the changes.</span></span>

![caixas e setas de processos e remapeamento de memória física](images/mem2.png)

## <a name="loading-applications-and-dlls"></a><span data-ttu-id="6d2d4-119">Carregando aplicativos e DLLs</span><span class="sxs-lookup"><span data-stu-id="6d2d4-119">Loading Applications and DLLs</span></span>

<span data-ttu-id="6d2d4-120">Quando várias instâncias do mesmo aplicativo baseado no Windows são carregadas, cada instância é executada em seu próprio espaço de endereço virtual protegido.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-120">When multiple instances of the same Windows-based application are loaded, each instance is run in its own protected virtual address space.</span></span> <span data-ttu-id="6d2d4-121">No entanto, seus identificadores de instância (*HINSTANCE*) normalmente têm o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-121">However, their instance handles (*hInstance*) typically have the same value.</span></span> <span data-ttu-id="6d2d4-122">Esse valor representa o endereço base do aplicativo em seu espaço de endereço virtual.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-122">This value represents the base address of the application in its virtual address space.</span></span> <span data-ttu-id="6d2d4-123">Se cada instância puder ser carregada em seu endereço base padrão, ela poderá mapear e compartilhar as mesmas páginas físicas com as outras instâncias, usando a proteção de cópia em gravação.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-123">If each instance can be loaded into its default base address, it can map to and share the same physical pages with the other instances, using copy-on-write protection.</span></span> <span data-ttu-id="6d2d4-124">O sistema permite que essas instâncias compartilhem as mesmas páginas físicas até que uma delas modifique uma página.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-124">The system allows these instances to share the same physical pages until one of them modifies a page.</span></span> <span data-ttu-id="6d2d4-125">Se, por algum motivo, uma dessas instâncias não puder ser carregada no endereço base desejado, ela receberá suas próprias páginas físicas.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-125">If for some reason one of these instances cannot be loaded in the desired base address, it receives its own physical pages.</span></span>

<span data-ttu-id="6d2d4-126">DLLs são criadas com um endereço base padrão.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-126">DLLs are created with a default base address.</span></span> <span data-ttu-id="6d2d4-127">Cada processo que usa uma DLL tentará carregar a DLL em seu próprio espaço de endereço no endereço virtual padrão para a DLL.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-127">Every process that uses a DLL will try to load the DLL within its own address space at the default virtual address for the DLL.</span></span> <span data-ttu-id="6d2d4-128">Se vários aplicativos puderem carregar uma DLL em seu endereço virtual padrão, eles poderão compartilhar as mesmas páginas físicas para a DLL.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-128">If multiple applications can load a DLL at its default virtual address, they can share the same physical pages for the DLL.</span></span> <span data-ttu-id="6d2d4-129">Se por algum motivo um processo não puder carregar a DLL no endereço padrão, ele carregará a DLL em outro lugar.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-129">If for some reason a process cannot load the DLL at the default address, it loads the DLL elsewhere.</span></span> <span data-ttu-id="6d2d4-130">A proteção de cópia em gravação força algumas das páginas da DLL a serem copiadas em páginas físicas diferentes para esse processo, pois as correções para instruções de salto são gravadas nas páginas da DLL e serão diferentes para esse processo.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-130">Copy-on-write protection forces some of the DLL's pages to be copied into different physical pages for this process, because the fixes for jump instructions are written within the DLL's pages, and they will be different for this process.</span></span> <span data-ttu-id="6d2d4-131">Se a seção de código contiver muitas referências à seção de dados, isso poderá fazer com que a seção de código inteira seja copiada para novas páginas físicas.</span><span class="sxs-lookup"><span data-stu-id="6d2d4-131">If the code section contains many references to the data section, this can cause the entire code section to be copied to new physical pages.</span></span>

 

 



