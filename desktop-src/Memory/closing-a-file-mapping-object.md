---
description: Quando um processo termina com o objeto de mapeamento de arquivo, ele deve destruir todas as exibições de arquivo em seu espaço de endereço usando a função UnmapViewOfFile para cada exibição de arquivo.
ms.assetid: d62d068c-9b1d-4dbf-8b21-31a636a41456
title: Fechando um objeto de mapeamento de arquivo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0ab35152bd90d401ca7f30a7497d1f0b06263539
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "103828262"
---
# <a name="closing-a-file-mapping-object"></a><span data-ttu-id="3478a-103">Fechando um objeto de mapeamento de arquivo</span><span class="sxs-lookup"><span data-stu-id="3478a-103">Closing a File Mapping Object</span></span>

<span data-ttu-id="3478a-104">Quando um processo termina com o objeto de mapeamento de arquivo, ele deve destruir todas as exibições de arquivo em seu espaço de endereço usando a função [**UnmapViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile) para cada exibição de arquivo.</span><span class="sxs-lookup"><span data-stu-id="3478a-104">When a process has finished with the file mapping object, it should destroy all file views in its address space by using the [**UnmapViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile) function for each file view.</span></span>

<span data-ttu-id="3478a-105">Desmapear uma exibição mapeada de um arquivo invalida o intervalo ocupado pelo modo de exibição no espaço de endereço do processo e torna o intervalo disponível para outras alocações.</span><span class="sxs-lookup"><span data-stu-id="3478a-105">Unmapping a mapped view of a file invalidates the range occupied by the view in the address space of the process and makes the range available for other allocations.</span></span> <span data-ttu-id="3478a-106">Ele remove a entrada do conjunto de trabalho para cada página virtual não mapeada que faz parte do conjunto de trabalho do processo e reduz o tamanho do conjunto de trabalho do processo.</span><span class="sxs-lookup"><span data-stu-id="3478a-106">It removes the working set entry for each unmapped virtual page that was part of the working set of the process and reduces the working set size of the process.</span></span> <span data-ttu-id="3478a-107">Ele também decrementa a contagem de compartilhamento da página física correspondente.</span><span class="sxs-lookup"><span data-stu-id="3478a-107">It also decrements the share count of the corresponding physical page.</span></span>

<span data-ttu-id="3478a-108">As páginas modificadas na exibição não mapeada não são gravadas no disco até que sua contagem de compartilhamento chegue a zero ou, em outras palavras, até que elas sejam desmapeadas ou cortadas dos conjuntos de trabalho de todos os processos que compartilham as páginas.</span><span class="sxs-lookup"><span data-stu-id="3478a-108">Modified pages in the unmapped view are not written to disk until their share count reaches zero, or in other words, until they are unmapped or trimmed from the working sets of all processes that share the pages.</span></span> <span data-ttu-id="3478a-109">Mesmo assim, as páginas modificadas são gravadas "lentamente" em disco; ou seja, as modificações podem ser armazenadas em cache na memória e gravadas em disco posteriormente.</span><span class="sxs-lookup"><span data-stu-id="3478a-109">Even then, the modified pages are written "lazily" to disk; that is, modifications may be cached in memory and written to disk at a later time.</span></span> <span data-ttu-id="3478a-110">Para minimizar o risco de perda de dados no caso de uma falha de energia ou de uma falha do sistema, os aplicativos devem liberar explicitamente as páginas modificadas usando a função [**FlushViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-flushviewoffile) .</span><span class="sxs-lookup"><span data-stu-id="3478a-110">To minimize the risk of data loss in the event of a power failure or a system crash, applications should explicitly flush modified pages using the [**FlushViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-flushviewoffile) function.</span></span>

<span data-ttu-id="3478a-111">Quando cada processo termina de usar o objeto de mapeamento de arquivo e tem todas as exibições não mapeadas, ele deve fechar o identificador do objeto de mapeamento de arquivo e o arquivo no disco chamando [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle).</span><span class="sxs-lookup"><span data-stu-id="3478a-111">When each process finishes using the file mapping object and has unmapped all views, it must close the file mapping object's handle and the file on disk by calling [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle).</span></span> <span data-ttu-id="3478a-112">Essas chamadas para **CloseHandle** são realizadas com sucesso mesmo quando há exibições de arquivo que ainda estão abertas.</span><span class="sxs-lookup"><span data-stu-id="3478a-112">These calls to **CloseHandle** succeed even when there are file views that are still open.</span></span> <span data-ttu-id="3478a-113">No entanto, deixar as exibições de arquivo mapeadas causa vazamentos de memória.</span><span class="sxs-lookup"><span data-stu-id="3478a-113">However, leaving file views mapped causes memory leaks.</span></span>

 

 
