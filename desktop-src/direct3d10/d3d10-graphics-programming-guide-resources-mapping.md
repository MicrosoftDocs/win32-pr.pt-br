---
description: Copiando e acessando dados de recurso (Direct3D 10)
ms.assetid: 34fd4d15-ee64-4acf-967d-a4afb6f26329
title: Copiando e acessando dados de recurso (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 38bd075585ee3123e163075a50b06b53a77a214c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "103646404"
---
# <a name="copying-and-accessing-resource-data-direct3d-10"></a><span data-ttu-id="bd0c4-103">Copiando e acessando dados de recurso (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="bd0c4-103">Copying and Accessing Resource Data (Direct3D 10)</span></span>

<span data-ttu-id="bd0c4-104">Não é mais necessário pensar em recursos como sendo criados na memória de vídeo ou na memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-104">It is no longer necessary to think about resources as being created in either video memory or system memory.</span></span> <span data-ttu-id="bd0c4-105">Ou se o tempo de execução deve ou não gerenciar a memória.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-105">Or whether or not the runtime should manage the memory.</span></span> <span data-ttu-id="bd0c4-106">Graças à arquitetura do novo WDDM (modelo de driver de vídeo do Windows), agora os aplicativos criam recursos do Direct3D 10 com sinalizadores de [**uso**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) diferentes para indicar como o aplicativo pretende usar os dados do recurso.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-106">Thanks to the architecture of the new WDDM (Windows Display Driver Model), applications now create Direct3D 10 resources with different [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) flags to indicate how the application intends on using the resource data.</span></span> <span data-ttu-id="bd0c4-107">O novo modelo de driver virtualiza a memória usada pelos recursos; em seguida, ele se torna responsável pelo Gerenciador de sistema operacional/driver/memória para posicionar recursos na área de mais desempenho da memória possível, dado o uso esperado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-107">The new driver model virtualizes the memory used by resources; it then becomes the responsibility of the operating system/driver/memory manager to place resources in the most performant area of memory possible given the expected usage.</span></span>

<span data-ttu-id="bd0c4-108">Por padrão, os recursos estão disponíveis para a GPU.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-108">The default case is for resources to be available to the GPU.</span></span> <span data-ttu-id="bd0c4-109">É claro que, tendo dito isso, há ocasiões em que os dados de recursos precisam estar disponíveis para a CPU.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-109">Of course, having said that, there are times when the resource data needs to be available to the CPU.</span></span> <span data-ttu-id="bd0c4-110">Copiar os dados de recurso ao redor para que o processador apropriado possa acessá-los sem afetar o desempenho exige algum conhecimento de como funcionam os métodos da API.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-110">Copying resource data around so that the appropriate processor can access it without impacting performance requires some knowledge of how the API methods work.</span></span>

-   [<span data-ttu-id="bd0c4-111">Copiando dados de recurso</span><span class="sxs-lookup"><span data-stu-id="bd0c4-111">Copying Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)
-   [<span data-ttu-id="bd0c4-112">Acessando dados de recursos</span><span class="sxs-lookup"><span data-stu-id="bd0c4-112">Accessing Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)

## <a name="copying-resource-data"></a><span data-ttu-id="bd0c4-113">Copiando dados de recurso</span><span class="sxs-lookup"><span data-stu-id="bd0c4-113">Copying Resource Data</span></span>

<span data-ttu-id="bd0c4-114">Os recursos são criados na memória quando o Direct3D executa uma chamada de criação.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-114">Resources are created in memory when Direct3D executes a Create call.</span></span> <span data-ttu-id="bd0c4-115">Eles podem ser criados na memória de vídeo, memória do sistema ou qualquer outro tipo de memória.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-115">They can be created in video memory, system memory, or any other kind of memory.</span></span> <span data-ttu-id="bd0c4-116">Como o modelo de driver WDDM virtualiza essa memória, apps não precisam mais acompanhar que tipo de recursos de memória são criados.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-116">Since WDDM driver model virtualizes this memory, applications no longer need to keep track of what kind of memory resources are created in.</span></span>

<span data-ttu-id="bd0c4-117">Idealmente, todos os recursos devem estar localizados na memória de vídeo para que a GPU possa ter acesso imediato a eles.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-117">Ideally, all resources would be located in video memory so that the GPU can have immediate access to them.</span></span> <span data-ttu-id="bd0c4-118">No entanto, às vezes, é necessário que a CPU leia os dados de recurso ou que a GPU acesse os dados de recurso nos quais a CPU realizou gravações.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-118">However, it is sometimes necessary for the CPU to read the resource data or for the GPU to access resource data the CPU has written to.</span></span> <span data-ttu-id="bd0c4-119">O Direct3D 10 lida com esses cenários diferentes solicitando que o aplicativo especifique um uso e, em seguida, oferece vários métodos para copiar os dados de recursos quando necessário.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-119">Direct3D 10 handles these different scenarios by requesting the application specify a usage, and then offers several methods for copying resource data when necessary.</span></span>

<span data-ttu-id="bd0c4-120">Dependendo de como o recurso foi criado, ele nem sempre é capaz de acessar diretamente os dados subjacentes.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-120">Depending on how the resource was created, it is not always possible to directly access the underlying data.</span></span> <span data-ttu-id="bd0c4-121">Isso pode significar que os dados de recurso devem ser copiados do recurso de origem para outro recurso que seja acessível pelo processador apropriado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-121">This may mean that the resource data must be copied from the source resource to another resource that is accessible by the appropriate processor.</span></span> <span data-ttu-id="bd0c4-122">Em termos de Direct3D 10, os recursos padrão podem ser acessados diretamente pela GPU, os recursos dinâmicos e de preparo podem ser acessados diretamente pela CPU.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-122">In terms of Direct3D 10, default resources can be accessed directly by the GPU, dynamic and staging resources can be directly accessed by the CPU.</span></span>

<span data-ttu-id="bd0c4-123">Depois que um recurso tiver sido criado, seu [**uso**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) não poderá ser alterado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-123">Once a resource has been created, its [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) cannot be changed.</span></span> <span data-ttu-id="bd0c4-124">Em vez disso, copie o conteúdo de um recurso para outro recurso que foi criado com um uso diferente.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-124">Instead, copy the contents of one resource to another resource that was created with a different usage.</span></span> <span data-ttu-id="bd0c4-125">O Direct3D 10 fornece essa funcionalidade com três métodos diferentes.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-125">Direct3D 10 provides this functionality with three different methods.</span></span> <span data-ttu-id="bd0c4-126">Os dois primeiros métodos ( [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) e [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) são projetados para copiar dados de recurso de um recurso para outro.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-126">The first two methods( [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) are designed to copy resource data from one resource to another.</span></span> <span data-ttu-id="bd0c4-127">O terceiro método ([**ID3D10Device:: UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) foi projetado para copiar dados da memória para um recurso.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-127">The third method ([**ID3D10Device::UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) is designed to copy data from memory to a resource.</span></span>

<span data-ttu-id="bd0c4-128">Existem dois tipos principais de recursos: mapeáveis e não mapeáveis.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-128">There are two main kinds of resources: mappable and non-mappable.</span></span> <span data-ttu-id="bd0c4-129">Os recursos criados com usos dinâmico ou de preparo são mapeáveis, enquanto os recursos criados com os usos padrão ou imutável são não mapeáveis.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-129">Resources created with dynamic or staging usages are mappable, while resources created with default or immutable usages are non-mappable.</span></span>

<span data-ttu-id="bd0c4-130">Copiar dados entre recursos não mapeáveis é muito rápido porque esse é o caso mais comum e foi otimizado para uma boa execução.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-130">Copying data among non-mappable resources is very fast because this is the most common case and has been optimized to perform well.</span></span> <span data-ttu-id="bd0c4-131">Como esses recursos não são diretamente acessíveis pela CPU, eles são otimizados para que a GPU possa manipulá-los rapidamente.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-131">Since these resources are not directly accessible by the CPU, they are optimized so that the GPU can manipulate them quickly.</span></span>

<span data-ttu-id="bd0c4-132">Copiar dados entre recursos mapeáveis é mais problemático porque o desempenho depende do uso com o qual o recurso foi criado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-132">Copying data among mappable resources is more problematic because the performance will depend on the usage the resource was created with.</span></span> <span data-ttu-id="bd0c4-133">Por exemplo, a GPU pode ler um recurso dinâmico rapidamente, mas não pode gravá-los, e a GPU não pode ler ou gravar recursos de preparo diretamente.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-133">For example, the GPU can read a dynamic resource fairly quickly but cannot write to them, and the GPU cannot read or write to staging resources directly.</span></span>

<span data-ttu-id="bd0c4-134">Aplicativos que desejam copiar dados de um recurso com uso padrão para um recurso com uso de preparo (para permitir que a CPU Leia os dados – ou seja, o problema de readback da GPU) devem fazer isso com cuidado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-134">Applications that wish to copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data -- i.e. the GPU readback problem) must do so with care.</span></span> <span data-ttu-id="bd0c4-135">Consulte [acessando dados de recursos](#copying-and-accessing-resource-data-direct3d-10) para obter mais detalhes sobre esse último caso.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-135">See [Accessing Resource Data](#copying-and-accessing-resource-data-direct3d-10) for more details on this last case.</span></span>

## <a name="accessing-resource-data"></a><span data-ttu-id="bd0c4-136">Acessando dados de recursos</span><span class="sxs-lookup"><span data-stu-id="bd0c4-136">Accessing Resource Data</span></span>

<span data-ttu-id="bd0c4-137">Acessar um recurso requer o mapeamento do recurso; mapeando significa essencialmente que o app está tentando dar acesso à CPU para a memória.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-137">Accessing a resource requires mapping the resource; mapping essentially means the application is trying to give the CPU access to memory.</span></span> <span data-ttu-id="bd0c4-138">O processo de mapeamento de um recurso para que a CPU possa acessar a memória subjacente pode causar alguns afunilamentos de desempenho e por esse motivo, é obrigatório ter cautela com a forma e o momento da execução dessa tarefa.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-138">The process of mapping a resource so that the CPU can access the underlying memory can cause some performance bottlenecks and for this reason, care must be taken as to how and when to perform this task.</span></span>

<span data-ttu-id="bd0c4-139">O desempenho pode ser interrompidas se o app tentar mapear um recurso no momento errado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-139">Performance can grind to a halt if the application tries to map a resource at the wrong time.</span></span> <span data-ttu-id="bd0c4-140">Se o app tentar acessar os resultados de uma operação antes que essa operação esteja concluída, ocorrerá uma vaga de pipeline.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-140">If the application tries to access the results of an operation before that operation is finished, a pipeline stall will occur.</span></span>

<span data-ttu-id="bd0c4-141">Executar uma operação de mapeamento no momento errado pode causar uma queda grave no desempenho, forçando a GPU e CPU a sincronizarem entre si.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-141">Performing a map operation at the wrong time could potentially cause a severe drop in performance by forcing the GPU and the CPU to synchronize with each other.</span></span> <span data-ttu-id="bd0c4-142">Essa sincronização ocorrerá se o app quiser acessar um recurso antes que a GPU termine de copiá-lo para um recurso que a CPU pode mapear.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-142">This synchronization will occur if the application wants to access a resource before the GPU is finished copying it into a resource the CPU can map.</span></span>

<span data-ttu-id="bd0c4-143">A CPU só pode ler de recursos criados com o sinalizador de preparo de uso de D3D10 \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="bd0c4-143">The CPU can only read from resources created with the D3D10\_USAGE\_STAGING flag.</span></span> <span data-ttu-id="bd0c4-144">Como os recursos criados com esse sinalizador não podem ser definidos como saídas do pipeline, se a CPU quiser ler os dados em um recurso gerado pela GPU, os dados deverão ser copiados para um recurso criado com o sinalizador de preparo.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-144">Since resources created with this flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU, the data must be copied to a resource created with the staging flag.</span></span> <span data-ttu-id="bd0c4-145">O aplicativo pode fazer isso usando os métodos [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) ou [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) para copiar o conteúdo de um recurso para outro.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-145">The application may do this by using the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods to copy the contents of one resource to another.</span></span> <span data-ttu-id="bd0c4-146">O aplicativo pode, então, obter acesso a esse recurso chamando o método MAP apropriado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-146">The application can then gain access to this resource by calling the appropriate Map method.</span></span> <span data-ttu-id="bd0c4-147">Quando o acesso ao recurso não for mais necessário, o aplicativo deverá chamar o método de mapeamento correspondente.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-147">When access to the resource is no longer needed, the application should then call the corresponding Unmap method.</span></span> <span data-ttu-id="bd0c4-148">Por exemplo, [**ID3D10Texture2D:: map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) e [**ID3D10Texture2D:: remapeamento**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span><span class="sxs-lookup"><span data-stu-id="bd0c4-148">For example, [**ID3D10Texture2D::Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) and [**ID3D10Texture2D::Unmap**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span></span> <span data-ttu-id="bd0c4-149">Os diferentes métodos de mapa retornam alguns valores específicos, dependendo dos sinalizadores de entrada.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-149">The different Map methods return some specific values depending on the input flags.</span></span> <span data-ttu-id="bd0c4-150">Consulte a [**seção comentários do mapa**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) para obter detalhes.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-150">See [**Map Remarks section**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) for details.</span></span>

> [!Note]  
> <span data-ttu-id="bd0c4-151">Quando o aplicativo chama o método MAP, ele recebe um ponteiro para os dados do recurso a serem acessados.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-151">When the application calls the Map method, it receives a pointer to the resource data to access.</span></span> <span data-ttu-id="bd0c4-152">O tempo de execução garante que o ponteiro tenha um alinhamento específico, dependendo do [nível de recurso](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span><span class="sxs-lookup"><span data-stu-id="bd0c4-152">The runtime ensures that the pointer has a specific alignment, depending on [feature level](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span></span> <span data-ttu-id="bd0c4-153">Para o [**nível de recurso do D3D \_ \_ \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) e superior, o ponteiro é alinhado a 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-153">For [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) and higher, the pointer is aligned to 16 bytes.</span></span> <span data-ttu-id="bd0c4-154">Para o nível de recurso do D3D inferior a [**\_ \_ \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), o ponteiro é alinhado a 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-154">For lower than [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), the pointer is aligned to 4 bytes.</span></span> <span data-ttu-id="bd0c4-155">O alinhamento de 16 bytes permite que o aplicativo execute operações otimizadas para [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))nos dados nativamente, sem realinhamento ou cópia.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-155">The 16-byte alignment allows the application to perform [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))-optimized operations on the data natively, without realignment or copy.</span></span>

 

### <a name="performance-considerations"></a><span data-ttu-id="bd0c4-156">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="bd0c4-156">Performance Considerations</span></span>

<span data-ttu-id="bd0c4-157">É melhor pensar em um computador como sendo uma máquina funcionando como uma arquitetura paralela com dois tipos principais de processadores: uma ou mais CPUs e uma ou mais GPUs.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-157">It is best to think of a PC as a machine running as a parallel architecture with two main types of processors: one or more CPU's and one or more GPU's.</span></span> <span data-ttu-id="bd0c4-158">Como em qualquer arquitetura paralela, o melhor desempenho é atingido quando cada processador está programado tarefas o suficiente para impedir que ele fique ocioso e que o trabalho de um processador não fique aguardando o trabalho do outro.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-158">As in any parallel architecture, the best performance is achieved when each processor is scheduled with enough tasks to prevent it from going idle and when the work of one processor is not waiting on the work of another.</span></span>

<span data-ttu-id="bd0c4-159">O pior cenário para o paralelismo de GPU/CPU é a necessidade de forçar um processador a esperar pelos resultados do trabalho feito pelo outro.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-159">The worst-case scenario for GPU/CPU parallelism is the need to force one processor to wait for the results of work done by another.</span></span> <span data-ttu-id="bd0c4-160">O Direct3D 10 tenta remover esse custo, tornando os métodos [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) e [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) assíncronos; a cópia não é necessariamente executada no momento em que o método retorna.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-160">Direct3D 10 tries to remove this cost by making the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods asynchronous; the copy has not necessarily executed by the time the method returns.</span></span> <span data-ttu-id="bd0c4-161">A vantagem disso é que o app não paga o custo de desempenho de copiar realmente os dados até que a CPU acesse os dados, que é quando é chamado o mapa.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-161">The benefit of this is that the application does not pay the performance cost of actually copying the data until the CPU accesses the data, which is when Map is called.</span></span> <span data-ttu-id="bd0c4-162">Se o método de mapa for chamado depois que os dados realmente foram copiados, nenhuma perda de desempenho ocorre.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-162">If the Map method is called after the data has actually been copied, no performance loss occurs.</span></span> <span data-ttu-id="bd0c4-163">Por outro lado, se o método de mapa for chamado antes dos dados terem sido copiados, uma vaga de pipeline ocorrerá.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-163">On the other hand, if the Map method is called before the data has been copied, then a pipeline stall will occur.</span></span>

<span data-ttu-id="bd0c4-164">As chamadas assíncronas no Direct3D 10 (que são a grande maioria dos métodos e especialmente chamadas de renderização) são armazenadas no que chamamos de buffer de comando.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-164">Asynchronous calls in Direct3D 10 (which are the vast majority of methods, and especially rendering calls) are stored in what is called a command buffer.</span></span> <span data-ttu-id="bd0c4-165">Esse buffer encontra-se no interior do driver de elementos gráficos e é usado para compilar em lotes as chamadas para o hardware subjacente, para que a alternância dispendiosa do modo de usuário para o modo de kernel no Microsoft Windows ocorra com a menor frequência possível.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-165">This buffer is internal to the graphics driver and is used to batch calls to the underlying hardware so that the costly switch from user mode to kernel mode in Microsoft Windows occurs as rarely as possible.</span></span>

<span data-ttu-id="bd0c4-166">O buffer de comando é liberado, causando uma alternância de modo de usuário/kernel, em uma das quatro situações, que são as seguintes.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-166">The command buffer is flushed, thus causing a user/kernel mode switch, in one of four situations, which are as follows.</span></span>

1.  <span data-ttu-id="bd0c4-167">[**Presente**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) é chamado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) is called.</span></span>
2.  <span data-ttu-id="bd0c4-168">[**ID3D10Device:: flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) é chamado.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-168">[**ID3D10Device::Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) is called.</span></span>
3.  <span data-ttu-id="bd0c4-169">O buffer de comando está cheio; seu tamanho é dinâmico e é controlado pelo sistema operacional e pelo driver gráfico.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-169">The command buffer is full; its size is dynamic and is controlled by the Operating System and the graphics driver.</span></span>
4.  <span data-ttu-id="bd0c4-170">A CPU requer acesso aos resultados de um comando que está aguardando para ser executado no buffer de comando.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-170">The CPU requires access to the results of a command waiting to execute in the command buffer.</span></span>

<span data-ttu-id="bd0c4-171">Das quatro situações acima, a número quatro é a mais crítica para o desempenho.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-171">Of the four situations above, number four is the most critical to performance.</span></span> <span data-ttu-id="bd0c4-172">Se o aplicativo emitir uma chamada [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) ou [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) , essa chamada será enfileirada no buffer de comando.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-172">If the application issues a [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) call, this call is queued in the command buffer.</span></span> <span data-ttu-id="bd0c4-173">Se o aplicativo tentar mapear o recurso de preparo que foi o destino da chamada de cópia antes de o buffer de comando ter sido liberado, ocorrerá uma parada de pipeline porque não apenas a chamada do método de cópia precisará ser executada, mas todos os outros comandos em buffer no buffer de comando também devem ser executados.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-173">If the application then tries to map the staging resource that was the target of the copy call before the command buffer has been flushed, a pipeline stall will occur because not only does the Copy method call need to execute, but all other buffered commands in the command buffer must execute as well.</span></span> <span data-ttu-id="bd0c4-174">Isso fará com que a GPU e a CPU sincronizem porque a CPU aguardará para acessar o recurso de preparo enquanto a GPU esvazia o buffer de comando e finalmente preenche o recurso que a CPU precisa.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-174">This will cause the GPU and CPU to synchronize because the CPU will be waiting to access the staging resource while the GPU is emptying the command buffer and finally filling the resource the CPU needs.</span></span> <span data-ttu-id="bd0c4-175">Depois que a GPU finalizar a cópia, a CPU começará a acessar o recurso de preparo, mas durante esse tempo, a GPU estará ociosa.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-175">Once the GPU finishes the copy, the CPU will begin accessing the staging resource, but during this time, the GPU will be sitting idle.</span></span>

<span data-ttu-id="bd0c4-176">Fazer isso com frequência em tempo de execução prejudicará gravemente o desempenho.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-176">Doing this frequently at runtime will severely degrade performance.</span></span> <span data-ttu-id="bd0c4-177">Por esse motivo, o mapeamento de recursos criado com o uso padrão deve ser feito com cautela.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-177">For that reason, mapping of resources created with default usage should be done with care.</span></span> <span data-ttu-id="bd0c4-178">O app precisa esperar tempo suficiente para que o buffer de comando seja esvaziado e, portanto, espera que todos esses comandos encerrem a execução antes de tentar mapear o recurso de preparo correspondente.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-178">The application needs to wait long enough for the command buffer to be emptied and thus have all of those commands finish executing before it tries to map the corresponding staging resource.</span></span> <span data-ttu-id="bd0c4-179">Quanto tempo o app deve esperar?</span><span class="sxs-lookup"><span data-stu-id="bd0c4-179">How long should the application wait?</span></span> <span data-ttu-id="bd0c4-180">Pelo menos dois quadros porque isso permitirá que o paralelismo entre as CPUs e a GPU seja utilizado ao máximo.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-180">At least two frames because this will enable parallelism between the CPU(s) and the GPU to be maximally leveraged.</span></span> <span data-ttu-id="bd0c4-181">A GPU funciona da seguinte forma: enquanto o app está processando o quadro N enviando chamadas para o buffer de comando, a GPU está ocupada executando as chamadas do quadro anterior, N-1.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-181">The way the GPU works is that while the application is processing frame N by submitting calls to the command buffer, the GPU is busy executing the calls from the previous frame, N-1.</span></span>

<span data-ttu-id="bd0c4-182">Portanto, se um aplicativo quiser mapear um recurso originado na memória de vídeo e chamar [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) ou [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) no quadro n, essa chamada começará a ser executada no quadro n + 1, quando o aplicativo estiver enviando chamadas para o próximo quadro.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-182">So if an application wants to map a resource that originates in video memory and calls [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) at frame N, this call will actually begin to execute at frame N+1, when the application is submitting calls for the next frame.</span></span> <span data-ttu-id="bd0c4-183">A cópia deve ser concluída quando o app estiver processando o quadro N+2.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-183">The copy should be finished when the application is processing frame N+2.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="bd0c4-184">Quadro</span><span class="sxs-lookup"><span data-stu-id="bd0c4-184">Frame</span></span></th>
<th><span data-ttu-id="bd0c4-185">Status da GPU/CPU</span><span class="sxs-lookup"><span data-stu-id="bd0c4-185">GPU/CPU Status</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="bd0c4-186">N</span><span class="sxs-lookup"><span data-stu-id="bd0c4-186">N</span></span></td>
<td><ul>
<li><span data-ttu-id="bd0c4-187">A CPU emite chamadas de renderização para o quadro atual.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-187">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="bd0c4-188">N+1</span><span class="sxs-lookup"><span data-stu-id="bd0c4-188">N+1</span></span></td>
<td><ul>
<li><span data-ttu-id="bd0c4-189">GPU executando chamadas enviadas da CPU durante o quadro N.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-189">GPU executing calls sent from CPU during frame N.</span></span></li>
<li><span data-ttu-id="bd0c4-190">A CPU emite chamadas de renderização para o quadro atual.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-190">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="bd0c4-191">N+2</span><span class="sxs-lookup"><span data-stu-id="bd0c4-191">N+2</span></span></td>
<td><ul>
<li><span data-ttu-id="bd0c4-192">A GPU encerrou as chamadas enviadas da CPU durante o quadro N. Resultados prontos.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-192">GPU finished executing calls sent from CPU during frame N. Results ready.</span></span></li>
<li><span data-ttu-id="bd0c4-193">GPU executando chamadas enviadas da CPU durante o quadro N+1.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-193">GPU executing calls sent from CPU during frame N+1.</span></span></li>
<li><span data-ttu-id="bd0c4-194">A CPU emite chamadas de renderização para o quadro atual.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-194">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="bd0c4-195">N+3</span><span class="sxs-lookup"><span data-stu-id="bd0c4-195">N+3</span></span></td>
<td><ul>
<li><span data-ttu-id="bd0c4-196">A GPU encerrou as chamadas enviadas da CPU durante o quadro N+1.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-196">GPU finished executing calls sent from CPU during frame N+1.</span></span> <span data-ttu-id="bd0c4-197">Resultados prontos.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-197">Results ready.</span></span></li>
<li><span data-ttu-id="bd0c4-198">GPU executando chamadas enviadas da CPU durante o quadro N+2.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-198">GPU executing calls sent from CPU during frame N+2.</span></span></li>
<li><span data-ttu-id="bd0c4-199">A CPU emite chamadas de renderização para o quadro atual.</span><span class="sxs-lookup"><span data-stu-id="bd0c4-199">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="bd0c4-200">N+4</span><span class="sxs-lookup"><span data-stu-id="bd0c4-200">N+4</span></span></td>
<td><span data-ttu-id="bd0c4-201">...</span><span class="sxs-lookup"><span data-stu-id="bd0c4-201">...</span></span></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="bd0c4-202">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="bd0c4-202">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="bd0c4-203">Recursos (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="bd0c4-203">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
