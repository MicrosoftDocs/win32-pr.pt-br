---
description: Todo desenvolvedor que cria aplicativos em tempo real que usam gráficos 3D está preocupado com a otimização do desempenho. Esta seção fornece diretrizes para obter o melhor desempenho do seu código.
ms.assetid: 074f848e-4a42-48a2-adf7-4026b8967413
title: Otimizações de desempenho (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4d42be994522f0d83e36387b1a5866b3eee10df3
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/06/2021
ms.locfileid: "104456367"
---
# <a name="performance-optimizations-direct3d-9"></a><span data-ttu-id="64aa6-104">Otimizações de desempenho (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="64aa6-104">Performance Optimizations (Direct3D 9)</span></span>

<span data-ttu-id="64aa6-105">Todo desenvolvedor que cria aplicativos em tempo real que usam gráficos 3D está preocupado com a otimização do desempenho.</span><span class="sxs-lookup"><span data-stu-id="64aa6-105">Every developer who creates real-time applications that use 3D graphics is concerned about performance optimization.</span></span> <span data-ttu-id="64aa6-106">Esta seção fornece diretrizes para obter o melhor desempenho do seu código.</span><span class="sxs-lookup"><span data-stu-id="64aa6-106">This section provides guidelines for getting the best performance from your code.</span></span>

-   [<span data-ttu-id="64aa6-107">Dicas gerais de desempenho</span><span class="sxs-lookup"><span data-stu-id="64aa6-107">General Performance Tips</span></span>](#general-performance-tips)
-   [<span data-ttu-id="64aa6-108">Bancos de dados e remoção</span><span class="sxs-lookup"><span data-stu-id="64aa6-108">Databases and Culling</span></span>](#databases-and-culling)
-   [<span data-ttu-id="64aa6-109">Primitivos de envio em lote</span><span class="sxs-lookup"><span data-stu-id="64aa6-109">Batching Primitives</span></span>](#batching-primitives)
-   [<span data-ttu-id="64aa6-110">Dicas de iluminação</span><span class="sxs-lookup"><span data-stu-id="64aa6-110">Lighting Tips</span></span>](#lighting-tips)
-   [<span data-ttu-id="64aa6-111">Tamanho da textura</span><span class="sxs-lookup"><span data-stu-id="64aa6-111">Texture Size</span></span>](#texture-size)
-   [<span data-ttu-id="64aa6-112">Transformações de matriz</span><span class="sxs-lookup"><span data-stu-id="64aa6-112">Matrix Transforms</span></span>](#matrix-transforms)
-   [<span data-ttu-id="64aa6-113">Usando texturas dinâmicas</span><span class="sxs-lookup"><span data-stu-id="64aa6-113">Using Dynamic Textures</span></span>](#using-dynamic-textures)
-   [<span data-ttu-id="64aa6-114">Usando um vértice dinâmico e buffers de índice</span><span class="sxs-lookup"><span data-stu-id="64aa6-114">Using Dynamic Vertex and Index Buffers</span></span>](#using-dynamic-vertex-and-index-buffers)
-   [<span data-ttu-id="64aa6-115">Usando malhas</span><span class="sxs-lookup"><span data-stu-id="64aa6-115">Using Meshes</span></span>](#using-meshes)
-   [<span data-ttu-id="64aa6-116">Desempenho de buffer Z</span><span class="sxs-lookup"><span data-stu-id="64aa6-116">Z-Buffer Performance</span></span>](#z-buffer-performance)

## <a name="general-performance-tips"></a><span data-ttu-id="64aa6-117">Dicas gerais de desempenho</span><span class="sxs-lookup"><span data-stu-id="64aa6-117">General Performance Tips</span></span>

-   <span data-ttu-id="64aa6-118">Desmarque somente quando precisar.</span><span class="sxs-lookup"><span data-stu-id="64aa6-118">Clear only when you must.</span></span>
-   <span data-ttu-id="64aa6-119">Minimize as alterações de estado e agrupe as alterações de estado restantes.</span><span class="sxs-lookup"><span data-stu-id="64aa6-119">Minimize state changes and group the remaining state changes.</span></span>
-   <span data-ttu-id="64aa6-120">Use texturas menores, se puder fazer isso.</span><span class="sxs-lookup"><span data-stu-id="64aa6-120">Use smaller textures, if you can do so.</span></span>
-   <span data-ttu-id="64aa6-121">Desenhe objetos em sua cena de frente para trás.</span><span class="sxs-lookup"><span data-stu-id="64aa6-121">Draw objects in your scene from front to back.</span></span>
-   <span data-ttu-id="64aa6-122">Use as faixas de triângulo em vez de listas e ventiladores.</span><span class="sxs-lookup"><span data-stu-id="64aa6-122">Use triangle strips instead of lists and fans.</span></span> <span data-ttu-id="64aa6-123">Para obter um desempenho de cache de vértice ideal, organize as faixas para reutilizar vértices de triângulo mais cedo, em vez de mais tarde</span><span class="sxs-lookup"><span data-stu-id="64aa6-123">For optimal vertex cache performance, arrange strips to reuse triangle vertices sooner, rather than later.</span></span>
-   <span data-ttu-id="64aa6-124">Degradar normalmente efeitos especiais que exigem um compartilhamento desproporcional de recursos do sistema.</span><span class="sxs-lookup"><span data-stu-id="64aa6-124">Gracefully degrade special effects that require a disproportionate share of system resources.</span></span>
-   <span data-ttu-id="64aa6-125">Teste constantemente o desempenho do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-125">Constantly test your application's performance.</span></span>
-   <span data-ttu-id="64aa6-126">Minimize as opções de buffer de vértice.</span><span class="sxs-lookup"><span data-stu-id="64aa6-126">Minimize vertex buffer switches.</span></span>
-   <span data-ttu-id="64aa6-127">Use buffers de vértice estáticos sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-127">Use static vertex buffers where possible.</span></span>
-   <span data-ttu-id="64aa6-128">Use um buffer de vértice estático grande por FVF para objetos estáticos, em vez de um por objeto.</span><span class="sxs-lookup"><span data-stu-id="64aa6-128">Use one large static vertex buffer per FVF for static objects, rather than one per object.</span></span>
-   <span data-ttu-id="64aa6-129">Se seu aplicativo precisar de acesso aleatório no buffer de vértice na memória AGP, escolha um tamanho de formato de vértice que seja múltiplo de 32 bytes.</span><span class="sxs-lookup"><span data-stu-id="64aa6-129">If your application needs random access into the vertex buffer in AGP memory, choose a vertex format size that is a multiple of 32 bytes.</span></span> <span data-ttu-id="64aa6-130">Caso contrário, selecione o menor formato apropriado.</span><span class="sxs-lookup"><span data-stu-id="64aa6-130">Otherwise, select the smallest appropriate format.</span></span>
-   <span data-ttu-id="64aa6-131">Desenhar usando primitivos indexados.</span><span class="sxs-lookup"><span data-stu-id="64aa6-131">Draw using indexed primitives.</span></span> <span data-ttu-id="64aa6-132">Isso pode permitir um cache de vértices mais eficiente no hardware.</span><span class="sxs-lookup"><span data-stu-id="64aa6-132">This can allow for more efficient vertex caching within hardware.</span></span>
-   <span data-ttu-id="64aa6-133">Se o formato de buffer de profundidade contiver um canal de estêncil, sempre Limpe os canais de profundidade e estêncil ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-133">If the depth buffer format contains a stencil channel, always clear the depth and stencil channels at the same time.</span></span>
-   <span data-ttu-id="64aa6-134">Combine a instrução do sombreador e a saída de dados sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-134">Combine the shader instruction and the data output where possible.</span></span> <span data-ttu-id="64aa6-135">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="64aa6-135">For example:</span></span>
    ```
    // Rather than doing a multiply and add, and then output the data with 
    //   two instructions:
    mad r2, r1, v0, c0
    mov oD0, r2

    // Combine both in a single instruction, because this eliminates an  
    //   additional register copy.
    mad oD0, r1, v0, c0 
    ```

    

## <a name="databases-and-culling"></a><span data-ttu-id="64aa6-136">Bancos de dados e remoção</span><span class="sxs-lookup"><span data-stu-id="64aa6-136">Databases and Culling</span></span>

<span data-ttu-id="64aa6-137">Criar um banco de dados confiável dos objetos em seu mundo é a chave para um desempenho excelente no Direct3D.</span><span class="sxs-lookup"><span data-stu-id="64aa6-137">Building a reliable database of the objects in your world is key to excellent performance in Direct3D.</span></span> <span data-ttu-id="64aa6-138">É mais importante do que melhorias na rasterização ou no hardware.</span><span class="sxs-lookup"><span data-stu-id="64aa6-138">It is more important than improvements to rasterization or hardware.</span></span>

<span data-ttu-id="64aa6-139">Você deve manter a contagem de polígonos mais baixa que possivelmente pode gerenciar.</span><span class="sxs-lookup"><span data-stu-id="64aa6-139">You should maintain the lowest polygon count you can possibly manage.</span></span> <span data-ttu-id="64aa6-140">Crie um pequeno número de polígonos criando modelos de baixo polígono desde o início.</span><span class="sxs-lookup"><span data-stu-id="64aa6-140">Design for a low polygon count by building low-polygon models from the start.</span></span> <span data-ttu-id="64aa6-141">Adicione polígonos se você puder fazer isso sem sacrificar o desempenho posteriormente no processo de desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="64aa6-141">Add polygons if you can do so without sacrificing performance later in the development process.</span></span> <span data-ttu-id="64aa6-142">Lembre-se de que os polígonos mais rápidos são aqueles que você não desenha.</span><span class="sxs-lookup"><span data-stu-id="64aa6-142">Remember, the fastest polygons are the ones you don't draw.</span></span>

## <a name="batching-primitives"></a><span data-ttu-id="64aa6-143">Primitivos de envio em lote</span><span class="sxs-lookup"><span data-stu-id="64aa6-143">Batching Primitives</span></span>

<span data-ttu-id="64aa6-144">Para obter o melhor desempenho de renderização durante a execução, tente trabalhar com primitivos em lotes e mantenha o número de alterações de estado de processamento o mais baixo possível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-144">To get the best rendering performance during execution, try to work with primitives in batches and keep the number of render-state changes as low as possible.</span></span> <span data-ttu-id="64aa6-145">Por exemplo, se você tiver um objeto com duas texturas, agrupe os triângulos que usam a primeira textura e siga-os com o estado de processamento necessário para alterar a textura.</span><span class="sxs-lookup"><span data-stu-id="64aa6-145">For example, if you have an object with two textures, group the triangles that use the first texture and follow them with the necessary render state to change the texture.</span></span> <span data-ttu-id="64aa6-146">Em seguida, agrupe todos os triângulos que usam a segunda textura.</span><span class="sxs-lookup"><span data-stu-id="64aa6-146">Then group all the triangles that use the second texture.</span></span> <span data-ttu-id="64aa6-147">O suporte de hardware mais simples para o Direct3D é chamado com lotes de Estados de renderização e lotes de primitivos por meio da HAL (camada de abstração de hardware).</span><span class="sxs-lookup"><span data-stu-id="64aa6-147">The simplest hardware support for Direct3D is called with batches of render states and batches of primitives through the hardware abstraction layer (HAL).</span></span> <span data-ttu-id="64aa6-148">Quanto mais efetivamente as instruções forem em lote, menos chamadas de HAL serão executadas durante a execução.</span><span class="sxs-lookup"><span data-stu-id="64aa6-148">The more effectively the instructions are batched, the fewer HAL calls are performed during execution.</span></span>

## <a name="lighting-tips"></a><span data-ttu-id="64aa6-149">Dicas de iluminação</span><span class="sxs-lookup"><span data-stu-id="64aa6-149">Lighting Tips</span></span>

<span data-ttu-id="64aa6-150">Como as luzes adicionam um custo por vértice a cada quadro renderizado, você pode melhorar o desempenho de forma significativa com o cuidado de usá-los em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-150">Because lights add a per-vertex cost to each rendered frame, you can improve performance significantly by being careful about how you use them in your application.</span></span> <span data-ttu-id="64aa6-151">A maioria das dicas a seguir derivam do máximo, "o código mais rápido é o código que nunca é chamado".</span><span class="sxs-lookup"><span data-stu-id="64aa6-151">Most of the following tips derive from the maxim, "the fastest code is code that is never called."</span></span>

-   <span data-ttu-id="64aa6-152">Use o menor número possível de fontes leves.</span><span class="sxs-lookup"><span data-stu-id="64aa6-152">Use as few light sources as possible.</span></span> <span data-ttu-id="64aa6-153">Para aumentar o nível de iluminação geral, por exemplo, use a luz ambiente em vez de adicionar uma nova fonte de luz.</span><span class="sxs-lookup"><span data-stu-id="64aa6-153">To increase the overall lighting level, for example, use the ambient light instead of adding a new light source.</span></span>
-   <span data-ttu-id="64aa6-154">Luzes direcionais são mais eficientes do que luzes de ponto ou Spotlights.</span><span class="sxs-lookup"><span data-stu-id="64aa6-154">Directional lights are more efficient than point lights or spotlights.</span></span> <span data-ttu-id="64aa6-155">Para luzes direcionais, a direção da luz é fixa e não precisa ser calculada por vértice.</span><span class="sxs-lookup"><span data-stu-id="64aa6-155">For directional lights, the direction to the light is fixed and doesn't need to be calculated on a per-vertex basis.</span></span>
-   <span data-ttu-id="64aa6-156">Os destaques podem ser mais eficientes do que as luzes de ponto, pois a área fora do cone de luz é calculada rapidamente.</span><span class="sxs-lookup"><span data-stu-id="64aa6-156">Spotlights can be more efficient than point lights, because the area outside the cone of light is calculated quickly.</span></span> <span data-ttu-id="64aa6-157">Se os Spotlights são mais eficientes ou não depende de quanto de sua cena está acesa pelo destaque.</span><span class="sxs-lookup"><span data-stu-id="64aa6-157">Whether spotlights are more efficient or not depends on how much of your scene is lit by the spotlight.</span></span>
-   <span data-ttu-id="64aa6-158">Use o parâmetro Range para limitar as luzes a apenas as partes da cena que você precisa iluminar.</span><span class="sxs-lookup"><span data-stu-id="64aa6-158">Use the range parameter to limit your lights to only the parts of the scene you need to illuminate.</span></span> <span data-ttu-id="64aa6-159">Todos os tipos de luz saem bastante cedo quando estão fora do intervalo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-159">All the light types exit fairly early when they are out of range.</span></span>
-   <span data-ttu-id="64aa6-160">Os realces especulares quase duplos são o custo de uma luz.</span><span class="sxs-lookup"><span data-stu-id="64aa6-160">Specular highlights almost double the cost of a light.</span></span> <span data-ttu-id="64aa6-161">Use-os somente quando precisar.</span><span class="sxs-lookup"><span data-stu-id="64aa6-161">Use them only when you must.</span></span> <span data-ttu-id="64aa6-162">Defina o \_ estado de RENDERIZAÇÃO D3DRS SPECULARENABLE como 0, o valor padrão, sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-162">Set the D3DRS\_SPECULARENABLE render state to 0, the default value, whenever possible.</span></span> <span data-ttu-id="64aa6-163">Ao definir materiais, você deve definir o valor de energia especular como zero para desativar os realces especulares para esse material; apenas definir a cor especular como 0, 0, 0 não é suficiente.</span><span class="sxs-lookup"><span data-stu-id="64aa6-163">When defining materials, you must set the specular power value to zero to turn off specular highlights for that material; just setting the specular color to 0,0,0 is not enough.</span></span>

## <a name="texture-size"></a><span data-ttu-id="64aa6-164">Tamanho da textura</span><span class="sxs-lookup"><span data-stu-id="64aa6-164">Texture Size</span></span>

<span data-ttu-id="64aa6-165">O desempenho de mapeamento de textura depende muito da velocidade da memória.</span><span class="sxs-lookup"><span data-stu-id="64aa6-165">Texture-mapping performance is heavily dependent on the speed of memory.</span></span> <span data-ttu-id="64aa6-166">Há várias maneiras de maximizar o desempenho do cache das texturas do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-166">There are a number of ways to maximize the cache performance of your application's textures.</span></span>

-   <span data-ttu-id="64aa6-167">Mantenha as texturas pequenas.</span><span class="sxs-lookup"><span data-stu-id="64aa6-167">Keep the textures small.</span></span> <span data-ttu-id="64aa6-168">Quanto menores forem as texturas, maior a chance de serem mantidas no cache secundário da CPU principal.</span><span class="sxs-lookup"><span data-stu-id="64aa6-168">The smaller the textures are, the better chance they have of being maintained in the main CPU's secondary cache.</span></span>
-   <span data-ttu-id="64aa6-169">Não altere as texturas em uma base por primitiva.</span><span class="sxs-lookup"><span data-stu-id="64aa6-169">Do not change the textures on a per-primitive basis.</span></span> <span data-ttu-id="64aa6-170">Tente manter os polígonos agrupados na ordem das texturas que eles usam.</span><span class="sxs-lookup"><span data-stu-id="64aa6-170">Try to keep polygons grouped in order of the textures they use.</span></span>
-   <span data-ttu-id="64aa6-171">Use texturas quadradas sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-171">Use square textures whenever possible.</span></span> <span data-ttu-id="64aa6-172">As texturas cujas dimensões são 256x256 são as mais rápidas.</span><span class="sxs-lookup"><span data-stu-id="64aa6-172">Textures whose dimensions are 256x256 are the fastest.</span></span> <span data-ttu-id="64aa6-173">Se seu aplicativo usar quatro texturas 128x128, por exemplo, tente garantir que elas usem a mesma paleta e coloque-as em uma textura 256x256.</span><span class="sxs-lookup"><span data-stu-id="64aa6-173">If your application uses four 128x128 textures, for example, try to ensure that they use the same palette and place them all into one 256x256 texture.</span></span> <span data-ttu-id="64aa6-174">Essa técnica também reduz a quantidade de permutação de textura.</span><span class="sxs-lookup"><span data-stu-id="64aa6-174">This technique also reduces the amount of texture swapping.</span></span> <span data-ttu-id="64aa6-175">É claro que você não deve usar texturas 256x256, a menos que seu aplicativo exija que muito texturing porque, como mencionado, as texturas devem ser mantidas o menor possível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-175">Of course, you should not use 256x256 textures unless your application requires that much texturing because, as mentioned, textures should be kept as small as possible.</span></span>

## <a name="matrix-transforms"></a><span data-ttu-id="64aa6-176">Transformações de matriz</span><span class="sxs-lookup"><span data-stu-id="64aa6-176">Matrix Transforms</span></span>

<span data-ttu-id="64aa6-177">O Direct3D usa as matrizes de mundo e modo de exibição que você definiu para configurar várias estruturas de dados internas.</span><span class="sxs-lookup"><span data-stu-id="64aa6-177">Direct3D uses the world and view matrices that you set to configure several internal data structures.</span></span> <span data-ttu-id="64aa6-178">Cada vez que você define um novo mundo ou uma matriz de exibição, o sistema recalcula as estruturas internas associadas.</span><span class="sxs-lookup"><span data-stu-id="64aa6-178">Each time you set a new world or view matrix, the system recalculates the associated internal structures.</span></span> <span data-ttu-id="64aa6-179">A definição dessas matrizes com frequência – por exemplo, milhares de vezes por quadro – é computacionalmente demorada.</span><span class="sxs-lookup"><span data-stu-id="64aa6-179">Setting these matrices frequently - for example, thousands of times per frame - is computationally time-consuming.</span></span> <span data-ttu-id="64aa6-180">Você pode minimizar o número de cálculos necessários concatenando as matrizes de mundo e modo de exibição em uma matriz de exibição de mundo que você define como matriz de mundo, e, em seguida, definindo a matriz de visualização para a identidade.</span><span class="sxs-lookup"><span data-stu-id="64aa6-180">You can minimize the number of required calculations by concatenating your world and view matrices into a world-view matrix that you set as the world matrix, and then setting the view matrix to the identity.</span></span> <span data-ttu-id="64aa6-181">Mantenha cópias em cache das matrizes individuais de mundo e modo de exibição para que você possa modificar, concatenar e restaurar a matriz de mundo conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="64aa6-181">Keep cached copies of individual world and view matrices so that you can modify, concatenate, and reset the world matrix as needed.</span></span> <span data-ttu-id="64aa6-182">Para maior clareza nesta documentação, os exemplos de Direct3D raramente empregam essa otimização.</span><span class="sxs-lookup"><span data-stu-id="64aa6-182">For clarity in this documentation, Direct3D samples rarely employ this optimization.</span></span>

## <a name="using-dynamic-textures"></a><span data-ttu-id="64aa6-183">Usando texturas dinâmicas</span><span class="sxs-lookup"><span data-stu-id="64aa6-183">Using Dynamic Textures</span></span>

<span data-ttu-id="64aa6-184">Para descobrir se o driver dá suporte a texturas dinâmicas, verifique o \_ sinalizador D3DCAPS2 DYNAMICTEXTURES da estrutura [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) .</span><span class="sxs-lookup"><span data-stu-id="64aa6-184">To find out if the driver supports dynamic textures, check the D3DCAPS2\_DYNAMICTEXTURES flag of the [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) structure.</span></span>

<span data-ttu-id="64aa6-185">Lembre-se das seguintes coisas ao trabalhar com texturas dinâmicas.</span><span class="sxs-lookup"><span data-stu-id="64aa6-185">Keep the following things in mind when working with dynamic textures.</span></span>

-   <span data-ttu-id="64aa6-186">Eles não podem ser gerenciados.</span><span class="sxs-lookup"><span data-stu-id="64aa6-186">They cannot be managed.</span></span> <span data-ttu-id="64aa6-187">Por exemplo, seu pool não pode ser \_ gerenciado por D3DPOOL.</span><span class="sxs-lookup"><span data-stu-id="64aa6-187">For example, their pool cannot be D3DPOOL\_MANAGED.</span></span>
-   <span data-ttu-id="64aa6-188">Texturas dinâmicas podem ser bloqueadas, mesmo que elas sejam criadas no \_ padrão D3DPOOL.</span><span class="sxs-lookup"><span data-stu-id="64aa6-188">Dynamic textures can be locked, even if they are created in D3DPOOL\_DEFAULT.</span></span>
-   <span data-ttu-id="64aa6-189">D3DLOCK \_ descarte é um sinalizador de bloqueio válido para texturas dinâmicas.</span><span class="sxs-lookup"><span data-stu-id="64aa6-189">D3DLOCK\_DISCARD is a valid lock flag for dynamic textures.</span></span>

<span data-ttu-id="64aa6-190">É uma boa ideia criar apenas uma textura dinâmica por formato e, possivelmente, por tamanho.</span><span class="sxs-lookup"><span data-stu-id="64aa6-190">It is a good idea to create only one dynamic texture per format and possibly per size.</span></span> <span data-ttu-id="64aa6-191">Mipmaps dinâmicos, cubos e volumes não são recomendados devido à sobrecarga adicional no bloqueio de cada nível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-191">Dynamic mipmaps, cubes, and volumes are not recommended because of the additional overhead in locking every level.</span></span> <span data-ttu-id="64aa6-192">Para mipmaps, o \_ descarte de D3DLOCK é permitido somente no nível superior.</span><span class="sxs-lookup"><span data-stu-id="64aa6-192">For mipmaps, D3DLOCK\_DISCARD is allowed only on the top level.</span></span> <span data-ttu-id="64aa6-193">Todos os níveis são descartados bloqueando apenas o nível superior.</span><span class="sxs-lookup"><span data-stu-id="64aa6-193">All levels are discarded by locking just the top level.</span></span> <span data-ttu-id="64aa6-194">Esse comportamento é o mesmo para volumes e cubos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-194">This behavior is the same for volumes and cubes.</span></span> <span data-ttu-id="64aa6-195">Para cubos, o nível superior e a face 0 estão bloqueados.</span><span class="sxs-lookup"><span data-stu-id="64aa6-195">For cubes, the top level and face 0 are locked.</span></span>

<span data-ttu-id="64aa6-196">O pseudocódigo a seguir mostra um exemplo de como usar uma textura dinâmica.</span><span class="sxs-lookup"><span data-stu-id="64aa6-196">The following pseudocode shows an example of using a dynamic texture.</span></span>


```
DrawProceduralTexture(pTex)
{
    // pTex should not be very small because overhead of 
    //   calling driver every D3DLOCK_DISCARD will not 
    //   justify the performance gain. Experimentation is encouraged.
    pTex->Lock(D3DLOCK_DISCARD);
    <Overwrite *entire* texture>
    pTex->Unlock();
    pDev->SetTexture();
    pDev->DrawPrimitive();
}
```



## <a name="using-dynamic-vertex-and-index-buffers"></a><span data-ttu-id="64aa6-197">Usando um vértice dinâmico e buffers de índice</span><span class="sxs-lookup"><span data-stu-id="64aa6-197">Using Dynamic Vertex and Index Buffers</span></span>

<span data-ttu-id="64aa6-198">Bloquear um buffer de vértices estáticos enquanto o processador de gráficos está usando o buffer pode ter uma penalidade de desempenho significativa.</span><span class="sxs-lookup"><span data-stu-id="64aa6-198">Locking a static vertex buffer while the graphics processor is using the buffer can have a significant performance penalty.</span></span> <span data-ttu-id="64aa6-199">A chamada de bloqueio deve aguardar até que o processador de gráficos termine de ler os dados de vértice ou de índice do buffer antes que ele possa retornar ao aplicativo de chamada, um atraso significativo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-199">The lock call must wait until the graphics processor is finished reading vertex or index data from the buffer before it can return to the calling application, a significant delay.</span></span> <span data-ttu-id="64aa6-200">O bloqueio e a renderização de um buffer estático várias vezes por quadro também impede que o processador de gráficos faça o armazenamento em buffer de comandos de renderização, já que ele deve concluir os comandos antes de retornar o ponteiro de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="64aa6-200">Locking and then rendering from a static buffer several times per frame also prevents the graphics processor from buffering rendering commands, since it must finish commands before returning the lock pointer.</span></span> <span data-ttu-id="64aa6-201">Sem comandos em buffer, o processador de gráficos permanece ocioso até que o aplicativo termine de preencher o buffer de vértices ou o buffer de índice e emita um comando de renderização.</span><span class="sxs-lookup"><span data-stu-id="64aa6-201">Without buffered commands, the graphics processor remains idle until after the application is finished filling the vertex buffer or index buffer and issues a rendering command.</span></span>

<span data-ttu-id="64aa6-202">O ideal é que os dados de vértice ou de índice nunca mudem, mas isso nem sempre é possível.</span><span class="sxs-lookup"><span data-stu-id="64aa6-202">Ideally the vertex or index data would never change, however this is not always possible.</span></span> <span data-ttu-id="64aa6-203">Há muitas situações em que o aplicativo precisa alterar os dados do vértice ou do índice a cada quadro, talvez até várias vezes por quadro.</span><span class="sxs-lookup"><span data-stu-id="64aa6-203">There are many situations where the application needs to change vertex or index data every frame, perhaps even multiple times per frame.</span></span> <span data-ttu-id="64aa6-204">Para essas situações, o vértice ou buffer de índice deve ser criado com D3DUSAGE \_ Dynamic.</span><span class="sxs-lookup"><span data-stu-id="64aa6-204">For these situations, the vertex or index buffer should be created with D3DUSAGE\_DYNAMIC.</span></span> <span data-ttu-id="64aa6-205">Esse sinalizador de uso faz com que o Direct3D Otimize para operações de bloqueio frequentes.</span><span class="sxs-lookup"><span data-stu-id="64aa6-205">This usage flag causes Direct3D to optimize for frequent lock operations.</span></span> <span data-ttu-id="64aa6-206">D3DUSAGE \_ Dynamic só é útil quando o buffer é bloqueado com frequência; os dados que permanecem constantes devem ser colocados em um buffer estático de índice ou de vértice.</span><span class="sxs-lookup"><span data-stu-id="64aa6-206">D3DUSAGE\_DYNAMIC is only useful when the buffer is locked frequently; data that remains constant should be placed in a static vertex or index buffer.</span></span>

<span data-ttu-id="64aa6-207">Para receber uma melhoria de desempenho ao usar buffers de vértice dinâmicos, o aplicativo deve chamar [**IDirect3DVertexBuffer9:: Lock**](/windows/desktop/api) ou [**IDirect3DIndexBuffer9:: Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) com os sinalizadores apropriados.</span><span class="sxs-lookup"><span data-stu-id="64aa6-207">To receive a performance improvement when using dynamic vertex buffers, the application must call [**IDirect3DVertexBuffer9::Lock**](/windows/desktop/api) or [**IDirect3DIndexBuffer9::Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) with the appropriate flags.</span></span> <span data-ttu-id="64aa6-208">D3DLOCK \_ descarte indica que o aplicativo não precisa manter o vértice antigo ou os dados de índice no buffer.</span><span class="sxs-lookup"><span data-stu-id="64aa6-208">D3DLOCK\_DISCARD indicates that the application does not need to keep the old vertex or index data in the buffer.</span></span> <span data-ttu-id="64aa6-209">Se o processador de gráficos ainda estiver usando o buffer quando o bloqueio for chamado com descarte de D3DLOCK \_ , um ponteiro para uma nova região de memória será retornado em vez dos dados de buffer antigos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-209">If the graphics processor is still using the buffer when lock is called with D3DLOCK\_DISCARD, a pointer to a new region of memory is returned instead of the old buffer data.</span></span> <span data-ttu-id="64aa6-210">Isso permite que o processador de gráficos continue usando os dados antigos enquanto o aplicativo coloca os dados no novo buffer.</span><span class="sxs-lookup"><span data-stu-id="64aa6-210">This allows the graphics processor to continue using the old data while the application places data in the new buffer.</span></span> <span data-ttu-id="64aa6-211">Nenhum gerenciamento de memória adicional é necessário no aplicativo; o buffer antigo é reutilizado ou destruído automaticamente quando o processador de gráficos é concluído com ele.</span><span class="sxs-lookup"><span data-stu-id="64aa6-211">No additional memory management is required in the application; the old buffer is reused or destroyed automatically when the graphics processor is finished with it.</span></span> <span data-ttu-id="64aa6-212">Observe que o bloqueio de um buffer com descarte de D3DLOCK \_ sempre descarta todo o buffer, especificando que um campo de tamanho de deslocamento diferente de zero ou limite não preserva as informações em áreas desbloqueadas do buffer.</span><span class="sxs-lookup"><span data-stu-id="64aa6-212">Note that locking a buffer with D3DLOCK\_DISCARD always discards the entire buffer, specifying a nonzero offset or limited size field does not preserve information in unlocked areas of the buffer.</span></span>

<span data-ttu-id="64aa6-213">Há casos em que a quantidade de dados que o aplicativo precisa armazenar por bloqueio é pequena, como adicionar quatro vértices para renderizar um Sprite.</span><span class="sxs-lookup"><span data-stu-id="64aa6-213">There are cases where the amount of data the application needs to store per lock is small, such as adding four vertices to render a sprite.</span></span> <span data-ttu-id="64aa6-214">D3DLOCK \_ NoOverwrite indica que o aplicativo não substituirá os dados que já estão em uso no buffer dinâmico.</span><span class="sxs-lookup"><span data-stu-id="64aa6-214">D3DLOCK\_NOOVERWRITE indicates that the application will not overwrite data already in use in the dynamic buffer.</span></span> <span data-ttu-id="64aa6-215">A chamada de bloqueio retornará um ponteiro para os dados antigos, permitindo que o aplicativo Adicione novos dados em regiões não utilizadas do vértice ou buffer de índice.</span><span class="sxs-lookup"><span data-stu-id="64aa6-215">The lock call will return a pointer to the old data, allowing the application to add new data in unused regions of the vertex or index buffer.</span></span> <span data-ttu-id="64aa6-216">O aplicativo não deve modificar vértices ou índices usados em uma operação de desenho, pois eles ainda podem estar em uso pelo processador de gráficos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-216">The application should not modify vertices or indices used in a draw operation as they might still be in use by the graphics processor.</span></span> <span data-ttu-id="64aa6-217">O aplicativo deve usar o \_ descarte D3DLOCK depois que o buffer dinâmico estiver cheio para receber uma nova região de memória, descartando os dados antigos do vértice ou do índice depois que o processador de gráficos for concluído.</span><span class="sxs-lookup"><span data-stu-id="64aa6-217">The application should then use D3DLOCK\_DISCARD after the dynamic buffer is full to receive a new region of memory, discarding the old vertex or index data after the graphics processor is finished.</span></span>

<span data-ttu-id="64aa6-218">O mecanismo de consulta assíncrona é útil para determinar se os vértices ainda estão em uso pelo processador de gráficos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-218">The asynchronous query mechanism is useful to determine if vertices are still in use by the graphics processor.</span></span> <span data-ttu-id="64aa6-219">Emita uma consulta do tipo \_ evento D3DQUERYTYPE após a última chamada de DrawPrimitive que usa os vértices.</span><span class="sxs-lookup"><span data-stu-id="64aa6-219">Issue a query of type D3DQUERYTYPE\_EVENT after the last DrawPrimitive call that uses the vertices.</span></span> <span data-ttu-id="64aa6-220">Os vértices não estão mais em uso quando [**IDirect3DQuery9:: GetData**](/windows/desktop/api) retorna S \_ OK.</span><span class="sxs-lookup"><span data-stu-id="64aa6-220">The vertices are no longer in use when [**IDirect3DQuery9::GetData**](/windows/desktop/api) returns S\_OK.</span></span> <span data-ttu-id="64aa6-221">Bloquear um buffer com \_ descartar D3DLOCK ou nenhum sinalizador sempre garantirá que os vértices sejam sincronizados corretamente com o processador de gráficos. no entanto, o uso do bloqueio sem sinalizadores incorrerá na penalidade de desempenho descrita anteriormente.</span><span class="sxs-lookup"><span data-stu-id="64aa6-221">Locking a buffer with D3DLOCK\_DISCARD or no flags will always guarantee the vertices are synchronized properly with the graphics processor, however using lock without flags will incur the performance penalty described earlier.</span></span> <span data-ttu-id="64aa6-222">Outras chamadas à API, como [**IDirect3DDevice9:: BeginScene**](/windows/desktop/api), [**IDirect3DDevice9:: EndScene**](/windows/desktop/api)e [**IDirect3DDevice9::P reenviadas**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) não garantem que o processador de gráficos termine de usar vértices.</span><span class="sxs-lookup"><span data-stu-id="64aa6-222">Other API calls such as [**IDirect3DDevice9::BeginScene**](/windows/desktop/api), [**IDirect3DDevice9::EndScene**](/windows/desktop/api), and [**IDirect3DDevice9::Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) do not guarantee the graphics processor is finished using vertices.</span></span>

<span data-ttu-id="64aa6-223">Veja abaixo as maneiras de usar buffers dinâmicos e os sinalizadores de bloqueio apropriados.</span><span class="sxs-lookup"><span data-stu-id="64aa6-223">Below are ways to use dynamic buffers and the proper lock flags.</span></span>


```
    // USAGE STYLE 1
    // Discard the entire vertex buffer and refill with thousands of vertices.
    // Might contain multiple objects and/or require multiple DrawPrimitive 
    //   calls separated by state changes, etc.
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // Discard and refill the used portion of the vertex buffer.
    CONST DWORD dwLockFlags = D3DLOCK_DISCARD;
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( 0, 0, &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, nNumberOfVertices/3)
```




```
    // USAGE STYLE 2
    // Reusing one vertex buffer for multiple objects
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // No overwrite will be used if the vertices can fit into 
    //   the space remaining in the vertex buffer.
    DWORD dwLockFlags = D3DLOCK_NOOVERWRITE;
    
    // Check to see if the entire vertex buffer has been used up yet.
    if( m_nNextVertexData > m_nSizeOfVB - nSizeOfData )
    {
        // No space remains. Start over from the beginning 
        //   of the vertex buffer.
        dwLockFlags = D3DLOCK_DISCARD;
        m_nNextVertexData = 0;
    }
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( (UINT)m_nNextVertexData, nSizeOfData, 
               &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 
               m_nNextVertexData/m_nVertexStride, nNumberOfVertices/3)
 
    // Advance to the next position in the vertex buffer.
    m_nNextVertexData += nSizeOfData;
```



## <a name="using-meshes"></a><span data-ttu-id="64aa6-224">Usando malhas</span><span class="sxs-lookup"><span data-stu-id="64aa6-224">Using Meshes</span></span>

<span data-ttu-id="64aa6-225">Você pode otimizar as malhas usando triângulos indexados do Direct3D em vez de faixas de triângulo indexadas.</span><span class="sxs-lookup"><span data-stu-id="64aa6-225">You can optimize meshes by using Direct3D indexed triangles instead of indexed triangle strips.</span></span> <span data-ttu-id="64aa6-226">O hardware descobrirá que 95% dos triângulos sucessivos realmente formam as faixas e se ajustam de acordo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-226">The hardware will discover that 95 percent of successive triangles actually form strips and adjust accordingly.</span></span> <span data-ttu-id="64aa6-227">Muitos drivers também fazem isso para hardware mais antigo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-227">Many drivers do this for older hardware also.</span></span>

<span data-ttu-id="64aa6-228">Os objetos de malha D3DX podem ter cada triângulo, ou face, marcado com um DWORD, chamado de atributo dessa face.</span><span class="sxs-lookup"><span data-stu-id="64aa6-228">D3DX mesh objects can have each triangle, or face, tagged with a DWORD, called the attribute of that face.</span></span> <span data-ttu-id="64aa6-229">A semântica do DWORD é definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="64aa6-229">The semantics of the DWORD are user-defined.</span></span> <span data-ttu-id="64aa6-230">Eles são usados pelo D3DX para classificar a malha em subconjuntos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-230">They are used by D3DX to classify the mesh into subsets.</span></span> <span data-ttu-id="64aa6-231">O aplicativo define os atributos por face usando a chamada [**ID3DXMesh:: LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) .</span><span class="sxs-lookup"><span data-stu-id="64aa6-231">The application sets per-face attributes using the [**ID3DXMesh::LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) call.</span></span> <span data-ttu-id="64aa6-232">O método [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md) tem uma opção para agrupar os vértices de malha e rostos em atributos usando a \_ opção ATTRSORT de D3DXMESHOPT.</span><span class="sxs-lookup"><span data-stu-id="64aa6-232">The [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) method has an option to group the mesh vertices and faces on attributes using the D3DXMESHOPT\_ATTRSORT option.</span></span> <span data-ttu-id="64aa6-233">Quando isso é feito, o objeto de malha calcula uma tabela de atributos que pode ser obtida pelo aplicativo chamando [**ID3DXBaseMesh:: Getattributetable**](id3dxbasemesh--getattributetable.md).</span><span class="sxs-lookup"><span data-stu-id="64aa6-233">When this is done, the mesh object calculates an attribute table that can be obtained by the application by calling [**ID3DXBaseMesh::GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span></span> <span data-ttu-id="64aa6-234">Essa chamada retornará 0 se a malha não estiver classificada por atributos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-234">This call returns 0 if the mesh is not sorted by attributes.</span></span> <span data-ttu-id="64aa6-235">Não há como um aplicativo definir uma tabela de atributos porque ele é gerado pelo método **ID3DXMesh:: Optimize** .</span><span class="sxs-lookup"><span data-stu-id="64aa6-235">There is no way for an application to set an attribute table because it is generated by the **ID3DXMesh::Optimize** method.</span></span> <span data-ttu-id="64aa6-236">A classificação de atributo é sensível a dados, portanto, se o aplicativo souber que uma malha é um atributo classificado, ele ainda precisará chamar **ID3DXMesh:: Optimize** para gerar a tabela de atributos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-236">The attribute sort is data sensitive, so if the application knows that a mesh is attribute sorted, it still needs to call **ID3DXMesh::Optimize** to generate the attribute table.</span></span>

<span data-ttu-id="64aa6-237">Os tópicos a seguir descrevem os diferentes atributos de uma malha.</span><span class="sxs-lookup"><span data-stu-id="64aa6-237">The following topics describe the different attributes of a mesh.</span></span>

### <a name="attribute-id"></a><span data-ttu-id="64aa6-238">ID do atributo</span><span class="sxs-lookup"><span data-stu-id="64aa6-238">Attribute ID</span></span>

<span data-ttu-id="64aa6-239">Uma ID de atributo é um valor que associa um grupo de rostos a um grupo de atributos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-239">An attribute id is a value that associates a group of faces with an attribute group.</span></span> <span data-ttu-id="64aa6-240">Essa ID descreve qual subconjunto de rostos [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) deve desenhar.</span><span class="sxs-lookup"><span data-stu-id="64aa6-240">This id describes which subset of faces [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) should draw.</span></span> <span data-ttu-id="64aa6-241">As IDs de atributo são especificadas para as faces no buffer de atributo.</span><span class="sxs-lookup"><span data-stu-id="64aa6-241">Attribute ids are specified for the faces in the attribute buffer.</span></span> <span data-ttu-id="64aa6-242">Os valores reais das IDs de atributo podem ser qualquer coisa que caiba em 32 bits, mas é comum usar 0 a n, em que n é o número de atributos.</span><span class="sxs-lookup"><span data-stu-id="64aa6-242">The actual values of the attribute ids can be anything that fits in 32 bits, but it is common to use 0 to n where n is the number of attributes.</span></span>

### <a name="attribute-buffer"></a><span data-ttu-id="64aa6-243">Buffer de atributo</span><span class="sxs-lookup"><span data-stu-id="64aa6-243">Attribute Buffer</span></span>

<span data-ttu-id="64aa6-244">O buffer de atributo é uma matriz de DWORDs (um por face) que especifica a qual grupo de atributos cada face pertence.</span><span class="sxs-lookup"><span data-stu-id="64aa6-244">The attribute buffer is an array of DWORDs (one per face) that specifies which attribute group each face belongs in.</span></span> <span data-ttu-id="64aa6-245">Esse buffer é inicializado para zero na criação de uma malha, mas é preenchido pelas rotinas de carga ou deve ser preenchido pelo usuário se mais de um atributo com ID 0 for desejado.</span><span class="sxs-lookup"><span data-stu-id="64aa6-245">This buffer is initialized to zero on creation of a mesh, but is either filled by the load routines or must be filled by the user if more than one attribute with id 0 is desired.</span></span> <span data-ttu-id="64aa6-246">Esse buffer contém as informações que são usadas para classificar a malha com base em atributos em [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md).</span><span class="sxs-lookup"><span data-stu-id="64aa6-246">This buffer contains the information that is used to sort the mesh based on attributes in [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md).</span></span> <span data-ttu-id="64aa6-247">Se nenhuma tabela de atributos estiver presente, [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) examinará esse buffer para selecionar as faces do atributo fornecido a serem desenhados.</span><span class="sxs-lookup"><span data-stu-id="64aa6-247">If no attribute table is present, [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) scans this buffer to select the faces of the given attribute to draw.</span></span>

### <a name="attribute-table"></a><span data-ttu-id="64aa6-248">Tabela de atributos</span><span class="sxs-lookup"><span data-stu-id="64aa6-248">Attribute Table</span></span>

<span data-ttu-id="64aa6-249">A tabela de atributos é uma estrutura de propriedade e mantida pela malha.</span><span class="sxs-lookup"><span data-stu-id="64aa6-249">The attribute table is a structure owned and maintained by the mesh.</span></span> <span data-ttu-id="64aa6-250">A única maneira de gerar um a ser gerado é chamando [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md) com classificação de atributo ou otimização mais forte habilitada.</span><span class="sxs-lookup"><span data-stu-id="64aa6-250">The only way for one to be generated is by calling [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) with attribute sorting or stronger optimization enabled.</span></span> <span data-ttu-id="64aa6-251">A tabela de atributos é usada para iniciar rapidamente uma única chamada primitiva de desenho para [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md).</span><span class="sxs-lookup"><span data-stu-id="64aa6-251">The attribute table is used to quickly initiate a single draw primitive call to [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md).</span></span> <span data-ttu-id="64aa6-252">O único outro uso é que o progresso das malhas também mantém essa estrutura, portanto, é possível ver quais faces e vértices estão ativos no nível de detalhes atual.</span><span class="sxs-lookup"><span data-stu-id="64aa6-252">The only other use is that progressing meshes also maintain this structure, so it is possible to see what faces and vertices are active at the current level of detail.</span></span>

## <a name="z-buffer-performance"></a><span data-ttu-id="64aa6-253">Desempenho de buffer Z</span><span class="sxs-lookup"><span data-stu-id="64aa6-253">Z-Buffer Performance</span></span>

<span data-ttu-id="64aa6-254">Os aplicativos podem aumentar o desempenho ao usar o buffer z e texturização, garantindo que as cenas sejam renderizadas da frente para trás.</span><span class="sxs-lookup"><span data-stu-id="64aa6-254">Applications can increase performance when using z-buffering and texturing by ensuring that scenes are rendered from front to back.</span></span> <span data-ttu-id="64aa6-255">Buffers z texturizados primitivos são pré-testados em relação ao buffer z em uma base de linha de varredura.</span><span class="sxs-lookup"><span data-stu-id="64aa6-255">Textured z-buffered primitives are pretested against the z-buffer on a scan line basis.</span></span> <span data-ttu-id="64aa6-256">Se uma linha de varredura for ocultada por um polígono renderizado anteriormente, o sistema a rejeita com rapidez e eficiência.</span><span class="sxs-lookup"><span data-stu-id="64aa6-256">If a scan line is hidden by a previously rendered polygon, the system rejects it quickly and efficiently.</span></span> <span data-ttu-id="64aa6-257">O buffer Z pode melhorar o desempenho, mas a técnica é mais útil quando uma cena desenha os mesmos pixels mais de uma vez.</span><span class="sxs-lookup"><span data-stu-id="64aa6-257">Z-buffering can improve performance, but the technique is most useful when a scene draws the same pixels more than once.</span></span> <span data-ttu-id="64aa6-258">Isso é difícil de calcular exatamente, mas geralmente, você pode obter uma boa aproximação.</span><span class="sxs-lookup"><span data-stu-id="64aa6-258">This is difficult to calculate exactly, but you can often make a close approximation.</span></span> <span data-ttu-id="64aa6-259">Se os mesmos pixels forem desenhados menos de duas vezes, você pode obter o melhor desempenho desativando o buffer z e renderizando a cena de trás para frente.</span><span class="sxs-lookup"><span data-stu-id="64aa6-259">If the same pixels are drawn less than twice, you can achieve the best performance by turning z-buffering off and rendering the scene from back to front.</span></span>

## <a name="related-topics"></a><span data-ttu-id="64aa6-260">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="64aa6-260">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="64aa6-261">Dicas de programação</span><span class="sxs-lookup"><span data-stu-id="64aa6-261">Programming Tips</span></span>](programming-tips.md)
</dt> </dl>

 

 
