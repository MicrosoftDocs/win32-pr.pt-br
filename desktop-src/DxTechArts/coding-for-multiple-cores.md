---
title: Codificação para vários núcleos no Xbox 360 e no Windows
description: Este tópico fornece conselhos sobre como começar a usar a programação multithread.
ms.assetid: 661f13a6-c73d-8513-2bad-0ef9d1a361a0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 75899dacdfba829fc1a83e9393e6aa58574c9f30
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/21/2020
ms.locfileid: "104366903"
---
# <a name="coding-for-multicore-on-xbox-360-and-windows"></a><span data-ttu-id="0559c-103">Codificação para vários núcleos no Xbox 360 e no Windows</span><span class="sxs-lookup"><span data-stu-id="0559c-103">Coding for multicore on Xbox 360 and Windows</span></span>

<span data-ttu-id="0559c-104">Durante anos, o desempenho dos processadores aumentou constantemente, e jogos e outros programas têm aproveitado os benefícios dessa crescente capacidade, sem a necessidade de fazer nada de especial.</span><span class="sxs-lookup"><span data-stu-id="0559c-104">For years the performance of processors has increased steadily, and games and other programs have reaped the benefits of this increasing power without having to do anything special.</span></span>

<span data-ttu-id="0559c-105">As regras foram alteradas.</span><span class="sxs-lookup"><span data-stu-id="0559c-105">The rules have changed.</span></span> <span data-ttu-id="0559c-106">O desempenho de núcleos de processador único agora está aumentando muito lentamente, se houver.</span><span class="sxs-lookup"><span data-stu-id="0559c-106">The performance of single processor cores is now increasing very slowly, if at all.</span></span> <span data-ttu-id="0559c-107">No entanto, o poder de computação disponível em um computador ou console típico continua crescendo.</span><span class="sxs-lookup"><span data-stu-id="0559c-107">However, the computing power available in a typical computer or console continues to grow.</span></span> <span data-ttu-id="0559c-108">A diferença é que a maior parte desse lucro de desempenho agora vem de ter vários núcleos de processador em um único computador, geralmente em um único chip.</span><span class="sxs-lookup"><span data-stu-id="0559c-108">The difference is that most of this performance gain now comes from having multiple processor cores in a single machine, often in a single chip.</span></span> <span data-ttu-id="0559c-109">A CPU do Xbox 360 tem três núcleos de processador em um chip, e aproximadamente 70% dos processadores de PC vendidos no 2006 eram vários núcleos.</span><span class="sxs-lookup"><span data-stu-id="0559c-109">The Xbox 360 CPU has three processor cores on one chip, and roughly 70 percent of PC processors sold in 2006 were multi-core.</span></span>

<span data-ttu-id="0559c-110">Os aumentos no poder de processamento disponível são tão significativos quanto no passado, mas agora os desenvolvedores precisam escrever código multithread para usar essa potência.</span><span class="sxs-lookup"><span data-stu-id="0559c-110">The increases in available processing power are just as dramatic as in the past, but now developers have to write multithreaded code in order to use this power.</span></span> <span data-ttu-id="0559c-111">A programação multi-threaded traz novos desafios de design e programação.</span><span class="sxs-lookup"><span data-stu-id="0559c-111">Multi-threaded programming brings with it new design and programming challenges.</span></span> <span data-ttu-id="0559c-112">Este tópico fornece conselhos sobre como começar a usar a programação multithread.</span><span class="sxs-lookup"><span data-stu-id="0559c-112">This topic gives some advice on how to get started with multithreaded programming.</span></span>

## <a name="the-importance-of-good-design"></a><span data-ttu-id="0559c-113">A importância de um bom design</span><span class="sxs-lookup"><span data-stu-id="0559c-113">The Importance of Good Design</span></span>

<span data-ttu-id="0559c-114">O bom design de programa multithread é essencial, mas pode ser muito difícil.</span><span class="sxs-lookup"><span data-stu-id="0559c-114">Good multithreaded program design is critical, but it can be very difficult.</span></span> <span data-ttu-id="0559c-115">Se você mover aleatoriamente seus principais sistemas de jogos para threads diferentes, provavelmente descobrirá que cada thread passa a maior parte de seu tempo aguardando os outros threads.</span><span class="sxs-lookup"><span data-stu-id="0559c-115">If you haphazardly move your major game systems onto different threads, you will likely find that each thread spends most of its time waiting on the other threads.</span></span> <span data-ttu-id="0559c-116">Esse tipo de design leva a uma maior complexidade e um esforço de depuração significativo, praticamente sem nenhum ganho de desempenho.</span><span class="sxs-lookup"><span data-stu-id="0559c-116">This type of design leads to increased complexity and significant debugging effort, with virtually no performance gain.</span></span>

<span data-ttu-id="0559c-117">Toda vez que os threads precisam sincronizar ou compartilhar dados, há o potencial de corrupção de dados, sobrecarga de sincronização, deadlocks e complexidade.</span><span class="sxs-lookup"><span data-stu-id="0559c-117">Every time that threads have to synchronize or share data there is the potential for data corruption, synchronization overhead, deadlocks, and complexity.</span></span> <span data-ttu-id="0559c-118">Portanto, seu design multithread precisa documentar claramente todos os pontos de sincronização e de comunicação, e ele deve minimizar esses pontos tanto quanto possível.</span><span class="sxs-lookup"><span data-stu-id="0559c-118">Therefore, your multithreaded design needs to clearly document every synchronization and communication point, and it should minimize such points as much as possible.</span></span> <span data-ttu-id="0559c-119">Onde os threads precisam se comunicar, o esforço de codificação aumentará, o que pode reduzir a produtividade se afetar muito código-fonte.</span><span class="sxs-lookup"><span data-stu-id="0559c-119">Where threads need to communicate, coding effort will increase, which can lower productivity if it affects too much source code.</span></span>

<span data-ttu-id="0559c-120">A meta de design mais simples para multithreading é dividir o código em grandes partes independentes.</span><span class="sxs-lookup"><span data-stu-id="0559c-120">The simplest design goal for multithreading is to break up the code into large independent pieces.</span></span> <span data-ttu-id="0559c-121">Se, em seguida, você restringir essas partes para se comunicar apenas algumas vezes por quadro, verá um aumento significativo do multithreading, sem complexidade indevida.</span><span class="sxs-lookup"><span data-stu-id="0559c-121">If you then restrict these pieces to communicating just a few times per frame, you will see significant speedup from multithreading, without undue complexity.</span></span>

## <a name="typical-threaded-tasks"></a><span data-ttu-id="0559c-122">Tarefas em thread típicas</span><span class="sxs-lookup"><span data-stu-id="0559c-122">Typical Threaded Tasks</span></span>

<span data-ttu-id="0559c-123">Alguns tipos de tarefas têm comprovado receptivos de serem colocados em threads separados.</span><span class="sxs-lookup"><span data-stu-id="0559c-123">A few types of tasks have proven amenable to being put onto separate threads.</span></span> <span data-ttu-id="0559c-124">A lista a seguir não deve ser exaustiva, mas deve dar algumas ideias.</span><span class="sxs-lookup"><span data-stu-id="0559c-124">The following list is not intended to be exhaustive, but should give some ideas.</span></span>

### <a name="rendering"></a><span data-ttu-id="0559c-125">Renderização</span><span class="sxs-lookup"><span data-stu-id="0559c-125">Rendering</span></span>

<span data-ttu-id="0559c-126">Renderização — que pode incluir a movimentação do grafo de cena ou, possivelmente, chamar apenas funções de D3D — muitas vezes conta com 50% ou mais de tempo de CPU.</span><span class="sxs-lookup"><span data-stu-id="0559c-126">Rendering — which may include walking the scene graph or, possibly, only calling D3D functions — often accounts for 50 percent or more of CPU time.</span></span> <span data-ttu-id="0559c-127">Portanto, mover o processamento para outro thread pode ter benefícios significativos.</span><span class="sxs-lookup"><span data-stu-id="0559c-127">Therefore, moving rendering to another thread can have significant benefits.</span></span> <span data-ttu-id="0559c-128">O thread de atualização pode preencher algum tipo de buffer de descrição de renderização, que o thread de renderização pode processar.</span><span class="sxs-lookup"><span data-stu-id="0559c-128">The update thread can fill in some sort of render description buffer, which the rendering thread can then process.</span></span>

<span data-ttu-id="0559c-129">O thread de atualização do jogo sempre é um quadro à frente do thread de renderização, o que significa que ele leva dois quadros antes que as ações do usuário apareçam na tela.</span><span class="sxs-lookup"><span data-stu-id="0559c-129">The game update thread is always one frame ahead of the render thread, which means that it takes two frames before user actions show up on the screen.</span></span> <span data-ttu-id="0559c-130">Embora essa latência maior possa ser um problema, a taxa de quadros aumentada da divisão da carga de trabalho geralmente mantém a latência total aceitável.</span><span class="sxs-lookup"><span data-stu-id="0559c-130">Although this increased latency can be a problem, the increased frame rate from splitting up the workload generally keeps the total latency acceptable.</span></span>

<span data-ttu-id="0559c-131">Na maioria dos casos, toda a renderização ainda é feita em um único thread, mas é um thread diferente da atualização do jogo.</span><span class="sxs-lookup"><span data-stu-id="0559c-131">In most cases all rendering is still done on a single thread, but it is a different thread from the game update.</span></span>

<span data-ttu-id="0559c-132">O \_ sinalizador MULTITHREAD D3DCREATE, às vezes, é usado para permitir a renderização em um thread e a criação de recursos em outros threads; esse sinalizador é ignorado no Xbox 360 e você deve evitar usá-lo no Windows.</span><span class="sxs-lookup"><span data-stu-id="0559c-132">The D3DCREATE\_MULTITHREADED flag is sometimes used to allow rendering on one thread and resource creation on other threads; this flag is ignored on Xbox 360, and you should avoid using it on Windows.</span></span> <span data-ttu-id="0559c-133">No Windows, a especificação desse sinalizador força o D3D a gastar uma quantidade significativa de tempo na sincronização, tornando o thread de renderização mais lento.</span><span class="sxs-lookup"><span data-stu-id="0559c-133">On Windows, specifying this flag forces D3D to spend a significant amount of time on synchronization, thus slowing down the render thread.</span></span>

### <a name="file-decompression"></a><span data-ttu-id="0559c-134">Descompactação de arquivo</span><span class="sxs-lookup"><span data-stu-id="0559c-134">File Decompression</span></span>

<span data-ttu-id="0559c-135">Os tempos de carregamento são sempre muito longos e o streaming de dados na memória sem afetar a taxa de quadros pode ser desafiador.</span><span class="sxs-lookup"><span data-stu-id="0559c-135">Load times are always too long, and streaming data into memory without affecting the frame rate can be challenging.</span></span> <span data-ttu-id="0559c-136">Se todos os dados forem compactados agressivamente no disco, a velocidade de transferência de dados do disco rígido ou do dísco óptico será menos provável de ser um fator limitante.</span><span class="sxs-lookup"><span data-stu-id="0559c-136">If all data is aggressively compressed on disc, then data transfer speed from the hard drive or optical disc is less likely to be a limiting factor.</span></span> <span data-ttu-id="0559c-137">Em um processador de thread único, geralmente não há tempo de processador suficiente disponível para compactação para ajudar a carregar tempos.</span><span class="sxs-lookup"><span data-stu-id="0559c-137">On a single-threaded processor, there is usually not enough processor time available for compression to help load times.</span></span> <span data-ttu-id="0559c-138">No entanto, em um sistema multiprocessador, a descompactação de arquivo usa ciclos de CPU que, de outra forma, seriam desperdiçados; Ele melhora os tempos de carregamento e o streaming; e economiza espaço no disco.</span><span class="sxs-lookup"><span data-stu-id="0559c-138">On a multiprocessor system, however, file decompression uses CPU cycles that would otherwise be wasted; it improves load times and streaming; and it saves space on the disc.</span></span>

<span data-ttu-id="0559c-139">Não use a descompactação de arquivo como uma substituição para o processamento que deve ser feito durante a produção.</span><span class="sxs-lookup"><span data-stu-id="0559c-139">Do not use file decompression as a replacement for processing that should be done during production.</span></span> <span data-ttu-id="0559c-140">Por exemplo, se você dedicar um thread extra para analisar dados XML durante o carregamento de nível, você não está usando multithreading para melhorar a experiência do jogador.</span><span class="sxs-lookup"><span data-stu-id="0559c-140">For instance, if you devote an extra thread to parsing XML data during level loading, you are not using multithreading to improve the player's experience.</span></span>

<span data-ttu-id="0559c-141">Ao usar um thread de descompactação de arquivo, você ainda deve usar e/s de arquivo assíncrono e leituras grandes para maximizar a eficiência da leitura de dados.</span><span class="sxs-lookup"><span data-stu-id="0559c-141">When using a file decompression thread, you should still use asynchronous file I/O and large reads in order to maximize data-reading efficiency.</span></span>

### <a name="graphics-fluff"></a><span data-ttu-id="0559c-142">Trivialidades de gráficos</span><span class="sxs-lookup"><span data-stu-id="0559c-142">Graphics Fluff</span></span>

<span data-ttu-id="0559c-143">Há muitos iguarias gráficos que melhoram a aparência do jogo, mas não são estritamente necessários.</span><span class="sxs-lookup"><span data-stu-id="0559c-143">There are many graphical niceties that improve the look of the game but aren't strictly necessary.</span></span> <span data-ttu-id="0559c-144">Isso inclui coisas como animações de nuvem geradas em procedimentos, simulações de tecido e de cabelo, ondas de procedimentos, vegetação de procedimentos, mais partículas ou física não cheia.</span><span class="sxs-lookup"><span data-stu-id="0559c-144">These include things like procedurally generated cloud animations, cloth and hair simulations, procedural waves, procedural vegetation, more particles, or non-gameplay physics.</span></span>

<span data-ttu-id="0559c-145">Como esses efeitos não afetam o jogo, eles não causam problemas de sincronização complicados – eles podem sincronizar com os outros threads uma vez por quadro ou com menos frequência.</span><span class="sxs-lookup"><span data-stu-id="0559c-145">Because these effects don't affect gameplay, they don't cause tricky synchronization problems—they can synchronize with the other threads once per frame or less often.</span></span> <span data-ttu-id="0559c-146">Além disso, em jogos para Windows, esses efeitos podem agregar valor para os jogadores com CPUs de vários núcleos, enquanto são omitidos silenciosamente em computadores de núcleo único, dando uma maneira fácil de dimensionar em uma ampla gama de recursos.</span><span class="sxs-lookup"><span data-stu-id="0559c-146">Additionally, on games for Windows these effects can add value for gamers with multicore CPUs, while silently being omitted on single-core computers, thus giving an easy way of scaling across a wide range of capabilities.</span></span>

### <a name="physics"></a><span data-ttu-id="0559c-147">Física</span><span class="sxs-lookup"><span data-stu-id="0559c-147">Physics</span></span>

<span data-ttu-id="0559c-148">A física geralmente não pode ser colocada em um thread separado para ser executado em paralelo com a atualização do jogo, pois a atualização do jogo geralmente requer os resultados dos cálculos de física imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0559c-148">Physics often cannot be put onto a separate thread to run in parallel with the game update because the game update usually requires the results of the physics calculations immediately.</span></span> <span data-ttu-id="0559c-149">A alternativa para a física multithread é executá-la em vários processadores.</span><span class="sxs-lookup"><span data-stu-id="0559c-149">The alternative for multithreading physics is to run it on multiple processors.</span></span> <span data-ttu-id="0559c-150">Embora isso possa ser feito, é uma tarefa complexa que exige acesso frequente a estruturas de dados compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="0559c-150">Although this can be done, it is a complex task requiring frequent access to shared data structures.</span></span> <span data-ttu-id="0559c-151">Se você puder manter a carga de trabalho da sua física baixa o suficiente para se ajustar ao thread principal, sua tarefa será mais simples.</span><span class="sxs-lookup"><span data-stu-id="0559c-151">If you can keep your physics workload low enough to fit on the main thread, your job will be simpler.</span></span>

<span data-ttu-id="0559c-152">Bibliotecas que oferecem suporte à física em execução em vários threads estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="0559c-152">Libraries that support running physics on multiple threads are available.</span></span> <span data-ttu-id="0559c-153">No entanto, isso pode levar a um problema: quando o jogo está executando a física, ele usa vários threads, mas o restante do tempo que ele usa poucos.</span><span class="sxs-lookup"><span data-stu-id="0559c-153">However, this can lead to a problem: when your game is running physics, it uses many threads, but the rest of the time it uses few.</span></span> <span data-ttu-id="0559c-154">Executar a física em vários threads exigirá resolver isso para que a carga de trabalho seja distribuída uniformemente no quadro.</span><span class="sxs-lookup"><span data-stu-id="0559c-154">Running physics on multiple threads will require addressing this so that the workload is distributed evenly over the frame.</span></span> <span data-ttu-id="0559c-155">Se você escrever um mecanismo de física multithread, deverá prestar atenção cuidadosa a todas as estruturas de dados, pontos de sincronização e balanceamento de carga.</span><span class="sxs-lookup"><span data-stu-id="0559c-155">If you write a multithreaded physics engine, you must pay careful attention to all of your data structures, synchronization points, and load balancing.</span></span>

## <a name="example-multithreaded-designs"></a><span data-ttu-id="0559c-156">Exemplos de designs multithread</span><span class="sxs-lookup"><span data-stu-id="0559c-156">Example Multithreaded Designs</span></span>

<span data-ttu-id="0559c-157">Os jogos para Windows precisam ser executados em computadores com números diferentes de núcleos de CPU.</span><span class="sxs-lookup"><span data-stu-id="0559c-157">Games for Windows need to run on computers with different numbers of CPU cores.</span></span> <span data-ttu-id="0559c-158">A maioria das máquinas de jogos ainda tem apenas um núcleo, embora o número de máquinas de dois núcleos esteja crescendo rapidamente.</span><span class="sxs-lookup"><span data-stu-id="0559c-158">Most game machines still have only one core, although the number of two-core machines is growing rapidly.</span></span> <span data-ttu-id="0559c-159">Um jogo típico do Windows pode dividir sua carga de trabalho em um thread para atualização e renderização, com threads de trabalho opcionais para adicionar funcionalidade extra.</span><span class="sxs-lookup"><span data-stu-id="0559c-159">A typical game for Windows might break its workload into one thread for update and rendering, with optional worker threads for adding extra functionality.</span></span> <span data-ttu-id="0559c-160">Além disso, alguns threads em segundo plano para fazer a e/s de arquivo e a rede provavelmente seriam usados.</span><span class="sxs-lookup"><span data-stu-id="0559c-160">In addition, some background threads for doing file I/O and networking would probably be used.</span></span> <span data-ttu-id="0559c-161">A Figura 1 mostra os threads, juntamente com os principais pontos de transferência de dados.</span><span class="sxs-lookup"><span data-stu-id="0559c-161">Figure 1 shows the threads, together with the main data transfer points.</span></span>

<span data-ttu-id="0559c-162">**Figura 1. Design de Threading em um jogo para Windows**</span><span class="sxs-lookup"><span data-stu-id="0559c-162">**Figure 1. Threading design in a game for Windows**</span></span>

![design de Threading em um jogo para Windows](images/coding-for-multiple-cores-1.gif)

<span data-ttu-id="0559c-164">Um jogo típico do Xbox 360 pode usar threads de software adicionais com uso intensivo de CPU, portanto, ele pode dividir sua carga de trabalho em um thread de atualização, thread de renderização e três threads, como mostra a Figura 2.</span><span class="sxs-lookup"><span data-stu-id="0559c-164">A typical Xbox 360 game can use additional CPU-intensive software threads, so it might break up its workload into an update thread, rendering thread, and three worker threads, as shown in Figure 2.</span></span>

<span data-ttu-id="0559c-165">**Figura 2. Design de Threading em um jogo para o Xbox 360**</span><span class="sxs-lookup"><span data-stu-id="0559c-165">**Figure 2. Threading design in a game for Xbox 360**</span></span>

![design de Threading em um jogo para o Xbox 360](images/coding-for-multiple-cores-2.gif)

<span data-ttu-id="0559c-167">Com exceção da e/s de arquivo e da rede, todas essas tarefas têm o potencial de ter uso intensivo de CPU para se beneficiarem do seu próprio thread de hardware.</span><span class="sxs-lookup"><span data-stu-id="0559c-167">With the exception of file I/O and networking, these tasks all have the potential to be CPU-intensive enough to benefit from being on their own hardware thread.</span></span> <span data-ttu-id="0559c-168">Essas tarefas também têm o potencial de ser independente o suficiente para que possam ser executadas em um quadro inteiro sem se comunicar.</span><span class="sxs-lookup"><span data-stu-id="0559c-168">These tasks also have the potential to be independent enough that they can run for an entire frame without communicating.</span></span>

<span data-ttu-id="0559c-169">O thread de atualização de jogo gerencia a entrada do controlador, ia e física, e prepara as instruções para os outros quatro threads.</span><span class="sxs-lookup"><span data-stu-id="0559c-169">The game update thread manages controller input, AI, and physics, and prepares instructions for the other four threads.</span></span> <span data-ttu-id="0559c-170">Essas instruções são colocadas em buffers de Propriedade do thread de atualização do jogo, portanto, nenhuma sincronização é necessária à medida que as instruções são geradas.</span><span class="sxs-lookup"><span data-stu-id="0559c-170">These instructions are placed into buffers owned by the game update thread, so no synchronization is required as the instructions are generated.</span></span>

<span data-ttu-id="0559c-171">No final do quadro, o thread de atualização do jogo entrega os buffers de instruções para os quatro outros threads e, em seguida, começa a trabalhar no próximo quadro, preenchendo outro conjunto de buffers de instruções.</span><span class="sxs-lookup"><span data-stu-id="0559c-171">At the end of the frame, the game update thread hands off the instruction buffers to the four other threads, and then starts working on the next frame, filling in another set of instruction buffers.</span></span>

<span data-ttu-id="0559c-172">Como os threads de atualização e de renderização funcionam em atrelada entre si, seus buffers de comunicação são simplesmente armazenados em buffer duplo: a qualquer momento, o thread de atualização está preenchendo um buffer enquanto o thread de renderização está lendo do outro.</span><span class="sxs-lookup"><span data-stu-id="0559c-172">Because the update and rendering threads work in lockstep with each other, their communication buffers are simply double buffered: at any given time, the update thread is filling one buffer while the render thread is reading from the other.</span></span>

<span data-ttu-id="0559c-173">Os outros threads de trabalho não estão necessariamente ligados à taxa de quadros.</span><span class="sxs-lookup"><span data-stu-id="0559c-173">The other worker threads are not necessarily tied to the frame rate.</span></span> <span data-ttu-id="0559c-174">A descompactação de dados pode levar muito menos do que um quadro ou pode levar muitos quadros.</span><span class="sxs-lookup"><span data-stu-id="0559c-174">Decompressing a piece of data may take much less than a frame, or it may take many frames.</span></span> <span data-ttu-id="0559c-175">Até mesmo a simulação de tecido e cabelo pode não precisar ser executada exatamente na taxa de quadros porque atualizações menos frequentes podem ser bem aceitáveis.</span><span class="sxs-lookup"><span data-stu-id="0559c-175">Even the cloth and hair simulation may not need to run exactly at the frame rate because less frequent updates may be quite acceptable.</span></span> <span data-ttu-id="0559c-176">Portanto, esses três threads precisam de estruturas de dados diferentes para se comunicar com o thread de atualização e com o thread de renderização.</span><span class="sxs-lookup"><span data-stu-id="0559c-176">Therefore, these three threads need different data structures to communicate with the update thread and the render thread.</span></span> <span data-ttu-id="0559c-177">Cada uma delas precisa de uma fila de entrada que possa conter solicitações de trabalho, e o thread de processamento precisa de uma fila de dados que possa conter os resultados produzidos pelos threads.</span><span class="sxs-lookup"><span data-stu-id="0559c-177">They each need an input queue that can hold work requests, and the render thread needs a data queue that can hold the results produced by the threads.</span></span> <span data-ttu-id="0559c-178">Ao final de cada quadro, o thread de atualização adicionará um bloco de solicitações de trabalho às filas de threads de trabalho.</span><span class="sxs-lookup"><span data-stu-id="0559c-178">At the end of each frame the update thread will add a block of work requests to worker threads' queues.</span></span> <span data-ttu-id="0559c-179">Adicionar à lista apenas uma vez por quadro garante que o thread de atualização Minimize a sobrecarga de sincronização.</span><span class="sxs-lookup"><span data-stu-id="0559c-179">Adding to the list just once per frame ensures that the update thread minimizes the synchronization overhead.</span></span> <span data-ttu-id="0559c-180">Cada um dos threads de trabalho efetua pull das atribuições da fila de trabalho da forma mais rápida possível, usando um loop semelhante a este:</span><span class="sxs-lookup"><span data-stu-id="0559c-180">Each of the worker threads pulls assignments from the work queue as quickly as it can, using a loop that looks something like this:</span></span>


```C++
for(;;)
{
    while( WorkQueueNotEmpty() )
    {
        RemoveWorkItemFromWorkQueue();
        ProcessWorkItem();
        PutResultInDataQueue();
    }
    WaitForSingleObject( hWorkSemaphore ); 
}
```



<span data-ttu-id="0559c-181">Como os dados vão dos threads de atualização para os threads de trabalho e, em seguida, para o thread de renderização, pode haver um atraso de três ou mais quadros antes que algumas ações o façam na tela.</span><span class="sxs-lookup"><span data-stu-id="0559c-181">Because the data goes from the update threads to the worker threads and then to the render thread, there can be a delay of three or more frames before some actions make it to the screen.</span></span> <span data-ttu-id="0559c-182">No entanto, se você atribuir tarefas tolerantes à latência para os threads de trabalho, isso não deverá ser um problema.</span><span class="sxs-lookup"><span data-stu-id="0559c-182">However, if you assign latency-tolerant tasks to the worker threads, then this should not be a problem.</span></span>

<span data-ttu-id="0559c-183">Um design alternativo seria ter vários threads de trabalho desenhando da mesma fila de trabalho.</span><span class="sxs-lookup"><span data-stu-id="0559c-183">An alternate design would be to have several worker threads all drawing from the same work queue.</span></span> <span data-ttu-id="0559c-184">Isso daria um balanceamento de carga automático e tornaria mais provável que todos os threads de trabalho permaneçam ocupados.</span><span class="sxs-lookup"><span data-stu-id="0559c-184">This would give automatic load balancing and would make it more likely that all of the worker threads would stay busy.</span></span>

<span data-ttu-id="0559c-185">O thread de atualização do jogo deve tomar cuidado para não dar muito trabalho aos threads de trabalho ou, caso contrário, as filas de trabalho podem crescer continuamente.</span><span class="sxs-lookup"><span data-stu-id="0559c-185">The game update thread must take care to not give too much work to the worker threads, or else the work queues may continuously grow.</span></span> <span data-ttu-id="0559c-186">Como o thread de atualização gerencia isso depende do tipo de tarefas que os threads de trabalho estão fazendo.</span><span class="sxs-lookup"><span data-stu-id="0559c-186">How the update thread manages this depends on what sort of tasks the worker threads are doing.</span></span>

## <a name="simultaneous-multithreading-and-number-of-threads"></a><span data-ttu-id="0559c-187">Vários threads e número de threads simultâneos</span><span class="sxs-lookup"><span data-stu-id="0559c-187">Simultaneous Multithreading and Number of Threads</span></span>

<span data-ttu-id="0559c-188">Todos os threads não são criados como iguais.</span><span class="sxs-lookup"><span data-stu-id="0559c-188">All threads are not created equal.</span></span> <span data-ttu-id="0559c-189">Dois threads de hardware podem estar em chips separados, no mesmo chip ou mesmo no mesmo núcleo.</span><span class="sxs-lookup"><span data-stu-id="0559c-189">Two hardware threads might be on separate chips, on the same chip, or even on the same core.</span></span> <span data-ttu-id="0559c-190">A configuração mais importante para programadores de jogos a serem cientes é dois threads de hardware em um núcleo – SMT (processos de multithreading simultâneos) ou tecnologia de Hyper-Threading (tecnologia HT).</span><span class="sxs-lookup"><span data-stu-id="0559c-190">The most important configuration for game programmers to be aware of is two hardware threads on one core—Simultaneous Multi-Threading (SMT) or Hyper-Threading Technology (HT Technology).</span></span>

<span data-ttu-id="0559c-191">Os threads de tecnologia SMT ou HT compartilham os recursos do núcleo da CPU.</span><span class="sxs-lookup"><span data-stu-id="0559c-191">SMT or HT Technology threads share the resources of the CPU core.</span></span> <span data-ttu-id="0559c-192">Como eles compartilham as unidades de execução, a velocidade máxima de execução de dois threads em vez de um é normalmente de 10 a 20%, em vez do percentual de 100 que é possível de dois threads de hardware independentes.</span><span class="sxs-lookup"><span data-stu-id="0559c-192">Because they share the execution units, the maximum speedup from running two threads instead of one is typically 10 to 20 percent, instead of the 100 percent that is possible from two independent hardware threads.</span></span>

<span data-ttu-id="0559c-193">Os threads de tecnologia mais significativamente, SMT ou HT compartilham a instrução L1 e os caches de dados.</span><span class="sxs-lookup"><span data-stu-id="0559c-193">More significantly, SMT or HT Technology threads share the L1 instruction and data caches.</span></span> <span data-ttu-id="0559c-194">Se seus padrões de acesso à memória forem incompatíveis, eles poderão acabar combatendo o cache e causando muitos erros de cache.</span><span class="sxs-lookup"><span data-stu-id="0559c-194">If their memory access patterns are incompatible, they can end up fighting over the cache and causing many cache misses.</span></span> <span data-ttu-id="0559c-195">Na pior das hipóteses, o desempenho total para o núcleo da CPU pode realmente diminuir quando um segundo thread é executado.</span><span class="sxs-lookup"><span data-stu-id="0559c-195">In the worst case, the total performance for the CPU core can actually decrease when a second thread is run.</span></span> <span data-ttu-id="0559c-196">No Xbox 360, esse é um problema bastante simples.</span><span class="sxs-lookup"><span data-stu-id="0559c-196">On Xbox 360, this is a fairly simple problem.</span></span> <span data-ttu-id="0559c-197">A configuração do Xbox 360 é conhecida — três núcleos de CPU cada um com dois threads de hardware — e os desenvolvedores atribuem seus threads de software a threads de CPU específicos e podem medir para ver se seu design de Threading oferece desempenho extra.</span><span class="sxs-lookup"><span data-stu-id="0559c-197">The configuration of the Xbox 360 is known—three CPU cores each with two hardware threads—and developers assign their software threads to specific CPU threads and can measure to see whether their threading design gives them extra performance.</span></span>

<span data-ttu-id="0559c-198">No Windows, a situação é mais complicada.</span><span class="sxs-lookup"><span data-stu-id="0559c-198">On Windows, the situation is more complicated.</span></span> <span data-ttu-id="0559c-199">O número de threads e sua configuração variam de computador para computador, e a determinação da configuração é complicada.</span><span class="sxs-lookup"><span data-stu-id="0559c-199">The number of threads and their configuration will vary from computer to computer, and determining the configuration is complicated.</span></span> <span data-ttu-id="0559c-200">A função [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) fornece informações sobre a relação entre diferentes threads de hardware, e essa função está disponível no Windows Vista, no Windows 7 e no Windows XP SP3.</span><span class="sxs-lookup"><span data-stu-id="0559c-200">The function [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) gives information about the relationship between different hardware threads, and this function is available on Windows Vista, Windows 7, and Windows XP SP3.</span></span> <span data-ttu-id="0559c-201">Portanto, por enquanto, você precisa usar a instrução CPUID e os algoritmos fornecidos pela Intel e AMD para decidir quantos threads "reais" estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="0559c-201">Therefore, for now you have to use the CPUID instruction and the algorithms given by Intel and AMD in order to decide how many "real" threads you have available.</span></span> <span data-ttu-id="0559c-202">Consulte as referências para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="0559c-202">See the references for more information.</span></span>

<span data-ttu-id="0559c-203">O exemplo de CoreDetection no SDK do DirectX contém um código de exemplo que usa a função [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) ou a instrução CPUID para retornar a topologia de núcleo da CPU.</span><span class="sxs-lookup"><span data-stu-id="0559c-203">The CoreDetection sample in the DirectX SDK contains sample code that uses the [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) function or the CPUID instruction to return the CPU core topology.</span></span> <span data-ttu-id="0559c-204">A instrução CPUID será usada se **GetLogicalProcessorInformation** não tiver suporte na plataforma atual.</span><span class="sxs-lookup"><span data-stu-id="0559c-204">The CPUID instruction is used if **GetLogicalProcessorInformation** is not supported on the current platform.</span></span> <span data-ttu-id="0559c-205">CoreDetection pode ser encontrado nos seguintes locais:</span><span class="sxs-lookup"><span data-stu-id="0559c-205">CoreDetection can be found in the following locations:</span></span>

<dl> <dt>

<span data-ttu-id="0559c-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Original</span><span class="sxs-lookup"><span data-stu-id="0559c-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Source:</span></span>
</dt> <dd>

<span data-ttu-id="0559c-207">Raiz do SDK do *DirectX* \\ Exemplos de \\ CoreDetection de C++ \\ misc \\</span><span class="sxs-lookup"><span data-stu-id="0559c-207">*DirectX SDK root*\\Samples\\C++\\Misc\\CoreDetection</span></span>

</dd> <dt>

<span data-ttu-id="0559c-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Executá</span><span class="sxs-lookup"><span data-stu-id="0559c-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Executable:</span></span>
</dt> <dd>

<span data-ttu-id="0559c-209">Raiz do SDK do *DirectX* \\ Amostras \\ de \\ \\CoreDetection.exe misc \\ bin do C++</span><span class="sxs-lookup"><span data-stu-id="0559c-209">*DirectX SDK root*\\Samples\\C++\\Misc\\Bin\\CoreDetection.exe</span></span>

</dd> </dl>

<span data-ttu-id="0559c-210">A suposição mais segura é não ter mais de um thread com uso intensivo de CPU por núcleo de CPU.</span><span class="sxs-lookup"><span data-stu-id="0559c-210">The safest assumption is to have no more than one CPU-intensive thread per CPU core.</span></span> <span data-ttu-id="0559c-211">Ter mais threads com uso intensivo de CPU que os núcleos de CPU oferece pouco ou nenhum benefício e traz a sobrecarga extra e a complexidade de threads adicionais.</span><span class="sxs-lookup"><span data-stu-id="0559c-211">Having more CPU-intensive threads than CPU cores gives little or no benefits, and brings the extra overhead and complexity of additional threads.</span></span>

## <a name="creating-threads"></a><span data-ttu-id="0559c-212">Criando threads</span><span class="sxs-lookup"><span data-stu-id="0559c-212">Creating Threads</span></span>

<span data-ttu-id="0559c-213">A criação de threads é uma operação bastante simples, mas há muitos erros potenciais.</span><span class="sxs-lookup"><span data-stu-id="0559c-213">Creating threads is a fairly simple operation, but there are many potential errors.</span></span> <span data-ttu-id="0559c-214">O código a seguir mostra a maneira apropriada de criar um thread, aguardando que ele seja encerrado e, em seguida, limpando.</span><span class="sxs-lookup"><span data-stu-id="0559c-214">The code below shows the proper way of creating a thread, waiting for it to terminate, and then cleaning up.</span></span>


```C++
const int stackSize = 65536;
HANDLE hThread = (HANDLE)_beginthreadex( 0, stackSize,
            ThreadFunction, 0, 0, 0 );
// Do work on main thread here.
// Wait for child thread to complete
WaitForSingleObject( hThread, INFINITE );
CloseHandle( hThread );

...

unsigned __stdcall ThreadFunction( void* data )
{
#if _XBOX_VER >= 200
    // On Xbox 360 you must explicitly assign
    // software threads to hardware threads.
    XSetThreadProcessor( GetCurrentThread(), 2 );
#endif
    // Do child thread work here.
    return 0;
}
```



<span data-ttu-id="0559c-215">Ao criar um thread, você tem a opção de especificar o tamanho da pilha para o thread filho ou especificar zero. nesse caso, o thread filho herdará o tamanho da pilha do thread pai.</span><span class="sxs-lookup"><span data-stu-id="0559c-215">When you create a thread, you have the option to specify the stack size for the child thread, or specify zero, in which case the child thread will inherit the parent thread's stack size.</span></span> <span data-ttu-id="0559c-216">No Xbox 360, em que as pilhas são totalmente confirmadas quando o thread é iniciado, a especificação de zero pode perder memória significativa, pois muitos threads filho não precisarão tanto de pilha como o pai.</span><span class="sxs-lookup"><span data-stu-id="0559c-216">On Xbox 360, where stacks are fully committed when the thread starts, specifying zero can waste significant memory, because many child threads will not need as much stack as the parent.</span></span> <span data-ttu-id="0559c-217">No Xbox 360, também é importante que o tamanho da pilha seja um múltiplo de 64 KB.</span><span class="sxs-lookup"><span data-stu-id="0559c-217">On Xbox 360 it is also important that the stack size be a multiple of 64-KB.</span></span>

<span data-ttu-id="0559c-218">Se você usar a função [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) para criar threads, o tempo de execução do C/C++ (CRT) não será inicializado corretamente no Windows.</span><span class="sxs-lookup"><span data-stu-id="0559c-218">If you use the [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) function to create threads, then the C/C++ runtime (CRT) will not get properly initialized on Windows.</span></span> <span data-ttu-id="0559c-219">É recomendável usar a função [**\_ BEGINTHREADEX**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) do CRT em vez disso.</span><span class="sxs-lookup"><span data-stu-id="0559c-219">We recommend that you use the CRT [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) function instead.</span></span>

<span data-ttu-id="0559c-220">O valor de retorno de [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) ou [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) é um identificador de thread.</span><span class="sxs-lookup"><span data-stu-id="0559c-220">The return value from [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) or [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) is a thread handle.</span></span> <span data-ttu-id="0559c-221">Esse thread pode ser usado para aguardar a finalização do thread filho, o que é muito mais simples e muito mais eficiente do que a rotação em um loop verificando o status do thread.</span><span class="sxs-lookup"><span data-stu-id="0559c-221">This thread can be used to wait for the child thread to terminate, which is much simpler and much more efficient than spinning in a loop checking the thread status.</span></span> <span data-ttu-id="0559c-222">Para aguardar até que o thread seja encerrado, basta chamar [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) com o identificador de thread.</span><span class="sxs-lookup"><span data-stu-id="0559c-222">To wait for the thread to terminate, simply call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) with the thread handle.</span></span>

<span data-ttu-id="0559c-223">Os recursos para o thread não serão liberados até que o thread seja encerrado e o identificador de thread tenha sido fechado.</span><span class="sxs-lookup"><span data-stu-id="0559c-223">The resources for the thread will not be freed until the thread has terminated and the thread handle has been closed.</span></span> <span data-ttu-id="0559c-224">Portanto, é importante fechar o identificador de thread com [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) quando você terminar.</span><span class="sxs-lookup"><span data-stu-id="0559c-224">Therefore, it is important to close the thread handle with [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) when you are finished with it.</span></span> <span data-ttu-id="0559c-225">Se você estiver aguardando o thread terminar com [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), não se esqueça de fechar o identificador até que a espera seja concluída.</span><span class="sxs-lookup"><span data-stu-id="0559c-225">If you will be waiting for the thread to terminate with [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), be sure to not close the handle until after the wait has completed.</span></span>

<span data-ttu-id="0559c-226">No Xbox 360, você deve atribuir explicitamente threads de software a um determinado thread de hardware usando **XSetThreadProcessor**.</span><span class="sxs-lookup"><span data-stu-id="0559c-226">On Xbox 360, you must explicitly assign software threads to a particular hardware thread by using **XSetThreadProcessor**.</span></span> <span data-ttu-id="0559c-227">Caso contrário, todos os threads filho permanecerão no mesmo thread de hardware que o pai.</span><span class="sxs-lookup"><span data-stu-id="0559c-227">Otherwise, all child threads will stay on the same hardware thread as the parent.</span></span> <span data-ttu-id="0559c-228">No Windows, você pode usar o [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) para sugerir fortemente para o sistema operacional em que threads de hardware seu thread deve ser executado.</span><span class="sxs-lookup"><span data-stu-id="0559c-228">On Windows, you can use [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) to strongly suggest to the operating system which hardware threads your thread should run on.</span></span> <span data-ttu-id="0559c-229">Essa técnica deve, em geral, ser evitada no Windows, já que você não sabe quais outros processos podem estar em execução no sistema.</span><span class="sxs-lookup"><span data-stu-id="0559c-229">This technique should generally be avoided on Windows since you don't know what other processes might be running on the system.</span></span> <span data-ttu-id="0559c-230">Normalmente, é melhor permitir que o Agendador do Windows atribua seus threads a threads de hardware ociosos.</span><span class="sxs-lookup"><span data-stu-id="0559c-230">It is typically better to let the Windows scheduler assign your threads to idle hardware threads.</span></span>

<span data-ttu-id="0559c-231">A criação de threads é uma operação cara.</span><span class="sxs-lookup"><span data-stu-id="0559c-231">Creating threads is an expensive operation.</span></span> <span data-ttu-id="0559c-232">Os threads devem ser criados e destruídos raramente.</span><span class="sxs-lookup"><span data-stu-id="0559c-232">Threads should be created and destroyed rarely.</span></span> <span data-ttu-id="0559c-233">Se você quiser criar e destruir threads com frequência, use um pool de threads que esperam pelo trabalho em vez disso.</span><span class="sxs-lookup"><span data-stu-id="0559c-233">If you find yourself wanting to create and destroy threads frequently, use a pool of threads that wait around for work instead.</span></span>

## <a name="synchronizing-threads"></a><span data-ttu-id="0559c-234">Sincronizando threads</span><span class="sxs-lookup"><span data-stu-id="0559c-234">Synchronizing Threads</span></span>

<span data-ttu-id="0559c-235">Para que vários threads funcionem juntos, você deve ser capaz de sincronizar threads, passar mensagens e solicitar acesso exclusivo aos recursos.</span><span class="sxs-lookup"><span data-stu-id="0559c-235">For multiple threads to work together, you must be able to synchronize threads, pass messages, and request exclusive access to resources.</span></span> <span data-ttu-id="0559c-236">O Windows e o Xbox 360 vêm com um rico conjunto de primitivos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="0559c-236">Windows and Xbox 360 come with a rich set of synchronization primitives.</span></span> <span data-ttu-id="0559c-237">Para obter detalhes completos sobre esses primitivos de sincronização, consulte a documentação da plataforma.</span><span class="sxs-lookup"><span data-stu-id="0559c-237">For full details on these synchronization primitives, see the platform documentation.</span></span>

### <a name="exclusive-access"></a><span data-ttu-id="0559c-238">Acesso exclusivo</span><span class="sxs-lookup"><span data-stu-id="0559c-238">Exclusive Access</span></span>

<span data-ttu-id="0559c-239">Obter acesso exclusivo a um recurso, estrutura de dados ou caminho de código é uma necessidade comum.</span><span class="sxs-lookup"><span data-stu-id="0559c-239">Gaining exclusive access to a resource, data structure, or code path is a common need.</span></span> <span data-ttu-id="0559c-240">Uma opção para obter acesso exclusivo é um mutex, cujo uso típico é mostrado aqui.</span><span class="sxs-lookup"><span data-stu-id="0559c-240">One option for gaining exclusive access is a mutex, whose typical usage is shown here.</span></span>


```C++
// Initialize
HANDLE mutex = CreateMutex( 0, FALSE, 0 );

// Use
void ManipulateSharedData()
{
    WaitForSingleObject( mutex, INFINITE );
    // Manipulate stuff...
    ReleaseMutex( mutex );
}

// Destroy
CloseHandle( mutex );
The kernel guarantees that, for a particular mutex, only one thread at a time can 
acquire it.
The main disadvantage to mutexes is that they are relatively expensive to acquire 
and release. A faster alternative is a critical section.
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection( &cs );

// Use
void ManipulateSharedData()
{
    EnterCriticalSection( &cs );
    // Manipulate stuff...
    LeaveCriticalSection( &cs );
}

// Destroy
DeleteCriticalSection( &cs );
```



<span data-ttu-id="0559c-241">As seções críticas têm semântica semelhante a mutexes, mas podem ser usadas para sincronizar somente dentro de um processo, não entre processos.</span><span class="sxs-lookup"><span data-stu-id="0559c-241">Critical sections have similar semantics to mutexes, but they can be used to synchronize only within a process, not between processes.</span></span> <span data-ttu-id="0559c-242">Sua principal vantagem é que eles são executados aproximadamente vinte vezes mais rápido do que os mutexes.</span><span class="sxs-lookup"><span data-stu-id="0559c-242">Their main advantage is that they execute roughly twenty times faster than mutexes.</span></span>

### <a name="events"></a><span data-ttu-id="0559c-243">Eventos</span><span class="sxs-lookup"><span data-stu-id="0559c-243">Events</span></span>

<span data-ttu-id="0559c-244">Se dois threads — talvez um thread de atualização e um thread de renderização — estiverem usando um par de buffers de descrição de renderização, eles precisarão de uma maneira de indicar quando eles são concluídos com seu buffer específico.</span><span class="sxs-lookup"><span data-stu-id="0559c-244">If two threads—perhaps an update thread and a render thread—are taking turns using a pair of render description buffers, they need a way to indicate when they are done with their particular buffer.</span></span> <span data-ttu-id="0559c-245">Isso pode ser feito associando um evento (alocado com [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) a cada buffer.</span><span class="sxs-lookup"><span data-stu-id="0559c-245">This can be done by associating an event (allocated with [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) with each buffer.</span></span> <span data-ttu-id="0559c-246">Quando um thread é concluído com um buffer, ele pode usar [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) para sinalizar isso e pode chamar [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) no evento do outro buffer.</span><span class="sxs-lookup"><span data-stu-id="0559c-246">When a thread is done with a buffer, it can use [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) to signal this, and can then call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) on the other buffer's event.</span></span> <span data-ttu-id="0559c-247">Essa técnica extrapola facilmente a um buffer triplo de recursos.</span><span class="sxs-lookup"><span data-stu-id="0559c-247">This technique extrapolates easily to triple buffering of resources.</span></span>

### <a name="semaphores"></a><span data-ttu-id="0559c-248">Semáforos</span><span class="sxs-lookup"><span data-stu-id="0559c-248">Semaphores</span></span>

<span data-ttu-id="0559c-249">Um semáforo é usado para controlar quantos threads podem ser executados e é comumente usado para implementar filas de trabalho.</span><span class="sxs-lookup"><span data-stu-id="0559c-249">A semaphore is used to control how many threads can be running and is commonly used to implement work queues.</span></span> <span data-ttu-id="0559c-250">Um thread adiciona trabalho a uma fila e usa [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) sempre que adiciona um novo item à fila.</span><span class="sxs-lookup"><span data-stu-id="0559c-250">One thread adds work to a queue and uses [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) whenever it adds a new item to the queue.</span></span> <span data-ttu-id="0559c-251">Isso permite que um thread de trabalho seja liberado do pool de threads em espera.</span><span class="sxs-lookup"><span data-stu-id="0559c-251">This allows one worker thread to be released from the pool of waiting threads.</span></span> <span data-ttu-id="0559c-252">Os threads de trabalho apenas chamam [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)e, quando eles são retornados, há um item de trabalho na fila para eles.</span><span class="sxs-lookup"><span data-stu-id="0559c-252">The worker threads just call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and when it returns they know there is a work item in the queue for them.</span></span> <span data-ttu-id="0559c-253">Além disso, uma seção crítica ou outra técnica de sincronização deve ser usada para garantir o acesso seguro à fila de trabalho compartilhada.</span><span class="sxs-lookup"><span data-stu-id="0559c-253">In addition, a critical section or other synchronization technique must be used in order to guarantee safe access to the shared work queue.</span></span>

### <a name="avoid-suspendthread"></a><span data-ttu-id="0559c-254">Evitar SuspendThread</span><span class="sxs-lookup"><span data-stu-id="0559c-254">Avoid SuspendThread</span></span>

<span data-ttu-id="0559c-255">Às vezes, quando você deseja que um thread pare o que está fazendo, é tentador usar [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) em vez dos primitivos de sincronização corretos.</span><span class="sxs-lookup"><span data-stu-id="0559c-255">Sometimes when you want a thread to stop what it is doing, it is tempting to use [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) instead of the correct synchronization primitives.</span></span> <span data-ttu-id="0559c-256">Essa é sempre uma ideia inadequada e pode facilmente causar deadlocks e outros problemas.</span><span class="sxs-lookup"><span data-stu-id="0559c-256">This is always a bad idea and can easily lead to deadlocks and other problems.</span></span> <span data-ttu-id="0559c-257">**SuspendThread** também interage incorretamente com o depurador do Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="0559c-257">**SuspendThread** also interacts badly with the Visual Studio debugger.</span></span> <span data-ttu-id="0559c-258">Evite **SuspendThread**.</span><span class="sxs-lookup"><span data-stu-id="0559c-258">Avoid **SuspendThread**.</span></span> <span data-ttu-id="0559c-259">Em vez disso, use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="0559c-259">Use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) instead.</span></span>

### <a name="waitforsingleobject-and-waitformultipleobjects"></a><span data-ttu-id="0559c-260">WaitForSingleObject e WaitForMultipleObjects</span><span class="sxs-lookup"><span data-stu-id="0559c-260">WaitForSingleObject and WaitForMultipleObjects</span></span>

<span data-ttu-id="0559c-261">A função [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) é a função de sincronização mais comumente usada.</span><span class="sxs-lookup"><span data-stu-id="0559c-261">The function [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) is the most commonly used synchronization function.</span></span> <span data-ttu-id="0559c-262">No entanto, às vezes você deseja que um thread aguarde até que várias condições sejam atendidas simultaneamente ou até que um de um conjunto de condições seja atendido.</span><span class="sxs-lookup"><span data-stu-id="0559c-262">However, sometimes you want a thread to wait until several conditions are simultaneously satisfied, or until one of a set of conditions are satisfied.</span></span> <span data-ttu-id="0559c-263">Nesse caso, você deve usar [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span><span class="sxs-lookup"><span data-stu-id="0559c-263">In this case, you should use [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

### <a name="interlocked-functions-and-lockless-programming"></a><span data-ttu-id="0559c-264">Funções intercadeados e programação de bloqueio</span><span class="sxs-lookup"><span data-stu-id="0559c-264">Interlocked Functions and Lockless Programming</span></span>

<span data-ttu-id="0559c-265">Há uma família de funções para executar operações simples de thread-safe sem usar bloqueios.</span><span class="sxs-lookup"><span data-stu-id="0559c-265">There is a family of functions for performing simple thread-safe operations without using locks.</span></span> <span data-ttu-id="0559c-266">Essas são as famílias de funções intercadeados, como [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span><span class="sxs-lookup"><span data-stu-id="0559c-266">These are the Interlocked family of functions, such as [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span></span> <span data-ttu-id="0559c-267">Essas funções, além de outras técnicas que usam uma configuração cuidadosa dos sinalizadores, são conhecidas como programação de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="0559c-267">These functions, plus other techniques using careful setting of flags, are together known as lockless programming.</span></span> <span data-ttu-id="0559c-268">A programação sem bloqueio pode ser extremamente complicada para fazer corretamente e é substancialmente mais difícil no Xbox 360 do que no Windows.</span><span class="sxs-lookup"><span data-stu-id="0559c-268">Lockless programming can be extremely tricky to do correctly, and is substantially more difficult on Xbox 360 than on Windows.</span></span>

<span data-ttu-id="0559c-269">Para obter mais informações sobre programação sem bloqueios, consulte [considerações de programação de bloqueio para o Xbox 360 e o Microsoft Windows](./lockless-programming.md).</span><span class="sxs-lookup"><span data-stu-id="0559c-269">For more information about programming without locks, see [Lockless Programming Considerations for Xbox 360 and Microsoft Windows](./lockless-programming.md).</span></span>

### <a name="minimizing-synchronization"></a><span data-ttu-id="0559c-270">Minimizando a sincronização</span><span class="sxs-lookup"><span data-stu-id="0559c-270">Minimizing Synchronization</span></span>

<span data-ttu-id="0559c-271">Alguns métodos de sincronização são mais rápidos do que outros.</span><span class="sxs-lookup"><span data-stu-id="0559c-271">Some synchronization methods are faster than others.</span></span> <span data-ttu-id="0559c-272">No entanto, em vez de otimizar seu código escolhendo as técnicas de sincronização mais rápidas possíveis, geralmente é melhor sincronizar com menos frequência.</span><span class="sxs-lookup"><span data-stu-id="0559c-272">However, rather than optimizing your code by choosing the fastest synchronization techniques possible, it is usually better to synchronize less often.</span></span> <span data-ttu-id="0559c-273">Isso é mais rápido do que a sincronização com muita frequência e torna o código mais simples que é mais fácil de depurar.</span><span class="sxs-lookup"><span data-stu-id="0559c-273">This is faster than synchronizing too frequently, and it makes for simpler code that is easier to debug.</span></span>

<span data-ttu-id="0559c-274">Algumas operações, como a alocação de memória, podem precisar usar primitivos de sincronização para funcionar corretamente.</span><span class="sxs-lookup"><span data-stu-id="0559c-274">Some operations, such as memory allocation, may have to use synchronization primitives in order to work correctly.</span></span> <span data-ttu-id="0559c-275">Portanto, fazer alocações frequentes do heap compartilhado padrão resultará em uma sincronização frequente, o que perderá algum desempenho.</span><span class="sxs-lookup"><span data-stu-id="0559c-275">Therefore, doing frequent allocations from the default shared heap will result in frequent synchronization, which will waste some performance.</span></span> <span data-ttu-id="0559c-276">Evitar alocações frequentes ou usar heaps por thread (usando HEAP \_ sem \_ serialização se você usar HeapCreate) pode evitar essa sincronização oculta.</span><span class="sxs-lookup"><span data-stu-id="0559c-276">Avoiding frequent allocations or using per-thread heaps (using HEAP\_NO\_SERIALIZE if you use HeapCreate) can avoid this hidden synchronization.</span></span>

<span data-ttu-id="0559c-277">Outra causa da sincronização oculta é o D3DCREATE \_ multithread, que faz com que o D3D no Windows Use a sincronização em várias operações.</span><span class="sxs-lookup"><span data-stu-id="0559c-277">Another cause of hidden synchronization is D3DCREATE\_MULTITHREADED, which causes D3D on Windows to use synchronization on many operations.</span></span> <span data-ttu-id="0559c-278">(O sinalizador é ignorado no Xbox 360.)</span><span class="sxs-lookup"><span data-stu-id="0559c-278">(The flag is ignored on Xbox 360.)</span></span>

<span data-ttu-id="0559c-279">Os dados por thread, também conhecidos como armazenamento local de thread, podem ser uma maneira importante de evitar a sincronização.</span><span class="sxs-lookup"><span data-stu-id="0559c-279">Per-thread data, also known as thread local storage, can be an important way of avoiding synchronization.</span></span> <span data-ttu-id="0559c-280">Visual C++ permite declarar variáveis globais como sendo por thread com a sintaxe **\_ \_ declspec (thread)** .</span><span class="sxs-lookup"><span data-stu-id="0559c-280">Visual C++ allows you to declare global variables as being per-thread with the **\_\_declspec(thread)** syntax.</span></span>


```C++
__declspec( thread ) int tls_i = 1;
```



<span data-ttu-id="0559c-281">Isso fornece a cada thread no processo sua própria cópia do TLS \_ i, que pode ser referenciado com segurança e eficiência sem a necessidade de sincronização.</span><span class="sxs-lookup"><span data-stu-id="0559c-281">This gives each thread in the process its own copy of tls\_i, which can be referenced safely and efficiently without requiring synchronization.</span></span>

<span data-ttu-id="0559c-282">A técnica de **\_ \_ declspec (thread)** não funciona com DLLs carregadas dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="0559c-282">The **\_\_declspec(thread)** technique does not work with dynamically loaded DLLs.</span></span> <span data-ttu-id="0559c-283">Se você usar DLLs carregadas dinamicamente, será necessário usar a família de funções TLSAlloc para implementar o armazenamento local de thread.</span><span class="sxs-lookup"><span data-stu-id="0559c-283">If you use dynamically loaded DLLs, you will need to use the TLSAlloc family of functions to implement thread local storage.</span></span>

## <a name="destroying-threads"></a><span data-ttu-id="0559c-284">Destruindo threads</span><span class="sxs-lookup"><span data-stu-id="0559c-284">Destroying Threads</span></span>

<span data-ttu-id="0559c-285">A única maneira segura de destruir um thread é fazer com que o próprio thread saia, seja retornando da função de thread principal ou fazendo com que a chamada de thread [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) ou [**\_ endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span><span class="sxs-lookup"><span data-stu-id="0559c-285">The only safe way to destroy a thread is to have the thread itself exit, either by returning from the main thread function or by having the thread call [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) or [**\_endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span></span> <span data-ttu-id="0559c-286">Se um thread for criado com [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), ele deverá usar **\_ endthreadex** ou retornar da função de thread principal, pois o uso do **ExitThread** não liberará corretamente os recursos de CRT.</span><span class="sxs-lookup"><span data-stu-id="0559c-286">If a thread is created with [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), then it should use **\_endthreadex** or return from the main thread function, since using **ExitThread** won't properly free CRT resources.</span></span> <span data-ttu-id="0559c-287">Nunca chame a função [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) , pois o thread não será limpo corretamente.</span><span class="sxs-lookup"><span data-stu-id="0559c-287">Never call the [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) function, because the thread will not be properly cleaned up.</span></span> <span data-ttu-id="0559c-288">Os threads sempre devem confirmar suicida — eles nunca devem ser Murdered.</span><span class="sxs-lookup"><span data-stu-id="0559c-288">Threads should always commit suicide—they should never be murdered.</span></span>

## <a name="openmp"></a><span data-ttu-id="0559c-289">OpenMP</span><span class="sxs-lookup"><span data-stu-id="0559c-289">OpenMP</span></span>

<span data-ttu-id="0559c-290">O OpenMP é uma extensão de linguagem para adicionar multithread ao seu programa usando pragmas para guiar o compilador em paralelizar loops.</span><span class="sxs-lookup"><span data-stu-id="0559c-290">OpenMP is a language extension for adding multithreading to your program by using pragmas to guide the compiler in parallelizing loops.</span></span> <span data-ttu-id="0559c-291">O OpenMP tem suporte pelo Visual C++ 2005 no Windows e no Xbox 360 e pode ser usado em conjunto com o gerenciamento manual de threads.</span><span class="sxs-lookup"><span data-stu-id="0559c-291">OpenMP is supported by Visual C++ 2005 on Windows and Xbox 360 and can be used in conjunction with manual thread management.</span></span> <span data-ttu-id="0559c-292">O OpenMP pode ser uma maneira conveniente de multithread partes do seu código, mas é improvável que seja a solução ideal, especialmente para jogos.</span><span class="sxs-lookup"><span data-stu-id="0559c-292">OpenMP can be a convenient way to multithread parts of your code, but is unlikely to be the ideal solution, especially for games.</span></span> <span data-ttu-id="0559c-293">O OpenMP pode ser mais aplicável a tarefas de produção de execução mais longa, como o processamento de arte e outros recursos.</span><span class="sxs-lookup"><span data-stu-id="0559c-293">OpenMP may be more applicable to longer-running production tasks such as processing art and other resources.</span></span> <span data-ttu-id="0559c-294">Para obter mais informações, consulte a documentação do Visual C++ ou vá para o [site](https://www.openmp.org/)de OpenMP.</span><span class="sxs-lookup"><span data-stu-id="0559c-294">For more information, see the Visual C++ documentation or go to the OpenMP [website](https://www.openmp.org/).</span></span>

## <a name="profiling"></a><span data-ttu-id="0559c-295">Criação de perfil</span><span class="sxs-lookup"><span data-stu-id="0559c-295">Profiling</span></span>

<span data-ttu-id="0559c-296">A criação de perfil multithread é importante.</span><span class="sxs-lookup"><span data-stu-id="0559c-296">Multithreaded profiling is important.</span></span> <span data-ttu-id="0559c-297">É fácil terminar com interrupções longas em que os threads estão aguardando uns aos outros.</span><span class="sxs-lookup"><span data-stu-id="0559c-297">It is easy to end up with long stalls where threads are waiting on each other.</span></span> <span data-ttu-id="0559c-298">Essas vagas podem ser difíceis de encontrar e diagnosticar.</span><span class="sxs-lookup"><span data-stu-id="0559c-298">These stalls can be difficult to find and diagnose.</span></span> <span data-ttu-id="0559c-299">Para ajudar a identificá-los, considere adicionar instrumentação às suas chamadas de sincronização.</span><span class="sxs-lookup"><span data-stu-id="0559c-299">To help identify them, consider adding instrumentation to your synchronization calls.</span></span> <span data-ttu-id="0559c-300">Um criador de perfil de amostragem também pode ajudar a identificar esses problemas porque ele pode registrar informações de tempo sem alterá-los substancialmente.</span><span class="sxs-lookup"><span data-stu-id="0559c-300">A sampling profiler can also help identify these problems because it can record timing information without substantially altering it.</span></span>

## <a name="timing"></a><span data-ttu-id="0559c-301">Timing</span><span class="sxs-lookup"><span data-stu-id="0559c-301">Timing</span></span>

<span data-ttu-id="0559c-302">A instrução RDTSC é uma maneira de obter informações precisas sobre o tempo no Windows.</span><span class="sxs-lookup"><span data-stu-id="0559c-302">The rdtsc instruction is one way to get accurate timing information on Windows.</span></span> <span data-ttu-id="0559c-303">Infelizmente, o RDTSC tem vários problemas que o tornam uma opção inadequada para o seu título de entrega.</span><span class="sxs-lookup"><span data-stu-id="0559c-303">Unfortunately, rdtsc has multiple problems that make it a poor choice for your shipping title.</span></span> <span data-ttu-id="0559c-304">Os contadores RDTSC não são necessariamente sincronizados entre CPUs, portanto, quando o thread se move entre os threads de hardware, você pode obter diferenças grandes positivos ou negativas.</span><span class="sxs-lookup"><span data-stu-id="0559c-304">The rdtsc counters are not necessarily synchronized between CPUs, so when your thread moves between hardware threads you may get large positive or negative differences.</span></span> <span data-ttu-id="0559c-305">Dependendo das configurações de gerenciamento de energia, a frequência na qual o contador RDTSC é incrementado também pode mudar à medida que seu jogo é executado.</span><span class="sxs-lookup"><span data-stu-id="0559c-305">Depending on power management settings, the frequency at which the rdtsc counter increments may also change as your game runs.</span></span> <span data-ttu-id="0559c-306">Para evitar essas dificuldades, você deve preferir [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) e [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) para o tempo de alta precisão em seu jogo de envio.</span><span class="sxs-lookup"><span data-stu-id="0559c-306">To avoid these difficulties, you should prefer [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) for high-precision timing in your shipping game.</span></span> <span data-ttu-id="0559c-307">Para obter mais informações sobre o tempo, consulte os [processadores de tempo de jogo e vários núcleos](./game-timing-and-multicore-processors.md).</span><span class="sxs-lookup"><span data-stu-id="0559c-307">For more information about timing, see [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md).</span></span>

## <a name="debugging"></a><span data-ttu-id="0559c-308">Depuração</span><span class="sxs-lookup"><span data-stu-id="0559c-308">Debugging</span></span>

<span data-ttu-id="0559c-309">O Visual Studio dá suporte total à depuração multithread para Windows e Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="0559c-309">Visual Studio fully supports multithreaded debugging for Windows and Xbox 360.</span></span> <span data-ttu-id="0559c-310">A janela threads do Visual Studio permite alternar entre threads a fim de ver as diferentes pilhas de chamadas e variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="0559c-310">The Visual Studio threads window lets you switch between threads in order to see the different call stacks and local variables.</span></span> <span data-ttu-id="0559c-311">A janela threads também permite congelar e descongelar Threads específicos.</span><span class="sxs-lookup"><span data-stu-id="0559c-311">The threads window also lets you freeze and thaw particular threads.</span></span>

<span data-ttu-id="0559c-312">No Xbox 360, você pode usar a Metavariável **\@ hwthread** na janela Watch para mostrar o thread de hardware no qual o thread de software selecionado no momento está em execução.</span><span class="sxs-lookup"><span data-stu-id="0559c-312">On Xbox 360, you can use the **\@hwthread** meta-variable in the watch window to show the hardware thread on which the currently selected software thread is running.</span></span>

<span data-ttu-id="0559c-313">A janela threads é mais fácil de usar se você nomear seus threads de forma significativa.</span><span class="sxs-lookup"><span data-stu-id="0559c-313">The threads window is easier to use if you name your threads meaningfully.</span></span> <span data-ttu-id="0559c-314">O Visual Studio e outros depuradores da Microsoft permitem que você nomeie seus threads.</span><span class="sxs-lookup"><span data-stu-id="0559c-314">Visual Studio and other Microsoft debuggers allow you to name your threads.</span></span> <span data-ttu-id="0559c-315">Implemente a seguinte função **SetThreadName** e chame-a de cada thread à medida que ela é iniciada.</span><span class="sxs-lookup"><span data-stu-id="0559c-315">Implement the following **SetThreadName** function and call it from each thread as it starts up.</span></span>


```C++
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

void SetThreadName( DWORD dwThreadID, LPCSTR szThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = szThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0,
                    sizeof(info) / sizeof(DWORD),
            (DWORD*)&info );
    }
    __except( EXCEPTION_CONTINUE_EXECUTION ) {
    }
}

// Example usage:
SetThreadName(-1, "Main thread");
```



<span data-ttu-id="0559c-316">O depurador de kernel (KD) e o WinDBG também oferecem suporte à depuração multithread.</span><span class="sxs-lookup"><span data-stu-id="0559c-316">The kernel debugger (KD) and WinDBG also support multithreaded debugging.</span></span>

## <a name="testing"></a><span data-ttu-id="0559c-317">Teste</span><span class="sxs-lookup"><span data-stu-id="0559c-317">Testing</span></span>

<span data-ttu-id="0559c-318">A programação multithread pode ser complicada e alguns bugs multissegmentados mostram apenas raramente, dificultando a localização e a correção.</span><span class="sxs-lookup"><span data-stu-id="0559c-318">Multithreaded programming can be tricky, and some multithreaded bugs show up only rarely, making them difficult to find and fix.</span></span> <span data-ttu-id="0559c-319">Uma das melhores maneiras de liberá-las é testar uma grande variedade de computadores, especialmente aqueles com quatro ou mais processadores.</span><span class="sxs-lookup"><span data-stu-id="0559c-319">One of the best ways to flush them out is to test on a wide range of computers, particularly those with four or more processors.</span></span> <span data-ttu-id="0559c-320">O código multithread que funciona perfeitamente em um computador de thread único pode falhar instantaneamente em um computador com quatro processadores.</span><span class="sxs-lookup"><span data-stu-id="0559c-320">Multithreaded code that works perfectly on a single-threaded computer may fail instantly on a four-processor computer.</span></span> <span data-ttu-id="0559c-321">As características de desempenho e de tempo das CPUs AMD e Intel podem variar substancialmente, portanto, certifique-se de testar computadores com vários processadores com base em CPUs de ambos os fornecedores.</span><span class="sxs-lookup"><span data-stu-id="0559c-321">The performance and timing characteristics of AMD and Intel CPUs can vary substantially, so be sure to test on multiprocessor computers based on CPUs from both vendors.</span></span>

## <a name="windows-vista-and-windows-7-improvements"></a><span data-ttu-id="0559c-322">Aprimoramentos do Windows Vista e do Windows 7</span><span class="sxs-lookup"><span data-stu-id="0559c-322">Windows Vista and Windows 7 Improvements</span></span>

<span data-ttu-id="0559c-323">Para jogos visando as versões mais recentes do Windows, há várias APIs que podem simplificar a criação de aplicativos multithread escalonáveis.</span><span class="sxs-lookup"><span data-stu-id="0559c-323">For games targeting the newer versions of Windows, there are a number of APIs that can simplify the creation of scalable multithreaded applications.</span></span> <span data-ttu-id="0559c-324">Isso é particularmente verdadeiro com a nova API ThreadPool e alguns primitivos syncrhonziation adicionais (variáveis de condição, o bloqueio de leitura/gravação fino e a inicialização única).</span><span class="sxs-lookup"><span data-stu-id="0559c-324">This is particularly true with the new ThreadPool API and some additional syncrhonziation primitives (condition variables, the slim read/writer lock, and one-time initialization).</span></span> <span data-ttu-id="0559c-325">Você pode encontrar uma visão geral dessas tecnologias nos seguintes artigos da MSDN Magazine:</span><span class="sxs-lookup"><span data-stu-id="0559c-325">You can find an overview of these technologies in the following MSDN Magazine articles:</span></span>

-   [<span data-ttu-id="0559c-326">Melhorar a escalabilidade com novas APIs de pool de threads</span><span class="sxs-lookup"><span data-stu-id="0559c-326">Improve Scalability With New Thread Pool APIs</span></span>](/archive/msdn-magazine/2007/october/pooled-threads-improve-scalability-with-new-thread-pool-apis)
-   [<span data-ttu-id="0559c-327">Novos primitivos de sincronização no Windows Vista</span><span class="sxs-lookup"><span data-stu-id="0559c-327">Synchronization Primitives New To Windows Vista</span></span>](/archive/msdn-magazine/2007/june/concurrency-synchronization-primitives-new-to-windows-vista)

<span data-ttu-id="0559c-328">Os aplicativos que usam os [recursos do Direct3D 11](../direct3d11/direct3d-11-features.md) nesses sistemas operacionais também podem aproveitar o novo design para a criação de objetos simultâneos e listas de comandos de contexto deferidas para uma melhor escalabilidade para renderização multi-threaded.</span><span class="sxs-lookup"><span data-stu-id="0559c-328">Applications using [Direct3D 11 Features](../direct3d11/direct3d-11-features.md) on these operating systems can also take advantage of the new design for concurrent object creation and deferred context command lists for better scalability for multithreaded rendering.</span></span>

## <a name="summary"></a><span data-ttu-id="0559c-329">Resumo</span><span class="sxs-lookup"><span data-stu-id="0559c-329">Summary</span></span>

<span data-ttu-id="0559c-330">Com um design cuidadoso que minimiza as interações entre threads, você pode obter ganhos substanciais de desempenho de programação multithread sem adicionar complexidade excessiva ao seu código.</span><span class="sxs-lookup"><span data-stu-id="0559c-330">With careful design that minimizes the interactions between threads, you can get substantial performance gains from multithreaded programming without adding excessive complexity to your code.</span></span> <span data-ttu-id="0559c-331">Isso permitirá que o código de jogos passe pela próxima onda de aprimoramentos do processador e forneça experiências de jogos mais atraentes.</span><span class="sxs-lookup"><span data-stu-id="0559c-331">This will let your game code ride the next wave of processor improvements and deliver ever more compelling gaming experiences.</span></span>

## <a name="references"></a><span data-ttu-id="0559c-332">Referências</span><span class="sxs-lookup"><span data-stu-id="0559c-332">References</span></span>

-   <span data-ttu-id="0559c-333">Jim Beveridge & Robert Weiner, *aplicativos multithreading no Win32*, Addison-Wesley, 1997</span><span class="sxs-lookup"><span data-stu-id="0559c-333">Jim Beveridge & Robert Weiner, *Multithreading Applications in Win32*, Addison-Wesley, 1997</span></span>
-   <span data-ttu-id="0559c-334">Chuck Walbourn, [tempo de jogo e processadores de vários núcleos](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span><span class="sxs-lookup"><span data-stu-id="0559c-334">Chuck Walbourn, [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span></span>
-   <span data-ttu-id="0559c-335">Biblioteca MSDN: [ **GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span><span class="sxs-lookup"><span data-stu-id="0559c-335">MSDN Library: [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span></span>
-   [<span data-ttu-id="0559c-336">OpenMP</span><span class="sxs-lookup"><span data-stu-id="0559c-336">OpenMP</span></span>](https://www.openmp.org/)

 

 