### YamlMime:FAQ
metadata:
  title: 10 perguntas frequentes sobre o Direct3D
  description: Este artigo contém algumas das perguntas frequentes sobre o Direct3D 10 a partir do ponto de vista de um desenvolvedor que está portando um aplicativo existente do Direct3D 9 (D3D9) para o Direct3D 10 (D3D10).
  ms.assetid: da3022ca-b120-d0d7-6747-65b946dbc73c
  ms.topic: article
  ms.date: 05/31/2018
  ms.openlocfilehash: e4d83f20d5dac1c067144e715dee7331cabe2ce7
  ms.sourcegitcommit: adba238660d8a5f4fe98fc6f5d105d56aac3a400
  ms.translationtype: MT
  ms.contentlocale: pt-BR
  ms.lasthandoff: 06/09/2021
  ms.locfileid: "111852684"
title: 10 perguntas frequentes sobre o Direct3D
summary: >
  Este artigo contém algumas das perguntas frequentes sobre o Direct3D 10 a partir do ponto de vista de um desenvolvedor que está portando um aplicativo existente do Direct3D 9 (D3D9) para o Direct3D 10 (D3D10).
sections:
- name: Buffers de constantes
  questions:
  - question: Qual é a melhor maneira de atualizar os buffers de constantes?
    answer: UpdateSubresource e MAP com descarte devem ter aproximadamente a mesma velocidade. Escolha entre elas, dependendo de qual delas copia a quantidade mínima de memória. Se você já tiver seus dados armazenados na memória em um bloco contíguo, use UpdateSubresource. Se você precisar acumular dados de outros locais, use mapear com descartar.
  - question: Qual é a pior maneira de organizar os buffers de constantes?
    answer: >
      O pior desempenho é realizado ao colocar todas as constantes para um sombreador específico em um buffer constante. Embora isso geralmente seja a maneira mais fácil de portar de D3D9 para D3D10, ele pode prejudicar o desempenho. Por exemplo, considere um cenário que usa o seguinte buffer de constantes:


      ``` syntax

      cbuffer VSGlobalsCB

      {
          matrix  ViewProj;
          matrix  Bones[100];
          matrix  World;
          float   SpecPower;
          float4  BDRFCoefficients;
          float   AppTime;
          uint2   RenderTargetSize;
      };

      ```


      O buffer é de 6560 bytes. Suponha que haja um aplicativo com 1000 objetos a serem processados, 100 dos quais são malhas com revestimento e 900 das que são malhas estáticas. Além disso, suponha que esse aplicativo esteja usando o mapeamento de sombra com uma fonte de luz. Isso significa que há duas passagens, uma para o mapa de profundidade renderizado da luz e outra para a passagem de renderização de encaminhamento. Isso resulta em chamadas de empate de 2000. Embora cada chamada de desenho não precise atualizar todas as partes do buffer de constantes, todo o buffer de constante ainda é atualizado e enviado para o cartão. Isso resulta na atualização de 13 MB de dados a cada quadro (o 2000 Draw chama o tempo de 6560 KB).
  - question: Qual é a melhor maneira de organizar meus buffers de constantes?
    answer: "A melhor maneira é organizar buffers constantes por frequência de atualização. As constantes que são atualizadas em frequências semelhantes devem estar no mesmo buffer. Por exemplo, considere o cenário apresentado em \"Qual é a pior maneira de organizar buffers de constantes?\", mas com um layout de constante melhor:\n\n``` syntax\ncbuffer VSGlobalPerFrameCB\n  { \n    float   AppTime; \n  };\ncbuffer VSPerSkinnedCB\n  { \n    matrix  Bones[100]; \n  };\ncbuffer VSPerStaticCB\n  {\n    matrix  World;\n  };\ncbuffer VSPerPassCB\n  {\n    matrix  ViewProj;\n    uint2   RenderTargetSize;\n  };\ncbuffer VSPerMaterialCB\n  {\n    float   SpecPower;\n    float4  BDRFCoefficients;\n  };    \n```\n\nOs buffers de constantes são divididos por sua frequência de atualização, mas isso só é metade da solução. O aplicativo precisa atualizar os buffers de constantes corretamente para tirar total proveito da divisão. Vamos pressupor a mesma cena acima: 900 malhas estáticas, 100 malhas com revestimento, uma passagem leve e uma passagem de avanço. Também presumiremos que alguns buffers de constante por objeto serão armazenados. Isso significa que cada objeto conterá um VSPerSkinnedCB ou um VSPerStaticCB, dependendo se ele é ou não docapado ou estático. Fazemos isso para evitar o dobro da quantidade de matrizes enviadas por meio do pipeline.\n\nDividimos o quadro em três fases. A primeira fase é o início do quadro e não envolve nenhuma renderização, apenas atualizações constantes.\n\n\n\n**Iniciar quadro**\n\n\n-   Atualizar VSGlobalPerFrameCB para o tempo do aplicativo (4 bytes)\n-   Atualizar a 100 VSPerSkinnedCB para os objetos 100 com revestimento (640000 bytes)\n-   Atualizar VSPerStaticCB para objetos estáticos 900 (57600 bytes)\n\nA seguir está a passagem do mapa de sombra. Observe que o único buffer constante que realmente atualiza é VSPerPassCB. Todos os outros buffers de constantes foram atualizados durante a fase de início do quadro. Embora ainda precisemos associar esses buffers de constantes, a quantidade de informações passadas para a placa de vídeo é mínima, porque os buffers já foram atualizados.\n\n\n**Passagem de sombra**\n\n\n-   Atualizar VSPerPassCB (72 bytes)\n-   Empates 100 malhas com revestimento (100 associações, sem atualizações)\n-   Desenhe malhas estáticas 900 (100 associações, sem atualizações)\n\nDa mesma forma, a passagem de renderização de encaminhamento só precisa atualizar dados por material, pois ela não foi armazenada por malha. Se presumirmos que há 500 materiais em uso na cena:\n\n\n**Passagem de encaminhamento**\n\n\n-   Atualizar VSPerPassCB (72 bytes)\n-   Atualização 500 VSPerMaterialCBs (10000 bytes)\n\nIsso resulta em um total de apenas 707 KB. Embora esse seja um cenário muito forçado, ele ilustra a quantidade de sobrecarga de atualização constante que pode ser reduzida por meio da classificação de constantes por frequência de atualização.\n\n \n"
  - question: E se eu não tiver espaço suficiente para armazenar buffers de constantes individuais para minhas malhas, material e assim por diante?
    answer: >
      Você sempre pode usar um sistema em camadas de buffers de constantes. Crie buffers de constante de tamanho variável (16 bytes, 32 bytes, 64 bytes e assim por diante) até o maior tamanho de buffer constante necessário. Quando for o momento de associar um buffer constante a um sombreador, selecione o menor buffer de constante que pode conter os dados necessários para o sombreador. Embora essa abordagem seja um pouco menos eficiente, ela é uma boa etapa intermediária.
  - question: Estou compartilhando buffers de constantes entre diferentes sombreadores. Um sombreador pode usar todas as constantes, mas outra pode usar algumas das constantes. Qual é a melhor maneira de atualizá-los?
    answer: >
      Uma abordagem é dividir ainda mais o buffer constante. No entanto, há um ponto em que muitos buffers de constante estão associados. Nesse caso, mova as constantes que provavelmente não serão usadas por vários sombreadores no final do buffer de constantes. Ao obter os dados de variável do sombreador, use o \_ sinalizador d3d10 SVF \_ used da \_ variável de sombreador d3d10 \_ \_ desc para determinar se a variável é usada. Ao colocar variáveis não utilizadas no final do buffer de constantes, você pode associar um buffer menor ao sombreador que não usa essas variáveis, poupando assim o custo de atualização.
  - question: Quanto posso melhorar minha taxa de quadros se eu carregar apenas os Bones do meu caractere uma vez por quadro, em vez de uma vez por passagem/desenho?
    answer: >
      Você pode melhorar a taxa de quadros entre 8% e 50 por cento, dependendo da quantidade de dados redundantes. No pior caso, o desempenho não será reduzido.
  - question: Quantos buffers de constantes devo associar ao mesmo tempo?
    answer: >
      Associe o número mínimo de buffers de constante que é necessário para obter todos os dados no sombreador. Em um cenário realista, cinco é o número recomendado de buffers de constantes a serem usados. O compartilhamento de buffers de constantes entre sombreadores (ligando o mesmo CB para o VS e PS) também pode melhorar o desempenho.
  - question: Há um custo para ligar buffers constantes sem usá-los?
    answer: >
      Sim, se você não for realmente usar o buffer, não chame VSSetConsantBuffer ou PSSetConstantBuffer. Essa sobrecarga extra da API pode ser somada ao longo de várias chamadas de desenho.
- name: Estado
  questions:
  - question: Qual é a melhor maneira de gerenciar o estado no D3D10?
    answer: >
      A melhor solução é conhecer todo o seu estado de antecedência e criar os objetos de estado antecipadamente. Isso significa que, no momento do processamento, a associação de estado é a única operação que precisa acontecer. D3D10 também filtra duplicatas.
  - question: Meu jogo carregou dinamicamente ou tem conteúdo gerado pelo usuário. Não consigo carregar todos os meus objetos de estado antecipadamente. O que devo fazer?
    answer: >
      Há duas soluções aqui. A primeira é apenas criar objetos de estado imediatamente e permitir que o D3D10 filtre duplicatas. No entanto, isso não é recomendado para cenários com muitas alterações de objeto de estado por quadro. Uma solução melhor é fazer o hash dos objetos de estado por conta própria e criar um objeto de estado somente se um que se ajuste aos requisitos não for encontrado na tabela de hash. O raciocínio por trás do uso de uma tabela de hash personalizada é que um aplicativo pode selecionar um hash rápido com base no cenário de uso específico para esse aplicativo. Por exemplo, se um aplicativo altera apenas o rendertargetwritemask no Blendstate e mantém todos os outros valores iguais, o aplicativo pode gerar um hash do rendertargetwritemask em vez de toda a estrutura.
  - question: O estado AlphaTest não existe mais. Onde foi?
    answer: >
      AlphaTest agora deve ser o desempenho no sombreador. Consulte o exemplo de FixedFuncEMU.
  - question: O que aconteceu com os planos de clipes do usuário?
    answer: >
      Os planos de clipes do usuário foram movidos para o sombreador. Há duas maneiras de lidar com isso. A primeira é a saída de \_ ClipDistance de VA do sombreador de vértice ou do sombreador de geometria. A outra opção é usar o descarte no sombreador de pixel com base em um valor passado pelo sombreador de vértice ou pelo sombreador Geometry. Experimente ambos para ver qual é mais rápido para seu cenário específico. O uso de \_ ClipDistance de VA pode fazer com que o hardware use uma rotina de recorte baseada em geometria que pode fazer com que as chamadas de empate de limite de geometria sejam executadas mais lentamente. Da mesma forma, o uso de descarte desloca o trabalho para o sombreador de pixel, o que pode fazer com que as chamadas de empate com limite de pixel sejam executadas mais lentamente.
  - question: Desmarcações não respeitam nenhuma configuração de estado, como minhas configurações de Rect de tesoura no estado do rasterizador.
    answer: >
      As desmarcações foram separadas do estado do pipeline. Para obter o comportamento do estilo D3D9, emular limpas desenhando um quatro de tela inteira.
  - question: Defini meus Estados de volta para o padrão para tentar diagnosticar um erro de renderização. Agora, minha tela mostra apenas preto, embora eu saiba que estou desenhando objetos na tela.
    answer: >
      Ao definir o estado de volta para valores padrão (NULL), verifique se SampleMask na chamada para OMSetBlendState nunca é zero. Se SampleMask for definido como zero, então todos os exemplos serão logicamente e com zero. Nesse cenário, nenhum exemplo passará no teste de mistura.
  - question: Onde foi o estado do D3DSAMP\SRGBTEXTURE?
    answer: >
      O SRGB foi removido como parte do estado de amostra e agora está vinculado ao formato de textura. A associação de uma textura SRGB resultará na mesma amostragem que você obteria se tiver especificado D3DSAMP \_ SRGBTEXTURE no Direct3D 9.
- name: Formatos
  questions:
  - question: Qual formato D3D9 corresponde ao formato D3D10?
    answer: >
      Para obter informações, consulte [considerações do Direct3D 9 para o Direct3D 10](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-d3d9-to-d3d10-considerations).
  - question: O que aconteceu com os formatos de textura A8R8G8B8?
    answer: >
      Eles foram preteridos no D3D10. Você pode recriar suas texturas como R8G8B8A8, ou pode swizzle-las na carga ou pode swizzle no sombreador.
  - question: Como fazer usar texturas palettized?
    answer: >
      Coloque a paleta de cores em uma textura ou em um buffer de constantes e associe-a ao pipeline. No sombreador de pixel, faça uma pesquisa indireta usando o índice em sua textura palettized.
  - question: Quais são esses novos formatos SRGB?
    answer: >
      O SRGB foi removido como parte do estado de amostra e agora está vinculado ao formato de textura. A associação de uma textura SRGB resultará na mesma amostragem que você obteria se tiver especificado D3DSAMP \_ SRGBTEXTURE no Direct3D 9.
  - question: Onde os fãs do triângulo vão?
    answer: >
      Os fãs do triângulo foram preteridos no D3D10. Os fãs do triângulo precisarão ser convertidos no pipeline de conteúdo ou no carregamento.
- name: Vinculação de sombreador
  questions:
  - question: Meus sombreadores do Direct3D 9 são bem compilados no modelo do sombreador 4,0, mas quando os vinculo ao pipeline, obtenho erros de vinculação aparecendo na saída de depuração com o tempo de execução de depuração.
    answer: >
      O vínculo do sombreador é muito mais estrito em D3D10. Os elementos em um estágio subsequente devem ser lidos na ordem em que são gerados do estágio anterior. Por exemplo:


      Saídas de um sombreador de vértice:


      ``` syntax
          float4 Pos  : SV_POSITION;
          float3 Norm : NORMAL;
          float2 Tex  : TEXCOORD0;
      ```


      Um sombreador de pixel lê em:


      ``` syntax
              float3 Norm : NORMAL;
              float2 Tex  : TEXCOORD0;
      ```


      Embora a posição não seja necessária no sombreador de pixel, isso causará um erro de vinculação, pois a posição está sendo saída do sombreador de vértice, mas não lida pelo sombreador de pixel. A versão mais correta ficaria assim:


      Saídas de um sombreador de vértice:


      ``` syntax
              float3 Norm : NORMAL;
              float2 Tex  : TEXCOORD0;
              float4 Pos  : SV_POSITION;
      ```


      Um sombreador de pixel lê em:


      ``` syntax
              float3 Norm : NORMAL;
              float2 Tex  : TEXCOORD0;
      ```


      Nesse caso, o sombreador de vértice está gerando as mesmas informações, mas agora o sombreador de pixel está lendo as coisas na saída do pedido. Como o sombreador de pixel não está lendo nada após Tex, não precisamos se preocupar que o VS está gerando mais informações do que o PS está lendo.
  - question: Preciso de uma assinatura de sombreador para criar um layout de entrada, mas eu carregou minhas malhas e Crio layouts antes de criar sombreadores. O que devo fazer?
    answer: >
      Uma solução é mudar os sombreadores de pedido e de carga antes de carregar malhas. No entanto, isso é muito mais fácil, dito do que fazer. Você sempre pode criar os layouts de entrada sob demanda quando necessário pelo aplicativo. Você precisará manter uma versão da assinatura do sombreador. Você deve criar um hash com base no layout do sombreador e do buffer e apenas criar o layout de entrada se um que corresponda ainda não existir.
- name: Chamar chamadas
  questions:
  - question: Qual é o meu limite para chamadas de desenho para D3D10 alcançar 60 Hz? 30 Hz?
    answer: >
      O Direct3D 9 tinha uma limitação no número de chamadas de desenho devido ao custo de CPU por chamada de desenho. No Direct3D 10, o custo de cada chamada de desenho foi reduzido. No entanto, não há mais uma correlação definitiva entre as chamadas de desenho e as taxas de quadros. Como as chamadas Draw geralmente exigem muitas chamadas de suporte (atualizações de buffer de constantes, associações de textura, configuração de estado e assim por diante), o impacto da taxa de quadros da API agora é mais dependente do uso geral da API em vez de simplesmente desenhar contagens de chamadas.
- name: Recursos
  questions:
  - question: Que tipo de uso de recursos devo usar para as operações?
    answer: >
      Use a seguinte folha de consulta:


      -   A CPU atualiza o recurso mais de uma vez por quadro: D3D10 \_ uso \_ dinâmico

      -   A CPU atualiza o recurso menos de uma vez por quadro: \_ padrão de uso d3d10 \_

      -   A CPU não atualiza o recurso: D3D10 \_ uso \_ imutável

      -   A CPU precisa ler o recurso: preparo de \_ uso de d3d10 \_


      Como os buffers de constante sempre devem ser atualizados com frequência, eles não estão em conformidade com a "folha de dicas". Para os tipos de recursos a serem usados para buffers de constantes, consulte a seção [buffers de constantes](/windows/win32/dxtecharts/direct3d10-frequently-asked-questions#constant-buffers) .
  - question: O que aconteceu com DrawPrimitiveUP e DrawIndexedPrimitiveUP?
    answer: >
      Eles ficaram em D3D10. Para geometria dinâmica, use um \_ buffer dinâmico de uso d3d10 grande \_ . No início do quadro, mapeie-o com o D3D10 \_ map \_ Write \_ Discard. Para cada chamada de desenho subsequente, avance o ponteiro de gravação após a posição dos vértices desenhados anteriormente e mapeie o buffer com D3D10 \_ map \_ Write \_ sem \_ substituição. Se você estiver próximo do final do buffer antes do final do quadro, empacote o ponteiro de gravação em volta ao início e ao mapa com \_ descarte de gravação do mapa de d3d10 \_ \_ .
  - question: Posso escrever índices de 16 bits e índices de 32 bits no mesmo buffer de geometria dinâmica?
    answer: >
      Sim, você pode, mas isso pode incorrer em uma penalidade de desempenho em determinado hardware. É mais seguro criar buffers separados para dados de índice dinâmico de 16 bits e dados de índice de 32 bits.
  - question: Como fazer ler dados de volta da GPU para a CPU?
    answer: >
      Você deve usar um recurso de preparo. Copie os dados do recurso de GPU para o recurso de preparo usando CopyResource. Mapeie o recurso de preparo para ler os dados.
  - question: Meu aplicativo era dependente da funcionalidade de StretchRect.
    answer: >
      Como esse era essencialmente um wrapper para a funcionalidade básica do Direct3D, ele foi removido da API. Algumas das funcionalidades StretchRect foram movidas para D3DX10LoadTextureFromTexture. Para conversões de formato e cópia de texturas, D3DX10LoadTextureFromTexture pode fazer o trabalho. No entanto, as operações como a conversão de um tamanho para outra provavelmente exigirão um processamento para a operação de textura no aplicativo.
  - question: Não há deslocamentos ou tamanhos em chamadas de mapa para recursos. Eles estavam lá em chamadas de bloqueio no Direct3D 9; Por que eles mudaram?
    answer: >
      Os deslocamentos e tamanhos nas chamadas de bloqueio no Direct3D 9 eram basicamente uma desordem na API e, muitas vezes, ignorados pelo driver. Os deslocamentos devem ser calculados em vez do aplicativo do ponteiro retornado na chamada de mapa.
- name: Profundidade como textura
  questions:
  - question: Que é mais rápido? Usar profundidade como uma textura ou uma profundidade de escrita em alfa e lendo isso?
    answer: >
      Isso é específico de aplicativo e hardware. Use aquele que salvar a maior largura de banda. Se você já estiver usando vários destinos de renderização e tiver um canal extra, a criação de profundidade do sombreador pode ser uma solução melhor. Além disso, escrever profundidade para alfa ou outro destino de renderização permite que você escreva valores de profundidade linear que podem acelerar os cálculos que precisam acessar o buffer de profundidade.
  - question: Posso ter uma textura ligada como entrada e associada como uma textura de estêncil de profundidade, desde que eu desabilite gravações de profundidade?
    answer: >
      Não está em D3D10.
- name: MSAA
  questions:
  - question: Posso resolver uma textura de estêncil de profundidade de MSAA?
    answer: >
      Não está em D3D10. No entanto, você pode exemplificar exemplos individuais da textura MSAA. Consulte a seção [HLSL](/windows/win32/dxtecharts/direct3d10-frequently-asked-questions#hlsl) para obter detalhes.
  - question: Por que meu aplicativo falha assim que eu habilito o MSAA?
    answer: >
      Verifique se você está habilitando uma contagem de exemplo de MSAA e um número de qualidade que, na verdade, são enumerados pelo driver.
- name: Falhas
  questions:
  - question: Meu aplicativo falha no D3D10 ou no driver e eu não sei por quê.
    answer: >
      A primeira etapa é habilitar o tempo de execução de depuração ([**d3d10 criar sinalizador de \_ \_ \_ depuração de dispositivo**](/windows/desktop/api/d3d10/ne-d3d10-d3d10_create_device_flag) passado para [**D3D10CreateDevice**](/windows/desktop/api/d3d10misc/nf-d3d10misc-d3d10createdevice)). Isso vai expor os erros mais comuns como saída de depuração.
  - question: O PIX falha ao tentar usar meu aplicativo com ele.
    answer: >
      A primeira etapa é habilitar o tempo de execução de depuração ([**d3d10 criar sinalizador de \_ \_ \_ depuração de dispositivo**](/windows/desktop/api/d3d10/ne-d3d10-d3d10_create_device_flag) passado para [**D3D10CreateDevice**](/windows/desktop/api/d3d10misc/nf-d3d10misc-d3d10createdevice)). O PIX tem uma probabilidade muito maior de falhar se a saída de depuração não estiver limpa.
  - question: Meu jogo fica sem espaço de endereço virtual no vista de 32 bits em D3D10. Ele não tem problemas no D3D9.
    answer: >
      Houve alguns problemas com o D3D10 e o espaço de endereço virtual. Isso foi corrigido em [KB940105](https://support.microsoft.com/kb/940105). Se isso não corrigir o problema, verifique se você não está criando mais recursos que podem ser mapeados (bloqueados) em D3D10 do que você estava criando no D3D9. Além disso, pense em portar para 64 bits, já que isso se tornará mais predominante no futuro.
- name: Renderização de predicado
  questions:
  - question: Usei renderização predicado (com base nos resultados da consulta oclusão). Por que meu aplicativo ainda é a mesma velocidade?
    answer: >
      Primeiro, verifique se a renderização que você gostaria de ignorar é, na verdade, o afunilamento do aplicativo. Se não for o afunilamento, ignorar a renderização não ajudará a taxa de quadros.


      Em segundo lugar, certifique-se de que o tempo suficiente tenha passado entre o problema da consulta e a renderização que você deseja predicado. Se a consulta não tiver sido concluída no momento em que a chamada de renderização atingir a GPU, a renderização ocorrerá de qualquer forma.


      Terceiro, predicação apenas ignora determinadas chamadas. As chamadas que são ignoradas são desenhar, limpar, copiar, atualizar, ResolveSubresource e GenerateMips. Configurações de estado, instalação de IA, mapear e criar chamadas não respeitam predicação. Se houver muitas chamadas de configuração de estado em relação à chamada de desenho a ser preparada, esses Estados ainda serão definidos.
- name: Sombreador de geometria
  questions:
  - question: Devo usar o sombreador Geometry para incluí meu (inserir algo aqui)?
    answer: >
      Não. O sombreador de geometria não deve ser usado para mosaico.
  - question: Posso usar o sombreador Geometry para criar geometria?
    answer: >
      Sim, em cenários muito limitados. O sombreador de geometria nas partes D3D10 (2008) atuais não está equipado para lidar com muita expansão. Isso pode ser alterado no futuro. Os fornecedores de placas de vídeo podem ter um caminho especial para uma a quatro expansões devido a um hardware de ponto-Sprite existente. Qualquer outra expansão teria de ser muito limitada. Os exemplos de ParticlesGS e PipesGS atingem altas taxas de quadros apenas com a expansão limitada. Apenas alguns pontos são expandidos por quadro.
  - question: Para que devo usar o sombreador Geometry?
    answer: >
      Qualquer coisa que exija operações em um primitivo inteiro, como detecção de silhueta, coordenadas barycentric e assim por diante. Use-o também para selecionar a qual fatia de uma matriz de destino de renderização enviar primitivos.
  - question: Posso gerar quantidades variáveis de geometria a partir do sombreador Geometry?
    answer: >
      Sim, mas isso pode causar problemas de desempenho. Veja o exemplo de saída de 1 ponto para uma invocação e 4 pontos para outro. Ao se ajustar nas diretrizes de expansão, isso pode fazer com que os threads do sombreador de geometria sejam executados em série.
  - question: Como o D3D10 sabe como gerar índices de adjacência para minha malha? Ou, por que o D3D10 não é renderizado corretamente quando eu especificar que o sombreador Geometry precisa de informações de adjacência.
    answer: >
      As informações de adjacência não são criadas por D3D10, mas pelo aplicativo. Os índices de adjacência são gerados pelo aplicativo e devem conter seis índices por primitivo; dos seis, os índices numerados ímpares são os vértices adjacentes da borda. ID3DX10Mesh:: GenerateAdjacencyAndPointsReps pode ser usado para gerar esses dados.
- name: HLSL
  questions:
  - question: Há instruções de inteiro e bit-de-processo lentas?
    answer: >
      Eles podem ser. Vários cartões D3D10 podem ser capazes de emitir operações de inteiros em um subconjunto das unidades de ALU disponíveis. Isso é altamente dependente do hardware. Consulte seu fornecedor de hardware individual para obter recomendações sobre como tratar operações de inteiros nesse hardware específico. Além disso, tenha muito cuidado com as conversões entre os tipos.
  - question: O que aconteceu com o VPOS?
    answer: >
      Se você declarar uma entrada para o sombreador de pixel como posição da VA \_ , obterá o mesmo comportamento que declará-la como VPOS.
  - question: Como fazer um exemplo de textura de MSAA?
    answer: >
      No sombreador, declare sua textura como Texture2DMS. Em seguida, você pode buscar exemplos individuais usando os métodos de exemplo fora do objeto Texture2DMS.
  - question: Como fazer dizer se uma variável de sombreador em um buffer de constantes realmente é usada?
    answer: >
      Examine a \_ estrutura desc de variável do sombreador d3d10 refletida \_ \_ para essa variável. uFlags deve ter o sinalizador de D3D10 \_ SVF \_ usado.
  - question: Como fazer dizer se uma variável de sombreador em um buffer constante realmente está usando FX10?
    answer: >
      Atualmente, isso não é possível usando FX10.
  - question: Não tenho controle sobre os buffers de constantes que o FX10 cria. Como eles são criados e atualizados?
    answer: >
      Todos os buffers de constante gerenciados por FX10 são criados como \_ recursos padrão de uso de d3d10 \_ e atualizados usando UpdateSubresource. Como o FX10 mantém um repositório de backup de todos os dados constantes, UpdateSubresource é a melhor abordagem para atualizá-los.
  - question: Como fazer emular o pipeline de função fixa usando sombreadores?
    answer: >
      Consulte o exemplo de FixedFuncEMU.
  - question: Devo usar o novo \[ relance \] , \[ loop \] , \[ ramificação \] , e assim por diante, dicas de compilador?
    answer: >
      Em geral, não. O compilador geralmente tentará as duas formas e escolherá a mais rápida. Em alguns casos, pode ser necessário usar \[ unroll \] , por exemplo, quando uma busca de textura dentro de um loop precisa de acesso a um gradiente.
  - question: A precisão parcial faz alguma diferença no D3D10? Posso especificar a precisão parcial em meu D3D9 HLSL, mas não em meu D3D10 HLSL.
    answer: >
      Todas as operações de D3D10 são especificadas para serem executadas com precisão de ponto flutuante de 32 bits. Portanto, a precisão parcial não deve fazer nenhuma diferença no D3D10.
  - question: No D3D9, eu poderia fazer a filtragem de sombra do PCF de HW ligando um buffer de profundidade como uma textura e usando instruções regulares de HLSL de tex2d. Como fazer fazer isso no D3D10?
    answer: >
      Você precisa usar um estado de amostra de comparação e usar instruções de SampleCmp.
  - question: Como essa palavra-chave Register funciona no D3D10?
    answer: >
      A palavra-chave register em D3D10 agora se aplica a qual slot um recurso específico está associado. Nesse caso, o recurso pode ser um buffer (constante ou, caso contrário), textura ou amostra.


      -   Para buffers de constantes, use a sintaxe: Register (bilhão), em que N é o slot de entrada (0-15)

      -   Para texturas, use a sintaxe: Register (tN), em que N é o slot de entrada (0-127)

      -   Para os exemplos, use a sintaxe: Register (sN), em que N é o slot de entrada (0-127)
  - question: Como fazer Coloque uma variável dentro de um buffer de constantes se o registro for usado apenas para especificar onde associar o buffer inteiro?
    answer: >-
      Use a palavra-chave packoffset. O argumento para packoffset está na forma de c \[ 0-4095 \] . \[ x, y, z, w \] . Por exemplo:


      ``` syntax
              cbuffer cbLotsOfEmptySpace
              {
              float   IWaste2Floats   : packoffset(c0.z);
              float4  IWasteMore  : packoffset(c13);
              };
      ```


      Nesse buffer de constante, IWaste2Floats é colocado no terceiro float (12 bytes) no buffer de constantes. IWasteMore é colocado no 13 FLOAT4 ou 52nd float no buffer de constantes.
