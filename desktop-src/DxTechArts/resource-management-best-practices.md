---
title: Práticas recomendadas de gerenciamento de recursos
description: Este artigo aborda as práticas recomendadas para lidar com recursos geralmente, como os recursos gerenciados e não gerenciados se comportam e fornece alguns detalhes sobre como os recursos são normalmente tratados pelo tempo de execução e pelos drivers.
ms.assetid: 265ae0b2-f268-a4a4-551e-9d3dae886517
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 27cdadb8cee3cb57f4208657054784937ecd1ea2
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104294300"
---
# <a name="resource-management-best-practices"></a><span data-ttu-id="663c3-103">Práticas recomendadas de gerenciamento de recursos</span><span class="sxs-lookup"><span data-stu-id="663c3-103">Resource Management Best Practices</span></span>

<span data-ttu-id="663c3-104">As texturas gerenciadas, também conhecidas como gerenciamento automático de textura, estão disponíveis no DirectX desde a versão 6, com várias revisões e aprimoramentos feitos nas versões subsequentes.</span><span class="sxs-lookup"><span data-stu-id="663c3-104">Managed textures, also known as automatic texture management, have been available in DirectX since version 6, with several revisions and enhancements made in subsequent releases.</span></span> <span data-ttu-id="663c3-105">No lançamento da API do Direct3D 9, o gerenciamento automático de recursos inclui suporte para texturas, buffers de vértices e buffers de índice, tudo com uma interface compartilhada consistente.</span><span class="sxs-lookup"><span data-stu-id="663c3-105">As of the release of the Direct3D 9 API, the automatic resource management includes support for textures, vertex buffers, and index buffers, all with a consistent shared interface.</span></span> <span data-ttu-id="663c3-106">Usando o Direct3D Resource Manager, os aplicativos podem simplificar bastante a manipulação de situações de dispositivo perdido e podem contar com o sistema para lidar com uma quantidade razoável de comprometimento excessivo dos recursos de memória de vídeo.</span><span class="sxs-lookup"><span data-stu-id="663c3-106">By using the Direct3D resource manager, applications can greatly simplify the handling of lost-device situations and can rely on the system to handle a reasonable amount of over-commitment of video memory resources.</span></span>

<span data-ttu-id="663c3-107">Os desenvolvedores às vezes têm dificuldades em usar recursos gerenciados, em parte devido à natureza abstrata do sistema.</span><span class="sxs-lookup"><span data-stu-id="663c3-107">Developers sometimes have difficulties using managed resources, in part due to the abstract nature of the system.</span></span> <span data-ttu-id="663c3-108">Embora muitos cenários comuns de recursos sejam uma boa opção para recursos gerenciados, alguns casos têm melhor desempenho ao usar recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="663c3-108">While many common scenarios for resources are a good fit for managed resources, some cases perform better when using unmanaged resources.</span></span> <span data-ttu-id="663c3-109">Este artigo aborda as práticas recomendadas para lidar com recursos geralmente, como os recursos gerenciados e não gerenciados se comportam e fornece alguns detalhes sobre como os recursos são normalmente tratados pelo tempo de execução e pelos drivers.</span><span class="sxs-lookup"><span data-stu-id="663c3-109">This article discusses best practices for dealing with resources generally, how managed and unmanaged resources behave, and provides some detail on how resources are typically handled by the runtime and drivers.</span></span>

<span data-ttu-id="663c3-110">Este artigo aborda estes conceitos:</span><span class="sxs-lookup"><span data-stu-id="663c3-110">This article covers these concepts:</span></span>

-   [<span data-ttu-id="663c3-111">Memória de vídeo</span><span class="sxs-lookup"><span data-stu-id="663c3-111">Video Memory</span></span>](#video-memory)
-   [<span data-ttu-id="663c3-112">Recursos gerenciados</span><span class="sxs-lookup"><span data-stu-id="663c3-112">Managed Resources</span></span>](#managed-resources)
-   [<span data-ttu-id="663c3-113">Recursos gerenciados por driver</span><span class="sxs-lookup"><span data-stu-id="663c3-113">Driver-Managed Resources</span></span>](#driver-managed-resources)
-   [<span data-ttu-id="663c3-114">Recursos padrão</span><span class="sxs-lookup"><span data-stu-id="663c3-114">Default Resources</span></span>](#default-resources)
    -   [<span data-ttu-id="663c3-115">Usando recursos gerenciados e padrão</span><span class="sxs-lookup"><span data-stu-id="663c3-115">Using Both Managed and Default Resources</span></span>](#using-both-managed-and-default-resources)
    -   [<span data-ttu-id="663c3-116">Recursos padrão dinâmicos</span><span class="sxs-lookup"><span data-stu-id="663c3-116">Dynamic Default Resources</span></span>](#dynamic-default-resources)
-   [<span data-ttu-id="663c3-117">Recursos de memória do sistema</span><span class="sxs-lookup"><span data-stu-id="663c3-117">System Memory Resources</span></span>](#system-memory-resources)
-   [<span data-ttu-id="663c3-118">Recomendações gerais</span><span class="sxs-lookup"><span data-stu-id="663c3-118">General Recommendations</span></span>](#general-recommendations)
-   [<span data-ttu-id="663c3-119">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="663c3-119">Related topics</span></span>](#related-topics)

## <a name="video-memory"></a><span data-ttu-id="663c3-120">Memória de vídeo</span><span class="sxs-lookup"><span data-stu-id="663c3-120">Video Memory</span></span>

<span data-ttu-id="663c3-121">Para que o sistema de vídeo Use um recurso, ele deve estar localizado na memória que está acessível para a GPU.</span><span class="sxs-lookup"><span data-stu-id="663c3-121">For the video system to make use of a resource, it must be located in memory that is accessible to the GPU.</span></span> <span data-ttu-id="663c3-122">A memória de vídeo local fornece o melhor desempenho para a GPU, e determinados recursos (como destinos de renderização e buffers de profundidade/estêncil) devem estar localizados em memória de vídeo local.</span><span class="sxs-lookup"><span data-stu-id="663c3-122">Local video memory provides the best performance for the GPU, and certain resources (such as render targets and depth/stencil buffers) must be located in local video memory.</span></span> <span data-ttu-id="663c3-123">Com o advento do AGP, a GPU também pode acessar uma parte da memória do sistema diretamente.</span><span class="sxs-lookup"><span data-stu-id="663c3-123">With the advent of AGP, the GPU can also access a portion of the system memory directly.</span></span> <span data-ttu-id="663c3-124">Essa área de memória, conhecida como a abertura do AGP, é conhecida como memória de vídeo não local e não está disponível para outras finalidades.</span><span class="sxs-lookup"><span data-stu-id="663c3-124">This memory area, known as the AGP aperture, is referred to as non-local video memory and is not available for other purposes.</span></span> <span data-ttu-id="663c3-125">A memória de vídeo não local pode ser lida e gravada pela CPU, que normalmente não tem acesso de alto desempenho à memória de vídeo local e, portanto, é ideal para uso como um recurso de memória compartilhada.</span><span class="sxs-lookup"><span data-stu-id="663c3-125">Non-local video memory can be read from and written to by the CPU, which typically has no high-performance access to local video memory, and is thus ideal for use as a shared memory resource.</span></span> <span data-ttu-id="663c3-126">Um ponto importante a ser lembrado sobre a memória AGP é que, como a memória de vídeo local, é invalidado em situações de dispositivo perdido e ativos persistentes localizados nele devem ser restaurados.</span><span class="sxs-lookup"><span data-stu-id="663c3-126">A key thing to remember about AGP memory is that it, like local video memory, is invalidated in lost-device situations, and persistent assets located there must be restored.</span></span>

<span data-ttu-id="663c3-127">**Figura 1. Relação da GPU, CPU, vídeo RAM e RAM do sistema**</span><span class="sxs-lookup"><span data-stu-id="663c3-127">**Figure 1. Relationship of the GPU, CPU, video RAM, and system RAM**</span></span>

![relação da GPU, CPU, vídeo RAM e RAM do sistema](images/managingresources1.gif)

<span data-ttu-id="663c3-129">Algumas soluções de vídeo integradas usam uma (arquitetura de memória unificada), em que a memória principal é endereçável por todos os componentes dos sistemas.</span><span class="sxs-lookup"><span data-stu-id="663c3-129">Some integrated video solutions make use of a unified memory architecture (UMA), where main memory is addressable by all components of the systems.</span></span> <span data-ttu-id="663c3-130">O Direct3D dá suporte a uma, sem a necessidade de qualquer alteração no aplicativo, utilizando as mesmas dicas das configurações de memória de vídeo local.</span><span class="sxs-lookup"><span data-stu-id="663c3-130">Direct3D supports UMA without requiring any change to the application, utilizing the same hints as for local video memory configurations.</span></span> <span data-ttu-id="663c3-131">Para esses sistemas, os recursos estão sempre localizados na memória do sistema, e o driver é responsável por garantir que os recursos funcionem da mesma forma que em uma arquitetura mais tradicional, aproveitando as propriedades de uma e qualquer comportamento específico da implementação de hardware.</span><span class="sxs-lookup"><span data-stu-id="663c3-131">For such systems, resources are always located in system memory, and the driver is responsible for ensuring that resources work much like they do in a more traditional architecture while taking advantage of UMA's properties and any specific behavior of the hardware implementation.</span></span>

<span data-ttu-id="663c3-132">**Figura 2. GPU e CPU têm acesso igual à RAM do sistema em uma arquitetura de memória unificada**</span><span class="sxs-lookup"><span data-stu-id="663c3-132">**Figure 2. GPU and CPU have equal access to system RAM in a unified memory architecture**</span></span>

![GPU e CPU têm acesso igual à RAM do sistema em uma arquitetura de memória unificada](images/managingresources2.gif)

## <a name="managed-resources"></a><span data-ttu-id="663c3-134">Recursos gerenciados</span><span class="sxs-lookup"><span data-stu-id="663c3-134">Managed Resources</span></span>

<span data-ttu-id="663c3-135">A maioria de seus recursos deve ser criada como recursos gerenciados no POOL \_ gerenciado.</span><span class="sxs-lookup"><span data-stu-id="663c3-135">The majority of your resources should be created as managed resources in POOL\_MANAGED.</span></span> <span data-ttu-id="663c3-136">Todos os seus recursos serão criados na memória do sistema e, em seguida, copiados conforme necessário na memória de vídeo.</span><span class="sxs-lookup"><span data-stu-id="663c3-136">All your resources will be created in system memory and then copied as needed into video memory.</span></span> <span data-ttu-id="663c3-137">As situações de dispositivo perdido serão tratadas automaticamente da cópia de memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="663c3-137">Lost-device situations will be handled automatically from the system memory copy.</span></span> <span data-ttu-id="663c3-138">Como nem todos os recursos gerenciados são necessários para se ajustar à memória de vídeo de uma só vez, é possível confirmar excessivamente a memória em que um conjunto de recursos de trabalho de memória de vídeo menor é tudo o que é necessário para renderizar em qualquer determinado quadro.</span><span class="sxs-lookup"><span data-stu-id="663c3-138">Since not all managed resources are required to fit into video memory all at once, you can over-commit memory where a smaller video memory working set of resources is all that is required to render in any given frame.</span></span> <span data-ttu-id="663c3-139">Observe que é provável que a maioria dessa memória do sistema de armazenamento de backup seja paginada para o disco ao longo do tempo, motivo pelo qual a operação de redefinição pode ser lenta devido à necessidade de paginar esses dados de volta para restaurar a memória de vídeo perdida.</span><span class="sxs-lookup"><span data-stu-id="663c3-139">Note that it is likely that the majority of this backing-store system memory will be paged out to disk over time, which is why the Reset operation can be slow due to the need to page this data back in to restore the lost video memory.</span></span>

<span data-ttu-id="663c3-140">O tempo de execução mantém um carimbo de data/hora na última vez em que um recurso é usado e quando uma alocação de memória de vídeo falha para carregar um recurso gerenciado necessário, ele libera recursos com base nesse carimbo de data/hora de maneira LRU.</span><span class="sxs-lookup"><span data-stu-id="663c3-140">The runtime keeps a timestamp for the last time a resource is used, and when a video memory allocation fails for loading a needed managed resource, it will release resources based on this timestamp in a LRU fashion.</span></span> <span data-ttu-id="663c3-141">O uso [**de**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3dresource9-setpriority) settevence tem precedência sobre o carimbo de data/hora, de modo que os recursos mais usados devem ser definidos com um valor de prioridade mais alto.</span><span class="sxs-lookup"><span data-stu-id="663c3-141">Usage of [**SetPriority**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3dresource9-setpriority) takes precedence over the timestamp, so more commonly used resources should be set to a higher priority value.</span></span> <span data-ttu-id="663c3-142">O Direct3D 9,0 tem informações limitadas sobre a memória de vídeo gerenciada pelo driver, de modo que o tempo de execução pode precisar remover vários recursos para criar uma região grande o suficiente para que a alocação tenha sucesso.</span><span class="sxs-lookup"><span data-stu-id="663c3-142">Direct3D 9.0 has limited information about the video memory managed by the driver, so the runtime may need to evict several resources to create a large enough region for the allocation to succeed.</span></span> <span data-ttu-id="663c3-143">As prioridades adequadas podem ajudar a eliminar situações em que algo é removido e, em seguida, é necessário novamente logo depois disso.</span><span class="sxs-lookup"><span data-stu-id="663c3-143">Proper priorities can help eliminate situations where something gets evicted and then is required again shortly thereafter.</span></span> <span data-ttu-id="663c3-144">O aplicativo também pode chamar [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) para forçar a remoção de todos os recursos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="663c3-144">The application can also call [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) to force all the managed resources to be removed.</span></span> <span data-ttu-id="663c3-145">Novamente, essa pode ser uma operação demorada para recarregar todos os recursos necessários para o próximo quadro, mas é muito útil para transições de nível em que o conjunto de trabalho muda significativamente e para remover a fragmentação da memória de vídeo.</span><span class="sxs-lookup"><span data-stu-id="663c3-145">Again, this can be a time-consuming operation to reload all the resources required for the next frame, but is very useful for level transitions where the working set changes significantly and for removing video memory fragmentation.</span></span>

<span data-ttu-id="663c3-146">Um número de quadros também é mantido para permitir que o tempo de execução detecte se o recurso escolhido para remoção foi usado no início do quadro atual, o que implica uma situação ultrapaginação em que mais recursos estão em uso em um único quadro do que se ajustará à memória de vídeo.</span><span class="sxs-lookup"><span data-stu-id="663c3-146">A frame count is also kept to allow the runtime to detect if the resource it just chose to evict was used early the current frame, which implies a thrashing situation where more resources are in use in a single frame than will fit into video memory.</span></span> <span data-ttu-id="663c3-147">Isso dispara a política de substituição para mudar para uma forma MRU em vez de LRU para o restante do quadro, pois isso tende a executar um pouco melhor sob tais condições.</span><span class="sxs-lookup"><span data-stu-id="663c3-147">This triggers the replacement policy to switch to a MRU fashion rather than LRU for the remainder of the frame as this tends to perform slightly better under such conditions.</span></span> <span data-ttu-id="663c3-148">Esse comportamento de ultrapaginação afetará significativamente o desempenho de renderização.</span><span class="sxs-lookup"><span data-stu-id="663c3-148">Such thrashing behavior will significantly impact the rendering performance.</span></span> <span data-ttu-id="663c3-149">Observe que a noção do quadro atual está vinculada ao [**EndScene**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-endscene), de modo que qualquer aplicativo que faça uso de recursos gerenciados precisa fazer chamadas regulares para esse método.</span><span class="sxs-lookup"><span data-stu-id="663c3-149">Note that the notion of current frame is tied to [**EndScene**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-endscene), so any application making use of managed resources needs to make regular calls to this method.</span></span>

<span data-ttu-id="663c3-150">Os desenvolvedores que buscam encontrar mais informações sobre como os recursos gerenciados estão se comportando em seus aplicativos podem usar a consulta de evento RESOURCEMANAGER por meio da interface [**IDirect3DQuery9**](/windows/desktop/api/d3d9helper/nn-d3d9helper-idirect3dquery9) .</span><span class="sxs-lookup"><span data-stu-id="663c3-150">Developers looking to find more information about how managed resources are behaving in their application can make use of the RESOURCEMANAGER event query via the [**IDirect3DQuery9**](/windows/desktop/api/d3d9helper/nn-d3d9helper-idirect3dquery9) interface.</span></span> <span data-ttu-id="663c3-151">Isso só funciona ao usar os tempos de execução de depuração, portanto, essas informações não podem ser dependentes pelo aplicativo, mas fornecem detalhes aprofundados sobre os recursos gerenciados pelo tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="663c3-151">This only works when using the debug runtimes, so this information cannot be depended upon by the application, but it provides deep detail on the resources managed by the runtime.</span></span>

<span data-ttu-id="663c3-152">Embora entender como o Gerenciador de recursos funciona pode ajudar ao ajustar e depurar seus aplicativos, é importante não vincular seu aplicativo muito bem aos detalhes da implementação do tempo de execução atual ou dos drivers.</span><span class="sxs-lookup"><span data-stu-id="663c3-152">While understanding how the resource manager works can help when tuning and debugging your applications, it is important to not tie your application too tightly to the implementation details of the current runtime or drivers.</span></span> <span data-ttu-id="663c3-153">As revisões do driver ou as alterações no hardware podem alterar significativamente o comportamento, e as versões futuras do Direct3D terão um gerenciamento de recursos consideravelmente melhorado e sofisticado.</span><span class="sxs-lookup"><span data-stu-id="663c3-153">Revisions of the driver or changes in hardware can significantly change the behavior, and future versions of Direct3D will have significantly improved and sophisticated resource management.</span></span>

## <a name="driver-managed-resources"></a><span data-ttu-id="663c3-154">Driver-Managed recursos</span><span class="sxs-lookup"><span data-stu-id="663c3-154">Driver-Managed Resources</span></span>

<span data-ttu-id="663c3-155">Os drivers do Direct3D são gratuitos para implementar o recurso de texturas gerenciadas por Driver, indicado por D3DCAPS2 \_ CANMANAGERESOURCE, que permite que o driver manipule o gerenciamento de recursos em vez do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="663c3-155">Direct3D drivers are free to implement the driver managed textures capability, indicated by D3DCAPS2\_CANMANAGERESOURCE, which allows the driver to handle the resource management instead of the runtime.</span></span> <span data-ttu-id="663c3-156">Para o driver (raro) que implementa esse recurso, o comportamento exato do Gerenciador de recursos do driver pode variar muito e você deve entrar em contato com o fornecedor do driver para obter detalhes sobre como isso funciona para sua implementação.</span><span class="sxs-lookup"><span data-stu-id="663c3-156">For the (rare) driver that implements this feature, the exact behavior of the driver's resource manager can vary widely, and you should contact the driver's vendor for details on how this works for their implementation.</span></span> <span data-ttu-id="663c3-157">Como alternativa, você pode garantir que o Gerenciador de tempo de execução sempre seja usado, especificando D3DCREATE \_ desabilitar \_ \_ o gerenciamento de driver ao criar o dispositivo.</span><span class="sxs-lookup"><span data-stu-id="663c3-157">Alternatively, you can ensure that the runtime manager is always used instead by specifying D3DCREATE\_DISABLE\_DRIVER\_MANAGEMENT when creating the device.</span></span>

## <a name="default-resources"></a><span data-ttu-id="663c3-158">Recursos padrão</span><span class="sxs-lookup"><span data-stu-id="663c3-158">Default Resources</span></span>

<span data-ttu-id="663c3-159">Embora os recursos gerenciados sejam simples, eficientes e fáceis de usar, há ocasiões em que usar a memória de vídeo diretamente é preferencial ou até mesmo necessário.</span><span class="sxs-lookup"><span data-stu-id="663c3-159">While managed resources are simple, efficient, and easy to use, there are times when using video memory directly is preferred or even required.</span></span> <span data-ttu-id="663c3-160">Esses recursos são criados na \_ categoria padrão do pool.</span><span class="sxs-lookup"><span data-stu-id="663c3-160">Such resources are created in the POOL\_DEFAULT category.</span></span> <span data-ttu-id="663c3-161">Fazer uso desses recursos causa complicações adicionais para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="663c3-161">Making use of such resources does cause additional complications for your application.</span></span> <span data-ttu-id="663c3-162">O código é necessário para lidar com a situação de dispositivo perdido para todos os \_ recursos padrão do pool, e as considerações de desempenho devem ser levadas em conta ao copiar dados neles.</span><span class="sxs-lookup"><span data-stu-id="663c3-162">Code is required to cope with the lost-device situation for all the POOL\_DEFAULT resources, and performance considerations must be taken into account when copying data into them.</span></span> <span data-ttu-id="663c3-163">Falha ao especificar \_ o uso de WRITEONLY ou fazer um bloqueáveis de destino de renderização também pode impor sérias penalidades de desempenho.</span><span class="sxs-lookup"><span data-stu-id="663c3-163">Failure to specify USAGE\_WRITEONLY or making a render target lockable can also impose serious performance penalties.</span></span>

<span data-ttu-id="663c3-164">A chamada de **bloqueio** em um recurso de pool \_ padrão é mais provável que a GPU seja interrompida do que trabalhar com um \_ recurso gerenciado por pool, a menos que use determinados sinalizadores de dica.</span><span class="sxs-lookup"><span data-stu-id="663c3-164">Calling **Lock** on a POOL\_DEFAULT resource is more likely to cause the GPU to stall than working with a POOL\_MANAGED resource, unless using certain hint flags.</span></span> <span data-ttu-id="663c3-165">Dependendo do local do recurso, o ponteiro retornado poderia ser um buffer de memória do sistema temporário ou pode ser um ponteiro diretamente na memória AGP.</span><span class="sxs-lookup"><span data-stu-id="663c3-165">Depending on the location of the resource, the pointer returned could be to a temporary system memory buffer, or it can be a pointer directly into AGP memory.</span></span> <span data-ttu-id="663c3-166">Se for um buffer de memória do sistema temporário, os dados precisarão ser transferidos para a memória de vídeo após a chamada de **desbloqueio** .</span><span class="sxs-lookup"><span data-stu-id="663c3-166">If it is a temporary system memory buffer, data will need to be transferred to the video memory after the **Unlock** call.</span></span> <span data-ttu-id="663c3-167">Se o recurso de vídeo não for somente gravação, os dados precisarão ser transferidos para o buffer temporário durante o **bloqueio**.</span><span class="sxs-lookup"><span data-stu-id="663c3-167">If the video resource is not write-only, data will have to be transferred into the temporary buffer during the **Lock**.</span></span> <span data-ttu-id="663c3-168">Se for uma área de memória AGP, as cópias temporárias serão evitadas, mas o comportamento de cache necessário poderá resultar em um desempenho lento.</span><span class="sxs-lookup"><span data-stu-id="663c3-168">If it is an AGP memory area, temporary copies are avoided but the cache behavior required can result in slow performance.</span></span>

<span data-ttu-id="663c3-169">Deve-se tomar cuidado para gravar uma linha de cache cheia de dados em qualquer ponteiro para a memória de abertura AGP para evitar a penalidade de gravação, o que induzi um ciclo de leitura/gravação, e o acesso sequencial da área de memória é preferencial.</span><span class="sxs-lookup"><span data-stu-id="663c3-169">Care should be taken to write a full cache line of data into any pointer to AGP aperture memory to avoid the penalty of write-combing, which induces a read-write cycle, and sequential access of the memory area is preferred.</span></span> <span data-ttu-id="663c3-170">Se seu aplicativo precisar fazer acesso aleatório aos dados durante a criação e você não quiser usar um recurso gerenciado para o buffer, você deverá trabalhar com uma cópia de memória do sistema em vez disso.</span><span class="sxs-lookup"><span data-stu-id="663c3-170">If your application needs to make random access to data during creation, and you do not wish to make use of a managed resource for the buffer, you should work with a system memory copy instead.</span></span> <span data-ttu-id="663c3-171">Depois que os dados tiverem sido criados, você poderá transmitir o resultado para a memória de recursos bloqueados para evitar o pagamento de uma alta penalidade para a operação de combinação de gravação de cache.</span><span class="sxs-lookup"><span data-stu-id="663c3-171">Once the data has been created, you can then stream the result into the locked resource memory to avoid paying a high penalty for the cache write-combining operation.</span></span>

<span data-ttu-id="663c3-172">O \_ sinalizador bloquear NoOverwrite pode ser usado para acrescentar dados de maneira eficiente para alguns recursos, mas, teoricamente, várias chamadas de **bloqueio** e **desbloqueio** para o mesmo recurso podem ser evitadas.</span><span class="sxs-lookup"><span data-stu-id="663c3-172">The LOCK\_NOOVERWRITE flag can be used to append data in an efficient manner for some resources, but ideally, multiple **Lock** and **Unlock** calls to the same resource can be avoided.</span></span> <span data-ttu-id="663c3-173">Fazer uso adequado dos vários sinalizadores de bloqueio é importante para o desempenho ideal, assim como o uso de um padrão amigável de acesso a dados para o cache ao preencher a memória bloqueada.</span><span class="sxs-lookup"><span data-stu-id="663c3-173">Making proper use of the various lock flags is important to optimal performance, as is using a cache-friendly pattern of data access when filling locked memory.</span></span>

### <a name="using-both-managed-and-default-resources"></a><span data-ttu-id="663c3-174">Usando recursos gerenciados e padrão</span><span class="sxs-lookup"><span data-stu-id="663c3-174">Using Both Managed and Default Resources</span></span>

<span data-ttu-id="663c3-175">A combinação de alocações de recursos gerenciados e padrão de POOL \_ pode causar a fragmentação da memória de vídeo e confundir a exibição do tempo de execução da memória de vídeo disponível para recursos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="663c3-175">Mixing allocations of managed and POOL\_DEFAULT resources can cause video memory fragmentation and confuse the runtime's view of the video memory available for managed resources.</span></span> <span data-ttu-id="663c3-176">Idealmente, você deve criar todos os \_ recursos padrão de pool antes de usar \_ os recursos gerenciados por pool ou fazer uso da chamada [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) antes de alocar recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="663c3-176">Ideally, you should create all POOL\_DEFAULT resources before making use of POOL\_MANAGED resources or make use of the [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) call before allocating unmanaged resources.</span></span> <span data-ttu-id="663c3-177">Lembre-se de que todas as alocações feitas do padrão de POOL \_ que residem na memória de vídeo vinculam a memória durante a vida útil do recurso que está indisponível para uso pelo Gerenciador de recursos ou por qualquer outra finalidade.</span><span class="sxs-lookup"><span data-stu-id="663c3-177">Remember that all allocations made from POOL\_DEFAULT that reside in video memory tie up memory for the life that resource that is unavailable for use by the resource manager or for any other purpose.</span></span>

<span data-ttu-id="663c3-178">Observe que, diferentemente das versões anteriores do Direct3D, o tempo de execução da versão 9 remove automaticamente alguns recursos gerenciados antes de desistir de uma alocação de recursos não gerenciado com falha para uma falta de memória de vídeo, mas isso pode potencialmente criar fragmentação adicional e até mesmo forçar um recurso em um local abaixo do ideal (por exemplo, ter uma textura estática na memória de vídeo não local)</span><span class="sxs-lookup"><span data-stu-id="663c3-178">Note that unlike previous versions of Direct3D, the version 9 runtime automatically evicts some managed resources before giving up on a failed unmanaged resource allocation for a lack of video memory, but this can potentially create additional fragmentation and even force a resource into a sub-optimal location (for example, having a static texture in non-local video memory).</span></span> <span data-ttu-id="663c3-179">Novamente, é melhor alocar todos os recursos não gerenciados necessários antecipadamente e antes de usar qualquer recurso gerenciado.</span><span class="sxs-lookup"><span data-stu-id="663c3-179">Again, it is best to allocate all required unmanaged resources up front and before using any managed resources.</span></span>

### <a name="dynamic-default-resources"></a><span data-ttu-id="663c3-180">Recursos padrão dinâmicos</span><span class="sxs-lookup"><span data-stu-id="663c3-180">Dynamic Default Resources</span></span>

<span data-ttu-id="663c3-181">Os dados gerados e atualizados a uma alta frequência não têm necessidade de armazenamento de backup, pois todas as informações serão recriadas ao restaurar o dispositivo.</span><span class="sxs-lookup"><span data-stu-id="663c3-181">Data that is generated and updated at a high frequency has no need for the backing-store since all the information will be re-created when restoring the device.</span></span> <span data-ttu-id="663c3-182">Esses dados normalmente são mais bem criados no \_ padrão de pool, especificando a \_ dica dinâmica de uso, para que o driver possa tomar decisões de otimização ao colocar o recurso, sabendo que ele será atualizado com frequência.</span><span class="sxs-lookup"><span data-stu-id="663c3-182">Such data is typically best created in POOL\_DEFAULT, specifying the USAGE\_DYNAMIC hint, so that the driver can make optimization decisions when placing the resource, knowing that it will be updated often.</span></span> <span data-ttu-id="663c3-183">Isso normalmente significa colocar o recurso em memória de vídeo não local e, portanto, normalmente é muito mais lento para a GPU acessar do que a memória de vídeo local.</span><span class="sxs-lookup"><span data-stu-id="663c3-183">This typically means putting the resource into non-local video memory, and thus, it is usually much slower for the GPU to access than local video memory.</span></span> <span data-ttu-id="663c3-184">Para arquiteturas de uma, o driver pode escolher um posicionamento específico para que os recursos dinâmicos otimizem para o acesso de gravação da CPU.</span><span class="sxs-lookup"><span data-stu-id="663c3-184">For UMA architectures, the driver might choose a particular placement for dynamic resources to optimize for CPU write access.</span></span>

<span data-ttu-id="663c3-185">Esse uso é típico para soluções de revestimento de software e sistemas de partículas baseados em CPU que preenchem buffers de vértice/índice e o sinalizador de descarte de bloqueio \_ garantirá que as vagas não sejam criadas nos casos em que o recurso ainda esteja em uso no quadro anterior.</span><span class="sxs-lookup"><span data-stu-id="663c3-185">This usage is typical for software skinning solutions and CPU-based particle systems filling out vertex/index buffers, and the LOCK\_DISCARD flag will ensure that stalls are not created in cases where the resource is still in use from the previous frame.</span></span> <span data-ttu-id="663c3-186">O uso de um recurso gerenciado, nesse caso, atualizaria um buffer de memória do sistema, que seria então copiado para memória de vídeo e, em seguida, usado apenas para um ou dois quadros antes de ser substituído.</span><span class="sxs-lookup"><span data-stu-id="663c3-186">Using a managed resource in this case would update a system memory buffer, which would then be copied to video memory, and then used for only a frame or two before being replaced.</span></span> <span data-ttu-id="663c3-187">Para sistemas com memória de vídeo não local, a cópia extra é eliminada pelo uso adequado desse padrão dinâmico.</span><span class="sxs-lookup"><span data-stu-id="663c3-187">For systems with non-local video memory, the extra copy is eliminated by proper use of this dynamic pattern.</span></span>

<span data-ttu-id="663c3-188">As texturas padrão não podem ser bloqueadas e só podem ser atualizadas por meio de [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) ou [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span><span class="sxs-lookup"><span data-stu-id="663c3-188">Standard textures cannot be locked, and can only be updated via [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) or [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span></span> <span data-ttu-id="663c3-189">Alguns sistemas dão suporte a texturas dinâmicas, que podem ser bloqueadas e usam o padrão de descarte de bloqueio \_ , mas um bit de recursos (D3DCAPS2 \_ DYNAMICTEXTURES) deve ser verificado antes de usar esses recursos.</span><span class="sxs-lookup"><span data-stu-id="663c3-189">Some systems support dynamic textures, which can be locked, and use the LOCK\_DISCARD pattern, but a capabilities bit (D3DCAPS2\_DYNAMICTEXTURES) must be checked before making use of such resources.</span></span> <span data-ttu-id="663c3-190">Para texturas altamente dinâmicas (vídeo ou procedimento), o aplicativo poderia criar recursos de POOL e de SYSTEMMEM de pool correspondentes \_ \_ e manipular atualizações de memória de vídeo usando o **UpdateTexture**.</span><span class="sxs-lookup"><span data-stu-id="663c3-190">For highly dynamic textures (video or procedural), your application could create matching POOL\_DEFAULT and POOL\_SYSTEMMEM resources and handle video-memory updates by using **UpdateTexture**.</span></span> <span data-ttu-id="663c3-191">Para atualizações muito frequentes e parciais, o paradigma **UpdateTexture** é provavelmente a melhor opção.</span><span class="sxs-lookup"><span data-stu-id="663c3-191">For highly frequent and partial updates, the **UpdateTexture** paradigm is likely the better choice.</span></span>

<span data-ttu-id="663c3-192">Assim como os recursos dinâmicos podem ser, tenha cuidado ao projetar sistemas que dependam muito do envio dinâmico.</span><span class="sxs-lookup"><span data-stu-id="663c3-192">As useful as dynamic resources can be, be careful when designing systems that rely heavily on dynamic submission.</span></span> <span data-ttu-id="663c3-193">Os recursos estáticos devem ser colocados no POOL \_ gerenciado para garantir uma boa utilização da memória de vídeo local e fazer uso mais eficiente de barramento limitado e largura de banda de memória principal.</span><span class="sxs-lookup"><span data-stu-id="663c3-193">Static resources should be placed into POOL\_MANAGED to ensure both good utilization of local video memory, and to make more efficient use of limited bus and main memory bandwidth.</span></span> <span data-ttu-id="663c3-194">Para recursos que são semiestáticos, você pode descobrir que o custo de um upload ocasional para a memória de vídeo local é muito menor do que o tráfego de barramento constante gerado, tornando-os dinâmicos.</span><span class="sxs-lookup"><span data-stu-id="663c3-194">For resources that are semi-static, you may find that the cost of an occasional upload to local video memory is much less than the constant bus traffic generated by making them dynamic.</span></span>

## <a name="system-memory-resources"></a><span data-ttu-id="663c3-195">Recursos de memória do sistema</span><span class="sxs-lookup"><span data-stu-id="663c3-195">System Memory Resources</span></span>

<span data-ttu-id="663c3-196">Os recursos também podem ser criados no POOL \_ SYSTEMMEM.</span><span class="sxs-lookup"><span data-stu-id="663c3-196">Resources can also be created in POOL\_SYSTEMMEM.</span></span> <span data-ttu-id="663c3-197">Embora eles não possam ser usados pelo pipeline de gráficos, eles podem ser usados como fontes para atualizar \_ os recursos padrão do pool usando [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) ou [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span><span class="sxs-lookup"><span data-stu-id="663c3-197">While they cannot be used by the graphics pipeline, they can be used as sources for updating POOL\_DEFAULT resources by using [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) or [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span></span> <span data-ttu-id="663c3-198">Seu comportamento de bloqueio é simples, embora as paralisações possam ocorrer se estiverem em uso por um dos métodos mencionados anteriormente.</span><span class="sxs-lookup"><span data-stu-id="663c3-198">Their locking behavior is simple, although stalls might occur if they are in use by one of the previously mentioned methods.</span></span>

<span data-ttu-id="663c3-199">Embora eles residam na memória do sistema, \_ os recursos do pool SYSTEMMEM são limitados aos mesmos formatos e capacidades (como o tamanho máximo) com suporte do driver de dispositivo.</span><span class="sxs-lookup"><span data-stu-id="663c3-199">Though they reside in system memory, POOL\_SYSTEMMEM resources are limited to the same formats and capabilities (such as maximum size) supported by the device driver.</span></span> <span data-ttu-id="663c3-200">O \_ tipo de recurso Scratch do pool é outra forma de recurso de memória do sistema que pode utilizar todos os formatos e funcionalidades com suporte no tempo de execução, mas não pode ser acessado pelo dispositivo.</span><span class="sxs-lookup"><span data-stu-id="663c3-200">The POOL\_SCRATCH resource type is another form of system memory resource that can utilize all formats and capabilities supported by the runtime, but cannot be accessed by the device.</span></span> <span data-ttu-id="663c3-201">Os recursos transitórios são destinados principalmente para uso por ferramentas de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="663c3-201">Scratch resources are intended primarily for use by content tools.</span></span>

<span data-ttu-id="663c3-202">**Figura 3. Recursos de memória em RAM de vídeo, abertura de AGP e RAM do sistema**</span><span class="sxs-lookup"><span data-stu-id="663c3-202">**Figure 3. Memory resources in video RAM, AGP aperture, and system RAM**</span></span>

![recursos de memória em RAM de vídeo, abertura de AGP e RAM do sistema](images/managingresources3.gif)

## <a name="general-recommendations"></a><span data-ttu-id="663c3-204">Recomendações gerais</span><span class="sxs-lookup"><span data-stu-id="663c3-204">General Recommendations</span></span>

<span data-ttu-id="663c3-205">Obter os detalhes da implementação técnica do gerenciamento de recursos correto será um longo caminho para atingir suas metas de desempenho para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="663c3-205">Getting the technical implementation details of resource management correct will go a long way toward achieving your performance goals for your application.</span></span> <span data-ttu-id="663c3-206">Planejar como os recursos são apresentados ao Direct3D e o design arquitetônico em relação à obtenção dos dados carregados em tempo hábil é uma tarefa mais complicada.</span><span class="sxs-lookup"><span data-stu-id="663c3-206">Planning how the resources are presented to Direct3D and the architectural design around getting the data loaded in a timely fashion is a more complicated task.</span></span> <span data-ttu-id="663c3-207">Recomendamos várias práticas recomendadas ao tomar essas decisões para seu aplicativo:</span><span class="sxs-lookup"><span data-stu-id="663c3-207">We recommend a number of best practices when making these decisions for your application:</span></span>

-   <span data-ttu-id="663c3-208">Pré-processar todos os seus recursos.</span><span class="sxs-lookup"><span data-stu-id="663c3-208">Pre-process all your resources.</span></span> <span data-ttu-id="663c3-209">Depender da conversão e da otimização do tempo de carga dispendioso para seus recursos é conveniente durante o desenvolvimento, mas isso coloca uma grande carga de desempenho nos computadores dos usuários.</span><span class="sxs-lookup"><span data-stu-id="663c3-209">Relying on expensive load-time conversion and optimization for your resources is convenient during development, but doing so puts a great performance burden on your users' computers.</span></span> <span data-ttu-id="663c3-210">Os recursos previamente processados são mais rápidos de carregar, mais rápidos de usar e oferecem a você a opção de fazer um trabalho off-line sofisticado.</span><span class="sxs-lookup"><span data-stu-id="663c3-210">Pre-processed resources are faster to load, faster to use, and give you the option of doing sophisticated off-line work.</span></span>
-   <span data-ttu-id="663c3-211">Evite criar muitos recursos por quadro.</span><span class="sxs-lookup"><span data-stu-id="663c3-211">Avoid creating many resources per frame.</span></span> <span data-ttu-id="663c3-212">As interações de driver necessárias podem serializar a CPU e a GPU, e as operações envolvidas são pesadas, pois elas geralmente exigem transições de kernel.</span><span class="sxs-lookup"><span data-stu-id="663c3-212">The driver interactions required can serialize the CPU and GPU, and the operations involved are heavy-weight, as they often require kernel transitions.</span></span> <span data-ttu-id="663c3-213">Espalhe a criação em vários quadros ou reutilize recursos sem criá-los/liberá-los.</span><span class="sxs-lookup"><span data-stu-id="663c3-213">Spread out creation over several frames or reuse resources without creating/releasing them.</span></span> <span data-ttu-id="663c3-214">O ideal é que você aguarde vários quadros antes de bloquear ou liberar recursos que foram usados recentemente para renderizar.</span><span class="sxs-lookup"><span data-stu-id="663c3-214">Ideally, you should wait several frames before locking or releasing resources that were recently used to render.</span></span>
-   <span data-ttu-id="663c3-215">No final do quadro, não se esqueça de desassociar todos os canais de recursos (ou seja, fontes de fluxo, estágios de textura e índices atuais).</span><span class="sxs-lookup"><span data-stu-id="663c3-215">At the end of the frame, be sure to unbind all resource channels (that is, stream sources, texture stages, and current indices).</span></span> <span data-ttu-id="663c3-216">Isso garantirá que as referências de pendente aos recursos sejam removidas antes que façam com que o Gerenciador de recursos Mantenha os recursos residentes que, na verdade, não estão mais em uso.</span><span class="sxs-lookup"><span data-stu-id="663c3-216">Doing so will ensure that dangling references to resources are removed before they cause the resource manager to keep resources resident that are actually no longer in use.</span></span>
-   <span data-ttu-id="663c3-217">Para texturas, use formatos compactados (por exemplo, DXTn) com os mapas MIP e considere usar um Atlas de textura.</span><span class="sxs-lookup"><span data-stu-id="663c3-217">For textures, use compressed formats (for example, DXTn) with mip-maps, and consider making use of a texture atlas.</span></span> <span data-ttu-id="663c3-218">Isso reduz significativamente os requisitos de largura de banda e pode reduzir o tamanho geral dos recursos, tornando-os mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="663c3-218">These greatly reduce bandwidth requirements, and they can reduce the overall size of the resources, thus making them more efficient.</span></span>
-   <span data-ttu-id="663c3-219">Para Geometry, use a geometria indexada, pois isso ajuda a compactar os recursos de buffer de vértice, e o hardware de vídeo moderno é muito otimizado em relação à reutilização de vértices.</span><span class="sxs-lookup"><span data-stu-id="663c3-219">For geometry, make use of indexed geometry as this helps compress vertex buffer resources, and modern video hardware is heavily optimized around reuse of vertices.</span></span> <span data-ttu-id="663c3-220">Ao fazer uso de sombreadores de vértice programáveis, você pode compactar as informações de vértice e expandi-las durante o processamento de vértice.</span><span class="sxs-lookup"><span data-stu-id="663c3-220">By making use of programmable vertex shaders, you can compress the vertex information and expand it during the vertex processing.</span></span> <span data-ttu-id="663c3-221">Novamente, isso ajuda a reduzir os requisitos de largura de banda e torna os recursos de buffer de vértice mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="663c3-221">Again, this helps reduce bandwidth requirements and makes vertex buffer resources more efficient.</span></span>
-   <span data-ttu-id="663c3-222">Evite a otimização excessiva de seu gerenciamento de recursos.</span><span class="sxs-lookup"><span data-stu-id="663c3-222">Avoid over-optimizing your resource management.</span></span> <span data-ttu-id="663c3-223">Revisões futuras de drivers, hardware e sistema operacional podem causar problemas de compatibilidade se o aplicativo for ajustado muito para uma combinação particularmente.</span><span class="sxs-lookup"><span data-stu-id="663c3-223">Future revisions of drivers, hardware, and the operating system can potentially cause compatibility problems if the application is tuned too heavily to a particularly combination.</span></span> <span data-ttu-id="663c3-224">Como a maioria dos aplicativos é limitada por CPU, o gerenciamento caro baseado em CPU geralmente causa mais problemas de desempenho do que é resolvido.</span><span class="sxs-lookup"><span data-stu-id="663c3-224">Since most applications are CPU-bound, expensive CPU-based management generally causes more performance issues than it solves.</span></span>

## <a name="related-topics"></a><span data-ttu-id="663c3-225">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="663c3-225">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="663c3-226">Gerenciando recursos</span><span class="sxs-lookup"><span data-stu-id="663c3-226">Managing Resources</span></span>](/windows/desktop/direct3d9/managing-resources)
</dt> <dt>

[<span data-ttu-id="663c3-227">Dispositivos perdidos</span><span class="sxs-lookup"><span data-stu-id="663c3-227">Lost Devices</span></span>](/windows/desktop/direct3d9/lost-devices)
</dt> <dt>

[<span data-ttu-id="663c3-228">Otimizações de desempenho</span><span class="sxs-lookup"><span data-stu-id="663c3-228">Performance Optimizations</span></span>](/windows/desktop/direct3d9/performance-optimizations)
</dt> <dt>

[<span data-ttu-id="663c3-229">Recursos de textura compactados</span><span class="sxs-lookup"><span data-stu-id="663c3-229">Compressed Texture Resources</span></span>](/windows/desktop/direct3d9/compressed-texture-resources)
</dt> <dt>

[<span data-ttu-id="663c3-230">Consultas</span><span class="sxs-lookup"><span data-stu-id="663c3-230">Queries</span></span>](/windows/desktop/direct3d9/queries)
</dt> <dt>

[<span data-ttu-id="663c3-231">**D3DUSAGE**</span><span class="sxs-lookup"><span data-stu-id="663c3-231">**D3DUSAGE**</span></span>](/windows/desktop/direct3d9/d3dusage)
</dt> <dt>

[<span data-ttu-id="663c3-232">**D3DPOOL**</span><span class="sxs-lookup"><span data-stu-id="663c3-232">**D3DPOOL**</span></span>](/windows/desktop/direct3d9/d3dpool)
</dt> <dt>

[<span data-ttu-id="663c3-233">D3DCREATE</span><span class="sxs-lookup"><span data-stu-id="663c3-233">D3DCREATE</span></span>](/windows/desktop/direct3d9/d3dcreate)
</dt> </dl>

 

 