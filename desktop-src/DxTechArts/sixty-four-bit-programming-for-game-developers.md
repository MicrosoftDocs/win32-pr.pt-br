---
title: programação de 64 bits para desenvolvedores de jogos
description: Este artigo aborda problemas de compatibilidade e portabilidade e ajuda os desenvolvedores a facilitarem sua transição para plataformas de 64 bits.
ms.assetid: 23a7ed41-6637-0607-327e-983b622e9104
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b12e57ea1b3cc3272ca40465df31a04244d99e68
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104007869"
---
# <a name="64-bit-programming-for-game-developers"></a><span data-ttu-id="8571b-103">programação de 64 bits para desenvolvedores de jogos</span><span class="sxs-lookup"><span data-stu-id="8571b-103">64-bit programming for Game Developers</span></span>

<span data-ttu-id="8571b-104">Os fabricantes de processador estão fornecendo exclusivamente processadores de 64 bits em seus computadores desktop e até mesmo os chipsets da maioria dos computadores laptop dão suporte à tecnologia x64.</span><span class="sxs-lookup"><span data-stu-id="8571b-104">Processor manufacturers are exclusively shipping 64-bit processors in their desktop computers, and even the chipsets of most laptop computers support x64 technology.</span></span> <span data-ttu-id="8571b-105">É importante que os desenvolvedores de jogos tirem proveito dos aprimoramentos que os processadores de 64 bits oferecem com seus novos aplicativos e para garantir que seus aplicativos anteriores sejam executados corretamente nos novos processadores e nas edições de 64 bits do Windows Vista e do Windows 7.</span><span class="sxs-lookup"><span data-stu-id="8571b-105">It is important for game developers to take advantage of the improvements that 64-bit processors offer with their new applications and to ensure that their earlier applications run correctly on the new processors and the 64-bit editions of Windows Vista and Windows 7.</span></span> <span data-ttu-id="8571b-106">Este artigo aborda problemas de compatibilidade e portabilidade e ajuda os desenvolvedores a facilitarem sua transição para plataformas de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-106">This article addresses compatibility and porting issues and helps developers ease their transition to 64-bit platforms.</span></span>

<span data-ttu-id="8571b-107">A Microsoft atualmente tem os seguintes sistemas operacionais de 64 bits:</span><span class="sxs-lookup"><span data-stu-id="8571b-107">Microsoft currently has the following 64-bit operating systems:</span></span>

-   <span data-ttu-id="8571b-108">Windows Server 2003 Service Pack 1</span><span class="sxs-lookup"><span data-stu-id="8571b-108">Windows Server 2003 Service Pack 1</span></span>
-   <span data-ttu-id="8571b-109">Windows XP Professional x64 Edition (disponível para OEMs e desenvolvedores por meio do MSDN)</span><span class="sxs-lookup"><span data-stu-id="8571b-109">Windows XP Professional x64 Edition (available to OEMs and to developers through MSDN)</span></span>
-   <span data-ttu-id="8571b-110">Windows Vista</span><span class="sxs-lookup"><span data-stu-id="8571b-110">Windows Vista</span></span>
-   <span data-ttu-id="8571b-111">Windows Server 2008</span><span class="sxs-lookup"><span data-stu-id="8571b-111">Windows Server 2008</span></span>
-   <span data-ttu-id="8571b-112">Windows 7</span><span class="sxs-lookup"><span data-stu-id="8571b-112">Windows 7</span></span>
-   <span data-ttu-id="8571b-113">Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="8571b-113">Windows Server 2008 R2</span></span>

> [!Note]  
> <span data-ttu-id="8571b-114">O Windows Server 2008 R2 só está disponível como uma edição de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-114">Windows Server 2008 R2 is only available as a 64-bit edition.</span></span>

 

-   [<span data-ttu-id="8571b-115">Diferenças na memória endereçável</span><span class="sxs-lookup"><span data-stu-id="8571b-115">Differences in Addressable Memory</span></span>](#differences-in-addressable-memory)
-   [<span data-ttu-id="8571b-116">Especificando o reconhecimento de endereço grande ao compilar</span><span class="sxs-lookup"><span data-stu-id="8571b-116">Specifying Large-Address-Aware When Building</span></span>](#specifying-large-address-aware-when-building)
-   [<span data-ttu-id="8571b-117">Compatibilidade de aplicativos de 32 bits em plataformas de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-117">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>](#compatibility-of-32-bit-applications-on-64-bit-platforms)
    -   [<span data-ttu-id="8571b-118">Armadilhas de compatibilidade em potencial</span><span class="sxs-lookup"><span data-stu-id="8571b-118">Potential Compatibility Pitfalls</span></span>](#potential-compatibility-pitfalls)
-   [<span data-ttu-id="8571b-119">Portando aplicativos para plataformas de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-119">Porting Applications to 64-Bit Platforms</span></span>](#porting-applications-to-64-bit-platforms)
-   [<span data-ttu-id="8571b-120">Criação de perfil e otimização de aplicativos portados</span><span class="sxs-lookup"><span data-stu-id="8571b-120">Profiling and Optimization of Ported Applications</span></span>](#profiling-and-optimization-of-ported-applications)
-   [<span data-ttu-id="8571b-121">Código gerenciado em um sistema operacional de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-121">Managed Code on a 64-bit Operating System</span></span>](#managed-code-on-a-64-bit-operating-system)
-   [<span data-ttu-id="8571b-122">Implicações de desempenho da execução de um sistema operacional de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-122">Performance Implications of Running a 64-bit Operating System</span></span>](#performance-implications-of-running-a-64-bit-operating-system)
-   [<span data-ttu-id="8571b-123">Resumo</span><span class="sxs-lookup"><span data-stu-id="8571b-123">Summary</span></span>](#summary)

## <a name="differences-in-addressable-memory"></a><span data-ttu-id="8571b-124">Diferenças na memória endereçável</span><span class="sxs-lookup"><span data-stu-id="8571b-124">Differences in Addressable Memory</span></span>

<span data-ttu-id="8571b-125">A primeira coisa que a maioria dos desenvolvedores observa é que os processadores de 64 bits fornecem um grande salto na quantidade de memória física e virtual que pode ser resolvida.</span><span class="sxs-lookup"><span data-stu-id="8571b-125">The first thing most developers notice is that 64-bit processors provide a huge leap in the amount of physical and virtual memory that can be addressed.</span></span>

-   <span data-ttu-id="8571b-126">aplicativos de 32 bits em plataformas de 32 bits podem resolver até 2 GB.</span><span class="sxs-lookup"><span data-stu-id="8571b-126">32-bit applications on 32-bit platforms can address up to 2 GB.</span></span>
-   <span data-ttu-id="8571b-127">os aplicativos de 32 bits criados com o sinalizador de vinculador/LARGEADDRESSAWARE: YES em 32 bits Windows XP ou Windows Server 2003 com a opção de inicialização especial/3GB podem lidar com até 3 GB.</span><span class="sxs-lookup"><span data-stu-id="8571b-127">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on 32-bit Windows XP or Windows Server 2003 with the special /3gb boot option can address up to 3 GB.</span></span> <span data-ttu-id="8571b-128">Isso restringe o kernel a apenas 1 GB, o que pode fazer com que alguns drivers e/ou serviços falhem.</span><span class="sxs-lookup"><span data-stu-id="8571b-128">This constrains the kernel to only 1 GB which may cause some drivers and/or services to fail.</span></span>
-   <span data-ttu-id="8571b-129">os aplicativos de 32 bits criados com o sinalizador de vinculador/LARGEADDRESSAWARE: YES nas edições de 32 bits do Windows Vista, do Windows Server 2008 e do Windows 7 podem endereçar a memória até o número especificado pelo elemento BCD (dados de configuração de inicialização) IncreaseUserVa.</span><span class="sxs-lookup"><span data-stu-id="8571b-129">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on the 32-bit editions of Windows Vista, Windows Server 2008, and Windows 7 can address memory up to the number specified by the boot configuration data (BCD) element IncreaseUserVa.</span></span> <span data-ttu-id="8571b-130">IncreaseUserVa pode ter um valor que varia de 2048, o padrão, para 3072 (que corresponde à quantidade de memória configurada pela opção de inicialização/3GB no Windows XP).</span><span class="sxs-lookup"><span data-stu-id="8571b-130">IncreaseUserVa can have a value ranging from 2048, the default, to 3072 (which matches the amount of memory configured by the /3gb boot option on Windows XP).</span></span> <span data-ttu-id="8571b-131">O restante de 4 GB é alocado para o kernel e pode resultar em falha nas configurações de driver e serviço.</span><span class="sxs-lookup"><span data-stu-id="8571b-131">The remainder of 4 GB is allocated to the kernel and can result in failing driver and service configurations.</span></span>

    <span data-ttu-id="8571b-132">Para obter mais informações sobre o BCD, consulte [dados de configuração da inicialização](https://msdn.microsoft.com/library/aa362692.aspx) no msdn.</span><span class="sxs-lookup"><span data-stu-id="8571b-132">For more information about BCD, see [Boot Configuration Data](https://msdn.microsoft.com/library/aa362692.aspx) on MSDN.</span></span>

-   <span data-ttu-id="8571b-133">aplicativos de 32 bits em plataformas de 64 bits podem lidar com até 2 GB ou até 4 GB com o sinalizador de vinculador/LARGEADDRESSAWARE: YES.</span><span class="sxs-lookup"><span data-stu-id="8571b-133">32-bit applications on 64-bit platforms can address up to 2 GB, or up to 4 GB with the /LARGEADDRESSAWARE:YES linker flag.</span></span>
-   <span data-ttu-id="8571b-134">os aplicativos de 64 bits usam 43 bits para endereçamento, que fornece 8 TB de endereço virtual para aplicativos e 8 TB reservados para o kernel.</span><span class="sxs-lookup"><span data-stu-id="8571b-134">64-bit applications use 43 bits for addressing, which provides 8 TB of virtual address for applications and 8 TB reserved for the kernel.</span></span>

<span data-ttu-id="8571b-135">Além de apenas memória, os aplicativos de 64 bits que usam o benefício de e/s de arquivo mapeado por memória são muito maiores do que o maior espaço de endereço virtual.</span><span class="sxs-lookup"><span data-stu-id="8571b-135">Beyond just memory, 64-bit applications that use memory-mapped file I/O benefit greatly from the increased virtual address space.</span></span> <span data-ttu-id="8571b-136">A arquitetura de 64 bits também melhorou o desempenho do ponto flutuante e a passagem mais rápida de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="8571b-136">The 64-bit architecture also has improved floating-point performance and faster passing of parameters.</span></span> <span data-ttu-id="8571b-137">Os processadores de 64 bits têm o dobro do número de registros, dos tipos de uso geral e de SSE (Streaming SIMD Extensions), bem como suporte para conjuntos de instruções SSE e SSE2; muitos processadores de 64 bits até mesmo dão suporte a conjuntos de instruções SSE3.</span><span class="sxs-lookup"><span data-stu-id="8571b-137">Sixty-four-bit processors have double the number of registers, of both general purpose and streaming SIMD extensions (SSE) types, as well as support for SSE and SSE2 instruction sets; many 64-bit processors even support SSE3 instruction sets.</span></span>

## <a name="specifying-large-address-aware-when-building"></a><span data-ttu-id="8571b-138">Especificando o reconhecimento de endereço grande ao compilar</span><span class="sxs-lookup"><span data-stu-id="8571b-138">Specifying Large-Address-Aware When Building</span></span>

<span data-ttu-id="8571b-139">É uma boa prática especificar um reconhecimento de endereço grande ao criar aplicativos de 32 bits, usando o sinalizador do vinculador/LARGEADDRESSAWARE, mesmo que o aplicativo não se destine a uma plataforma de 64 bits, devido às vantagens que são obtidas sem nenhum custo.</span><span class="sxs-lookup"><span data-stu-id="8571b-139">It is a good practice to specify large-address-aware when building 32-bit applications, by using the linker flag /LARGEADDRESSAWARE, even if the application is not intended for a 64-bit platform, because of the advantages that are gained at no cost.</span></span> <span data-ttu-id="8571b-140">Conforme explicado anteriormente, a habilitação desse sinalizador para uma compilação permite que um programa de 32 bits acesse mais memória com opções de inicialização especiais em um sistema operacional de 32 bits ou em um sistema operacional de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-140">As explained earlier, enabling this flag for a build allows a 32-bit program to access more memory with special boot options on a 32-bit OS or on a 64-bit OS.</span></span> <span data-ttu-id="8571b-141">No entanto, os desenvolvedores devem ter cuidado para que as suposições do ponteiro não sejam feitas, como supondo que o alto bit nunca seja definido em um ponteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-141">However, developers must be careful that pointer assumptions are not made, such as assuming that the high-bit is never set in a 32-bit pointer.</span></span> <span data-ttu-id="8571b-142">Em geral, a habilitação do sinalizador/LARGEADDRESSAWARE é uma boa prática.</span><span class="sxs-lookup"><span data-stu-id="8571b-142">In general, enabling the /LARGEADDRESSAWARE flag is a good practice.</span></span>

<span data-ttu-id="8571b-143">Os aplicativos de 32 bits com reconhecimento de endereço grande podem determinar em tempo de execução quanto espaço de endereço virtual total está disponível para eles com a configuração do sistema operacional atual chamando [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span><span class="sxs-lookup"><span data-stu-id="8571b-143">Thirty-two-bit applications that are large-address-aware can determine at run time how much total virtual address space is available to them with the current OS configuration by calling [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span></span> <span data-ttu-id="8571b-144">O resultado de ullTotalVirtual vai variar de 2147352576 bytes (2 GB) a 4294836224 bytes (4 GB).</span><span class="sxs-lookup"><span data-stu-id="8571b-144">The ullTotalVirtual result will range from 2147352576 bytes (2 GB) to 4294836224 bytes (4 GB).</span></span> <span data-ttu-id="8571b-145">Valores maiores que 3221094400 (3 GB) só podem ser obtidos em edições de 64 bits do Windows.</span><span class="sxs-lookup"><span data-stu-id="8571b-145">Values that are larger than 3221094400 (3 GB) can only be obtained on 64-bit editions of Windows.</span></span> <span data-ttu-id="8571b-146">Por exemplo, se IncreaseUserVa tiver um valor de 2560, o resultado será ullTotalVirtual com um valor de 2684223488 bytes.</span><span class="sxs-lookup"><span data-stu-id="8571b-146">For example, if IncreaseUserVa has a value of 2560, the result is ullTotalVirtual with a value of 2684223488 bytes.</span></span>

## <a name="compatibility-of-32-bit-applications-on-64-bit-platforms"></a><span data-ttu-id="8571b-147">Compatibilidade de aplicativos de 32 bits em plataformas de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-147">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>

<span data-ttu-id="8571b-148">Os sistemas operacionais Windows de 64 bits são binários compatíveis com a arquitetura IA32 e a maioria das APIs que os aplicativos de 32 bits usam estão disponíveis por meio do Windows 32 bits no emulador de bits do Windows de 64, WOW64.</span><span class="sxs-lookup"><span data-stu-id="8571b-148">Sixty-four-bit Windows operating systems are binary compatible with the IA32 architecture, and the majority of APIs that 32-bit applications use are available through the Windows 32-bit on Windows 64-bit Emulator, WOW64.</span></span> <span data-ttu-id="8571b-149">O WOW64 ajuda a garantir que essas APIs funcionem conforme o esperado.</span><span class="sxs-lookup"><span data-stu-id="8571b-149">WOW64 helps ensure that these APIs will work as intended.</span></span>

<span data-ttu-id="8571b-150">O WOW64 tem uma camada de execução que manipula o marshaling de dados de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-150">WOW64 has an execution layer that handles the marshalling of 32-bit data.</span></span> <span data-ttu-id="8571b-151">O WOW64 redireciona as solicitações de arquivo DLL, redireciona algumas ramificações do registro para aplicativos de 32 bits e reflete algumas ramificações do registro para aplicativos de 32 e 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-151">WOW64 redirects DLL file requests, redirects some registry branches for 32-bit applications, and reflects some registry branches for 32- and 64-bit applications.</span></span>

<span data-ttu-id="8571b-152">Mais informações sobre o WOW64 podem ser encontradas em [detalhes de implementação do WOW64](/windows/desktop/WinProg64/wow64-implementation-details) no msdn.</span><span class="sxs-lookup"><span data-stu-id="8571b-152">More information on WOW64 can be found at [WOW64 Implementation Details](/windows/desktop/WinProg64/wow64-implementation-details) on MSDN.</span></span> <span data-ttu-id="8571b-153">Para obter as práticas recomendadas para a criação de aplicativos executados no WOW64, consulte [práticas recomendadas para o WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) no Windows hardware Developer Central.</span><span class="sxs-lookup"><span data-stu-id="8571b-153">For best practices for building applications that run on WOW64, see [Best Practices for WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) on Windows Hardware Developer Central.</span></span>

### <a name="potential-compatibility-pitfalls"></a><span data-ttu-id="8571b-154">Armadilhas de compatibilidade em potencial</span><span class="sxs-lookup"><span data-stu-id="8571b-154">Potential Compatibility Pitfalls</span></span>

<span data-ttu-id="8571b-155">A maioria dos aplicativos desenvolvidos para uma plataforma de 32 bits será executada sem problemas em uma plataforma de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-155">Most applications developed for a 32-bit platform will run without problems on a 64-bit platform.</span></span> <span data-ttu-id="8571b-156">Alguns aplicativos podem ter problemas, que podem incluir o seguinte:</span><span class="sxs-lookup"><span data-stu-id="8571b-156">A few applications could have issues, which might include the following:</span></span>

-   <span data-ttu-id="8571b-157">Todos os drivers para as edições de 64 bits dos sistemas operacionais Windows devem ser versões de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-157">All drivers for by 64-bit editions of Windows operating systems must be 64-bit versions.</span></span> <span data-ttu-id="8571b-158">Exigir novos drivers de 64 bits tem implicações para esquemas de proteção de cópia que dependem de drivers antigos.</span><span class="sxs-lookup"><span data-stu-id="8571b-158">Requiring new 64-bit drivers has implications for copy-protection schemes that rely on old drivers.</span></span> <span data-ttu-id="8571b-159">Observe que os drivers do modo kernel devem ser assinados por Authenticode para serem carregados por edições de 64 bits do Windows.</span><span class="sxs-lookup"><span data-stu-id="8571b-159">Note that kernel-mode drivers must be Authenticode-signed to be loaded by 64-bit editions of Windows.</span></span>
-   <span data-ttu-id="8571b-160">os processos de 64 bits não podem carregar DLLs de 32 bits e os processos de 32 bits não podem carregar DLLs de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-160">64-bit processes cannot load 32-bit DLLs, and 32-bit processes cannot load 64-bit DLLs.</span></span> <span data-ttu-id="8571b-161">Os desenvolvedores devem garantir que as versões de 64 bits de DLLs de terceiros estejam disponíveis antes de prosseguir com o desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="8571b-161">Developers must ensure that 64-bit versions of third-party DLLs are available before proceeding with development.</span></span> <span data-ttu-id="8571b-162">Se você precisar usar uma DLL de 32 bits em um processo de 64 bits, a comunicação entre processos do Windows (IPC) poderá ser usada.</span><span class="sxs-lookup"><span data-stu-id="8571b-162">If you must use a 32-bit DLL in a 64-bit process, then Windows inter-process communication (IPC) can be used.</span></span> <span data-ttu-id="8571b-163">Os componentes COM também podem fazer uso de servidores fora do processo e marshalling para comunicação entre limites, mas isso pode introduzir uma penalidade de desempenho.</span><span class="sxs-lookup"><span data-stu-id="8571b-163">COM components can also make use of out-of-process servers and marshalling to communicate between boundaries, but doing so may introduce a performance penalty.</span></span>
-   <span data-ttu-id="8571b-164">Muitos processadores x64 também são processadores de vários núcleos, e os desenvolvedores precisam testar como isso afeta seus aplicativos herdados.</span><span class="sxs-lookup"><span data-stu-id="8571b-164">Many x64 processors are also multi-core processors, and developers need to test to how this affects their legacy applications.</span></span> <span data-ttu-id="8571b-165">Mais informações sobre processadores de vários núcleos e as implicações para aplicativos de jogos podem ser encontradas nos [processadores de tempo de jogo e de diversos núcleos](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span><span class="sxs-lookup"><span data-stu-id="8571b-165">More information on multi-core processors and the implications for gaming applications can be found in [Game Timing and Multicore Processors](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span></span>
-   <span data-ttu-id="8571b-166">Os aplicativos também devem chamar [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) para descobrir caminhos de arquivo, pois alguns nomes de pastas foram alterados em determinados casos.</span><span class="sxs-lookup"><span data-stu-id="8571b-166">Applications should also call [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) to discover file paths, as some folder names have changed in certain cases.</span></span> <span data-ttu-id="8571b-167">Por exemplo, \_ os arquivos de programa CSIDL \_ retornariam "C: \\ Program Files (x86)" para um aplicativo de 32 bits em execução em uma plataforma de 64 bits em vez de "C: \\ Program Files".</span><span class="sxs-lookup"><span data-stu-id="8571b-167">For example, CSIDL\_PROGRAM\_FILES would return "C:\\Program Files(x86)" for a 32-bit application running on a 64-bit platform instead of "C:\\Program Files".</span></span> <span data-ttu-id="8571b-168">Os desenvolvedores devem estar atentos à forma como os recursos de redirecionamento e reflexão do emulador do WOW64 funcionam.</span><span class="sxs-lookup"><span data-stu-id="8571b-168">Developers must be mindful of how the WOW64 emulator's redirection and reflection capabilities work.</span></span>

<span data-ttu-id="8571b-169">Além disso, os desenvolvedores precisam ser cautelosos em programas de 16 bits que ainda podem estar usando.</span><span class="sxs-lookup"><span data-stu-id="8571b-169">In addition, developers need to be wary of 16-bit programs that they might still be using.</span></span> <span data-ttu-id="8571b-170">O WOW64 não pode lidar com aplicativos de 16 bits; Isso inclui instaladores antigos e todos os programas do MS-DOS.</span><span class="sxs-lookup"><span data-stu-id="8571b-170">WOW64 cannot handle 16-bit applications; this includes old installers and all MS-DOS programs.</span></span>

> [!Note]  
> <span data-ttu-id="8571b-171">Os problemas de compatibilidade mais comuns são instaladores que executam código de 16 bits e não têm drivers de 64 bits para esquemas de proteção de cópia.</span><span class="sxs-lookup"><span data-stu-id="8571b-171">The most common compatibility issues are installers that execute 16-bit code and not having 64-bit drivers for copy protection schemes.</span></span>

 

<span data-ttu-id="8571b-172">A próxima seção discute problemas relacionados à portagem de código para o 64-bit nativo para desenvolvedores que desejam garantir que seus programas herdados funcionem em plataformas de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-172">The next section discusses issues related to porting code to 64-bit native for developers that want to ensure their legacy programs work on 64-bit platforms.</span></span> <span data-ttu-id="8571b-173">Ele também é para os desenvolvedores que não estão familiarizados com a programação de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-173">It is also for developers who are unfamiliar with 64-bit programming.</span></span>

## <a name="porting-applications-to-64-bit-platforms"></a><span data-ttu-id="8571b-174">Portando aplicativos para plataformas de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-174">Porting Applications to 64-Bit Platforms</span></span>

<span data-ttu-id="8571b-175">Ter as ferramentas e bibliotecas certas ajudará a facilitar a transição de 32 para o desenvolvimento de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-175">Having the right tools and libraries will help to ease the transition from 32-bit to 64-bit development.</span></span> <span data-ttu-id="8571b-176">O SDK do DirectX 9 tem bibliotecas para dar suporte a projetos baseados em x86 e x64.</span><span class="sxs-lookup"><span data-stu-id="8571b-176">The DirectX 9 SDK has libraries to support both x86- and x64-based projects.</span></span> <span data-ttu-id="8571b-177">Microsoft Visual Studio 2005 e o Visual Studio 2008 oferecem suporte à geração de código para x86 e x64, e eles são fornecidos com bibliotecas otimizadas para gerar código x64.</span><span class="sxs-lookup"><span data-stu-id="8571b-177">Microsoft Visual Studio 2005 and Visual Studio 2008 support code generation for both x86 and x64, and they comes with libraries optimized for generating x64 code.</span></span> <span data-ttu-id="8571b-178">No entanto, também será necessário que os desenvolvedores distribuam os tempos de execução do Visual C com seus aplicativos.</span><span class="sxs-lookup"><span data-stu-id="8571b-178">However, it will also be necessary for developers to distribute the Visual C runtimes with their applications.</span></span> <span data-ttu-id="8571b-179">Observe que as edições Express do Visual Studio 2005 e do Visual Studio 2008 não incluem o compilador x64, mas as edições Standard, Professional e Team System fazem.</span><span class="sxs-lookup"><span data-stu-id="8571b-179">Note that the Express Editions of Visual Studio 2005 and Visual Studio 2008 do not include the x64 compiler, but that the Standard, Professional, and Team System editions all do.</span></span>

<span data-ttu-id="8571b-180">Os desenvolvedores que estão visando plataformas de 32 bits podem se preparar para o desenvolvimento de 64 bits para facilitar a transição mais tarde.</span><span class="sxs-lookup"><span data-stu-id="8571b-180">Developers who are targeting 32-bit platforms can prepare for 64-bit development to make their transition easier later on.</span></span> <span data-ttu-id="8571b-181">Ao compilar projetos de 32 bits, os desenvolvedores devem usar o sinalizador/Wp64, o que fará com que a geração de avisos sobre problemas afete a portabilidade.</span><span class="sxs-lookup"><span data-stu-id="8571b-181">When compiling 32-bit projects, developers should use the /Wp64 flag, which will cause the generation of warnings about issues that affect portability.</span></span> <span data-ttu-id="8571b-182">A mudança para ferramentas e bibliotecas de 64 bits provavelmente irá gerar muitos erros de compilação inicialmente; Portanto, é aconselhável alternar ferramentas e bibliotecas com neutralidade de bits e corrigir quaisquer avisos antes de alternar para um Build de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-182">Switching to 64-bit tools and libraries will probably generate a lot of new build errors initially; so, it is advisable to switch bit-neutral tools and libraries and correct any warnings before switching to a 64-bit build.</span></span>

<span data-ttu-id="8571b-183">No entanto, a alteração de ferramentas, a alteração de bibliotecas e o uso de determinados sinalizadores de compilador não serão suficientes.</span><span class="sxs-lookup"><span data-stu-id="8571b-183">Changing tools, changing libraries, and using certain compiler flags will not be enough, though.</span></span> <span data-ttu-id="8571b-184">As suposições em padrões de codificação devem ser reavaliadas para garantir que os padrões de codificação atuais não permitam problemas de portabilidade.</span><span class="sxs-lookup"><span data-stu-id="8571b-184">Assumptions in coding standards must be reevaluated to ensure that current coding standards don't allow portability issues.</span></span> <span data-ttu-id="8571b-185">Problemas de portabilidade podem incluir truncamento de ponteiro, tamanho e alinhamento de tipos de dados, confiança em DLLs de 32 bits, uso de APIs herdadas, código de assembly e arquivos binários antigos.</span><span class="sxs-lookup"><span data-stu-id="8571b-185">Portability issues can include pointer truncation, size and alignment of data types, reliance on 32-bit DLLs, use of legacy APIs, assembly code, and old binary files.</span></span>

> [!Note]  
> <span data-ttu-id="8571b-186">Visual C++ 2010 inclui os cabeçalhos stdint. h e cstdint C99 que definem os tipos de portabilidade padrão Int32 \_ t, UInt32 \_ t, Int64 \_ t, UInt64 t, IntPtr t e \_ \_ UIntPtr \_ t.</span><span class="sxs-lookup"><span data-stu-id="8571b-186">Visual C++ 2010 includes the stdint.h and cstdint C99 headers which define the standard portability types int32\_t, uint32\_t, int64\_t, uint64\_t, intptr\_t, and uintptr\_t.</span></span> <span data-ttu-id="8571b-187">Usar esses tipos de dados padrão ptrdiff \_ t e Size \_ t pode ser preferível aos tipos de portabilty do Windows usados abaixo para melhorar a portabilidade do código.</span><span class="sxs-lookup"><span data-stu-id="8571b-187">Using these along with the standard ptrdiff\_t and size\_t data types may be preferrable to the Windows portabilty types used below for improving portability of code.</span></span>

 

<span data-ttu-id="8571b-188">Os principais problemas de portabilidade incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="8571b-188">Major porting issues include the following:</span></span>

<dl> <dt>

<span data-ttu-id="8571b-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Truncamento do ponteiro**</span><span class="sxs-lookup"><span data-stu-id="8571b-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Pointer Truncation**</span></span>
</dt> <dd>

<span data-ttu-id="8571b-190">OS ponteiros são 64 bits em um sistema operacional de 64 bits, portanto, a conversão de ponteiros para outros tipos de dados pode resultar em truncamento, e a aritmética de ponteiro pode resultar em corrupção.</span><span class="sxs-lookup"><span data-stu-id="8571b-190">Pointers are 64-bits on a 64-bit OS, so casting pointers to other data types can result in truncation, and pointer arithmetic can result in corruption.</span></span> <span data-ttu-id="8571b-191">Usar o sinalizador/Wp64 geralmente fornecerá um aviso sobre esse tipo de problema, mas usando tipos polimórficos (INT \_ PTR, DWORD \_ PTR, Size \_ T, uint \_ PTR e assim por diante) durante a conversão de tipos de ponteiro é uma boa prática para ajudar a evitar esse problema completamente.</span><span class="sxs-lookup"><span data-stu-id="8571b-191">Using the /Wp64 flag will usually provide a warning about this kind of issue, but using polymorphic types (INT\_PTR, DWORD\_PTR, SIZE\_T, UINT\_PTR, and so on) when casting pointer types is a good practice to help avoid this issue altogether.</span></span> <span data-ttu-id="8571b-192">Como os ponteiros são de 64 bits em novas plataformas, os desenvolvedores devem verificar a ordenação de ponteiros e os tipos de dados em classes e estruturas para reduzir ou eliminar o preenchimento.</span><span class="sxs-lookup"><span data-stu-id="8571b-192">Since pointers are 64-bit on new platforms, developers should check the ordering of pointers, and the data types in classes and structures, to reduce or eliminate padding.</span></span>

</dd> <dt>

<span data-ttu-id="8571b-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Tipos de dados e arquivos binários**</span><span class="sxs-lookup"><span data-stu-id="8571b-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Data Types and Binary Files**</span></span>
</dt> <dd>

<span data-ttu-id="8571b-194">Embora os ponteiros aumentem de 32 bits para 64 em uma plataforma de 64 bits, outros tipos de dados não.</span><span class="sxs-lookup"><span data-stu-id="8571b-194">While pointers increase from 32 bits to 64 on a 64-bit platform, other data types don't.</span></span> <span data-ttu-id="8571b-195">Os tipos de dados de precisão fixa (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32 e UINT64) podem ser usados em locais onde o tamanho do tipo de dados deve ser conhecido; por exemplo, em uma estrutura de arquivo binário.</span><span class="sxs-lookup"><span data-stu-id="8571b-195">Fixed-precision data types (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) can be used in places where the size of the data type must be known; for example, in a binary file structure.</span></span> <span data-ttu-id="8571b-196">As alterações no tamanho do ponteiro e no alinhamento de dados exigem tratamento especial para garantir a compatibilidade de 32 bits para 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-196">The changes in pointer size and data alignment require special handling to ensure 32-bit-to-64-bit compatibility.</span></span> <span data-ttu-id="8571b-197">Mais informações podem ser encontradas em [preparando-se para o Windows de 64 bits: os novos tipos de dados](/windows/desktop/WinProg64/the-new-data-types).</span><span class="sxs-lookup"><span data-stu-id="8571b-197">More information can be found in [Getting Ready for 64-bit Windows: The New Data Types](/windows/desktop/WinProg64/the-new-data-types).</span></span>

</dd> <dt>

<span data-ttu-id="8571b-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**APIs e alinhamento de dados mais antigos do Win32**</span><span class="sxs-lookup"><span data-stu-id="8571b-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Older Win32 APIs and Data Alignment**</span></span>
</dt> <dd>

<span data-ttu-id="8571b-199">Algumas APIs do Win32 foram preteridas e substituídas por chamadas de API mais neutras, como SetWindowLongPtr no lugar de SetWindowLong.</span><span class="sxs-lookup"><span data-stu-id="8571b-199">Some Win32 APIs have been deprecated and replaced with more neutral API calls such as SetWindowLongPtr in place of SetWindowLong.</span></span>

<span data-ttu-id="8571b-200">A penalidade de desempenho para acessos não alinhados é maior em plataforma x64 do que em uma plataforma x86.</span><span class="sxs-lookup"><span data-stu-id="8571b-200">The performance penalty for non-aligned accesses is greater on x64 platform than on an x86 platform.</span></span> <span data-ttu-id="8571b-201">As \_ macros de alinhamento de tipo (t) e deslocamento de campo \_ (t, membro) podem ser usadas para determinar as informações de alinhamento que podem ser usadas diretamente pelo código.</span><span class="sxs-lookup"><span data-stu-id="8571b-201">The TYPE\_ALIGNMENT(t) and the FIELD\_OFFSET(t, member) macros can be used to determine alignment information that can used directly by code.</span></span> <span data-ttu-id="8571b-202">O uso correto dessas macros mencionadas anteriormente deve eliminar penalidades de acesso não alinhadas.</span><span class="sxs-lookup"><span data-stu-id="8571b-202">Correct use of these aforementioned macros should eliminate potential non-aligned access penalties.</span></span>

<span data-ttu-id="8571b-203">Mais informações sobre a macro de alinhamento de tipo \_ , a macro de deslocamento de campo \_ e informações gerais de programação de 64 bits podem ser encontradas em [programação de 64 bits do Windows: dicas de migração: considerações adicionais](/windows/desktop/WinProg64/additional-considerations) e [preparação para janelas de 64 bits: regras para usar ponteiros](/windows/desktop/WinProg64/rules-for-using-pointers).</span><span class="sxs-lookup"><span data-stu-id="8571b-203">More information on the TYPE\_ALIGNMENT macro, the FIELD\_OFFSET macro, and general 64-bit programming information can be found at [64-bit Windows Programming: Migration Tips: Additional Considerations](/windows/desktop/WinProg64/additional-considerations) and [Getting Ready for 64-bit Windows: Rules for Using Pointers](/windows/desktop/WinProg64/rules-for-using-pointers).</span></span>

</dd> <dt>

<span data-ttu-id="8571b-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Código do assembly**</span><span class="sxs-lookup"><span data-stu-id="8571b-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Assembly Code**</span></span>
</dt> <dd>

<span data-ttu-id="8571b-205">O código de assembly embutido não tem suporte em plataformas de 64 bits e precisa ser substituído.</span><span class="sxs-lookup"><span data-stu-id="8571b-205">Inline assembly code is not supported on 64-bit platforms and needs to be replaced.</span></span> <span data-ttu-id="8571b-206">As alterações na arquitetura podem ter alterado afunilamentos de aplicativo, e C/C++ ou intrínsecos podem obter resultados semelhantes com o código que é mais fácil de ler.</span><span class="sxs-lookup"><span data-stu-id="8571b-206">Changes in the architecture may have changed application bottlenecks, and C/C++ or intrinsics can achieve similar results with code that is easier to read.</span></span> <span data-ttu-id="8571b-207">A prática mais recomendável é alternar todo o código do assembly para C ou C++.</span><span class="sxs-lookup"><span data-stu-id="8571b-207">The most advisable practice is to switch all assembly code to C or C++.</span></span> <span data-ttu-id="8571b-208">Intrínsecos podem ser usados no lugar do código do assembly, mas só devem ser usados após a execução da criação de perfil completa e da análise.</span><span class="sxs-lookup"><span data-stu-id="8571b-208">Intrinsics can be used in place of assembly code, but should only be used after full profiling and analysis has been performed.</span></span>

<span data-ttu-id="8571b-209">X87, MMX e 3DNow!</span><span class="sxs-lookup"><span data-stu-id="8571b-209">The x87, MMX, and 3DNow!</span></span> <span data-ttu-id="8571b-210">os conjuntos de instruções são preteridos nos modos de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-210">instruction sets are deprecated in 64-bit modes.</span></span> <span data-ttu-id="8571b-211">Os conjuntos de instruções ainda estão presentes para compatibilidade com versões anteriores para o modo de 32 bits; no entanto, para evitar problemas de compatibilidade no futuro, seu uso em projetos atuais e futuros é desencorajado.</span><span class="sxs-lookup"><span data-stu-id="8571b-211">The instructions sets are still present for backward compatibility for 32-bit mode; however, to avoid compatibility issues in the future, their use in current and future projects is discouraged.</span></span>

</dd> <dt>

<span data-ttu-id="8571b-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**APIs preteridas**</span><span class="sxs-lookup"><span data-stu-id="8571b-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Deprecated APIs**</span></span>
</dt> <dd>

<span data-ttu-id="8571b-213">Algumas APIs mais antigas do DirectX foram descartadas para aplicativos nativos de 64 bits: DirectPlay 4 e anteriores, DirectDraw 6 e anteriores, Direct3D 8 e anteriores e DirectInput 7 e anteriores.</span><span class="sxs-lookup"><span data-stu-id="8571b-213">Some older DirectX APIs have been dropped for 64-bit native applications: DirectPlay 4 and earlier, DirectDraw 6 and earlier, Direct3D 8 and earlier, and DirectInput 7 and earlier.</span></span> <span data-ttu-id="8571b-214">Além disso, a API principal do DirectMusic está disponível para aplicativos nativos de 64 bits, mas a camada de desempenho e o produtor do DirectMusic são preteridos.</span><span class="sxs-lookup"><span data-stu-id="8571b-214">Also, the core API of DirectMusic is available to native 64-bit applications, but the performance layer and DirectMusic Producer are deprecated.</span></span>

<span data-ttu-id="8571b-215">O Visual Studio emite avisos de substituição e essas alterações não são um problema para os desenvolvedores que usam as APIs mais recentes.</span><span class="sxs-lookup"><span data-stu-id="8571b-215">Visual Studio issues deprecation warnings, and these changes are not an issue for developers who use the latest APIs.</span></span>

</dd> </dl>

## <a name="profiling-and-optimization-of-ported-applications"></a><span data-ttu-id="8571b-216">Criação de perfil e otimização de aplicativos portados</span><span class="sxs-lookup"><span data-stu-id="8571b-216">Profiling and Optimization of Ported Applications</span></span>

<span data-ttu-id="8571b-217">Todos os desenvolvedores precisam recriar o perfil de todos os aplicativos que estão sendo portados para novas arquiteturas.</span><span class="sxs-lookup"><span data-stu-id="8571b-217">All developers need to re-profile any applications that are being ported to new architectures.</span></span> <span data-ttu-id="8571b-218">Muitos aplicativos sendo portados para plataformas de 64 bits terão perfis de desempenho diferentes de suas versões de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-218">Many applications being ported to 64-bit platforms will have different performance profiles from their 32-bit versions.</span></span> <span data-ttu-id="8571b-219">Os desenvolvedores precisam executar testes de desempenho de 64 bits antes de avaliar o que precisa ser otimizado.</span><span class="sxs-lookup"><span data-stu-id="8571b-219">Developers need to run 64-bit performance tests before assessing what needs to be optimized.</span></span> <span data-ttu-id="8571b-220">A boa notícia sobre isso é que muitas otimizações tradicionais funcionam em plataformas de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-220">The good news about this is that many traditional optimizations work on 64-bit platforms.</span></span> <span data-ttu-id="8571b-221">Além disso, os compiladores de 64 bits também podem executar muitas otimizações com o uso correto de sinalizadores de compilador e dicas de codificação.</span><span class="sxs-lookup"><span data-stu-id="8571b-221">In addition, 64-bit compilers can also perform many optimizations with the correct use of compiler flags and coding hints.</span></span>

<span data-ttu-id="8571b-222">Algumas estruturas podem ter seus tipos de dados internos reordenados para conservar espaço de memória e melhorar o Caching.</span><span class="sxs-lookup"><span data-stu-id="8571b-222">Some structures may have their internal data types reordered to conserve memory space and improve caching.</span></span> <span data-ttu-id="8571b-223">Os índices de matriz podem ser usados em vez de um ponteiro completo de 64 bits em alguns casos.</span><span class="sxs-lookup"><span data-stu-id="8571b-223">Array indices can be used instead of a full 64-bit pointer in some cases.</span></span> <span data-ttu-id="8571b-224">O sinalizador/fp: Fast pode melhorar a otimização e a vetorização de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="8571b-224">The /fp:fast flag can improve floating-point optimizing and vectorization.</span></span> <span data-ttu-id="8571b-225">\_ \_ O uso de restrict, declspec (restrict) e declspec (noalias) pode ajudar o compilador a resolver o alias e melhorar o uso do arquivo de registro.</span><span class="sxs-lookup"><span data-stu-id="8571b-225">Using \_\_restrict, declspec(restrict), and declspec(noalias) can help the compiler resolve aliasing and improve use of the register file.</span></span>

<span data-ttu-id="8571b-226">Mais informações sobre o/fp: Fast podem ser encontradas em [/FP (especificar o comportamento do Floating-Point)](/cpp/build/reference/fp-specify-floating-point-behavior).</span><span class="sxs-lookup"><span data-stu-id="8571b-226">More information on /fp:fast can be found at [/fp (Specify Floating-Point Behavior)](/cpp/build/reference/fp-specify-floating-point-behavior).</span></span>

<span data-ttu-id="8571b-227">Mais informações sobre \_ \_ o restringir podem ser encontradas em [modificadores específicos da Microsoft](/cpp/cpp/microsoft-specific-modifiers).</span><span class="sxs-lookup"><span data-stu-id="8571b-227">More information on \_\_restrict can be found at [Microsoft-Specific Modifiers](/cpp/cpp/microsoft-specific-modifiers).</span></span>

<span data-ttu-id="8571b-228">Mais informações sobre declspec (restrict) podem ser encontradas em [práticas recomendadas de otimização](/cpp/build/optimization-best-practices).</span><span class="sxs-lookup"><span data-stu-id="8571b-228">More information on declspec(restrict) can be found at [Optimization Best Practices](/cpp/build/optimization-best-practices).</span></span>

<span data-ttu-id="8571b-229">Mais informações sobre declspec (noalias) podem ser encontradas em [ \_ \_ declspec (noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span><span class="sxs-lookup"><span data-stu-id="8571b-229">More information on declspec(noalias) can be found at [\_\_declspec(noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span></span>

## <a name="managed-code-on-a-64-bit-operating-system"></a><span data-ttu-id="8571b-230">Código gerenciado em um sistema operacional de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-230">Managed Code on a 64-bit Operating System</span></span>

<span data-ttu-id="8571b-231">O código gerenciado é usado por muitos desenvolvedores de jogos em sua cadeia de ferramentas, portanto, uma compreensão de como ele se comporta em um sistema operacional de 64 bits pode ser útil.</span><span class="sxs-lookup"><span data-stu-id="8571b-231">Managed code is used by many game developers in their tool chain, so an understanding of how it behaves on a 64-bit OS can be helpful.</span></span> <span data-ttu-id="8571b-232">O código gerenciado é um conjunto de instruções neutro, portanto, quando você executa um aplicativo gerenciado em um sistema operacional de 64 bits, o CLR (Common Language Runtime) pode executá-lo como um processo de 32 bits ou de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-232">Managed code is instruction-set neutral, so when you run a managed application on a 64-bit OS, the Common Language Runtime (CLR) can run it as either a 32-bit or 64-bit process.</span></span> <span data-ttu-id="8571b-233">Por padrão, o CLR executa aplicativos gerenciados como 64 bits e eles devem funcionar bem sem problemas.</span><span class="sxs-lookup"><span data-stu-id="8571b-233">By default, the CLR runs managed applications as 64-bit, and they should work fine with no problems.</span></span> <span data-ttu-id="8571b-234">No entanto, se seu aplicativo depender de uma DLL nativa de 32 bits, o aplicativo falhará quando tentar chamar essa DLL.</span><span class="sxs-lookup"><span data-stu-id="8571b-234">However, if your application depends on a DLL that is native 32-bit, then your application will fail when it tries to call this DLL.</span></span> <span data-ttu-id="8571b-235">Um processo de 64 bits precisa de um código de 64 bits completamente e uma DLL de bits de 32 não pode ser chamada de um processo de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-235">A 64-bit process needs completely 64-bit code, and a 32-bit DLL cannot be called from a 64-bit process.</span></span> <span data-ttu-id="8571b-236">A melhor solução a longo prazo é compilar seu código nativo como 64-bit também, mas uma solução perfeitamente razoável de curto prazo é simplesmente marcar seu aplicativo gerenciado como somente para x86 usando o sinalizador de Build/Platform: x86.</span><span class="sxs-lookup"><span data-stu-id="8571b-236">The best long-term solution is to compile your native code as 64-bit also, but a perfectly reasonable short-term solution is to simply mark your managed application as being for x86 only by using the /platform:x86 build flag.</span></span>

## <a name="performance-implications-of-running-a-64-bit-operating-system"></a><span data-ttu-id="8571b-237">Implicações de desempenho da execução de um sistema operacional de 64 bits</span><span class="sxs-lookup"><span data-stu-id="8571b-237">Performance Implications of Running a 64-bit Operating System</span></span>

<span data-ttu-id="8571b-238">Como OS processadores com AMD64 e a arquitetura Intel 64 podem executar instruções de 32 bits nativamente, eles podem executar aplicativos de 32 bits em plena velocidade, mesmo em um sistema operacional de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-238">Because processors with AMD64 and Intel 64 architecture can execute 32-bit instructions natively, they can run 32-bit applications at full speed, even on a 64-bit OS.</span></span> <span data-ttu-id="8571b-239">Há um custo modesto para converter parâmetros entre 32 bits e 64 bits ao chamar funções do sistema operacional, mas esse custo geralmente é insignificante.</span><span class="sxs-lookup"><span data-stu-id="8571b-239">There is a modest cost for converting parameters between 32-bit and 64-bit when calling operating system functions, but this cost is generally negligible.</span></span> <span data-ttu-id="8571b-240">Isso significa que você não deve ver nenhuma lentidão ao executar aplicativos de 32 bits em um sistema operacional de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="8571b-240">This means that you should see no slowdown when running 32-bit applications on a 64-bit OS.</span></span>

<span data-ttu-id="8571b-241">Quando você compila aplicativos como 64 bits, os cálculos ficam mais complicados.</span><span class="sxs-lookup"><span data-stu-id="8571b-241">When you compile applications as 64-bit, the calculations get more complicated.</span></span> <span data-ttu-id="8571b-242">Um programa de 64 bits usa ponteiros de 64 bits e suas instruções são um pouco maiores, portanto, o requisito de memória é um pouco maior.</span><span class="sxs-lookup"><span data-stu-id="8571b-242">A 64-bit program uses 64-bit pointers, and its instructions are slightly larger, so the memory requirement is slightly increased.</span></span> <span data-ttu-id="8571b-243">Isso pode causar um pequeno descarte no desempenho.</span><span class="sxs-lookup"><span data-stu-id="8571b-243">This can cause a slight drop in performance.</span></span> <span data-ttu-id="8571b-244">Por outro lado, ter duas vezes mais registros e ter a capacidade de fazer cálculos de inteiro de 64 bits em uma única instrução geralmente será maior do que Compensate.</span><span class="sxs-lookup"><span data-stu-id="8571b-244">On the other hand, having twice as many registers and having the ability to do 64-bit integer calculations in a single instruction will often more than compensate.</span></span> <span data-ttu-id="8571b-245">O resultado líquido é que um aplicativo de 64 bits pode ser executado um pouco mais devagar do que o mesmo aplicativo compilado como 32 bits, mas geralmente é executado ligeiramente mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="8571b-245">The net result is that a 64-bit application might run slightly slower than the same application compiled as 32-bit, but it will often run slightly faster.</span></span>

## <a name="summary"></a><span data-ttu-id="8571b-246">Resumo</span><span class="sxs-lookup"><span data-stu-id="8571b-246">Summary</span></span>

<span data-ttu-id="8571b-247">As arquiteturas de 64 bits permitem que os desenvolvedores enviem as limitações sobre a aparência, o som e a reprodução dos jogos.</span><span class="sxs-lookup"><span data-stu-id="8571b-247">Sixty-four-bit architectures allow developers to push the limitations on how games look, sound, and play.</span></span> <span data-ttu-id="8571b-248">No entanto, a transição da programação de 32 bits para a programação de 64 bits não é trivial.</span><span class="sxs-lookup"><span data-stu-id="8571b-248">Transitioning from 32-bit programming to 64-bit programming is not trivial, however.</span></span> <span data-ttu-id="8571b-249">Ao compreender as diferenças entre os dois, e usando as ferramentas mais recentes, a transição para plataformas de 64 bits pode ser mais fácil e rápida.</span><span class="sxs-lookup"><span data-stu-id="8571b-249">By understanding the differences between the two, and by using the newest tools, the transition to 64-bit platforms can be easier and faster.</span></span>

<span data-ttu-id="8571b-250">Mais informações sobre a programação de 64 bits podem ser encontradas em [Visual C++ Developer Center: programação de 64 bits](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span><span class="sxs-lookup"><span data-stu-id="8571b-250">More information on 64-bit programming can be found at [Visual C++ Developer Center: 64-Bit Programming](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span></span>

 

 