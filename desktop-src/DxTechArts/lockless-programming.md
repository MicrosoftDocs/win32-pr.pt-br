---
title: Considerações sobre programação sem bloqueio para Xbox 360 e Microsoft Windows
description: Este artigo fornece uma visão geral de alguns dos problemas a serem considerados ao tentar usar técnicas de programação de bloqueio.
ms.assetid: 44700352-a791-7ef7-0858-146214b0e3da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 23bf8d66cada8aff00735fe6d6ac2d4f1369bc32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/21/2020
ms.locfileid: "103917777"
---
# <a name="lockless-programming-considerations-for-xbox-360-and-microsoft-windows"></a><span data-ttu-id="e8984-103">Considerações sobre programação sem bloqueio para Xbox 360 e Microsoft Windows</span><span class="sxs-lookup"><span data-stu-id="e8984-103">Lockless Programming Considerations for Xbox 360 and Microsoft Windows</span></span>

<span data-ttu-id="e8984-104">A programação sem bloqueios é uma maneira de compartilhar com segurança dados de alteração entre vários threads e não o custo de aquisição e liberação de bloqueios.</span><span class="sxs-lookup"><span data-stu-id="e8984-104">Lockless programming is a way to safely share changing data between multiple threads without the cost of acquiring and releasing locks.</span></span> <span data-ttu-id="e8984-105">Isso parece uma solução completa, mas a programação sem bloqueio é complexa e sutil e, às vezes, não oferece os benefícios que ele promete.</span><span class="sxs-lookup"><span data-stu-id="e8984-105">This sounds like a panacea, but lockless programming is complex and subtle, and sometimes doesn't give the benefits that it promises.</span></span> <span data-ttu-id="e8984-106">A programação de bloqueio é particularmente complexa no Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="e8984-106">Lockless programming is particularly complex on Xbox 360.</span></span>

<span data-ttu-id="e8984-107">A programação sem bloqueios é uma técnica válida para programação multithread, mas não deve ser usada com pouco cuidado.</span><span class="sxs-lookup"><span data-stu-id="e8984-107">Lockless programming is a valid technique for multithreaded programming, but it should not be used lightly.</span></span> <span data-ttu-id="e8984-108">Antes de usá-lo, você deve entender as complexidades, e deve medir atentamente para garantir que realmente esteja dando a você os ganhos esperados.</span><span class="sxs-lookup"><span data-stu-id="e8984-108">Before using it you must understand the complexities, and you should measure carefully to make sure that it is actually giving you the gains that you expect.</span></span> <span data-ttu-id="e8984-109">Em muitos casos, há soluções mais simples e mais rápidas, como o compartilhamento de dados com menos frequência, que deve ser usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="e8984-109">In many cases, there are simpler and faster solutions, such as sharing data less frequently, which should be used instead.</span></span>

<span data-ttu-id="e8984-110">Usar a programação sem bloqueio de forma correta e segura exige um conhecimento significativo do seu hardware e do seu compilador.</span><span class="sxs-lookup"><span data-stu-id="e8984-110">Using lockless programming correctly and safely requires significant knowledge of both your hardware and your compiler.</span></span> <span data-ttu-id="e8984-111">Este artigo fornece uma visão geral de alguns dos problemas a serem considerados ao tentar usar técnicas de programação de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="e8984-111">This article gives an overview of some of the issues to consider when trying to use lockless programming techniques.</span></span>

## <a name="programming-with-locks"></a><span data-ttu-id="e8984-112">Programando com bloqueios</span><span class="sxs-lookup"><span data-stu-id="e8984-112">Programming with Locks</span></span>

<span data-ttu-id="e8984-113">Ao escrever código multi-threaded, é muitas vezes necessário compartilhar dados entre threads.</span><span class="sxs-lookup"><span data-stu-id="e8984-113">When writing multi-threaded code it is often necessary to share data between threads.</span></span> <span data-ttu-id="e8984-114">Se vários threads estiverem lendo e gravando as estruturas de dados compartilhadas simultaneamente, a corrupção de memória poderá ocorrer.</span><span class="sxs-lookup"><span data-stu-id="e8984-114">If multiple threads are simultaneously reading and writing the shared data structures, memory corruption can occur.</span></span> <span data-ttu-id="e8984-115">A maneira mais simples de resolver esse problema é usar bloqueios.</span><span class="sxs-lookup"><span data-stu-id="e8984-115">The simplest way of solving this problem is to use locks.</span></span> <span data-ttu-id="e8984-116">Por exemplo, se ManipulateSharedData só deve ser executado por um thread por vez, uma seção crítica \_ pode ser usada para garantir isso, como no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="e8984-116">For instance, if ManipulateSharedData should only be executed by one thread at a time, a CRITICAL\_SECTION can be used to guarantee this, as in the following code:</span></span>

``` syntax
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);

// Use
void ManipulateSharedData()
{
    EnterCriticalSection(&cs);
    // Manipulate stuff...
    LeaveCriticalSection(&cs);
}

// Destroy
DeleteCriticalSection(&cs);
```

<span data-ttu-id="e8984-117">Esse código é razoavelmente simples e direto, e é fácil dizer que está correto.</span><span class="sxs-lookup"><span data-stu-id="e8984-117">This code is fairly simple and straightforward, and it is easy to tell that it is correct.</span></span> <span data-ttu-id="e8984-118">No entanto, a programação com bloqueios vem com várias desvantagens em potencial.</span><span class="sxs-lookup"><span data-stu-id="e8984-118">However, programming with locks comes with several potential disadvantages.</span></span> <span data-ttu-id="e8984-119">Por exemplo, se dois threads tentarem adquirir os mesmos dois bloqueios, mas adquiri-los em uma ordem diferente, você poderá ter um deadlock.</span><span class="sxs-lookup"><span data-stu-id="e8984-119">For example, if two threads try to acquire the same two locks but acquire them in a different order, you may get a deadlock.</span></span> <span data-ttu-id="e8984-120">Se um programa mantiver um bloqueio por muito tempo — devido a um design insatisfatório ou porque o thread foi trocado por um thread de prioridade mais alta — outros threads poderão ser bloqueados por um longo tempo.</span><span class="sxs-lookup"><span data-stu-id="e8984-120">If a program holds a lock for too long—because of poor design or because the thread has been swapped out by a higher priority thread—other threads may be blocked for a long time.</span></span> <span data-ttu-id="e8984-121">Esse risco é particularmente ótimo no Xbox 360 porque os threads de software são atribuídos a um thread de hardware pelo desenvolvedor, e o sistema operacional não os moverá para outro thread de hardware, mesmo se um estiver ocioso.</span><span class="sxs-lookup"><span data-stu-id="e8984-121">This risk is particularly great on Xbox 360 because the software threads are assigned a hardware thread by the developer, and the operating system won't move them to another hardware thread, even if one is idle.</span></span> <span data-ttu-id="e8984-122">O Xbox 360 também não tem proteção contra a inversão de prioridade, em que um thread de alta prioridade gira em um loop enquanto aguarda um thread de baixa prioridade liberar um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="e8984-122">The Xbox 360 also has no protection against priority inversion, where a high-priority thread spins in a loop while waiting for a low-priority thread to release a lock.</span></span> <span data-ttu-id="e8984-123">Finalmente, se uma chamada de procedimento deferida ou uma rotina de serviço de interrupção tentar adquirir um bloqueio, você poderá obter um deadlock.</span><span class="sxs-lookup"><span data-stu-id="e8984-123">Finally, if a deferred procedure call or interrupt service routine tries to acquire a lock, you may get a deadlock.</span></span>

<span data-ttu-id="e8984-124">Apesar desses problemas, os primitivos de sincronização, como seções críticas, geralmente são a melhor maneira de coordenar vários threads.</span><span class="sxs-lookup"><span data-stu-id="e8984-124">Despite these problems, synchronization primitives, such as critical sections, are generally the best way of coordinating multiple threads.</span></span> <span data-ttu-id="e8984-125">Se os primitivos de sincronização forem muito lentos, a melhor solução geralmente será usá-los com menos frequência.</span><span class="sxs-lookup"><span data-stu-id="e8984-125">If the synchronization primitives are too slow, the best solution is usually to use them less frequently.</span></span> <span data-ttu-id="e8984-126">No entanto, para aqueles que podem arcar com a complexidade extra, outra opção é a programação de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="e8984-126">However, for those who can afford the extra complexity, another option is lockless programming.</span></span>

## <a name="lockless-programming"></a><span data-ttu-id="e8984-127">Programação de bloqueio</span><span class="sxs-lookup"><span data-stu-id="e8984-127">Lockless Programming</span></span>

<span data-ttu-id="e8984-128">A programação sem bloqueio, como o nome sugere, é uma família de técnicas para a manipulação segura de dados compartilhados com a utilização de bloqueios.</span><span class="sxs-lookup"><span data-stu-id="e8984-128">Lockless programming, as the name suggests, is a family of techniques for safely manipulating shared data without using locks.</span></span> <span data-ttu-id="e8984-129">Há algoritmos de bloqueio disponíveis para passar mensagens, compartilhar listas e filas de dados e outras tarefas.</span><span class="sxs-lookup"><span data-stu-id="e8984-129">There are lockless algorithms available for passing messages, sharing lists and queues of data, and other tasks.</span></span>

<span data-ttu-id="e8984-130">Ao fazer uma programação sem bloqueios, há dois desafios com os quais você deve lidar: operações não atômicas e reordenação.</span><span class="sxs-lookup"><span data-stu-id="e8984-130">When doing lockless programming, there are two challenges that you must deal with: non-atomic operations and reordering.</span></span>

## <a name="non-atomic-operations"></a><span data-ttu-id="e8984-131">Operações não atômicas</span><span class="sxs-lookup"><span data-stu-id="e8984-131">Non-Atomic Operations</span></span>

<span data-ttu-id="e8984-132">Uma operação atômica é uma que é indivisível – uma em que outros threads são garantidos para nunca ver a operação quando ela é metade concluída.</span><span class="sxs-lookup"><span data-stu-id="e8984-132">An atomic operation is one that is indivisible—one where other threads are guaranteed to never see the operation when it is half done.</span></span> <span data-ttu-id="e8984-133">As operações atômicas são importantes para a programação de bloqueio, porque sem elas, outros threads podem ver valores de meia gravação ou estado inconsistente.</span><span class="sxs-lookup"><span data-stu-id="e8984-133">Atomic operations are important for lockless programming, because without them, other threads might see half-written values, or otherwise inconsistent state.</span></span>

<span data-ttu-id="e8984-134">Em todos os processadores modernos, você pode assumir que leituras e gravações de tipos nativos alinhados naturalmente são atômicas.</span><span class="sxs-lookup"><span data-stu-id="e8984-134">On all modern processors, you can assume that reads and writes of naturally aligned native types are atomic.</span></span> <span data-ttu-id="e8984-135">Desde que o barramento de memória seja pelo menos tão largo quanto o tipo que está sendo lido ou gravado, a CPU lê e grava esses tipos em uma única transação de barramento, tornando impossível para outros threads vê-los em um estado de metade concluída.</span><span class="sxs-lookup"><span data-stu-id="e8984-135">As long as the memory bus is at least as wide as the type being read or written, the CPU reads and writes these types in a single bus transaction, making it impossible for other threads to see them in a half-completed state.</span></span> <span data-ttu-id="e8984-136">Em x86 e x64, não há garantia de que leituras e gravações maiores que oito bytes são atômicas.</span><span class="sxs-lookup"><span data-stu-id="e8984-136">On x86 and x64 there, is no guarantee that reads and writes larger than eight bytes are atomic.</span></span> <span data-ttu-id="e8984-137">Isso significa que leituras de 16 bytes e gravações de registros SSE (Streaming SIMD Extension) e operações de cadeia de caracteres podem não ser atômicas.</span><span class="sxs-lookup"><span data-stu-id="e8984-137">This means that 16-byte reads and writes of streaming SIMD extension (SSE) registers, and string operations, might not be atomic.</span></span>

<span data-ttu-id="e8984-138">Leituras e gravações de tipos que não são naturalmente alinhados — por exemplo, escrever DWORDs que cruzam limites de quatro bytes — não têm garantia de ser atômica.</span><span class="sxs-lookup"><span data-stu-id="e8984-138">Reads and writes of types that are not naturally aligned—for instance, writing DWORDs that cross four-byte boundaries—are not guaranteed to be atomic.</span></span> <span data-ttu-id="e8984-139">A CPU pode precisar fazer essas leituras e gravações como várias transações de barramento, o que pode permitir que outro thread modifique ou veja os dados no meio da leitura ou gravação.</span><span class="sxs-lookup"><span data-stu-id="e8984-139">The CPU may have to do these reads and writes as multiple bus transactions, which could allow another thread to modify or see the data in the middle of the read or write.</span></span>

<span data-ttu-id="e8984-140">As operações de composição, como a sequência Read-Modify-Write, que ocorre quando você incrementa uma variável compartilhada, não são atômicas.</span><span class="sxs-lookup"><span data-stu-id="e8984-140">Composite operations, such as the read-modify-write sequence that occurs when you increment a shared variable, are not atomic.</span></span> <span data-ttu-id="e8984-141">No Xbox 360, essas operações são implementadas como várias instruções (LWZ, por e STW), e o thread pode ser trocado de MSRC durante por meio da sequência.</span><span class="sxs-lookup"><span data-stu-id="e8984-141">On Xbox 360, these operations are implemented as multiple instructions (lwz, addi, and stw), and the thread could be swapped out partway through the sequence.</span></span> <span data-ttu-id="e8984-142">Em x86 e x64, há uma única instrução (Inc) que pode ser usada para incrementar uma variável na memória.</span><span class="sxs-lookup"><span data-stu-id="e8984-142">On x86 and x64, there is a single instruction (inc) that can be used to increment a variable in memory.</span></span> <span data-ttu-id="e8984-143">Se você usar essa instrução, incrementar uma variável é atômica em sistemas de processador único, mas ele ainda não é atômico em sistemas com vários processadores.</span><span class="sxs-lookup"><span data-stu-id="e8984-143">If you use this instruction, incrementing a variable is atomic on single-processor systems, but it is still not atomic on multi-processor systems.</span></span> <span data-ttu-id="e8984-144">A criação de sistemas com vários processadores baseados em x86 e x64 requer o uso do prefixo de bloqueio, o que impede que outro processador faça sua própria sequência de leitura-modificação-gravação entre a leitura e a gravação da instrução Inc.</span><span class="sxs-lookup"><span data-stu-id="e8984-144">Making inc atomic on x86- and x64-based multi-processor systems requires using the lock prefix, which prevents another processor from doing its own read-modify-write sequence between the read and the write of the inc instruction.</span></span>

<span data-ttu-id="e8984-145">O código a seguir mostra alguns exemplos:</span><span class="sxs-lookup"><span data-stu-id="e8984-145">The following code shows some examples:</span></span>

``` syntax
// This write is not atomic because it is not natively aligned.
DWORD* pData = (DWORD*)(pChar + 1);
*pData = 0;

// This is not atomic because it is three separate operations.
++g_globalCounter;

// This write is atomic.
g_alignedGlobal = 0;

// This read is atomic.
DWORD local = g_alignedGlobal;
```

## <a name="guaranteeing-atomicity"></a><span data-ttu-id="e8984-146">Garantindo a atomicidade</span><span class="sxs-lookup"><span data-stu-id="e8984-146">Guaranteeing Atomicity</span></span>

<span data-ttu-id="e8984-147">Você pode ter certeza de que está usando operações atômicas por uma combinação do seguinte:</span><span class="sxs-lookup"><span data-stu-id="e8984-147">You can be sure you are using atomic operations by a combination of the following:</span></span>

-   <span data-ttu-id="e8984-148">Operações atômicas naturalmente</span><span class="sxs-lookup"><span data-stu-id="e8984-148">Naturally atomic operations</span></span>
-   <span data-ttu-id="e8984-149">Bloqueios para encapsule as operações compostas</span><span class="sxs-lookup"><span data-stu-id="e8984-149">Locks to wrap composite operations</span></span>
-   <span data-ttu-id="e8984-150">Funções do sistema operacional que implementam versões atômicas de operações de composição populares</span><span class="sxs-lookup"><span data-stu-id="e8984-150">Operating system functions that implement atomic versions of popular composite operations</span></span>

<span data-ttu-id="e8984-151">Incrementar uma variável não é uma operação atômica e incrementar pode levar à corrupção de dados, se executado em vários threads.</span><span class="sxs-lookup"><span data-stu-id="e8984-151">Incrementing a variable is not an atomic operation, and incrementing may lead to data corruption if executed on multiple threads.</span></span>

``` syntax
// This will be atomic.
g_globalCounter = 0;

// This is not atomic and gives undefined behavior
// if executed on multiple threads
++g_globalCounter;
```

<span data-ttu-id="e8984-152">O Win32 vem com uma família de funções que oferecem versões atômicas de leitura-modificação-gravação de várias operações comuns.</span><span class="sxs-lookup"><span data-stu-id="e8984-152">Win32 comes with a family of functions that offer atomic read-modify-write versions of several common operations.</span></span> <span data-ttu-id="e8984-153">Essas são as InterlockedXxx da família de funções.</span><span class="sxs-lookup"><span data-stu-id="e8984-153">These are the InterlockedXxx family of functions.</span></span> <span data-ttu-id="e8984-154">Se todas as modificações da variável compartilhada usarem essas funções, as modificações serão seguras para thread.</span><span class="sxs-lookup"><span data-stu-id="e8984-154">If all modifications of the shared variable use these functions, the modifications will be thread safe.</span></span>

``` syntax
// Incrementing our variable in a safe lockless way.
InterlockedIncrement(&g_globalCounter);
```

## <a name="reordering"></a><span data-ttu-id="e8984-155">Reordenação</span><span class="sxs-lookup"><span data-stu-id="e8984-155">Reordering</span></span>

<span data-ttu-id="e8984-156">Um problema mais sutil é A reordenação.</span><span class="sxs-lookup"><span data-stu-id="e8984-156">A more subtle problem is reordering.</span></span> <span data-ttu-id="e8984-157">Leituras e gravações nem sempre ocorrem na ordem em que foram gravadas em seu código, e isso pode levar a problemas muito confusos.</span><span class="sxs-lookup"><span data-stu-id="e8984-157">Reads and writes do not always happen in the order that you have written them in your code, and this can lead to very confusing problems.</span></span> <span data-ttu-id="e8984-158">Em muitos algoritmos multi-threaded, um thread grava alguns dados e, em seguida, grava em um sinalizador que informa a outros threads que os dados estão prontos.</span><span class="sxs-lookup"><span data-stu-id="e8984-158">In many multi-threaded algorithms, a thread writes some data and then writes to a flag that tells other threads that the data is ready.</span></span> <span data-ttu-id="e8984-159">Isso é conhecido como uma versão de gravação.</span><span class="sxs-lookup"><span data-stu-id="e8984-159">This is known as a write-release.</span></span> <span data-ttu-id="e8984-160">Se as gravações forem reordenadas, outros threads poderão ver que o sinalizador está definido antes que possam ver os dados gravados.</span><span class="sxs-lookup"><span data-stu-id="e8984-160">If the writes are reordered, other threads may see that the flag is set before they can see the written data.</span></span>

<span data-ttu-id="e8984-161">Da mesma forma, em muitos casos, um thread lê de um sinalizador e, em seguida, lê alguns dados compartilhados se o sinalizador diz que o thread adquiriu o acesso aos dados compartilhados.</span><span class="sxs-lookup"><span data-stu-id="e8984-161">Similarly, in many cases, a thread reads from a flag and then reads some shared data if the flag says that the thread has acquired access to the shared data.</span></span> <span data-ttu-id="e8984-162">Isso é conhecido como leitura-aquisição.</span><span class="sxs-lookup"><span data-stu-id="e8984-162">This is known as a read-acquire.</span></span> <span data-ttu-id="e8984-163">Se as leituras forem reordenadas, os dados poderão ser lidos do armazenamento compartilhado antes do sinalizador, e os valores vistos podem não estar atualizados.</span><span class="sxs-lookup"><span data-stu-id="e8984-163">If reads are reordered, then the data may be read from shared storage before the flag, and the values seen might not be up to date.</span></span>

<span data-ttu-id="e8984-164">A reordenação de leituras e gravações pode ser feita pelo compilador e pelo processador.</span><span class="sxs-lookup"><span data-stu-id="e8984-164">Reordering of reads and writes can be done both by the compiler and by the processor.</span></span> <span data-ttu-id="e8984-165">Os compiladores e os processadores fizeram essa reordenação por anos, mas em máquinas com um único processador ele era menos um problema.</span><span class="sxs-lookup"><span data-stu-id="e8984-165">Compilers and processors have done this reordering for years, but on single-processor machines it was less of an issue.</span></span> <span data-ttu-id="e8984-166">Isso ocorre porque a reorganização de CPU de leituras e gravações é invisível em máquinas com um único processador (para código que não é um driver de dispositivo que não faz parte de um driver de dispositivo), e a reorganização do compilador de leituras e gravações é menos provável de causar problemas em máquinas de processador único.</span><span class="sxs-lookup"><span data-stu-id="e8984-166">This is because CPU rearrangement of reads and writes is invisible on single-processor machines (for non-device driver code that is not part of a device driver), and compiler rearrangement of reads and writes is less likely to cause problems on single-processor machines.</span></span>

<span data-ttu-id="e8984-167">Se o compilador ou a CPU reorganizar as gravações mostradas no código a seguir, outro thread poderá ver que o sinalizador Alive está definido enquanto ainda vê os valores antigos para x ou y.</span><span class="sxs-lookup"><span data-stu-id="e8984-167">If the compiler or the CPU rearranges the writes shown in the following code, another thread may see that the alive flag is set while still seeing the old values for x or y.</span></span> <span data-ttu-id="e8984-168">A reorganização semelhante pode ocorrer durante a leitura.</span><span class="sxs-lookup"><span data-stu-id="e8984-168">Similar rearrangement can happen when reading.</span></span>

<span data-ttu-id="e8984-169">Nesse código, um thread adiciona uma nova entrada à matriz Sprite:</span><span class="sxs-lookup"><span data-stu-id="e8984-169">In this code, one thread adds a new entry to the sprite array:</span></span>

``` syntax
// Create a new sprite by writing its position into an empty
// entry and then setting the ‘alive' flag. If ‘alive' is
// written before x or y then errors may occur.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="e8984-170">Neste próximo bloco de código, outro thread lê a partir da matriz Sprite:</span><span class="sxs-lookup"><span data-stu-id="e8984-170">In this next code block, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites. If the reads of x and y are moved ahead of
// the read of ‘alive' then errors may occur.
for( int i = 0; i < numSprites; ++i )
{
    if( g_sprites[nextSprite].alive )
    {
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="e8984-171">Para tornar esse sistema Sprite seguro, precisamos impedir a reordenação do compilador e da CPU de leituras e gravações.</span><span class="sxs-lookup"><span data-stu-id="e8984-171">To make this sprite system safe, we need to prevent both compiler and CPU reordering of reads and writes.</span></span>

### <a name="understanding-cpu-rearrangement-of-writes"></a><span data-ttu-id="e8984-172">Compreendendo a reorganização da CPU de gravações</span><span class="sxs-lookup"><span data-stu-id="e8984-172">Understanding CPU Rearrangement of Writes</span></span>

<span data-ttu-id="e8984-173">Algumas CPUs reorganizam as gravações para que elas sejam visíveis externamente para outros processadores ou dispositivos em ordem não programada.</span><span class="sxs-lookup"><span data-stu-id="e8984-173">Some CPUs rearrange writes so that they are externally visible to other processors or devices in non-program order.</span></span> <span data-ttu-id="e8984-174">Essa reorganização nunca é visível para um código de não driver de thread único, mas pode causar problemas no código multi-threaded.</span><span class="sxs-lookup"><span data-stu-id="e8984-174">This rearranging is never visible to single-threaded non-driver code, but it can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="e8984-175">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="e8984-175">Xbox 360</span></span>

<span data-ttu-id="e8984-176">Embora a CPU 360 do Xbox não reordene as instruções, ela reorganiza as operações de gravação, que são concluídas após as próprias instruções.</span><span class="sxs-lookup"><span data-stu-id="e8984-176">While the Xbox 360 CPU does not reorder instructions, it does rearrange write operations, which complete after the instructions themselves.</span></span> <span data-ttu-id="e8984-177">Essa reorganização de gravações é especificamente permitida pelo modelo de memória PowerPC.</span><span class="sxs-lookup"><span data-stu-id="e8984-177">This rearranging of writes is specifically allowed by the PowerPC memory model.</span></span>

<span data-ttu-id="e8984-178">As gravações no Xbox 360 não vão diretamente para o cache L2.</span><span class="sxs-lookup"><span data-stu-id="e8984-178">Writes on Xbox 360 do not go directly to the L2 cache.</span></span> <span data-ttu-id="e8984-179">Em vez disso, para melhorar a largura de banda de gravação do cache L2, elas passam por filas de armazenamento e, em seguida, para armazenar buffers de coleta.</span><span class="sxs-lookup"><span data-stu-id="e8984-179">Instead, in order to improve L2 cache write bandwidth, they go through store queues and then to store-gather buffers.</span></span> <span data-ttu-id="e8984-180">Os buffers de coleta de armazenamento permitem que os blocos de 64 bytes sejam gravados no cache L2 em uma única operação.</span><span class="sxs-lookup"><span data-stu-id="e8984-180">The store-gather buffers allow 64-byte blocks to be written to the L2 cache in one operation.</span></span> <span data-ttu-id="e8984-181">Há oito buffers de coleta de armazenamento, que permitem a gravação eficiente em várias áreas de memória diferentes.</span><span class="sxs-lookup"><span data-stu-id="e8984-181">There are eight store-gather buffers, which allow efficient writing to several different areas of memory.</span></span>

<span data-ttu-id="e8984-182">Os buffers de coleta de armazenamento normalmente são gravados no cache L2 na ordem FIFO (primeiro a entrar, primeiro a sair).</span><span class="sxs-lookup"><span data-stu-id="e8984-182">The store-gather buffers are normally written to the L2 cache in first-in-first-out (FIFO) order.</span></span> <span data-ttu-id="e8984-183">No entanto, se a linha de cache de destino de uma gravação não estiver no cache L2, essa gravação poderá ser atrasada enquanto a linha de cache for buscada da memória.</span><span class="sxs-lookup"><span data-stu-id="e8984-183">However, if the target cache-line of a write is not in the L2 cache, that write may be delayed while the cache-line is fetched from memory.</span></span>

<span data-ttu-id="e8984-184">Mesmo quando os buffers do Store-gather são gravados no cache L2 na ordem FIFO estrita, isso não garante que as gravações individuais sejam gravadas no cache L2 na ordem.</span><span class="sxs-lookup"><span data-stu-id="e8984-184">Even when the store-gather buffers are written to the L2 cache in strict FIFO order, this does not guarantee that individual writes are written to the L2 cache in order.</span></span> <span data-ttu-id="e8984-185">Por exemplo, imagine que a CPU grava no local 0x1000, em seguida, no local 0x2000 e no local 0x1004.</span><span class="sxs-lookup"><span data-stu-id="e8984-185">For instance, imagine that the CPU writes to location 0x1000, then to location 0x2000, and then to location 0x1004.</span></span> <span data-ttu-id="e8984-186">A primeira gravação aloca um buffer de coleta de armazenamento e o coloca na frente da fila.</span><span class="sxs-lookup"><span data-stu-id="e8984-186">The first write allocates a store-gather buffer and puts it at the front of the queue.</span></span> <span data-ttu-id="e8984-187">A segunda gravação aloca outro buffer de coleta de armazenamento e a coloca em seguida na fila.</span><span class="sxs-lookup"><span data-stu-id="e8984-187">The second write allocates another store-gather buffer and puts it next in the queue.</span></span> <span data-ttu-id="e8984-188">A terceira gravação adiciona seus dados ao primeiro buffer de coleta de armazenamento, que permanece na frente da fila.</span><span class="sxs-lookup"><span data-stu-id="e8984-188">The third write adds its data to the first store-gather buffer, which remains at the front of the queue.</span></span> <span data-ttu-id="e8984-189">Assim, a terceira gravação acaba indo até o cache L2 antes da segunda gravação.</span><span class="sxs-lookup"><span data-stu-id="e8984-189">Thus, the third write ends up going to the L2 cache before the second write.</span></span>

<span data-ttu-id="e8984-190">A reordenação causada por buffers de coleta de armazenamento é fundamentalmente imprevisível, especialmente porque ambos os threads em um núcleo compartilham buffers de coleta de armazenamento, tornando a alocação e o esvaziamento da Store-coletar buffers de forma altamente variável.</span><span class="sxs-lookup"><span data-stu-id="e8984-190">Reordering caused by store-gather buffers is fundamentally unpredictable, especially because both threads on a core share the store-gather buffers, making the allocation and emptying of the store-gather buffers highly variable.</span></span>

<span data-ttu-id="e8984-191">Este é um exemplo de como as gravações podem ser reordenadas.</span><span class="sxs-lookup"><span data-stu-id="e8984-191">This is one example of how writes can be reordered.</span></span> <span data-ttu-id="e8984-192">Pode haver outras possibilidades.</span><span class="sxs-lookup"><span data-stu-id="e8984-192">There may be other possibilities.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="e8984-193">x86 e x64</span><span class="sxs-lookup"><span data-stu-id="e8984-193">x86 and x64</span></span>

<span data-ttu-id="e8984-194">Embora as CPUs x86 e x64 façam instruções de reordenação, elas geralmente não reordenam operações de gravação em relação a outras gravações.</span><span class="sxs-lookup"><span data-stu-id="e8984-194">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder write operations relative to other writes.</span></span> <span data-ttu-id="e8984-195">Há algumas exceções para a memória combinada de gravação.</span><span class="sxs-lookup"><span data-stu-id="e8984-195">There are some exceptions for write-combined memory.</span></span> <span data-ttu-id="e8984-196">Além disso, as operações de cadeia de caracteres (MOVS e STOS) e as gravações SSE de 16 bytes podem ser reordenadas internamente, mas de outra forma, as gravações não são reordenadas em relação umas às outras.</span><span class="sxs-lookup"><span data-stu-id="e8984-196">Additionally, string operations (MOVS and STOS) and 16-byte SSE writes can be internally reordered, but otherwise, writes are not reordered relative to each other.</span></span>

### <a name="understanding-cpu-rearrangement-of-reads"></a><span data-ttu-id="e8984-197">Entendendo a reorganização de leituras da CPU</span><span class="sxs-lookup"><span data-stu-id="e8984-197">Understanding CPU Rearrangement of Reads</span></span>

<span data-ttu-id="e8984-198">Algumas CPUs reorganizam as leituras para que elas venham efetivamente do armazenamento compartilhado em ordem de não programa.</span><span class="sxs-lookup"><span data-stu-id="e8984-198">Some CPUs rearrange reads so that they effectively come from shared storage in non-program order.</span></span> <span data-ttu-id="e8984-199">Essa reorganização nunca é visível para um código de não driver de thread único, mas pode causar problemas no código multi-threaded.</span><span class="sxs-lookup"><span data-stu-id="e8984-199">This rearranging is never visible to single-threaded non-driver code, but can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="e8984-200">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="e8984-200">Xbox 360</span></span>

<span data-ttu-id="e8984-201">Os erros de cache podem fazer com que algumas leituras sejam atrasadas, o que efetivamente faz com que as leituras venham da memória compartilhada fora de ordem, e o tempo desses erros de cache é fundamentalmente imprevisível.</span><span class="sxs-lookup"><span data-stu-id="e8984-201">Cache misses can cause some reads to be delayed, which effectively causes reads to come from shared memory out of order, and the timing of these cache misses is fundamentally unpredictable.</span></span> <span data-ttu-id="e8984-202">A pré-busca e a previsão de ramificação também podem fazer com que os dados sejam provenientes da memória compartilhada fora de ordem.</span><span class="sxs-lookup"><span data-stu-id="e8984-202">Prefetching and branch prediction can also cause data to come from shared memory out of order.</span></span> <span data-ttu-id="e8984-203">Esses são apenas alguns exemplos de como as leituras podem ser reordenadas.</span><span class="sxs-lookup"><span data-stu-id="e8984-203">These are just a few examples of how reads can be reordered.</span></span> <span data-ttu-id="e8984-204">Pode haver outras possibilidades.</span><span class="sxs-lookup"><span data-stu-id="e8984-204">There may be other possibilities.</span></span> <span data-ttu-id="e8984-205">Essa reorganização de leituras é especificamente permitida pelo modelo de memória PowerPC.</span><span class="sxs-lookup"><span data-stu-id="e8984-205">This rearranging of reads is specifically allowed by the PowerPC memory model.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="e8984-206">x86 e x64</span><span class="sxs-lookup"><span data-stu-id="e8984-206">x86 and x64</span></span>

<span data-ttu-id="e8984-207">Embora as CPUs x86 e x64 façam instruções de reordenação, elas geralmente não reordenam operações de leitura em relação a outras leituras.</span><span class="sxs-lookup"><span data-stu-id="e8984-207">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder read operations relative to other reads.</span></span> <span data-ttu-id="e8984-208">As operações de cadeia de caracteres (MOVS e STOS) e as leituras SSE de 16 bytes podem ser reordenadas internamente, mas do contrário, as leituras não são reordenadas em relação umas às outras.</span><span class="sxs-lookup"><span data-stu-id="e8984-208">String operations (MOVS and STOS) and 16-byte SSE reads can be internally reordered, but otherwise, reads are not reordered relative to each other.</span></span>

### <a name="other-reordering"></a><span data-ttu-id="e8984-209">Outra reordenação</span><span class="sxs-lookup"><span data-stu-id="e8984-209">Other Reordering</span></span>

<span data-ttu-id="e8984-210">Embora as CPUs x86 e x64 não reordenem as gravações em relação a outras gravações ou reordenem as leituras relativas a outras leituras, elas podem reordenar as leituras em relação às gravações.</span><span class="sxs-lookup"><span data-stu-id="e8984-210">Even though x86 and x64 CPUs do not reorder writes relative to other writes, or reorder reads relative to other reads, they can reorder reads relative to writes.</span></span> <span data-ttu-id="e8984-211">Especificamente, se um programa gravar em um local seguido da leitura de um local diferente, os dados de leitura poderão vir da memória compartilhada antes que os dados gravados o façam.</span><span class="sxs-lookup"><span data-stu-id="e8984-211">Specifically, if a program writes to one location followed by reading from a different location, the read data may come from shared memory before the written data makes it there.</span></span> <span data-ttu-id="e8984-212">Essa reordenação pode interromper alguns algoritmos, como os algoritmos de exclusão mútua do Dekker.</span><span class="sxs-lookup"><span data-stu-id="e8984-212">This reordering can break some algorithms, such as Dekker’s mutual exclusion algorithms.</span></span> <span data-ttu-id="e8984-213">No algoritmo do Dekker, cada thread define um sinalizador para indicar que ele deseja inserir a região crítica e, em seguida, verifica o sinalizador do outro thread para ver se o outro thread está na região crítica ou tentando inseri-lo.</span><span class="sxs-lookup"><span data-stu-id="e8984-213">In Dekker's algorithm, each thread sets a flag to indicate that it wants to enter the critical region, and then checks the other thread’s flag to see if the other thread is in the critical region or trying to enter it.</span></span> <span data-ttu-id="e8984-214">O código inicial é mostrado a seguir.</span><span class="sxs-lookup"><span data-stu-id="e8984-214">The initial code follows.</span></span>

``` syntax
volatile bool f0 = false;
volatile bool f1 = false;

void P0Acquire()
{
    // Indicate intention to enter critical region
    f0 = true;
    // Check for other thread in or entering critical region
    while (f1)
    {
        // Handle contention.
    }
    // critical region
    ...
}


void P1Acquire()
{
    // Indicate intention to enter critical region
    f1 = true;
    // Check for other thread in or entering critical region
    while (f0)
    {
        // Handle contention.
    }
    // critical region
    ...
}
```

<span data-ttu-id="e8984-215">O problema é que a leitura de F1 no P0Acquire pode ler do armazenamento compartilhado antes que a gravação em F0 o torne para o armazenamento compartilhado.</span><span class="sxs-lookup"><span data-stu-id="e8984-215">The problem is that the read of f1 in P0Acquire can read from shared storage before the write to f0 makes it to shared storage.</span></span> <span data-ttu-id="e8984-216">Enquanto isso, a leitura de F0 no P1Acquire pode ler do armazenamento compartilhado antes que a gravação para F1 o faça no armazenamento compartilhado.</span><span class="sxs-lookup"><span data-stu-id="e8984-216">Meanwhile, the read of f0 in P1Acquire can read from shared storage before the write to f1 makes it to shared storage.</span></span> <span data-ttu-id="e8984-217">O efeito líquido é que ambos os threads definem seus sinalizadores como TRUE e os dois threads veem o sinalizador do outro thread como falso, para que ambos insiram a região crítica.</span><span class="sxs-lookup"><span data-stu-id="e8984-217">The net effect is that both threads set their flags to TRUE, and both threads see the other thread's flag as being FALSE, so they both enter the critical region.</span></span> <span data-ttu-id="e8984-218">Portanto, embora problemas com a reordenação em sistemas baseados em x86 e x64 sejam menos comuns do que no Xbox 360, eles definitivamente ainda podem acontecer.</span><span class="sxs-lookup"><span data-stu-id="e8984-218">Therefore, while problems with reordering on x86- and x64-based systems are less common than on Xbox 360, they definitely can still happen.</span></span> <span data-ttu-id="e8984-219">O algoritmo do Dekker não funcionará sem barreiras de memória de hardware em nenhuma dessas plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8984-219">Dekker’s algorithm will not work without hardware memory barriers on any of these platforms.</span></span>

<span data-ttu-id="e8984-220">as CPUs x86 e x64 não reordenarão uma gravação antecipada de uma leitura anterior.</span><span class="sxs-lookup"><span data-stu-id="e8984-220">x86 and x64 CPUs will not reorder a write ahead of a previous read.</span></span> <span data-ttu-id="e8984-221">CPUs x86 e x64 apenas reordenam leituras antecipadas de gravações anteriores se direcionarem locais diferentes.</span><span class="sxs-lookup"><span data-stu-id="e8984-221">x86 and x64 CPUs only reorder reads ahead of previous writes if they target different locations.</span></span>

<span data-ttu-id="e8984-222">As CPUs PowerPC podem reordenar as leituras à frente de gravações e podem reordenar as gravações antes de leituras, desde que sejam para endereços diferentes.</span><span class="sxs-lookup"><span data-stu-id="e8984-222">PowerPC CPUs can reorder reads ahead of writes, and can reorder writes ahead of reads, as long as they are to different addresses.</span></span>

### <a name="reordering-summary"></a><span data-ttu-id="e8984-223">Reordenando Resumo</span><span class="sxs-lookup"><span data-stu-id="e8984-223">Reordering Summary</span></span>

<span data-ttu-id="e8984-224">A CPU do Xbox 360 Reordena as operações de memória de forma muito mais agressiva do que as CPUs x86 e x64, conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e8984-224">The Xbox 360 CPU reorders memory operations much more aggressively than do x86 and x64 CPUs, as shown in the following table.</span></span> <span data-ttu-id="e8984-225">Para obter mais detalhes, consulte a documentação do processador.</span><span class="sxs-lookup"><span data-stu-id="e8984-225">For more details, consult the processor documentation.</span></span>



| <span data-ttu-id="e8984-226">Reordenando atividade</span><span class="sxs-lookup"><span data-stu-id="e8984-226">Reordering Activity</span></span>           | <span data-ttu-id="e8984-227">x86 e x64</span><span class="sxs-lookup"><span data-stu-id="e8984-227">x86 and x64</span></span> | <span data-ttu-id="e8984-228">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="e8984-228">Xbox 360</span></span> |
|-------------------------------|-------------|----------|
| <span data-ttu-id="e8984-229">Leituras em movimento à frente de leituras</span><span class="sxs-lookup"><span data-stu-id="e8984-229">Reads moving ahead of reads</span></span>   | <span data-ttu-id="e8984-230">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-230">No</span></span>          | <span data-ttu-id="e8984-231">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-231">Yes</span></span>      |
| <span data-ttu-id="e8984-232">Gravações em movimento à frente de gravações</span><span class="sxs-lookup"><span data-stu-id="e8984-232">Writes moving ahead of writes</span></span> | <span data-ttu-id="e8984-233">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-233">No</span></span>          | <span data-ttu-id="e8984-234">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-234">Yes</span></span>      |
| <span data-ttu-id="e8984-235">Gravações em movimento à frente de leituras</span><span class="sxs-lookup"><span data-stu-id="e8984-235">Writes moving ahead of reads</span></span>  | <span data-ttu-id="e8984-236">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-236">No</span></span>          | <span data-ttu-id="e8984-237">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-237">Yes</span></span>      |
| <span data-ttu-id="e8984-238">Leituras em movimento à frente de gravações</span><span class="sxs-lookup"><span data-stu-id="e8984-238">Reads moving ahead of writes</span></span>  | <span data-ttu-id="e8984-239">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-239">Yes</span></span>         | <span data-ttu-id="e8984-240">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-240">Yes</span></span>      |



 

## <a name="read-acquire-and-write-release-barriers"></a><span data-ttu-id="e8984-241">Barreiras de Read-Acquire e Write-Release</span><span class="sxs-lookup"><span data-stu-id="e8984-241">Read-Acquire and Write-Release Barriers</span></span>

<span data-ttu-id="e8984-242">As principais construções usadas para impedir a reordenação de leituras e gravações são chamadas de barreiras de leitura e aquisição de gravação.</span><span class="sxs-lookup"><span data-stu-id="e8984-242">The main constructs used to prevent reordering of reads and writes are called read-acquire and write-release barriers.</span></span> <span data-ttu-id="e8984-243">Uma leitura-aquisição é uma leitura de um sinalizador ou outra variável para obter a propriedade de um recurso, juntamente com uma barreira contra reordenação.</span><span class="sxs-lookup"><span data-stu-id="e8984-243">A read-acquire is a read of a flag or other variable to gain ownership of a resource, coupled with a barrier against reordering.</span></span> <span data-ttu-id="e8984-244">Da mesma forma, um Write-Release é uma gravação de um sinalizador ou outra variável para deixar a propriedade de um recurso, acoplada a uma barreira contra reordenação.</span><span class="sxs-lookup"><span data-stu-id="e8984-244">Similarly, a write-release is a write of a flag or other variable to give away ownership of a resource, coupled with a barrier against reordering.</span></span>

<span data-ttu-id="e8984-245">As definições formais, cortesia de Herb Sutter, são:</span><span class="sxs-lookup"><span data-stu-id="e8984-245">The formal definitions, courtesy of Herb Sutter, are:</span></span>

-   <span data-ttu-id="e8984-246">Uma aquisição de leitura/execução antes de todas as leituras e gravações pelo mesmo thread que a segue em ordem de programa.</span><span class="sxs-lookup"><span data-stu-id="e8984-246">A read-acquire executes before all reads and writes by the same thread that follow it in program order.</span></span>
-   <span data-ttu-id="e8984-247">Uma versão de gravação é executada após todas as leituras e gravações pelo mesmo thread que a precede na ordem do programa.</span><span class="sxs-lookup"><span data-stu-id="e8984-247">A write-release executes after all reads and writes by the same thread that precede it in program order.</span></span>

<span data-ttu-id="e8984-248">Quando o código adquire a propriedade de alguma memória adquirindo um bloqueio ou puxando um item de uma lista compartilhada vinculada (sem um bloqueio), sempre há uma leitura envolvida — testando um sinalizador ou ponteiro para ver se a propriedade da memória foi adquirida.</span><span class="sxs-lookup"><span data-stu-id="e8984-248">When your code acquires ownership of some memory, either by acquiring a lock or by pulling an item off of a shared linked list (without a lock), there is always a read involved—testing a flag or pointer to see if ownership of the memory has been acquired.</span></span> <span data-ttu-id="e8984-249">Essa leitura pode fazer parte de uma operação **InterlockedXxx** ; nesse caso, ela envolve uma leitura e uma gravação, mas é a leitura que indica se a propriedade foi obtida.</span><span class="sxs-lookup"><span data-stu-id="e8984-249">This read may be part of an **InterlockedXxx** operation, in which case it involves both a read and a write, but it is the read that indicates whether ownership has been gained.</span></span> <span data-ttu-id="e8984-250">Depois que a propriedade da memória é adquirida, os valores são normalmente lidos ou gravados nessa memória, e é muito importante que essas leituras e gravações sejam executadas após a aquisição da propriedade.</span><span class="sxs-lookup"><span data-stu-id="e8984-250">After ownership of the memory is acquired, values are typically read from or written to that memory, and it is very important that these reads and writes execute after acquiring ownership.</span></span> <span data-ttu-id="e8984-251">Uma barreira de leitura/aquisição garante isso.</span><span class="sxs-lookup"><span data-stu-id="e8984-251">A read-acquire barrier guarantees this.</span></span>

<span data-ttu-id="e8984-252">Quando a propriedade de alguma memória é liberada, liberando um bloqueio ou enviando um item para uma lista compartilhada vinculada, sempre há uma gravação envolvida que notifica outros threads de que a memória agora está disponível para eles.</span><span class="sxs-lookup"><span data-stu-id="e8984-252">When ownership of some memory is released, either by releasing a lock or by pushing an item on to a shared linked list, there is always a write involved which notifies other threads that the memory is now available to them.</span></span> <span data-ttu-id="e8984-253">Embora seu código tenha propriedade da memória, ele provavelmente leu ou gravou nele, e é muito importante que essas leituras e gravações sejam executadas antes de liberar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="e8984-253">While your code had ownership of the memory, it probably read from or wrote to it, and it is very important that these reads and writes execute before releasing ownership.</span></span> <span data-ttu-id="e8984-254">Uma barreira de gravação/liberação garante isso.</span><span class="sxs-lookup"><span data-stu-id="e8984-254">A write-release barrier guarantees this.</span></span>

<span data-ttu-id="e8984-255">É mais simples considerar as barreiras de leitura e aquisição de gravação como operações únicas.</span><span class="sxs-lookup"><span data-stu-id="e8984-255">It is simplest to think of read-acquire and write-release barriers as single operations.</span></span> <span data-ttu-id="e8984-256">No entanto, às vezes eles precisam ser construídos de duas partes: uma leitura ou gravação e uma barreira que não permite leituras ou gravações para se mover entre elas.</span><span class="sxs-lookup"><span data-stu-id="e8984-256">However, they sometimes have to be constructed from two parts: a read or write and a barrier that does not allow reads or writes to move across it.</span></span> <span data-ttu-id="e8984-257">Nesse caso, o posicionamento da barreira é crítico.</span><span class="sxs-lookup"><span data-stu-id="e8984-257">In this case, the placement of the barrier is critical.</span></span> <span data-ttu-id="e8984-258">Para uma barreira de aquisição de leitura, a leitura do sinalizador vem primeiro, depois a barreira e, em seguida, as leituras e gravações dos dados compartilhados.</span><span class="sxs-lookup"><span data-stu-id="e8984-258">For a read-acquire barrier, the read of the flag comes first, then the barrier, and then the reads and writes of the shared data.</span></span> <span data-ttu-id="e8984-259">Para uma barreira de gravação, as leituras e gravações dos dados compartilhados são primeiro, depois, a barreira e, em seguida, a gravação do sinalizador.</span><span class="sxs-lookup"><span data-stu-id="e8984-259">For a write-release barrier the reads and writes of the shared data come first, then the barrier, and then the write of the flag.</span></span>

``` syntax
// Read that acquires the data.
if( g_flag )
{
    // Guarantee that the read of the flag executes before
    // all reads and writes that follow in program order.
    BarrierOfSomeSort();

    // Now we can read and write the shared data.
    int localVariable = sharedData.y;
    sharedData.x = 0;

    // Guarantee that the write to the flag executes after all
    // reads and writes that precede it in program order.
    BarrierOfSomeSort();
    
    // Write that releases the data.
    g_flag = false;
}
```

<span data-ttu-id="e8984-260">A única diferença entre Read-Acquire e Write-Release é o local da barreira de memória.</span><span class="sxs-lookup"><span data-stu-id="e8984-260">The only difference between a read-acquire and a write-release is the location of the memory barrier.</span></span> <span data-ttu-id="e8984-261">Uma aquisição de leitura tem a barreira após a operação de bloqueio e uma liberação de gravação tem a barreira antes.</span><span class="sxs-lookup"><span data-stu-id="e8984-261">A read-acquire has the barrier after the lock operation, and a write-release has the barrier before.</span></span> <span data-ttu-id="e8984-262">Em ambos os casos, a barreira está entre as referências à memória bloqueada e as referências ao bloqueio.</span><span class="sxs-lookup"><span data-stu-id="e8984-262">In both cases the barrier is in-between the references to the locked memory and the references to the lock.</span></span>

<span data-ttu-id="e8984-263">Para entender por que as barreiras são necessárias ao adquirir e ao liberar dados, é melhor (e mais preciso) considerar essas barreiras como garantia de sincronização com memória compartilhada, não com outros processadores.</span><span class="sxs-lookup"><span data-stu-id="e8984-263">To understand why barriers are needed both when acquiring and when releasing data, it is best (and most accurate) to think of these barriers as guaranteeing synchronization with shared memory, not with other processors.</span></span> <span data-ttu-id="e8984-264">Se um processador usar uma versão de gravação para liberar uma estrutura de dados para a memória compartilhada e outro processador usar uma aquisição de leitura para obter acesso à estrutura de dados da memória compartilhada, o código funcionará corretamente.</span><span class="sxs-lookup"><span data-stu-id="e8984-264">If one processor uses a write-release to release a data structure to shared memory, and another processor uses a read-acquire to gain access to that data structure from shared memory, the code will then work properly.</span></span> <span data-ttu-id="e8984-265">Se um dos processadores não usar a barreira apropriada, o compartilhamento de dados poderá falhar.</span><span class="sxs-lookup"><span data-stu-id="e8984-265">If either processor doesn't use the appropriate barrier, the data sharing may fail.</span></span>

<span data-ttu-id="e8984-266">Usar a barreira certa para impedir o compilador e a reordenação de CPU para sua plataforma é essencial.</span><span class="sxs-lookup"><span data-stu-id="e8984-266">Using the right barrier to prevent compiler and CPU reordering for your platform is critical.</span></span>

<span data-ttu-id="e8984-267">Uma das vantagens de usar os primitivos de sincronização fornecidos pelo sistema operacional é que todos eles incluem as barreiras de memória apropriadas.</span><span class="sxs-lookup"><span data-stu-id="e8984-267">One of the advantages of using the synchronization primitives provided by the operating system is that all of them include the appropriate memory barriers.</span></span>

## <a name="preventing-compiler-reordering"></a><span data-ttu-id="e8984-268">Impedindo a reordenação do compilador</span><span class="sxs-lookup"><span data-stu-id="e8984-268">Preventing Compiler Reordering</span></span>

<span data-ttu-id="e8984-269">O trabalho de um compilador é otimizar agressivamente seu código para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="e8984-269">A compiler's job is to aggressively optimize your code in order to improve performance.</span></span> <span data-ttu-id="e8984-270">Isso inclui a reorganização de instruções onde quer que seja útil e onde quer que ele não altere o comportamento.</span><span class="sxs-lookup"><span data-stu-id="e8984-270">This includes rearranging instructions wherever it is helpful and wherever it will not change behavior.</span></span> <span data-ttu-id="e8984-271">Como o C++ Standard nunca menciona multithreading e como o compilador não sabe qual código precisa ser thread-safe, o compilador pressupõe que seu código é de thread único ao decidir quais reorganizados ele pode fazer com segurança.</span><span class="sxs-lookup"><span data-stu-id="e8984-271">Because the C++ Standard never mentions multithreading, and because the compiler doesn't know what code needs to be thread-safe, the compiler assumes that your code is single-threaded when deciding what rearrangements it can safely do.</span></span> <span data-ttu-id="e8984-272">Portanto, você precisa informar ao compilador quando não for permitido reordenar as leituras e gravações.</span><span class="sxs-lookup"><span data-stu-id="e8984-272">Therefore, you need to tell the compiler when it is not allowed to reorder reads and writes.</span></span>

<span data-ttu-id="e8984-273">Com Visual C++ você pode impedir a reordenação do compilador usando o [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx)intrínseco do compilador.</span><span class="sxs-lookup"><span data-stu-id="e8984-273">With Visual C++ you can prevent compiler reordering by using the compiler intrinsic [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx).</span></span> <span data-ttu-id="e8984-274">Onde você insere **\_ ReadWriteBarrier** em seu código, o compilador não moverá as leituras e as gravações entre elas.</span><span class="sxs-lookup"><span data-stu-id="e8984-274">Where you insert **\_ReadWriteBarrier** into your code, the compiler will not move reads and writes across it.</span></span>

``` syntax
#if _MSC_VER < 1400
    // With VC++ 2003 you need to declare _ReadWriteBarrier
    extern "C" void _ReadWriteBarrier();
#else
    // With VC++ 2005 you can get the declaration from intrin.h
#include <intrin.h>
#endif
// Tell the compiler that this is an intrinsic, not a function.
#pragma intrinsic(_ReadWriteBarrier)

// Create a new sprite by filling in a previously empty entry.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
// Write-release, barrier followed by write.
// Guarantee that the compiler leaves the write to the flag
// after all reads and writes that precede it in program order.
_ReadWriteBarrier();
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="e8984-275">No código a seguir, outro thread lê a partir da matriz Sprite:</span><span class="sxs-lookup"><span data-stu-id="e8984-275">In the following code, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites.
for( int i = 0; i < numSprites; ++i )
{

    // Read-acquire, read followed by barrier.
    if( g_sprites[nextSprite].alive )
    {
    
        // Guarantee that the compiler leaves the read of the flag
        // before all reads and writes that follow in program order.
        _ReadWriteBarrier();
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="e8984-276">É importante entender que o [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) não insere instruções adicionais e não impede que a CPU reorganize leituras e gravações — ela apenas impede que o compilador as reorganizem.</span><span class="sxs-lookup"><span data-stu-id="e8984-276">It is important to understand that [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) does not insert any additional instructions, and it does not prevent the CPU from rearranging reads and writes—it only prevents the compiler from rearranging them.</span></span> <span data-ttu-id="e8984-277">Assim, o **\_ ReadWriteBarrier** é suficiente quando você implementa uma barreira de gravação em x86 e x64 (porque x86 e x64 não reordenam gravações e uma gravação normal é suficiente para liberar um bloqueio), mas na maioria dos outros casos, também é necessário impedir que a CPU reordene leituras e gravações.</span><span class="sxs-lookup"><span data-stu-id="e8984-277">Thus, **\_ReadWriteBarrier** is sufficient when you implement a write-release barrier on x86 and x64 (because x86 and x64 do not reorder writes, and a normal write is sufficient for releasing a lock), but in most other cases, it is also necessary to prevent the CPU from reordering reads and writes.</span></span>

<span data-ttu-id="e8984-278">Você também pode usar [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) ao gravar em memória combinada de gravação não armazenável em cache para evitar a reordenação de gravações.</span><span class="sxs-lookup"><span data-stu-id="e8984-278">You can also use [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) when you write to non-cacheable write-combined memory to prevent reordering of writes.</span></span> <span data-ttu-id="e8984-279">Nesse caso, o **\_ ReadWriteBarrier** ajuda a melhorar o desempenho, garantindo que as gravações ocorram na ordem linear preferida do processador.</span><span class="sxs-lookup"><span data-stu-id="e8984-279">In this case **\_ReadWriteBarrier** helps to improve performance, by guaranteeing that the writes happen in the processor's preferred linear order.</span></span>

<span data-ttu-id="e8984-280">Também é possível usar os intrínsecos [**\_ ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) e [**\_ WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) para um controle mais preciso da reordenação do compilador.</span><span class="sxs-lookup"><span data-stu-id="e8984-280">It is also possible to use the [**\_ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) and [**\_WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) intrinsics for more precise control of compiler reordering.</span></span> <span data-ttu-id="e8984-281">O compilador não moverá as leituras em um **\_ ReadBarrier** e não moverá gravações em um **\_ WriteBarrier**.</span><span class="sxs-lookup"><span data-stu-id="e8984-281">The compiler will not move reads across a **\_ReadBarrier**, and it will not move writes across a **\_WriteBarrier**.</span></span>

## <a name="preventing-cpu-reordering"></a><span data-ttu-id="e8984-282">Impedindo a reordenação da CPU</span><span class="sxs-lookup"><span data-stu-id="e8984-282">Preventing CPU Reordering</span></span>

<span data-ttu-id="e8984-283">A reordenação da CPU é mais sutil do que a reordenação do compilador.</span><span class="sxs-lookup"><span data-stu-id="e8984-283">CPU reordering is more subtle than compiler reordering.</span></span> <span data-ttu-id="e8984-284">Você nunca pode vê-lo acontecer diretamente, você só vê bugs inexplicables.</span><span class="sxs-lookup"><span data-stu-id="e8984-284">You can't ever see it happen directly, you just see inexplicable bugs.</span></span> <span data-ttu-id="e8984-285">Para evitar a reordenação da CPU de leituras e gravações, você precisa usar instruções de barreira de memória, em alguns processadores.</span><span class="sxs-lookup"><span data-stu-id="e8984-285">In order to prevent CPU reordering of reads and writes you need to use memory barrier instructions, on some processors.</span></span> <span data-ttu-id="e8984-286">O nome de todas as finalidades para uma instrução de barreira de memória, no Xbox 360 e no Windows, é [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span><span class="sxs-lookup"><span data-stu-id="e8984-286">The all-purpose name for a memory barrier instruction, on Xbox 360 and on Windows, is [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span></span> <span data-ttu-id="e8984-287">Essa macro é implementada adequadamente para cada plataforma.</span><span class="sxs-lookup"><span data-stu-id="e8984-287">This macro is implemented appropriately for each platform.</span></span>

<span data-ttu-id="e8984-288">No Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) é definido como **lwsync** (Lightweight Sync), também disponível por meio do **\_ \_ lwsync** intrínseco, que é definido em ppcintrinsics. h.</span><span class="sxs-lookup"><span data-stu-id="e8984-288">On Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined as **lwsync** (lightweight sync), also available through the **\_\_lwsync** intrinsic, which is defined in ppcintrinsics.h.</span></span> <span data-ttu-id="e8984-289">**\_ \_ lwsync** também serve como uma barreira de memória do compilador, impedindo a reorganização de leituras e gravações pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="e8984-289">**\_\_lwsync** also serves as a compiler memory barrier, preventing rearranging of reads and writes by the compiler.</span></span>

<span data-ttu-id="e8984-290">A instrução **lwsync** é uma barreira de memória no Xbox 360 que sincroniza um núcleo de processador com o cache L2.</span><span class="sxs-lookup"><span data-stu-id="e8984-290">The **lwsync** instruction is a memory barrier on Xbox 360 that synchronizes one processor core with the L2 cache.</span></span> <span data-ttu-id="e8984-291">Ele garante que todas as gravações antes de **lwsync** a transformem no cache L2 antes das gravações que se seguem.</span><span class="sxs-lookup"><span data-stu-id="e8984-291">It guarantees that all writes before **lwsync** make it to the L2 cache before any writes that follow.</span></span> <span data-ttu-id="e8984-292">Ele também garante que todas as leituras que seguem **lwsync** não obtenham dados mais antigos do L2 do que as leituras anteriores.</span><span class="sxs-lookup"><span data-stu-id="e8984-292">It also guarantees that any reads that follow **lwsync** don't get older data from L2 than previous reads.</span></span> <span data-ttu-id="e8984-293">O tipo de reordenação que ele não impede é uma leitura à frente de uma gravação em um endereço diferente.</span><span class="sxs-lookup"><span data-stu-id="e8984-293">The one type of reordering that it does not prevent is a read moving ahead of a write to a different address.</span></span> <span data-ttu-id="e8984-294">Assim, o **lwsync** impõe a ordenação de memória que corresponde à ordenação de memória padrão em processadores x86 e x64.</span><span class="sxs-lookup"><span data-stu-id="e8984-294">Thus, **lwsync** enforces memory ordering that matches the default memory ordering on x86 and x64 processors.</span></span> <span data-ttu-id="e8984-295">Para obter a ordenação de memória completa, é necessário ter uma instrução de sincronização mais cara (também conhecida como sincronização pesada), mas, na maioria dos casos, isso não é necessário.</span><span class="sxs-lookup"><span data-stu-id="e8984-295">To get full memory ordering requires the more expensive sync instruction (also known as heavyweight sync), but in most cases, this is not required.</span></span> <span data-ttu-id="e8984-296">As opções de reordenação de memória no Xbox 360 são mostradas na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="e8984-296">The memory reordering options on Xbox 360 are shown in the following table.</span></span>



| <span data-ttu-id="e8984-297">Reordenação do Xbox 360</span><span class="sxs-lookup"><span data-stu-id="e8984-297">Xbox 360 Reordering</span></span>           | <span data-ttu-id="e8984-298">Sem sincronização</span><span class="sxs-lookup"><span data-stu-id="e8984-298">No sync</span></span> | <span data-ttu-id="e8984-299">lwsync</span><span class="sxs-lookup"><span data-stu-id="e8984-299">lwsync</span></span> | <span data-ttu-id="e8984-300">sync</span><span class="sxs-lookup"><span data-stu-id="e8984-300">sync</span></span> |
|-------------------------------|---------|--------|------|
| <span data-ttu-id="e8984-301">Leituras em movimento à frente de leituras</span><span class="sxs-lookup"><span data-stu-id="e8984-301">Reads moving ahead of reads</span></span>   | <span data-ttu-id="e8984-302">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-302">Yes</span></span>     | <span data-ttu-id="e8984-303">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-303">No</span></span>     | <span data-ttu-id="e8984-304">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-304">No</span></span>   |
| <span data-ttu-id="e8984-305">Gravações em movimento à frente de gravações</span><span class="sxs-lookup"><span data-stu-id="e8984-305">Writes moving ahead of writes</span></span> | <span data-ttu-id="e8984-306">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-306">Yes</span></span>     | <span data-ttu-id="e8984-307">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-307">No</span></span>     | <span data-ttu-id="e8984-308">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-308">No</span></span>   |
| <span data-ttu-id="e8984-309">Gravações em movimento à frente de leituras</span><span class="sxs-lookup"><span data-stu-id="e8984-309">Writes moving ahead of reads</span></span>  | <span data-ttu-id="e8984-310">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-310">Yes</span></span>     | <span data-ttu-id="e8984-311">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-311">No</span></span>     | <span data-ttu-id="e8984-312">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-312">No</span></span>   |
| <span data-ttu-id="e8984-313">Leituras em movimento à frente de gravações</span><span class="sxs-lookup"><span data-stu-id="e8984-313">Reads moving ahead of writes</span></span>  | <span data-ttu-id="e8984-314">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-314">Yes</span></span>     | <span data-ttu-id="e8984-315">Sim</span><span class="sxs-lookup"><span data-stu-id="e8984-315">Yes</span></span>    | <span data-ttu-id="e8984-316">Não</span><span class="sxs-lookup"><span data-stu-id="e8984-316">No</span></span>   |



 

<span data-ttu-id="e8984-317">O PowerPC também tem as instruções de sincronização **iSync** e **eieio** (que é usada para controlar a reordenação para memória de cache inibida).</span><span class="sxs-lookup"><span data-stu-id="e8984-317">PowerPC also has the synchronization instructions **isync** and **eieio** (which is used to control reordering to caching-inhibited memory).</span></span> <span data-ttu-id="e8984-318">Essas instruções de sincronização não devem ser necessárias para fins de sincronização normais.</span><span class="sxs-lookup"><span data-stu-id="e8984-318">These synchronization instructions should not be needed for normal synchronization purposes.</span></span>

<span data-ttu-id="e8984-319">No Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) é definido em Winnt. h e fornece uma instrução de barreira de memória diferente, dependendo se você está compilando para x86 ou x64.</span><span class="sxs-lookup"><span data-stu-id="e8984-319">On Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined in Winnt.h and gives you a different memory barrier instruction depending on whether you are compiling for x86 or x64.</span></span> <span data-ttu-id="e8984-320">A instrução de barreira de memória serve como uma barreira completa, impedindo todas as reordenação de leituras e gravações em toda a barreira.</span><span class="sxs-lookup"><span data-stu-id="e8984-320">The memory barrier instruction serves as a full barrier, preventing all reordering of reads and writes across the barrier.</span></span> <span data-ttu-id="e8984-321">Assim, o **MemoryBarrier** no Windows oferece uma garantia de reordenação mais forte do que no Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="e8984-321">Thus, **MemoryBarrier** on Windows gives a stronger reordering guarantee than it does on Xbox 360.</span></span>

<span data-ttu-id="e8984-322">No Xbox 360 e em muitas outras CPUs, há uma maneira adicional de que a reordenação de leitura pela CPU possa ser evitada.</span><span class="sxs-lookup"><span data-stu-id="e8984-322">On Xbox 360, and on many other CPUs, there is one additional way that read-reordering by the CPU can be prevented.</span></span> <span data-ttu-id="e8984-323">Se você ler um ponteiro e, em seguida, usar esse ponteiro para carregar outros dados, a CPU garante que as leituras do ponteiro não sejam mais antigas do que a leitura do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="e8984-323">If you read a pointer and then use that pointer to load other data, the CPU guarantees that the reads off of the pointer are not older than the read of the pointer.</span></span> <span data-ttu-id="e8984-324">Se o sinalizador de bloqueio for um ponteiro e se todas as leituras de dados compartilhados estiverem fora do ponteiro, o [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) poderá ser omitido para uma economia de desempenho modesto.</span><span class="sxs-lookup"><span data-stu-id="e8984-324">If your lock flag is a pointer and if all reads of shared data are off of the pointer, the [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) can be omitted, for a modest performance savings.</span></span>

``` syntax
Data* localPointer = g_sharedPointer;
if( localPointer )
{
    // No import barrier is needed--all reads off of localPointer
    // are guaranteed to not be reordered past the read of
    // localPointer.
    int localVariable = localPointer->y;
    // A memory barrier is needed to stop the read of g_global
    // from being speculatively moved ahead of the read of
    // g_sharedPointer.
    int localVariable2 = g_global;
}
```

<span data-ttu-id="e8984-325">A instrução [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) só impede a reordenação de leituras e gravações na memória armazenável em cache.</span><span class="sxs-lookup"><span data-stu-id="e8984-325">The [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) instruction only prevents reordering of reads and writes to cacheable memory.</span></span> <span data-ttu-id="e8984-326">Se você alocar memória como PAGE \_ NoCache ou Page \_ WRITECOMBINE, uma técnica comum para autores de driver de dispositivo e desenvolvedores de jogos no Xbox 360, o **MemoryBarrier** não tem nenhum efeito sobre acesso a essa memória.</span><span class="sxs-lookup"><span data-stu-id="e8984-326">If you allocate memory as PAGE\_NOCACHE or PAGE\_WRITECOMBINE, a common technique for device driver authors and for game developers on Xbox 360, **MemoryBarrier** has no effect on accesses to this memory.</span></span> <span data-ttu-id="e8984-327">A maioria dos desenvolvedores não precisa de sincronização de memória não armazenável em cache.</span><span class="sxs-lookup"><span data-stu-id="e8984-327">Most developers don't need synchronization of non-cacheable memory.</span></span> <span data-ttu-id="e8984-328">Isso está além do escopo deste artigo.</span><span class="sxs-lookup"><span data-stu-id="e8984-328">That is beyond the scope of this article.</span></span>

## <a name="interlocked-functions-and-cpu-reordering"></a><span data-ttu-id="e8984-329">Funções interligadas e reordenação de CPU</span><span class="sxs-lookup"><span data-stu-id="e8984-329">Interlocked Functions and CPU Reordering</span></span>

<span data-ttu-id="e8984-330">Às vezes, a leitura ou gravação que adquire ou libera um recurso é feita usando uma das funções **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="e8984-330">Sometimes the read or write that acquires or releases a resource is done using one of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="e8984-331">No Windows, isso simplifica as coisas; como no Windows, as funções **InterlockedXxx** são barreiras de memória total.</span><span class="sxs-lookup"><span data-stu-id="e8984-331">On Windows, this simplifies things; because on Windows, the **InterlockedXxx** functions are all full-memory barriers.</span></span> <span data-ttu-id="e8984-332">Eles efetivamente têm uma barreira de memória de CPU antes e depois delas, o que significa que eles são uma barreira completa de leitura-aquisição ou gravação-liberação por si só.</span><span class="sxs-lookup"><span data-stu-id="e8984-332">They effectively have a CPU memory barrier both before and after them, which means that they are a full read-acquire or write-release barrier all by themselves.</span></span>

<span data-ttu-id="e8984-333">No Xbox 360, as funções **InterlockedXxx** não contêm barreiras de memória de CPU.</span><span class="sxs-lookup"><span data-stu-id="e8984-333">On Xbox 360, the **InterlockedXxx** functions do not contain CPU memory barriers.</span></span> <span data-ttu-id="e8984-334">Eles impedem a reordenação de leituras e gravações do compilador, mas não a reordenação da CPU.</span><span class="sxs-lookup"><span data-stu-id="e8984-334">They prevent compiler reordering of reads and writes but not CPU reordering.</span></span> <span data-ttu-id="e8984-335">Portanto, na maioria dos casos, ao usar as funções **InterlockedXxx** no Xbox 360, você deve precedê-las ou segui-las com um **\_ \_ lwsync**, para torná-las uma barreira Read-Acquire ou Write-Release.</span><span class="sxs-lookup"><span data-stu-id="e8984-335">Therefore, in most cases when using **InterlockedXxx** functions on Xbox 360, you should precede or follow them with an **\_\_lwsync**, to make them a read-acquire or write-release barrier.</span></span> <span data-ttu-id="e8984-336">Para sua conveniência e facilitar a legibilidade, há versões de **aquisição** e **lançamento** de muitas das funções **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="e8984-336">For convenience and for easier readability, there are **Acquire** and **Release** versions of many of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="e8984-337">Eles são fornecidos com uma barreira de memória interna.</span><span class="sxs-lookup"><span data-stu-id="e8984-337">These come with a built-in memory barrier.</span></span> <span data-ttu-id="e8984-338">Por exemplo, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) faz um incremento intercadeado seguido por uma barreira de memória **\_ \_ lwsync** para fornecer a funcionalidade completa de leitura/aquisição.</span><span class="sxs-lookup"><span data-stu-id="e8984-338">For instance, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) does an interlocked increment followed by an **\_\_lwsync** memory barrier to give the full read-acquire functionality.</span></span>

<span data-ttu-id="e8984-339">É recomendável que você use as versões de **aquisição** e **lançamento** das funções **InterlockedXxx** (a maioria delas também estão disponíveis no Windows, sem penalidade de desempenho) para tornar sua intenção mais óbvia e facilitar a obtenção das instruções de barreira de memória no local correto.</span><span class="sxs-lookup"><span data-stu-id="e8984-339">It is recommended that you use the **Acquire** and **Release** versions of the **InterlockedXxx** functions (most of which are available on Windows as well, with no performance penalty) to make your intent more obvious and to make it easier to get the memory barrier instructions in the correct place.</span></span> <span data-ttu-id="e8984-340">Qualquer uso de **InterlockedXxx** no Xbox 360 sem uma barreira de memória deve ser examinado com muito cuidado, pois geralmente é um bug.</span><span class="sxs-lookup"><span data-stu-id="e8984-340">Any use of **InterlockedXxx** on Xbox 360 without a memory barrier should be examined very carefully, because it is often a bug.</span></span>

<span data-ttu-id="e8984-341">Este exemplo demonstra como um thread pode passar tarefas ou outros dados para outro thread usando as versões de **aquisição** e **liberação** das funções **InterlockedXxxSList** .</span><span class="sxs-lookup"><span data-stu-id="e8984-341">This sample demonstrates how one thread can pass tasks or other data to another thread using the **Acquire** and **Release** versions of the **InterlockedXxxSList** functions.</span></span> <span data-ttu-id="e8984-342">As funções **InterlockedXxxSList** são uma família de funções para manter uma lista compartilhada vinculada individualmente sem um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="e8984-342">The **InterlockedXxxSList** functions are a family of functions for maintaining a shared singly linked list without a lock.</span></span> <span data-ttu-id="e8984-343">Observe que as variantes de **aquisição** e **liberação** dessas funções não estão disponíveis no Windows, mas as versões regulares dessas funções são uma barreira de memória total no Windows.</span><span class="sxs-lookup"><span data-stu-id="e8984-343">Note that **Acquire** and **Release** variants of these functions are not available on Windows, but the regular versions of these functions are a full memory barrier on Windows.</span></span>

``` syntax
// Declarations for the Task class go here.

// Add a new task to the list using lockless programming.
void AddTask( DWORD ID, DWORD data )
{
    Task* newItem = new Task( ID, data );
    InterlockedPushEntrySListRelease( g_taskList, newItem );
}

// Remove a task from the list, using lockless programming.
// This will return NULL if there are no items in the list.
Task* GetTask()
{
    Task* result = (Task*)
        InterlockedPopEntrySListAcquire( g_taskList );
    return result;
}
```

## <a name="volatile-variables-and-reordering"></a><span data-ttu-id="e8984-344">Variáveis voláteis e reordenação</span><span class="sxs-lookup"><span data-stu-id="e8984-344">Volatile Variables and Reordering</span></span>

<span data-ttu-id="e8984-345">O padrão C++ diz que as leituras de variáveis voláteis não podem ser armazenadas em cache, gravações voláteis não podem ser atrasadas, e leituras e gravações voláteis não podem ser movidas além das outras.</span><span class="sxs-lookup"><span data-stu-id="e8984-345">The C++ Standard says that reads of volatile variables cannot be cached, volatile writes cannot be delayed, and volatile reads and writes cannot be moved past each other.</span></span> <span data-ttu-id="e8984-346">Isso é suficiente para a comunicação com dispositivos de hardware, que é a finalidade da palavra-chave volátil no padrão C++.</span><span class="sxs-lookup"><span data-stu-id="e8984-346">This is sufficient for communicating with hardware devices, which is the purpose of the volatile keyword in the C++ Standard.</span></span>

<span data-ttu-id="e8984-347">No entanto, as garantias do padrão não são suficientes para o uso de volatile para multithreading.</span><span class="sxs-lookup"><span data-stu-id="e8984-347">However, the guarantees of the standard are not sufficient for using volatile for multi-threading.</span></span> <span data-ttu-id="e8984-348">O padrão C++ não interrompe o compilador de reordenar leituras e gravações não voláteis em relação a leituras e gravações voláteis e não diz nada sobre impedir a reordenação da CPU.</span><span class="sxs-lookup"><span data-stu-id="e8984-348">The C++ Standard does not stop the compiler from reordering non-volatile reads and writes relative to volatile reads and writes, and it says nothing about preventing CPU reordering.</span></span>

<span data-ttu-id="e8984-349">Visual C++ 2005 vai além do C++ padrão para definir a semântica amigável de vários threads para acesso de variável volátil.</span><span class="sxs-lookup"><span data-stu-id="e8984-349">Visual C++ 2005 goes beyond standard C++ to define multi-threading-friendly semantics for volatile variable access.</span></span> <span data-ttu-id="e8984-350">A partir do Visual C++ 2005, as leituras de variáveis voláteis são definidas para ter semântica de leitura/aquisição, e as gravações para variáveis voláteis são definidas para ter semântica de gravação/liberação.</span><span class="sxs-lookup"><span data-stu-id="e8984-350">Starting with Visual C++ 2005, reads from volatile variables are defined to have read-acquire semantics, and writes to volatile variables are defined to have write-release semantics.</span></span> <span data-ttu-id="e8984-351">Isso significa que o compilador não reorganizará nenhuma leitura e gravação além delas e, no Windows, garantirá que a CPU também não faça isso.</span><span class="sxs-lookup"><span data-stu-id="e8984-351">This means that the compiler will not rearrange any reads and writes past them, and on Windows it will ensure that the CPU does not do so either.</span></span>

<span data-ttu-id="e8984-352">É importante entender que essas novas garantias só se aplicam ao Visual C++ 2005 e a versões futuras do Visual C++.</span><span class="sxs-lookup"><span data-stu-id="e8984-352">It is important to understand that these new guarantees only apply to Visual C++ 2005 and future versions of Visual C++.</span></span> <span data-ttu-id="e8984-353">Os compiladores de outros fornecedores geralmente implementarão semânticas diferentes, sem garantias extras de Visual C++ 2005.</span><span class="sxs-lookup"><span data-stu-id="e8984-353">Compilers from other vendors will generally implement different semantics, without the extra guarantees of Visual C++ 2005.</span></span> <span data-ttu-id="e8984-354">Além disso, no Xbox 360, o compilador não insere nenhuma instrução para impedir que a CPU reordene leituras e gravações.</span><span class="sxs-lookup"><span data-stu-id="e8984-354">Also, on Xbox 360, the compiler does not insert any instructions to prevent the CPU from reordering reads and writes.</span></span>

## <a name="example-of-a-lock-free-data-pipe"></a><span data-ttu-id="e8984-355">Exemplo de um pipe de dados de Lock-Free</span><span class="sxs-lookup"><span data-stu-id="e8984-355">Example of a Lock-Free Data Pipe</span></span>

<span data-ttu-id="e8984-356">Um pipe é um constructo que permite que um ou mais threads gravem dados que são lidos por outros threads.</span><span class="sxs-lookup"><span data-stu-id="e8984-356">A pipe is a construct that lets one or more threads write data that is then read by other threads.</span></span> <span data-ttu-id="e8984-357">Uma versão bloqueada de um pipe pode ser uma maneira elegante e eficiente de passar o trabalho do thread para o thread.</span><span class="sxs-lookup"><span data-stu-id="e8984-357">A lockless version of a pipe can be an elegant and efficient way to pass work from thread to thread.</span></span> <span data-ttu-id="e8984-358">O SDK do DirectX fornece **LockFreePipe**, um único leitor de bloqueio de gravador único, que está disponível em DXUTLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="e8984-358">The DirectX SDK supplies **LockFreePipe**, a single-reader, single-writer lockless pipe that is available in DXUTLockFreePipe.h.</span></span> <span data-ttu-id="e8984-359">O mesmo **LockFreePipe** está disponível no SDK do Xbox 360 em AtgLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="e8984-359">The same **LockFreePipe** is available in the Xbox 360 SDK in AtgLockFreePipe.h.</span></span>

<span data-ttu-id="e8984-360">**LockFreePipe** pode ser usado quando dois threads têm uma relação produtor/consumidor.</span><span class="sxs-lookup"><span data-stu-id="e8984-360">**LockFreePipe** can be used when two threads have a producer/consumer relationship.</span></span> <span data-ttu-id="e8984-361">O thread de produtor pode gravar dados no pipe para que o thread do consumidor processe em uma data posterior, sem nunca bloqueá-lo.</span><span class="sxs-lookup"><span data-stu-id="e8984-361">The producer thread can write data to the pipe for the consumer thread to process at a later date, without ever blocking.</span></span> <span data-ttu-id="e8984-362">Se o pipe for preenchido, as gravações falharão e o thread de produtor precisará tentar novamente mais tarde, mas isso só aconteceria se o thread de produtor estiver à frente.</span><span class="sxs-lookup"><span data-stu-id="e8984-362">If the pipe fills up, writes fail, and the producer thread will have to try again later, but this would only happen if the producer thread is ahead.</span></span> <span data-ttu-id="e8984-363">Se o pipe for esvaziado, as leituras falharão e o thread do consumidor precisará tentar novamente mais tarde, mas isso só aconteceria se não houver nenhum trabalho para o thread de consumidor fazer.</span><span class="sxs-lookup"><span data-stu-id="e8984-363">If the pipe empties, reads fail, and the consumer thread will have to try again later, but this would only happen if there is no work for the consumer thread to do.</span></span> <span data-ttu-id="e8984-364">Se os dois threads estiverem bem balanceados e o pipe for grande o suficiente, o pipe permitirá que eles passem dados sem problemas, sem atrasos ou blocos.</span><span class="sxs-lookup"><span data-stu-id="e8984-364">If the two threads are well-balanced, and the pipe is big enough, the pipe lets them smoothly pass data along with no delays or blocks.</span></span>

## <a name="xbox-360-performance"></a><span data-ttu-id="e8984-365">Desempenho do Xbox 360</span><span class="sxs-lookup"><span data-stu-id="e8984-365">Xbox 360 Performance</span></span>

<span data-ttu-id="e8984-366">O desempenho das instruções e das funções de sincronização no Xbox 360 varia de acordo com o outro código em execução.</span><span class="sxs-lookup"><span data-stu-id="e8984-366">The performance of synchronization instructions and functions on Xbox 360 will vary depending on what other code is running.</span></span> <span data-ttu-id="e8984-367">A aquisição de bloqueios levará muito mais tempo se outro thread possuir o bloqueio no momento.</span><span class="sxs-lookup"><span data-stu-id="e8984-367">Acquiring locks will take much longer if another thread currently owns the lock.</span></span> <span data-ttu-id="e8984-368">As operações de [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) e de seção crítica levarão muito mais tempo se outros threads estiverem gravando na mesma linha de cache.</span><span class="sxs-lookup"><span data-stu-id="e8984-368">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) and critical section operations will take much longer if other threads are writing to the same cache line.</span></span> <span data-ttu-id="e8984-369">O conteúdo das filas de armazenamento também pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="e8984-369">The contents of the store queues can also affect performance.</span></span> <span data-ttu-id="e8984-370">Portanto, todos esses números são apenas aproximações, gerados a partir de testes muito simples:</span><span class="sxs-lookup"><span data-stu-id="e8984-370">Therefore, all of these numbers are just approximations, generated from very simple tests:</span></span>

-   <span data-ttu-id="e8984-371">**lwsync** foi medido como levar 33-48 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-371">**lwsync** was measured as taking 33-48 cycles.</span></span>
-   <span data-ttu-id="e8984-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) foi medido como levar 225-260 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 225-260 cycles.</span></span>
-   <span data-ttu-id="e8984-373">A aquisição ou a liberação de uma seção crítica foi medida considerando cerca de 345 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-373">Acquiring or releasing a critical section was measured as taking about 345 cycles.</span></span>
-   <span data-ttu-id="e8984-374">Adquirir ou liberar um mutex foi medido como cerca de 2350 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-374">Acquiring or releasing a mutex was measured as taking about 2350 cycles.</span></span>

## <a name="windows-performance"></a><span data-ttu-id="e8984-375">Desempenho do Windows</span><span class="sxs-lookup"><span data-stu-id="e8984-375">Windows Performance</span></span>

<span data-ttu-id="e8984-376">O desempenho de instruções de sincronização e funções no Windows varia muito dependendo do tipo de processador e da configuração e do que o outro código está executando.</span><span class="sxs-lookup"><span data-stu-id="e8984-376">The performance of synchronization instructions and functions on Windows vary widely depending on the processor type and configuration, and on what other code is running.</span></span> <span data-ttu-id="e8984-377">Os sistemas com vários núcleos e vários soquetes geralmente demoram mais para executar instruções de sincronização e a aquisição de bloqueios leva muito mais tempo se outro thread possuir o bloqueio no momento.</span><span class="sxs-lookup"><span data-stu-id="e8984-377">Multi-core and multi-socket systems often take longer to execute synchronizing instructions, and acquiring locks take much longer if another thread currently owns the lock.</span></span>

<span data-ttu-id="e8984-378">No entanto, até mesmo algumas medidas geradas de testes muito simples são úteis:</span><span class="sxs-lookup"><span data-stu-id="e8984-378">However, even some measurements generated from very simple tests are helpful:</span></span>

-   <span data-ttu-id="e8984-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) foi medido como levar 20-90 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) was measured as taking 20-90 cycles.</span></span>
-   <span data-ttu-id="e8984-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) foi medido como levar 36-90 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 36-90 cycles.</span></span>
-   <span data-ttu-id="e8984-381">A aquisição ou a liberação de uma seção crítica foi medida como levar 40-100 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-381">Acquiring or releasing a critical section was measured as taking 40-100 cycles.</span></span>
-   <span data-ttu-id="e8984-382">Adquirir ou liberar um mutex foi medido como cerca de 750-2500 ciclos.</span><span class="sxs-lookup"><span data-stu-id="e8984-382">Acquiring or releasing a mutex was measured as taking about 750-2500 cycles.</span></span>

<span data-ttu-id="e8984-383">Esses testes foram feitos no Windows XP em uma variedade de processadores diferentes.</span><span class="sxs-lookup"><span data-stu-id="e8984-383">These tests were done on Windows XP on a range of different processors.</span></span> <span data-ttu-id="e8984-384">Os horários curtos estavam em um computador com um único processador e os tempos mais longos estavam em um computador com vários processadores.</span><span class="sxs-lookup"><span data-stu-id="e8984-384">The short times were on a single-processor machine, and the longer times were on a multi-processor machine.</span></span>

<span data-ttu-id="e8984-385">Embora adquirir e liberar bloqueios seja mais caro do que usar a programação sem bloqueios, é ainda melhor compartilhar dados com menos frequência, evitando, assim, o custo total.</span><span class="sxs-lookup"><span data-stu-id="e8984-385">While acquiring and releasing locks is more expensive than using lockless programming, it is even better to share data less frequently, thus avoiding the cost altogether.</span></span>

## <a name="performance-thoughts"></a><span data-ttu-id="e8984-386">Pensamentos sobre o desempenho</span><span class="sxs-lookup"><span data-stu-id="e8984-386">Performance Thoughts</span></span>

<span data-ttu-id="e8984-387">A aquisição ou a liberação de uma seção crítica consiste em uma barreira de memória, uma operação **InterlockedXxx** e alguma verificação extra para lidar com a recursão e retornar a um mutex, se necessário.</span><span class="sxs-lookup"><span data-stu-id="e8984-387">Acquiring or releasing a critical section consists of a memory barrier, an **InterlockedXxx** operation, and some extra checking to handle recursion and to fall back to a mutex, if necessary.</span></span> <span data-ttu-id="e8984-388">Você deve ter cuidado ao implementar sua própria seção crítica, pois a rotação em um loop aguardando que um bloqueio seja gratuito, sem voltar a um mutex, pode desperdiçar um desempenho considerável.</span><span class="sxs-lookup"><span data-stu-id="e8984-388">You should be wary of implementing your own critical section, because spinning in a loop waiting for a lock to be free, without falling back to a mutex, can waste considerable performance.</span></span> <span data-ttu-id="e8984-389">Para seções críticas que são altamente contratadas, mas não são mantidas por longos, você deve considerar o uso de [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) para que o sistema operacional seja girado por um tempo esperando pela seção crítica estar disponível em vez de ser imediatamente desreferenciado a um mutex se a seção crítica for de sua propriedade quando você tentar adquiri-la.</span><span class="sxs-lookup"><span data-stu-id="e8984-389">For critical sections that are heavily contended but not held for long, you should consider using [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) so that the operating system will spin for a while waiting for the critical section to be available rather than immediately deferring to a mutex if the critical section is owned when you try to acquire it.</span></span> <span data-ttu-id="e8984-390">Para identificar as seções críticas que podem se beneficiar de uma contagem de rotação, é necessário medir o comprimento da espera típica para um bloqueio específico.</span><span class="sxs-lookup"><span data-stu-id="e8984-390">In order to identify critical sections that can benefit from a spin count, it is necessary to measure the length of the typical wait for a particular lock.</span></span>

<span data-ttu-id="e8984-391">Se um heap compartilhado for usado para alocações de memória — o comportamento padrão — cada alocação de memória e livre envolverá a aquisição de um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="e8984-391">If a shared heap is used for memory allocations—the default behavior—every memory allocation and free involves acquiring a lock.</span></span> <span data-ttu-id="e8984-392">À medida que o número de threads e o número de alocações aumenta, os níveis de desempenho são desativados e, eventualmente, começam a diminuir.</span><span class="sxs-lookup"><span data-stu-id="e8984-392">As the number of threads and the number of allocations increases, performance levels off, and eventually starts to decrease.</span></span> <span data-ttu-id="e8984-393">O uso de heaps por thread ou a redução do número de alocações pode evitar esse afunilamento de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="e8984-393">Using per-thread heaps, or reducing the number of allocations, can avoid this locking bottleneck.</span></span>

<span data-ttu-id="e8984-394">Se um thread estiver gerando dados e outro thread estiver consumindo dados, eles poderão acabar compartilhando dados com frequência.</span><span class="sxs-lookup"><span data-stu-id="e8984-394">If one thread is generating data and another thread is consuming data, they may end up sharing data frequently.</span></span> <span data-ttu-id="e8984-395">Isso pode acontecer se um thread estiver carregando recursos e outro thread estiver renderizando a cena.</span><span class="sxs-lookup"><span data-stu-id="e8984-395">This can happen if one thread is loading resources and another thread is rendering the scene.</span></span> <span data-ttu-id="e8984-396">Se o thread de renderização fizer referência aos dados compartilhados em cada chamada de desenho, a sobrecarga de bloqueio será alta.</span><span class="sxs-lookup"><span data-stu-id="e8984-396">If the rendering thread references the shared data on every draw call, the locking overhead will be high.</span></span> <span data-ttu-id="e8984-397">Um desempenho muito melhor pode ser percebido se cada thread tiver estruturas de dados particulares que são sincronizadas uma vez por quadro ou menos.</span><span class="sxs-lookup"><span data-stu-id="e8984-397">Much better performance can be realized if each thread has private data structures which are then synchronized once per frame or less.</span></span>

<span data-ttu-id="e8984-398">Não há garantia de que os algoritmos sem bloqueio sejam mais rápidos do que os algoritmos que usam bloqueios.</span><span class="sxs-lookup"><span data-stu-id="e8984-398">Lockless algorithms are not guaranteed to be faster than algorithms that use locks.</span></span> <span data-ttu-id="e8984-399">Você deve verificar se os bloqueios estão realmente causando problemas antes de tentar evitá-los, e você deve medir para ver se o seu código de bloqueio realmente melhora o desempenho.</span><span class="sxs-lookup"><span data-stu-id="e8984-399">You should check to see if locks are actually causing you problems before trying to avoid them, and you should measure to see if your lockless code actually improves performance.</span></span>

## <a name="platform-differences-summary"></a><span data-ttu-id="e8984-400">Resumo de diferenças de plataforma</span><span class="sxs-lookup"><span data-stu-id="e8984-400">Platform Differences Summary</span></span>

-   <span data-ttu-id="e8984-401">As funções **InterlockedXxx** impedem a reordenação de leitura/gravação de CPU no Windows, mas não no Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="e8984-401">**InterlockedXxx** functions prevent CPU read/write reordering on Windows, but not on Xbox 360.</span></span>
-   <span data-ttu-id="e8984-402">A leitura e a gravação de variáveis voláteis usando o Visual Studio C++ 2005 evita a reordenação de leitura/gravação de CPU no Windows, mas no Xbox 360, ela impede apenas a reordenação de leitura/gravação do compilador.</span><span class="sxs-lookup"><span data-stu-id="e8984-402">Reading and writing of volatile variables using Visual Studio C++ 2005 prevents CPU read/write reordering on Windows, but on Xbox 360, it only prevents compiler read/write reordering.</span></span>
-   <span data-ttu-id="e8984-403">As gravações são reordenadas no Xbox 360, mas não em x86 ou x64.</span><span class="sxs-lookup"><span data-stu-id="e8984-403">Writes are reordered on Xbox 360, but not on x86 or x64.</span></span>
-   <span data-ttu-id="e8984-404">As leituras são reordenadas no Xbox 360, mas em x86 ou x64 elas são reordenadas apenas em relação às gravações, e somente se as leituras e gravações forem direcionadas a locais diferentes.</span><span class="sxs-lookup"><span data-stu-id="e8984-404">Reads are reordered on Xbox 360, but on x86 or x64 they are only reordered relative to writes, and only if the reads and writes target different locations.</span></span>

## <a name="recommendations"></a><span data-ttu-id="e8984-405">Recomendações</span><span class="sxs-lookup"><span data-stu-id="e8984-405">Recommendations</span></span>

-   <span data-ttu-id="e8984-406">Use bloqueios quando possível porque eles são mais fáceis de usar corretamente.</span><span class="sxs-lookup"><span data-stu-id="e8984-406">Use locks when possible because they are easier to use correctly.</span></span>
-   <span data-ttu-id="e8984-407">Evite o bloqueio com muita frequência, para que os custos de bloqueio não se tornem significativos.</span><span class="sxs-lookup"><span data-stu-id="e8984-407">Avoid locking too frequently, so that locking costs do not become significant.</span></span>
-   <span data-ttu-id="e8984-408">Evite manter os bloqueios por muito tempo, a fim de evitar interrupções longas.</span><span class="sxs-lookup"><span data-stu-id="e8984-408">Avoid holding locks for too long, in order to avoid long stalls.</span></span>
-   <span data-ttu-id="e8984-409">Use a programação sem bloqueio quando apropriado, mas certifique-se de que os ganhos justifiquem a complexidade.</span><span class="sxs-lookup"><span data-stu-id="e8984-409">Use lockless programming when appropriate, but be sure that the gains justify the complexity.</span></span>
-   <span data-ttu-id="e8984-410">Use a programação de bloqueio ou bloqueios de rotação em situações em que outros bloqueios são proibidos, como ao compartilhar dados entre chamadas de procedimento deferidas e código normal.</span><span class="sxs-lookup"><span data-stu-id="e8984-410">Use lockless programming or spin locks in situations where other locks are prohibited, such as when sharing data between deferred procedure calls and normal code.</span></span>
-   <span data-ttu-id="e8984-411">Use somente algoritmos de programação de bloqueio padrão que foram comprovados como corretos.</span><span class="sxs-lookup"><span data-stu-id="e8984-411">Only use standard lockless programming algorithms that have been proven to be correct.</span></span>
-   <span data-ttu-id="e8984-412">Ao fazer uma programação de bloqueio, certifique-se de usar as variáveis de sinalizador volátil e as instruções de barreira de memória, conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="e8984-412">When doing lockless programming, be sure to use volatile flag variables and memory barrier instructions as needed.</span></span>
-   <span data-ttu-id="e8984-413">Ao usar o **InterlockedXxx** no Xbox 360, use as variantes de **aquisição** e **versão** .</span><span class="sxs-lookup"><span data-stu-id="e8984-413">When using **InterlockedXxx** on Xbox 360, use the **Acquire** and **Release** variants.</span></span>

## <a name="references"></a><span data-ttu-id="e8984-414">Referências</span><span class="sxs-lookup"><span data-stu-id="e8984-414">References</span></span>

-   <span data-ttu-id="e8984-415">Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="e8984-415">MSDN Library.</span></span> <span data-ttu-id="e8984-416">"[**volátil (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)".</span><span class="sxs-lookup"><span data-stu-id="e8984-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)."</span></span> <span data-ttu-id="e8984-417">Referência da linguagem C++.</span><span class="sxs-lookup"><span data-stu-id="e8984-417">C++ Language Reference.</span></span>
-   <span data-ttu-id="e8984-418">Vance Morrison.</span><span class="sxs-lookup"><span data-stu-id="e8984-418">Vance Morrison.</span></span> <span data-ttu-id="e8984-419">"[Entenda o impacto das técnicas de Low-Lock em aplicativos multissegmentados](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)".</span><span class="sxs-lookup"><span data-stu-id="e8984-419">"[Understand the Impact of Low-Lock Techniques in Multithreaded Apps](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)."</span></span> <span data-ttu-id="e8984-420">MSDN Magazine, outubro de 2005.</span><span class="sxs-lookup"><span data-stu-id="e8984-420">MSDN Magazine, October 2005.</span></span>
-   <span data-ttu-id="e8984-421">Lyons, Michael.</span><span class="sxs-lookup"><span data-stu-id="e8984-421">Lyons, Michael.</span></span> <span data-ttu-id="e8984-422">"[Modelo de armazenamento de PowerPC e programação de Aix](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)".</span><span class="sxs-lookup"><span data-stu-id="e8984-422">"[PowerPC Storage Model and AIX Programming](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)."</span></span> <span data-ttu-id="e8984-423">IBM developerWorks, 16 de novembro de 2005.</span><span class="sxs-lookup"><span data-stu-id="e8984-423">IBM developerWorks, 16 Nov 2005.</span></span>
-   <span data-ttu-id="e8984-424">McKenney, Paul E. "[ordenação de memória em microprocessadores modernos, parte II](https://www.linuxjournal.com/article/8212)".</span><span class="sxs-lookup"><span data-stu-id="e8984-424">McKenney, Paul E. "[Memory Ordering in Modern Microprocessors, Part II](https://www.linuxjournal.com/article/8212)."</span></span> <span data-ttu-id="e8984-425">Diário do Linux, setembro de 2005.</span><span class="sxs-lookup"><span data-stu-id="e8984-425">Linux Journal, September 2005.</span></span> <span data-ttu-id="e8984-426">\[Este artigo tem alguns detalhes do x86.\]</span><span class="sxs-lookup"><span data-stu-id="e8984-426">\[This article has some x86 details.\]</span></span>
-   <span data-ttu-id="e8984-427">Intel Corporation.</span><span class="sxs-lookup"><span data-stu-id="e8984-427">Intel Corporation.</span></span> <span data-ttu-id="e8984-428">"[Classificação de memória da arquitetura Intel® 64](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)".</span><span class="sxs-lookup"><span data-stu-id="e8984-428">"[Intel® 64 Architecture Memory Ordering](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)."</span></span> <span data-ttu-id="e8984-429">Agosto de 2007.</span><span class="sxs-lookup"><span data-stu-id="e8984-429">August 2007.</span></span> <span data-ttu-id="e8984-430">\[Aplica-se aos processadores IA-32 e Intel 64.\]</span><span class="sxs-lookup"><span data-stu-id="e8984-430">\[Applies to both IA-32 and Intel 64 processors.\]</span></span>
-   <span data-ttu-id="e8984-431">Niebler, Eric.</span><span class="sxs-lookup"><span data-stu-id="e8984-431">Niebler, Eric.</span></span> <span data-ttu-id="e8984-432">"[Relatório de corrida: reunião ad hoc em threads em C++](https://www.artima.com/cppsource/threads_meeting.html)".</span><span class="sxs-lookup"><span data-stu-id="e8984-432">"[Trip Report: Ad-Hoc Meeting on Threads in C++](https://www.artima.com/cppsource/threads_meeting.html)."</span></span> <span data-ttu-id="e8984-433">A fonte C++, 17 de outubro de 2006.</span><span class="sxs-lookup"><span data-stu-id="e8984-433">The C++ Source, 17 Oct 2006.</span></span>
-   <span data-ttu-id="e8984-434">Hart, Thomas E. 2006.</span><span class="sxs-lookup"><span data-stu-id="e8984-434">Hart, Thomas E. 2006.</span></span> <span data-ttu-id="e8984-435">"[Tornar a sincronização de bloqueio rápida: implicações de desempenho da recuperação de memória](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)".</span><span class="sxs-lookup"><span data-stu-id="e8984-435">"[Making Lockless Synchronization Fast: Performance Implications of Memory Reclamation](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)."</span></span> <span data-ttu-id="e8984-436">Procedimentos do 2006 Internacional de processamento distribuído paralelo e Symposium (IPDPS 2006), ilha Rhodes, Grécia, 2006 de abril.</span><span class="sxs-lookup"><span data-stu-id="e8984-436">Proceedings of the 2006 International Parallel and Distributed Processing Symposium (IPDPS 2006), Rhodes Island, Greece, April 2006.</span></span>

 

 