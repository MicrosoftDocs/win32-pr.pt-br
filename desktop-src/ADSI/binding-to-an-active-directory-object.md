---
title: Associação a um objeto Active Directory
description: A maneira mais comum de associar a um objeto de Active Directory é usar a função GetObject entre um cliente ADSI e um provedor ADSI.
ms.assetid: d278ea26-2fd5-4343-8d87-ff85515325fb
ms.tgt_platform: multiple
keywords:
- Ligando a um objeto Active Directory ADSI
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 59992dbc88c00be6306dec24523ec4e030d4a516
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/21/2020
ms.locfileid: "103823980"
---
# <a name="binding-to-an-active-directory-object"></a><span data-ttu-id="1e2f9-104">Associação a um objeto Active Directory</span><span class="sxs-lookup"><span data-stu-id="1e2f9-104">Binding to an Active Directory Object</span></span>

<span data-ttu-id="1e2f9-105">A maneira mais comum de associar a um objeto de Active Directory é usar a função **GetObject** entre um cliente ADSI e um provedor ADSI.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-105">The most common way to bind to an Active Directory object is to use the **GetObject** function between an ADSI client and an ADSI provider.</span></span> <span data-ttu-id="1e2f9-106">Essa também é a maneira mais fácil de mostrar como o componente de provedor recebe e serviços de solicitações.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-106">This is also the easiest way to show how the provider component receives and services requests.</span></span> <span data-ttu-id="1e2f9-107">Tanto a função ADSI API [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) quanto a função Visual Basic **GetObject** seguem as mesmas etapas para associação.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-107">Both the ADSI API function [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) or the Visual Basic function **GetObject** follow the same steps for binding.</span></span>

<span data-ttu-id="1e2f9-108">Para este exemplo, suponha que o cliente ADSI é um aplicativo de visualizador ADSI que recebeu o ADsPath "Sample://Seattle/Redmond/Shelly" da interface do usuário (1).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-108">For this example, assume the ADSI client is an ADSI viewer application that has received the ADsPath "Sample://Seattle/Redmond/Shelly" from its user interface (1).</span></span> <span data-ttu-id="1e2f9-109">A figura a seguir detalha a sequência de eventos numerando as setas de fluxo.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-109">The following figure details the sequence of events by numbering the flow arrows.</span></span>

![exibição detalhada dos componentes ADSI](images/dscsex.png)

<span data-ttu-id="1e2f9-111">Na figura anterior, o cliente inicia a solicitação para um ponteiro de interface no objeto Active Directory representado pelo ADsPath "Sample://Seattle/Redmond/Shelly" dos serviços ADSI (2).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-111">In the preceding figure, the client initiates the request for an interface pointer on the Active Directory object represented by the ADsPath "Sample://Seattle/Redmond/Shelly" from ADSI services (2).</span></span> <span data-ttu-id="1e2f9-112">Durante a inicialização, o software de serviços populava uma tabela de identificadores programáticos do provedor instalado (ProgIDs) a partir do registro ("LDAP:", "exemplo:", "WinNT:" e assim por diante) e os emparelharam com os s **CLSID** correspondentes que identificam o módulo de software apropriado.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-112">During initialization, the services software populated a table of installed provider programmatic identifiers (ProgIDs) from the registry ("LDAP:","Sample:", "WinNT:", and so on) and paired them with the matching **CLSID** s which identify the appropriate software module.</span></span>

<span data-ttu-id="1e2f9-113">O servidor ADSI verifica se o ProgID, neste caso, "Sample:", existe no ADsPath.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-113">The ADSI server verifies that the ProgID, in this case "Sample:", exists in the ADsPath.</span></span> <span data-ttu-id="1e2f9-114">Em seguida, ele cria um contexto de associação para otimizar referências adicionais a esse objeto e chama a função COM padrão [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) para criar um moniker com que pode ser usado para localizar e associar ao objeto que representa o usuário "Shelly".</span><span class="sxs-lookup"><span data-stu-id="1e2f9-114">It then creates a bind context to optimize further references to this object, and calls the standard COM function [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) to create a COM moniker that can be used to find and bind to the object that represents the user "Shelly".</span></span>

<span data-ttu-id="1e2f9-115">Na seção a seguir, os nomes de arquivo do componente do provedor de exemplo código-fonte são incluídos entre parênteses, quando apropriado.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-115">In the following section, the file names of the example provider component source code are included in parentheses where appropriate.</span></span>

<span data-ttu-id="1e2f9-116">Como em outras implementações de servidor COM, o [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) examina o ProgID e pesquisa o **CLSID** apropriado no registro (3) para localizar o código de fábrica de classe fornecido pelo provedor correspondente (Cprovcf. cpp) na implementação do provedor apropriado (4).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-116">As in other COM server implementations, [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) examines the ProgID, and looks up the proper **CLSID** in the registry (3) to find the corresponding provider-supplied class factory code (Cprovcf.cpp) in the appropriate provider implementation (4).</span></span> <span data-ttu-id="1e2f9-117">Esse código cria um objeto inicial de nível superior que implementa o método [**IParseDisplayName::P arsedisplayname**](/windows/win32/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname) (Cprov. cpp).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-117">This code creates an initial top-level object that implements the [**IParseDisplayName::ParseDisplayName**](/windows/win32/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname) method (Cprov.cpp).</span></span> <span data-ttu-id="1e2f9-118">A implementação do provedor de **ParseDisplayName** resolve o caminho no próprio namespace do provedor.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-118">The provider's implementation of **ParseDisplayName** resolves the path in the provider's own namespace.</span></span> <span data-ttu-id="1e2f9-119">Isso eventualmente chama ADsObject e invoca o analisador fornecido com o componente do provedor (Parse. cpp) para verificar se o ADsPath está sintaticamente correto para esse namespace.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-119">This eventually calls ADsObject and invokes the parser supplied with the provider component (Parse.cpp) to verify that the ADsPath is syntactically correct for this namespace.</span></span>

<span data-ttu-id="1e2f9-120">**GetObject**, que é definido em Getobj. cpp, determina se o objeto solicitado é um objeto de namespace, um objeto de esquema ou algum outro tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-120">**GetObject**, that is defined in Getobj.cpp, then determines if the object requested is a namespace object, a schema object, or some other type of object.</span></span> <span data-ttu-id="1e2f9-121">Se um dos dois primeiros, esse tipo de objeto de classe de esquema é criado e o ponteiro de interface apropriado é recuperado.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-121">If either of the first two, that type of schema class object is created and the appropriate interface pointer retrieved.</span></span> <span data-ttu-id="1e2f9-122">Caso contrário, o caminho do diretório de exemplo será criado a partir do ADsPath (por exemplo, " \\ Seattle \\ Redmond \\ Shelly", mas em um serviço de diretório diferente, talvez tenha tido que " \\ ou = Seattle \\ ou = Redmond \\ CN = Shelly") e o controle passe para SampleDSOpenObject, o que abre o objeto no armazenamento de dados de exemplo e também recupera seu tipo de objeto (neste caso, "User</span><span class="sxs-lookup"><span data-stu-id="1e2f9-122">Otherwise the Sample directory path is created from the ADsPath (for example, "\\Seattle\\Redmond\\Shelly", but in a different directory service it might have had to be "\\OU=Seattle\\OU=Redmond\\CN=Shelly") and control passes to SampleDSOpenObject which opens the object in the example data storage and also retrieves its object type (in this case, "User") (5).</span></span>

<span data-ttu-id="1e2f9-123">Com os dados coletados, um novo objeto é criado (6) para representar o item descrito pelo ADsPath, e um ponteiro para a interface [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown) nesse objeto é recuperado.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-123">With the data gathered, a new object is created (6) to represent the item described by the ADsPath, and a pointer to the [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface on that object is retrieved.</span></span> <span data-ttu-id="1e2f9-124">Nesse caso, é criado um objeto Active Directory genérico que dá suporte aos métodos **IUnknown** e [**IADs**](/windows/desktop/api/Iads/nn-iads-iads) (Cgenobj. cpp, Core. cpp).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-124">In this case, a generic Active Directory object is created that supports the **IUnknown** and [**IADs**](/windows/desktop/api/Iads/nn-iads-iads) methods (Cgenobj.cpp, Core.cpp).</span></span> <span data-ttu-id="1e2f9-125">A rotina CSampleDSGenObject:: AllocateGenObject lê os dados da biblioteca de tipos para criar as entradas de expedição adequadas para esses novos objetos a fim de oferecer suporte a [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-125">The CSampleDSGenObject::AllocateGenObject routine reads the type library data to create the proper dispatch entries for these new objects in order to support [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch).</span></span>

<span data-ttu-id="1e2f9-126">O encapsulamento deste ponteiro de interface em um moniker conclui a função ResolvePathName (Cprov. cpp) e analisa o nome de exibição.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-126">Wrapping this interface pointer into a moniker completes the ResolvePathName (Cprov.cpp) function and parses the display name.</span></span>

<span data-ttu-id="1e2f9-127">Todos os objetos COM criados durante esse processo são armazenados em cache por motivos de desempenho e gerenciados por meio do contexto de associação.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-127">All the COM objects created during this process are cached for performance reasons and managed through the binding context.</span></span> <span data-ttu-id="1e2f9-128">Isso melhora o desempenho para outras operações no mesmo objeto que segue imediatamente a associação de moniker.</span><span class="sxs-lookup"><span data-stu-id="1e2f9-128">This improves performance for other operations on the same object that immediately follows the moniker binding.</span></span>

<span data-ttu-id="1e2f9-129">Esse objeto de Active Directory bem formado agora é consultado para o identificador de interface solicitado para a chamada [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) inicial e um ponteiro para essa interface é recuperado (7) e passado de volta pelo servidor ADSI para o cliente (8&9).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-129">This well-formed Active Directory object is now queried for the interface identifier requested for the initial [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) call and a pointer to that interface is retrieved (7) and passed back through the ADSI server to the client (8&9).</span></span> <span data-ttu-id="1e2f9-130">A partir desse caso, o cliente funciona diretamente com o componente do provedor por meio dos métodos de interface até que a solicitação inicial seja satisfeita (10).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-130">From then on, the client works directly with the provider component through the interface methods until the initial request is satisfied (10).</span></span>

<span data-ttu-id="1e2f9-131">Além disso, as solicitações de dados de objeto do cliente geralmente assumem a forma de solicitações de gets e takes de propriedade, todas otimizadas por meio da implementação do provedor de um cache de propriedade (cProps. cpp).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-131">Furthermore, requests for object data from the client usually take the form of requests for property gets and puts, all of which are optimized through the provider implementation of a property cache (Cprops.cpp).</span></span> <span data-ttu-id="1e2f9-132">Empacotar e desempacotar dados de forma inteligente, muitas vezes incluindo copiar e liberar estruturas e cadeias de caracteres, entre os tipos de dados nativos no sistema operacional do componente de provedor de exemplo e o tipo de [**variante**](/windows/win32/api/oaidl/ns-oaidl-variant) de automação com suporte pelo ADSI ocorre antes que as propriedades sejam carregadas no cache (Smpoper. cpp).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-132">Intelligently packing and unpacking data, often including copying and freeing structures and strings, between the native data types on the example provider component's operating system and the Automation [**VARIANT**](/windows/win32/api/oaidl/ns-oaidl-variant) type supported by ADSI takes place before the properties are loaded into the cache (Smpoper.cpp).</span></span>

<span data-ttu-id="1e2f9-133">O componente de provedor de exemplo é projetado de forma que as chamadas reais para o sistema operacional sejam logicamente isoladas do componente do provedor, criando software portátil para mais de um sistema operacional (RegDSAPI. cpp).</span><span class="sxs-lookup"><span data-stu-id="1e2f9-133">The example provider component is designed so that the actual calls to the operating system are logically isolated from the provider component, creating software portable to more than one operating system (RegDSAPI.cpp).</span></span>

 

 