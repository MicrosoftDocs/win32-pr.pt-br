---
description: A proteção de fluxo de controle (CFG) é um recurso de segurança de plataforma altamente otimizado que foi criado para combater vulnerabilidades de corrupção de memória.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Proteção de Fluxo de Controle
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91cf97a648443135e7fee666ea4c259b1c32104e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104091808"
---
# <a name="control-flow-guard"></a><span data-ttu-id="f5bcf-103">Proteção de Fluxo de Controle</span><span class="sxs-lookup"><span data-stu-id="f5bcf-103">Control Flow Guard</span></span>

## <a name="what-is-control-flow-guard"></a><span data-ttu-id="f5bcf-104">O que é a proteção de fluxo de controle?</span><span class="sxs-lookup"><span data-stu-id="f5bcf-104">What is Control Flow Guard?</span></span>

<span data-ttu-id="f5bcf-105">A proteção de fluxo de controle (CFG) é um recurso de segurança de plataforma altamente otimizado que foi criado para combater vulnerabilidades de corrupção de memória.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-105">Control Flow Guard (CFG) is a highly-optimized platform security feature that was created to combat memory corruption vulnerabilities.</span></span> <span data-ttu-id="f5bcf-106">Ao colocar restrições rígidas sobre onde um aplicativo pode executar código, isso torna muito mais difícil para explorações executar código arbitrário por meio de vulnerabilidades como estouros de buffer.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-106">By placing tight restrictions on where an application can execute code from, it makes it much harder for exploits to execute arbitrary code through vulnerabilities such as buffer overflows.</span></span> <span data-ttu-id="f5bcf-107">O CFG estende as tecnologias de mitigação de exploração anteriores, como [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)e [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span><span class="sxs-lookup"><span data-stu-id="f5bcf-107">CFG extends previous exploit mitigation technologies such as [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md), and [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span></span>

<span data-ttu-id="f5bcf-108">Esse recurso está disponível no Microsoft Visual Studio 2015 e é executado em versões "com reconhecimento de CFG" do Windows — as versões x86 e x64 para desktop e servidor do Windows 10 e do Windows 8.1 Update (KB3000850).</span><span class="sxs-lookup"><span data-stu-id="f5bcf-108">This feature is available in Microsoft Visual Studio 2015, and runs on "CFG-Aware" versions of Windows—the x86 and x64 releases for Desktop and Server of Windows 10 and Windows 8.1 Update (KB3000850).</span></span>

<span data-ttu-id="f5bcf-109">Recomendamos que os desenvolvedores habilitem o CFG para seus aplicativos.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-109">We strongly encourage developers to enable CFG for their applications.</span></span> <span data-ttu-id="f5bcf-110">Você não precisa habilitar o CFG para cada parte do seu código, pois uma combinação de CFG habilitado e código não habilitado para CFG será executada corretamente.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-110">You don't have to enable CFG for every part of your code, as a mixture of CFG enabled and non-CFG enabled code will execute fine.</span></span> <span data-ttu-id="f5bcf-111">Mas a falha ao habilitar CFG para todo o código pode abrir lacunas na proteção.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-111">But failing to enable CFG for all code can open gaps in the protection.</span></span> <span data-ttu-id="f5bcf-112">Além disso, o código de CFG habilitado funciona bem em versões "CFG sem reconhecimento" do Windows e, portanto, é totalmente compatível com eles.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-112">Furthermore, CFG enabled code works fine on "CFG-Unaware" versions of Windows and is therefore fully compatible with them.</span></span>

## <a name="how-can-i-enable-cfg"></a><span data-ttu-id="f5bcf-113">Como posso habilitar o CFG?</span><span class="sxs-lookup"><span data-stu-id="f5bcf-113">How Can I Enable CFG?</span></span>

<span data-ttu-id="f5bcf-114">Na maioria dos casos, não há necessidade de alterar o código-fonte.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-114">In most cases, there is no need to change source code.</span></span> <span data-ttu-id="f5bcf-115">Tudo o que você precisa fazer é adicionar uma opção ao seu projeto do Visual Studio 2015, e o compilador e o vinculador habilitarão o CFG.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-115">All you have to do is add an option to your Visual Studio 2015 project, and the compiler and linker will enable CFG.</span></span>

<span data-ttu-id="f5bcf-116">O método mais simples é navegar até **Propriedades de projeto \| configurações de \| configuração \| C/C++ \| geração de código** e escolher **Sim (/Guard: CF)** para proteção de fluxo de controle.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-116">The simplest method is to navigate to **Project \| Properties \| Configuration Properties \| C/C++ \| Code Generation** and choose **Yes (/guard:cf)** for Control Flow Guard.</span></span>

![Propriedade cfg no Visual Studio](images/cfg-vs.png)

<span data-ttu-id="f5bcf-118">Como alternativa, adicione **/Guard: CF** às propriedades do projeto Propriedades de **configuração de linha de \| \| \| comando C/C++ \| \| Opções adicionais** (para o compilador) e **/Guard: CF** às propriedades do projeto Propriedades de **\| \| configuração linha de comando do \| vinculador \| \| Opções adicionais** (para o vinculador).</span><span class="sxs-lookup"><span data-stu-id="f5bcf-118">Alternatively, add **/guard:cf** to **Project \| Properties \| Configuration Properties \| C/C++ \| Command Line \| Additional Options** (for the compiler) and **/guard:cf** to **Project \| Properties \| Configuration Properties \| Linker \| Command Line \| Additional Options** (for the linker).</span></span>

![Propriedade cfg para o compilador](images/cfg-compiler.png)![Propriedade cfg para o vinculador](images/cfg-linker.png)

<span data-ttu-id="f5bcf-121">Consulte [/Guard (habilitar proteção de fluxo de controle)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) para obter informações adicionais.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-121">See [/guard (Enable Control Flow Guard)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) for additional info.</span></span>

<span data-ttu-id="f5bcf-122">Se você estiver criando seu projeto na linha de comando, poderá adicionar as mesmas opções.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-122">If you are building your project from the command line, you can add the same options.</span></span> <span data-ttu-id="f5bcf-123">Por exemplo, se você estiver Compilando um projeto chamado Test. cpp, use **CL/Guard: CF Test. cpp/link/Guard: CF**.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-123">For example, if you are compiling a project called test.cpp, use **cl /guard:cf test.cpp /link /guard:cf**.</span></span>

<span data-ttu-id="f5bcf-124">Você também tem a opção de controlar dinamicamente o conjunto de endereços de destino iCal que são considerados válidos por CFG usando o [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) da API de gerenciamento de memória.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-124">You also have the option of dynamically controlling the set of icall target addresses that are considered valid by CFG using the [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) from the Memory Management API.</span></span> <span data-ttu-id="f5bcf-125">A mesma API pode ser usada para especificar se as páginas são destinos inválidos ou válidos para CFG.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-125">The same API can be used to specify whether pages are invalid or valid targets for CFG.</span></span> <span data-ttu-id="f5bcf-126">As funções [**usar VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) e [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) , por padrão, tratam uma região especificada do executável e as páginas confirmadas como destinos de chamada indiretos válidos.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-126">The [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) and [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) functions will by default treat a specified region of executable and committed pages as valid indirect call targets.</span></span> <span data-ttu-id="f5bcf-127">É possível substituir esse comportamento, como ao implementar um compilador just-in-time, especificando **destinos de página \_ \_ inválidos** ao chamar o **VirtualAlloc** ou **o \_ direcionamento de página \_ sem \_ atualização** ao chamar **usar VirtualProtect** , conforme detalhado em [**constantes de proteção de memória**](/windows/desktop/Memory/memory-protection-constants).</span><span class="sxs-lookup"><span data-stu-id="f5bcf-127">It is possible to override this behavior, such as when implementing a Just-in-Time compiler, by specifying **PAGE\_TARGETS\_INVALID** when calling **VirtualAlloc** or **PAGE\_TARGETS\_NO\_UPDATE** when calling **VirtualProtect** as detailed under [**Memory Protection Constants**](/windows/desktop/Memory/memory-protection-constants).</span></span>

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a><span data-ttu-id="f5bcf-128">Como faço para dizer que um binário está sob o controle do Flow Guard?</span><span class="sxs-lookup"><span data-stu-id="f5bcf-128">How Do I Tell That a Binary is under Control Flow Guard?</span></span>

<span data-ttu-id="f5bcf-129">Execute a [ferramenta DUMPBIN](/cpp/build/reference/dumpbin-reference) (incluída na instalação do visual Studio 2015) no prompt de comando do Visual Studio com as opções */Headers* e */loadconfig* : **DUMPBIN/Headers/loadconfig test.exe**.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-129">Run the [dumpbin tool](/cpp/build/reference/dumpbin-reference) (included in the Visual Studio 2015 installation) from the Visual Studio command prompt with the */headers* and */loadconfig* options: **dumpbin /headers /loadconfig test.exe**.</span></span> <span data-ttu-id="f5bcf-130">A saída de um binário em CFG deve mostrar que os valores de cabeçalho incluem "Guard" e que os valores de configuração de carga incluem "CF instrumentado" e "tabela FID presente".</span><span class="sxs-lookup"><span data-stu-id="f5bcf-130">The output for a binary under CFG should show that the header values include "Guard", and that the load config values include "CF Instrumented" and "FID table present".</span></span>

![saída de DUMPBIN/Headers](images/cfg-dumpbin-headers.png)

![saída de DUMPBIN/loadconfig](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a><span data-ttu-id="f5bcf-133">Como o CFG realmente funciona?</span><span class="sxs-lookup"><span data-stu-id="f5bcf-133">How Does CFG Really Work?</span></span>

<span data-ttu-id="f5bcf-134">As vulnerabilidades de software são frequentemente exploradas fornecendo dados pouco, incomuns ou extremos a um programa em execução.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-134">Software vulnerabilities are often exploited by providing unlikely, unusual, or extreme data to a running program.</span></span> <span data-ttu-id="f5bcf-135">Por exemplo, um invasor pode explorar uma vulnerabilidade de estouro de buffer fornecendo mais entrada a um programa do que o esperado e, assim, executando em excesso a área reservada pelo programa para manter uma resposta.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-135">For example, an attacker can exploit a buffer overflow vulnerability by providing more input to a program than expected, thereby over-running the area reserved by the program to hold a response.</span></span> <span data-ttu-id="f5bcf-136">Isso pode corromper a memória adjacente que pode conter um ponteiro de função.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-136">This could corrupt adjacent memory that may hold a function pointer.</span></span> <span data-ttu-id="f5bcf-137">Quando o programa chama essa função, ele pode então saltar para um local indesejado especificado pelo invasor.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-137">When the program calls through this function it may then jump to an unintended location specified by the attacker.</span></span>

<span data-ttu-id="f5bcf-138">No entanto, uma combinação potente de compilação e suporte de tempo de execução do CFG implementa a integridade do fluxo de controle que restringe rigorosamente onde as instruções de chamada indireta podem ser executadas.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-138">However, a potent combination of compile and run-time support from CFG implements control flow integrity that tightly restricts where indirect call instructions can execute.</span></span>

<span data-ttu-id="f5bcf-139">O compilador faz o seguinte:</span><span class="sxs-lookup"><span data-stu-id="f5bcf-139">The compiler does the following:</span></span>

1.  <span data-ttu-id="f5bcf-140">Adiciona verificações de segurança leves ao código compilado.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-140">Adds lightweight security checks to the compiled code.</span></span>
2.  <span data-ttu-id="f5bcf-141">Identifica o conjunto de funções no aplicativo que são destinos válidos para chamadas indiretas.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-141">Identifies the set of functions in the application that are valid targets for indirect calls.</span></span>

<span data-ttu-id="f5bcf-142">O suporte ao tempo de execução, fornecido pelo kernel do Windows:</span><span class="sxs-lookup"><span data-stu-id="f5bcf-142">The runtime support, provided by the Windows kernel:</span></span>

1.  <span data-ttu-id="f5bcf-143">Mantém o estado com eficiência que identifica destinos de chamada indiretos válidos.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-143">Efficiently maintains state that identifies valid indirect call targets.</span></span>
2.  <span data-ttu-id="f5bcf-144">Implementa a lógica que verifica se um destino de chamada indireta é válido.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-144">Implements the logic that verifies that an indirect call target is valid.</span></span>

<span data-ttu-id="f5bcf-145">Para ilustrar:</span><span class="sxs-lookup"><span data-stu-id="f5bcf-145">To illustrate:</span></span>

![o pseudocódigo de cfg](images/cfg-pseudocode.jpg)

<span data-ttu-id="f5bcf-147">Quando uma verificação de CFG falha em tempo de execução, o Windows imediatamente encerra o programa, interrompendo qualquer exploração que tente chamar indiretamente um endereço inválido.</span><span class="sxs-lookup"><span data-stu-id="f5bcf-147">When a CFG check fails at runtime, Windows immediately terminates the program, thus breaking any exploit that attempts to indirectly call an invalid address.</span></span>

 

 
