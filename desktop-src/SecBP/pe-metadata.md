---
description: este artigo fornece detalhes adicionais para controlar os metadados do Flow Guard em imagens PE.
title: Metadados do PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c2bce23a94629900f8610cf3cbc1e2ba0db1c4e6a079bd5f610be230df24ec6e
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/11/2021
ms.locfileid: "119994478"
---
# <a name="pe-metadata"></a>Metadados do PE

este artigo fornece detalhes adicionais para os metadados de controle de Flow Guard (CFG) em imagens PE. Pressupõe-se a familiaridade com a estrutura de metadados CFG em imagens PE. Consulte o tópico [formato PE](../debug/pe-format.md) para obter a documentação de alto nível para os metadados de cfg em imagens PE.

- As funções que são destinos de chamada indireta válidos são listadas no **GuardCFFunctionTable** anexado ao diretório de configuração de carga, às vezes, têm como termo a tabela **GFIDS** para fins de brevidade. Esta é uma lista classificada de endereços virtuais relativos (RVA) que contêm informações sobre destinos de chamada CFG válidos. Eles são, em geral, abordam os símbolos de função obtidos. Uma imagem que deseja a imposição de CFG deve enumerar todos os símbolos de função obtidos em sua tabela **GFIDS** . A lista de RVA na tabela **GFIDS** deve ser classificada corretamente ou a imagem não será carregada. A tabela **GFIDS** é uma matriz de 4 + *n* bytes, em que *n* é fornecido pelo ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT). "GuardFlags" é o campo GuardFlags do diretório de configuração de carga. Isso permite que os metadados extras sejam anexados aos destinos de chamada do CFG no futuro. Os únicos metadados atualmente definidos são um campo de sinalizadores extras de 1 byte opcional ("sinalizadores GFIDS") que é anexado a cada entrada **GFIDS** se qualquer destino de chamada tiver metadados. Há dois sinalizadores **GFIDS** definidos:
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | O destino da chamada é suprimido explicitamente (não o trate como válido para fins de CFG) |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2 | O destino da chamada é a exportação suprimida. Consulte [supressão de exportação](#export-suppression) para obter mais detalhes |
  
  Para compatibilidade futura, as ferramentas não devem definir sinalizadores **GFIDS** que ainda não foram definidos e não devem incluir outros bytes de metadados extras do **GFIDS** além do 1 byte definido atualmente, pois os significados para outros sinalizadores ou metadados adicionais ainda não foram atribuídos. você pode encontrar exemplos de imagens que incluem bytes de metadados extras, despejando a tabela **GFIDS** de binários, como Ntdll.dll em uma versão moderna do sistema operacional Windows 10.

  As ferramentas só devem declarar símbolos de função como destinos de chamada válidos, o que pode levar a uma consideração adicional para o código do assembler em que os rótulos podem ser obtidos. Por razões históricas, o código do assembler pode depender de rótulos de código diferentes de PROC ou. ditendant não ser convertido em destinos de chamada CFG pelo vinculador.

  Além disso, por motivos históricos, o código pode declarar deliberadamente o código como dados para evitar a inclusão na tabela **GFIDS** . Por exemplo, um arquivo de objeto pode implementar um símbolo como código, enquanto outro pode declará-lo como dados para obter o endereço do símbolo sem gerar um registro de destino de CFG válido. Para compatibilidade, é recomendável que os conjuntos de ferramentas ofereçam suporte a essa prática.

- Imagens que dão suporte a CFG e que desejam ou executam verificações de CFG devem definir o IMAGE_GUARD_CF_INSTRUMENTED e IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT bits GuardFlags e devem definir o IMAGE_DLLCHARACTERISTICS_GUARD_CF bit DllCharacteristics nos cabeçalhos de imagem.

- O diretório de configuração de carregamento anuncia dois ponteiros de função: GuardCFCheckFunctionPointer e GuardCFDispatchFunctionPointer (o último tem suporte apenas para determinadas arquiteturas, como AMD64). Esses ponteiros de função devem apontar para a memória somente leitura para que a segurança de CFG seja efetiva; o carregador de DLL do sistema operacional protegerá novamente a memória de forma transitória durante o carregamento da imagem para armazenar os ponteiros de função. O uso típico pode ser mesclá-los na mesma seção que contém a tabela de endereços de importação (IAT). O GuardCFCheckFunctionPointer fornece o endereço de um símbolo do sistema operacional fornecido que pode ser chamado com um ponteiro de função no primeiro registro de argumento inteiro (ECX em x86) que será retornado em caso de êxito ou abortará o processo se o destino da chamada não for um destino de CFG válido. O GuardCFDispatchFunctionPointer fornece o endereço de um símbolo do carregador do sistema operacional que usa um destino de chamada no registro RAX e executa uma verificação de CFG combinada e uma chamada otimizada da ramificação tail para o destino da chamada (os registradores R10/R11 são reservados para uso pelo GuardCFDispatchFunctionPointer e os registros de argumento de inteiro são reservados para uso pelo destino de chamada final). O endereço padrão dos símbolos CFG em uma imagem deve apontar para uma função que simplesmente retorna (GuardCFCheckFunctionPointer) ou que retorna um símbolo de proteção suprimida (ou é, de preferência, totalmente omitido do símbolo de tabela **GFIDS** ) que executa uma instrução "JMP Rax". Para AMD64 GuardCFDispatchFunctionPointer, quando uma imagem é carregada em um sistema operacional com reconhecimento de CFG e o CFG é habilitado, o carregador de DLL do sistema operacional instalará ponteiros de função apropriados, que oferece compatibilidade com versões anteriores. Uma imagem pode fornecer 0 para o GuardCFDispatchFunctionPointer na configuração de carga se não pretender usar a instalação de expedição de CFG. Isso deve ser feito para arquiteturas não AMD64 para compatibilidade futura, caso essas arquiteturas eventualmente ofereçam suporte ao mecanismo de expedição de CFG de alguma forma. observe que Windows 8.1 AMD64 não oferecia suporte à expedição de CFG e deixaria o ponteiro de função padrão em vigor para GuardCFDispatchFunctionPointer. a expedição de CFG tem suporte apenas em sistemas operacionais Windows 10 e posteriores.

- O modo de usuário CFG só pode ser imposto para imagens marcadas como compatíveis com ASLR (Address Space layout Randomization) (especificado pela opção/DYNAMICBASE com o Microsoft Linker). Isso ocorre devido a como o sistema operacional manipula o CFG internamente, onde ele é essencialmente conectado à infraestrutura ASLR. Em geral, os usuários do CFG devem habilitar a ASLR para suas imagens como uma primeira etapa. As ferramentas não devem pressupor que o sistema operacional sempre ignorará CFG sem o ASLR definido, mas deve geralmente definir ambos ao mesmo tempo.

## <a name="compiler-directives"></a>Diretivas do compilador

- Os destinos de chamada podem ser marcados como suprimidos explicitamente com o modificador de __declspec (proteção (supressão)) ou com a diretiva de vinculador/guardsym: symname, S (para o código ASM, por exemplo). Isso faz com que o destino da chamada seja incluído na tabela **GFIDS** , mas marcado de forma que o sistema operacional trate o destino da chamada como inválida. Alguns cenários de não produção, como com determinada instrumentação do Application Verifier habilitada em alguns sistemas operacionais mais antigos, podem habilitar destinos de chamada suprimidos para serem tratados como válidos, mas em geral esses cenários não devem ser cenários de produção. Essa diretiva é útil para anotar funções "perigosas" que não devem ser consideradas como destinos de chamada válidos, embora a regra de CFG normal as inclua.

- O código pode indicar que as verificações de CFG não são desejadas com o modificador de __declspec (Guard (nocf)). Isso instrui o compilador a não inserir nenhuma verificação de CFG para a função inteira. O compilador deve tomar cuidado para propagar essa diretiva para qualquer código contribuído por uma função embutida que está marcada como não desejo de cheques de CFG. Essa abordagem é normalmente usada apenas com moderação em situações específicas em que o programador inseriu manualmente a proteção "CFG-equivalente". O programador sabe que eles estão chamando por meio de uma tabela de função somente leitura cujo endereço é obtido por meio de referências de memória somente leitura e para a qual o índice é mascarado para o limite da tabela de funções. Essa abordagem também pode ser aplicada a pequenas funções de invólucro que não são embutidas e que não fazem nada mais do que fazer uma chamada por meio de um ponteiro de função. Como o uso incorreto dessa diretiva pode comprometer a segurança de CFG, o programador deve ser muito cuidadoso ao usar a diretiva. Normalmente, esse uso é limitado a funções muito pequenas que chamam apenas uma função.

## <a name="import-handling"></a>Tratamento de importação

- Chamadas por meio de IAT não devem usar a proteção CFG. O IAT é somente leitura em imagens modernas (supondo que a IAT seja declarada nos cabeçalhos PE, nesse caso, ela deve estar em suas próprias páginas). O IAT pode ser usado para alcançar funções que são suprimidas por proteção, portanto, esse é um requisito de correção. A proteção de memória somente leitura por meio do IAT substitui a de CFG, uma vez que a associação de destino de chamada é imutável depois que os snaps de importação de imagem são resolvidos e a resolução de associação é refinada.

- Carga de atraso protegida: chamadas por meio do IAT de carga de atraso não devem usar a proteção CFG, pelos mesmos motivos que o IAT padrão. O IAT de carga de atraso deve estar em sua própria seção e a imagem deve definir o IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit. isso indica que o carregador de DLL do sistema operacional deve alterar as proteções para o IAT de carga de atraso durante a resolução de exportação se estiver usando o suporte de carregamento de atraso do sistema operacional nativo para Windows 8 e sistemas operacionais posteriores. A sincronização desta etapa será gerenciada pelo carregador de DLL do sistema operacional se o suporte à carga de atraso do sistema operacional nativo estiver em uso (por exemplo, ResolveDelayLoadedAPI), portanto, nenhum outro componente deve proteger novamente as páginas que abrangem a carga de atraso declarada IAT. Para compatibilidade com versões anteriores, com sistemas operacionais anteriores ao CFG, as ferramentas podem habilitar a opção de mover o IAT de carregamento de atraso para sua própria seção (canônicamente ". didat"), protegido como leitura/gravação nos cabeçalhos da imagem e, além disso, definir o sinalizador de IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION. Essa configuração fará com que os carregadores da DLL do sistema operacional com reconhecimento de CFG protejam novamente a seção inteira que contém a tabela IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT para ler apenas a memória durante o carregamento da imagem. A opção de colocar o IAT de carga de atraso em sua própria seção pode não ser necessária se você não se importa com a execução de uma imagem em sistemas operacionais que precedam o suporte a CFG, mas as ferramentas devem tomar essa decisão com base no suporte mínimo de sistema operacional que uma imagem precisa.

  Se uma imagem não usar o suporte de carregamento de atraso nativo do sistema operacional, ela ainda poderá definir os bits de GuardFlags relacionados à carga de atraso protegido. Nessa configuração, o carregador do sistema operacional apenas fornecerá suporte para proteger a carga de atraso IAT como somente leitura no tempo de execução, se houver suporte da plataforma, e se tornará a responsabilidade dos stubs de resolução de carga de atraso interno da imagem para sincronizar e gerenciar a proteção do IAT de carga de atraso. Desde que a tabela de configuração de carregamento esteja armazenada em memória somente leitura (o que é recomendado), a presença ou a ausência do bit de IAT de carga de atraso protegido no campo GuardFlags da imagem pode ser útil como uma dica interna para os stubs de resolução de carregamento de atraso interno da imagem para indicar se ele deve ou não proteger a carga de atraso IAT.

  É recomendável que a carga de atraso protegida seja habilitada por padrão se o CFG estiver habilitado. Imagens que são executadas em versões mais antigas do sistema operacional e que usam o suporte nativo para carregamento de atraso do sistema operacional, como observado, podem usar o IAT de carregamento de atraso em sua própria seção de suporte para compatibilidade com versões anteriores. Isso é para marcar o IAT de carregamento de atraso como somente leitura e mesclá-lo com outra seção, que pode ser interrompida em sistemas operacionais mais antigos que não entendem cargas de atraso protegidas e que fornecem suporte à resolução de carregamento de atraso nativo. todas as versões de Windows 10 e as primeiras compilações do Windows 8.1/Windows Server 2012 R2 com suporte para CFG (ou seja, a atualização de novembro de 2014) introduzem o suporte à carga de atraso protegida no sistema operacional.

## <a name="function-alignment"></a>Alinhamento de função

- As funções que são obtidas pelo endereço e, portanto, são incluídas na tabela **GFIDS** devem se tornar alinhadas em 16 bytes, se possível. Isso nem sempre pode ser possível. Por exemplo, para funções não COMDAT que fazem parte de arquivos de objeto montados como uma unidade por ferramentas que não reconhecem o CFG, que alguns montadores podem produzir, o usuário da ferramenta que produziu os arquivos deve definir adequadamente o alinhamento. As ferramentas podem optar por emitir um aviso de diagnóstico nessa situação para que o usuário possa executar a ação corretiva apropriada. O motivo disso é que CFG marca destinos como válidos ou não válidos em limites de 16 bytes para eficiência das verificações de CFG rápidas. Se uma função não estiver alinhada em 16 bytes, o slot inteiro de 16 bytes deverá ser marcado como válido, o que não é tão seguro, pois você pode chamar inalinhado ao código que não está no início de uma função. Esse cenário tem suporte para a facilidade de interoperabilidade ao trazer o CFG para um projeto pela primeira vez. Imagens com reconhecimento de não-CFG são marcadas da mesma forma como válidas para qualquer alinhamento de destino de chamada para compatibilidade. Como antes, ter destinos de chamada desalinhados reduz os benefícios de segurança de CFG, portanto, as ferramentas devem alinhar-se automaticamente a um limite de 16 bytes para qualquer coisa na tabela **GFIDS** quando cfg for desejado para uma imagem. Os símbolos que não estão na tabela **GFIDS** não precisam ter alinhamentos específicos para cfg.

## <a name="export-suppression"></a>Supressão de exportação

- A supressão de exportação do CFG (CFG) é um modo opcional que permite que um processo indique que os destinos de chamada que só eram válidos porque eram dllexport símbolos e que ainda não foram resolvidos dinamicamente por GetProcAddress, serão considerados como inválidos para fins de CFG. Isso reduz a área de superfície de CFG de exportações de DLL do sistema. A supressão de exportação envolve a comunicação de destinos de chamada dllexport qualificados "exportar suprimidos" marcando-os com os sinalizadores de **GFIDS** de IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED. Os símbolos dllexport e o ponto de entrada de imagem PE devem ser considerados um endereço assumido implicitamente pelas ferramentas para fins de geração da tabela **GFIDS** .  Se um símbolo de exportação estiver alinhado em 16 bytes e o endereço for tomado por nenhum outro motivo de ser um dllexport, ele poderá ser marcado com o sinalizador exportar **GFIDS** suprimido na tabela de funções. Os destinos de chamada que não são alinhados em 16 bytes **não devem** ser marcados com o sinalizador IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** e não podem ser restritos para serem habilitados dinamicamente como destinos de chamada válidos em tempo de GetProcAddress.

  Uma imagem que dá suporte a CFG ES inclui um GuardAddressTakenIatEntryTable cuja contagem é fornecida pelo GuardAddressTakenIatEntryCount como parte de seu diretório de configuração de carga. Essa tabela é formatada estruturalmente da mesma forma que a tabela **GFIDS** . Ele usa o mesmo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK de GuardFlags para codificar bytes de metadados opcionais adicionais na tabela Address taked IAT, embora todos os bytes de metadados devam ser zero para o endereço obtido IAT tabela e são reservados. A tabela Address takeed IAT indica uma matriz classificada de RVAs de conversões de importação que têm a importação como um endereço de símbolo obtido como destino de chamada. Essa construção dá suporte a símbolos de endereço tirados que existem em um módulo remoto e que são dllexports, com CFG ES em uso. Um exemplo de tal construção de código seria:

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  Todas essas conversões de importação obtidas por endereço devem ser enumeradas para que o carregador do sistema operacional possa encontrá-las e fazer com que os destinos de chamada apropriados sejam válidos ao carregar uma imagem e ajustar suas importações. A tabela e a contagem podem ser 0 se não houver conversões de importação que foram obtidas por endereço.

  Um módulo define o IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT bit GuardFlags para indicar que ele enumerou todas as conversões de endereço obtidas em seu endereço IAT tabela obtida e que todas as exportações que estão qualificadas são marcadas com o sinalizador **GFIDS** de IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED. Observe que pode haver zero conversão dessas conversões e que também pode haver zero símbolos dllexport. A falha na manutenção do endereço obtido pela tabela IAT pode ser um problema de correção, pois alguns destinos de chamada podem não ser válidos quando devem estar no tempo de carregamento da DLL.

  Um módulo define o IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION bit GuardFlags para indicar que deseja habilitar CFG ES para o processo. Na prática, isso só é significativo para os EXEs atuais. Um processo que habilita o CFG ES não deve carregar DLLs não criadas com CFG ES ou falhas de tempo de execução podem ocorrer devido a endereços não designados IAT símbolos de uso. O suporte para habilitar CFG ES deve ser uma opção de aceitação separada da habilitação de CFG. Fornecer metadados de CFG ES é seguro e recomendado por padrão com CFG, embora os conjuntos de ferramentas devam ter cuidado para garantir que eles produzam metadados corretos. Caso contrário, suas imagens geradas podem não ser executadas corretamente em um processo CFG ES. Esse suporte deve ser totalmente testado em um processo de teste que impõe CFG ES. as DLLs do sistema interno do sistema operacional dão suporte aos metadados de CFG ES para versões modernas Windows 10 sistema operacional que entendem CFG ES. As versões do sistema operacional anteriores a esse suporte não entendem o CFG ES e ignorarão quaisquer diretivas relacionadas a CFG ES na imagem. Essas imagens ainda são compatíveis com versões anteriores do sistema operacional.

  O suporte ao CFG ES é opcional de uma perspectiva do conjunto de ferramentas, mas é recomendável que os conjuntos de ferramentas, pelo menos, incluam suporte para enumerar informações suficientes para que as imagens sejam executadas em um processo que queira CFG ES. Conforme mencionado, é essencial que o suporte do conjunto de ferramentas seja totalmente testado para garantir que ele seja compatível com CFG ES, pois a maioria dos processos ainda não habilitam o CFG ES.

## <a name="exception-handling-and-unwinding"></a>Manipulação e desenrolamento de exceção

- Manipuladores de idioma específicos como __C_specific_handler, conforme designado pelas informações do manipulador de exceção em um registro. pData, não devem ser marcados como destinos de chamada válidos na tabela **GFIDS** . Em vez disso, eles são pesquisados atravessando a memória somente leitura. Da mesma forma, o manipulador específico da linguagem Microsoft C usa pesquisas de memória somente leitura para localizar funclets para manipuladores de exceção e, portanto, não declara seu funclets como destinos de chamada válidos na tabela **GFIDS** .

- Tratamento de salto longo (para destinos não x86 como AMD64): os conjuntos de ferramentas que compilam com CFG e dão suporte a setjmp ()/longjmp () devem implementar um longo salto como "salto longo seguro" que interopera com o SEH (tratamento de exceção estruturada). Isso significa que o salto longo é implementado como uma chamada para RtlUnwindEx com STATUS_LONGJUMP como o código de status no registro de exceção fornecido e um _JUMP_BUFFER padrão apontado por ExceptionInformation [0]. O destino de desenrolamento de salto deve ser o TargetIp do desenrolamento. O buffer de salto representa o contexto de registro que é restaurado pelo sistema operacional após a conclusão do salto longo. RtlUnwind (ex) quando chamado com STATUS_LONGJUMP tem um significado especial exclusivo para CFG. O destino de salto longo (_JUMP_BUFFER. Rip ou _JUMP_BUFFER. LR em ARM64) é pesquisada na lista de módulos carregados mantida pelo sistema operacional em memória somente leitura. Se o módulo que o contém para o destino de salto (o "módulo de destino") tiver o sinalizador IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT definido em seu campo GuardFlags, o diretório de configuração de carga terá um GuardLongJumpTargetTable whith uma contagem de elementos especificada pelo campo carregar configuração GuardLongJumpTargetCount. Essa tabela é formatada estruturalmente da mesma forma que a tabela **GFIDS** e usa o mesmo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags para codificar bytes de metadados extras opcionais na tabela de salto longo. Todos os bytes de metadados devem ser zero para a tabela de salto longa e são reservados.

  A tabela de salto longo representa uma matriz classificada de RVAs que são destinos de salto longos válidos. Se um módulo de destino de salto longo definir IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT em seu campo GuardFlags, todos os destinos de salto longos deverão ser enumerados no LongJumpTargetTable. Mesmo que um módulo tenha zero destinos de salto longos, ele ainda deverá definir o sinalizador IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT se o conjunto de ferramentas der suporte à proteção de salto longo para o CFG. Isso significa explicitamente que a imagem não tem destinos de salto longos e não é uma imagem antiga que o sistema operacional deve assumir pode ter destinos de salto longos válidos em locais desmarcados para os quais ele não pode executar a verificação de destino de salto longo.

  A proteção de salto longo é recomendável para ser habilitada por padrão se o CFG tiver suporte. Esta é a disposição dos compiladores da Microsoft. os sistemas operacionais que não entendem a proteção de salto longo (Windows 10 ou versões mais antigas do Windows 10) não executarão verificações longas de proteção de salto e ignorarão todos os metadados de proteção de longo prazo, de modo que a proteção de salto longo é compatível com versões anteriores do sistema operacional.

  Para imagens de modo kernel, a tabela de destino de salto longo de proteção não deve ser incluída em uma seção que pode ser descartada. A tabela de destino de salto longo de proteção sempre deve ser armazenada em memória somente leitura para que suas propriedades de segurança sejam efetivas.

## <a name="coff-information"></a>Informações COFF

- Há marcações de arquivo de objeto para declarar se um arquivo de objeto está de acordo com CFG ou não. Um arquivo de objeto que está de acordo com o CFG listará os destinos de chamada válidos que ele produz, explicitamente, bem como qualquer endereço obtido de metadados IAT. Um arquivo de objeto que não está em conformidade com o CFG deve ter destinos de chamada inferidos examinando as realocações COFF do arquivo obj para encontrar realocações que apontam para o início de um símbolo de função. Isso pode sobreaproximar destinos de chamada CFG válidos, portanto, é desejável que as ferramentas Marquem seus arquivos obj que reconhecem o CFG e incluam os metadados do arquivo CFG obj se estiverem compilando com CFG.

- Há marcações de arquivo de objeto para declarar destinos longos de salto para o salto longo protegido por CFG, que deve ser preenchido para o modo de compilação de CFG.
