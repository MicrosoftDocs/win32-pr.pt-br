---
description: Este artigo fornece detalhes adicionais para metadados de proteção de fluxo de controle em imagens PE.
title: Metadados do PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "105749215"
---
# <a name="pe-metadata"></a><span data-ttu-id="a2a49-103">Metadados do PE</span><span class="sxs-lookup"><span data-stu-id="a2a49-103">PE metadata</span></span>

<span data-ttu-id="a2a49-104">Este artigo fornece detalhes adicionais para os metadados da proteção de fluxo de controle (CFG) em imagens PE.</span><span class="sxs-lookup"><span data-stu-id="a2a49-104">This article provides additional details for Control Flow Guard (CFG) metadata in PE images.</span></span> <span data-ttu-id="a2a49-105">Pressupõe-se a familiaridade com a estrutura de metadados CFG em imagens PE.</span><span class="sxs-lookup"><span data-stu-id="a2a49-105">Familiarity with the structure for CFG metadata in PE images is assumed.</span></span> <span data-ttu-id="a2a49-106">Consulte o tópico [formato PE](../debug/pe-format.md) para obter a documentação de alto nível para os metadados de cfg em imagens PE.</span><span class="sxs-lookup"><span data-stu-id="a2a49-106">See the [PE Format](../debug/pe-format.md) topic for high-level documentation for CFG metadata in PE images.</span></span>

- <span data-ttu-id="a2a49-107">As funções que são destinos de chamada indireta válidos são listadas no **GuardCFFunctionTable** anexado ao diretório de configuração de carga, às vezes, têm como termo a tabela **GFIDS** para fins de brevidade.</span><span class="sxs-lookup"><span data-stu-id="a2a49-107">Functions that are valid indirect call targets are listed in the **GuardCFFunctionTable** attached to the load configuration directory, sometimes termed the **GFIDS** table for brevity.</span></span> <span data-ttu-id="a2a49-108">Esta é uma lista classificada de endereços virtuais relativos (RVA) que contêm informações sobre destinos de chamada CFG válidos.</span><span class="sxs-lookup"><span data-stu-id="a2a49-108">This is a sorted list of relative virtual addresses (RVA) that contain information about valid CFG call targets.</span></span> <span data-ttu-id="a2a49-109">Eles são, em geral, abordam os símbolos de função obtidos.</span><span class="sxs-lookup"><span data-stu-id="a2a49-109">These are, generally speaking, address taken function symbols.</span></span> <span data-ttu-id="a2a49-110">Uma imagem que deseja a imposição de CFG deve enumerar todos os símbolos de função obtidos em sua tabela **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="a2a49-110">An image that wants CFG enforcement must enumerate all address taken function symbols in its **GFIDS** table.</span></span> <span data-ttu-id="a2a49-111">A lista de RVA na tabela **GFIDS** deve ser classificada corretamente ou a imagem não será carregada.</span><span class="sxs-lookup"><span data-stu-id="a2a49-111">The RVA list in the **GFIDS** table must be sorted properly or the image will not be loaded.</span></span> <span data-ttu-id="a2a49-112">A tabela **GFIDS** é uma matriz de 4 + *n* bytes, em que *n* é fornecido pelo ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span><span class="sxs-lookup"><span data-stu-id="a2a49-112">The **GFIDS** table is an array of 4 + *n* bytes, where *n* is given by ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span></span> <span data-ttu-id="a2a49-113">"GuardFlags" é o campo GuardFlags do diretório de configuração de carga.</span><span class="sxs-lookup"><span data-stu-id="a2a49-113">“GuardFlags” is the GuardFlags field of the load configuration directory.</span></span> <span data-ttu-id="a2a49-114">Isso permite que os metadados extras sejam anexados aos destinos de chamada do CFG no futuro.</span><span class="sxs-lookup"><span data-stu-id="a2a49-114">This allows for extra metadata to be attached to CFG call targets in the future.</span></span> <span data-ttu-id="a2a49-115">Os únicos metadados atualmente definidos são um campo de sinalizadores extras de 1 byte opcional ("sinalizadores GFIDS") que é anexado a cada entrada **GFIDS** se qualquer destino de chamada tiver metadados.</span><span class="sxs-lookup"><span data-stu-id="a2a49-115">The only currently defined metadata is an optional 1-byte extra flags field (“GFIDS flags”) that is attached to each **GFIDS** entry if any call targets have metadata.</span></span> <span data-ttu-id="a2a49-116">Há dois sinalizadores **GFIDS** definidos:</span><span class="sxs-lookup"><span data-stu-id="a2a49-116">There are two **GFIDS** flags defined:</span></span>
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | <span data-ttu-id="a2a49-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span><span class="sxs-lookup"><span data-stu-id="a2a49-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span></span> | <span data-ttu-id="a2a49-118">O destino da chamada é suprimido explicitamente (não o trate como válido para fins de CFG)</span><span class="sxs-lookup"><span data-stu-id="a2a49-118">Call target is explicitly suppressed (do not treat it as valid for purposes of CFG)</span></span> |
  | <span data-ttu-id="a2a49-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span><span class="sxs-lookup"><span data-stu-id="a2a49-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span></span> | <span data-ttu-id="a2a49-120">O destino da chamada é a exportação suprimida.</span><span class="sxs-lookup"><span data-stu-id="a2a49-120">Call target is export suppressed.</span></span> <span data-ttu-id="a2a49-121">Consulte [supressão de exportação](#export-suppression) para obter mais detalhes</span><span class="sxs-lookup"><span data-stu-id="a2a49-121">See [Export suppression](#export-suppression) for more details</span></span> |
  
  <span data-ttu-id="a2a49-122">Para compatibilidade futura, as ferramentas não devem definir sinalizadores **GFIDS** que ainda não foram definidos e não devem incluir outros bytes de metadados extras do **GFIDS** além do 1 byte definido atualmente, pois os significados para outros sinalizadores ou metadados adicionais ainda não foram atribuídos.</span><span class="sxs-lookup"><span data-stu-id="a2a49-122">For future compatibility, tools should not set **GFIDS** flags that have not yet been defined and should not include additional **GFIDS** extra metadata bytes beyond the 1-byte currently defined since the meanings for other flags or additional metadata are not yet assigned.</span></span> <span data-ttu-id="a2a49-123">Você pode encontrar exemplos de imagens que incluem bytes de metadados extras, despejando a tabela **GFIDS** de binários, como Ntdll.dll em uma versão moderna do sistema operacional Windows 10.</span><span class="sxs-lookup"><span data-stu-id="a2a49-123">You can find examples of images that include extra metadata bytes by dumping the **GFIDS** table of binaries such as Ntdll.dll on a modern Windows 10 OS version.</span></span>

  <span data-ttu-id="a2a49-124">As ferramentas só devem declarar símbolos de função como destinos de chamada válidos, o que pode levar a uma consideração adicional para o código do assembler em que os rótulos podem ser obtidos.</span><span class="sxs-lookup"><span data-stu-id="a2a49-124">Tools should only declare function symbols as valid call targets which may merit additional consideration for assembler code where labels might be address taken.</span></span> <span data-ttu-id="a2a49-125">Por razões históricas, o código do assembler pode depender de rótulos de código diferentes de PROC ou. ditendant não ser convertido em destinos de chamada CFG pelo vinculador.</span><span class="sxs-lookup"><span data-stu-id="a2a49-125">For historical reasons, assembler code may rely on code labels other than PROC or .altentry as not being converted into CFG call targets by the linker.</span></span>

  <span data-ttu-id="a2a49-126">Além disso, por motivos históricos, o código pode declarar deliberadamente o código como dados para evitar a inclusão na tabela **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="a2a49-126">Also for historical reasons, code may deliberately declare code as data to avoid inclusion in the **GFIDS** table.</span></span> <span data-ttu-id="a2a49-127">Por exemplo, um arquivo de objeto pode implementar um símbolo como código, enquanto outro pode declará-lo como dados para obter o endereço do símbolo sem gerar um registro de destino de CFG válido.</span><span class="sxs-lookup"><span data-stu-id="a2a49-127">For example, one object file may implement a symbol as code while another may declare it as data in order to take the address of the symbol without generating a valid CFG target record.</span></span> <span data-ttu-id="a2a49-128">Para compatibilidade, é recomendável que os conjuntos de ferramentas ofereçam suporte a essa prática.</span><span class="sxs-lookup"><span data-stu-id="a2a49-128">For compatibility, it is recommended that toolsets support this practice.</span></span>

- <span data-ttu-id="a2a49-129">Imagens que dão suporte a CFG e que desejam ou executam verificações de CFG devem definir o IMAGE_GUARD_CF_INSTRUMENTED e IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT bits GuardFlags e devem definir o IMAGE_DLLCHARACTERISTICS_GUARD_CF bit DllCharacteristics nos cabeçalhos de imagem.</span><span class="sxs-lookup"><span data-stu-id="a2a49-129">Images that support CFG and that want or perform CFG checks should set the IMAGE_GUARD_CF_INSTRUMENTED and IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags bits, and should set the IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics bit in the image headers.</span></span>

- <span data-ttu-id="a2a49-130">O diretório de configuração de carregamento anuncia dois ponteiros de função: GuardCFCheckFunctionPointer e GuardCFDispatchFunctionPointer (o último tem suporte apenas para determinadas arquiteturas, como AMD64).</span><span class="sxs-lookup"><span data-stu-id="a2a49-130">The load configuration directory advertises two function pointers: GuardCFCheckFunctionPointer and GuardCFDispatchFunctionPointer (the latter is only supported for certain architectures such as AMD64).</span></span> <span data-ttu-id="a2a49-131">Esses ponteiros de função devem apontar para a memória somente leitura para que a segurança de CFG seja efetiva; o carregador de DLL do sistema operacional protegerá novamente a memória de forma transitória durante o carregamento da imagem para armazenar os ponteiros de função.</span><span class="sxs-lookup"><span data-stu-id="a2a49-131">These function pointers should point to read only memory for CFG security to be effective; the operating system’s DLL loader will reprotect the memory transiently during image loading to store the function pointers.</span></span> <span data-ttu-id="a2a49-132">O uso típico pode ser mesclá-los na mesma seção que contém a tabela de endereços de importação (IAT).</span><span class="sxs-lookup"><span data-stu-id="a2a49-132">Typical usage might be to merge these into the same section that contains the Import Address Table (IAT).</span></span> <span data-ttu-id="a2a49-133">O GuardCFCheckFunctionPointer fornece o endereço de um símbolo do sistema operacional fornecido que pode ser chamado com um ponteiro de função no primeiro registro de argumento inteiro (ECX em x86) que será retornado em caso de êxito ou abortará o processo se o destino da chamada não for um destino de CFG válido.</span><span class="sxs-lookup"><span data-stu-id="a2a49-133">The GuardCFCheckFunctionPointer provides the address of an OS-loader provided symbol that can be called with a function pointer in the first integer argument register (ECX on x86) which will return on success or will abort the process if the call target is not a valid CFG target.</span></span> <span data-ttu-id="a2a49-134">O GuardCFDispatchFunctionPointer fornece o endereço de um símbolo do carregador do sistema operacional que usa um destino de chamada no registro RAX e executa uma verificação de CFG combinada e uma chamada otimizada da ramificação tail para o destino da chamada (os registradores R10/R11 são reservados para uso pelo GuardCFDispatchFunctionPointer e os registros de argumento de inteiro são reservados para uso pelo destino de chamada final).</span><span class="sxs-lookup"><span data-stu-id="a2a49-134">The GuardCFDispatchFunctionPointer provides the address of an OS-loader provided symbol that takes a call target in register RAX and performs a combined CFG check and tail branch optimized call to the call target (registers R10/R11 are reserved for use by the GuardCFDispatchFunctionPointer and integer argument registers are reserved for use by the ultimate call target).</span></span> <span data-ttu-id="a2a49-135">O endereço padrão dos símbolos CFG em uma imagem deve apontar para uma função que simplesmente retorna (GuardCFCheckFunctionPointer) ou que retorna um símbolo de proteção suprimida (ou é, de preferência, totalmente omitido do símbolo de tabela **GFIDS** ) que executa uma instrução "JMP Rax".</span><span class="sxs-lookup"><span data-stu-id="a2a49-135">The default address of the CFG symbols in an image should point to a function that just returns (GuardCFCheckFunctionPointer) or that returns a guard-suppressed symbol (or is preferably entirely omitted from the **GFIDS** table symbol) that executes a “jmp rax” instruction.</span></span> <span data-ttu-id="a2a49-136">Para AMD64 GuardCFDispatchFunctionPointer, quando uma imagem é carregada em um sistema operacional com reconhecimento de CFG e o CFG é habilitado, o carregador de DLL do sistema operacional instalará ponteiros de função apropriados, que oferece compatibilidade com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="a2a49-136">For AMD64 GuardCFDispatchFunctionPointer, when an image is loaded on a CFG-aware operating system, and CFG is enabled, the OS DLL loader will install appropriate function pointers, which facilities backwards compatibility.</span></span> <span data-ttu-id="a2a49-137">Uma imagem pode fornecer 0 para o GuardCFDispatchFunctionPointer na configuração de carga se não pretender usar a instalação de expedição de CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-137">An image can supply 0 for the GuardCFDispatchFunctionPointer in the load config if it does not intend to use the CFG dispatch facility.</span></span> <span data-ttu-id="a2a49-138">Isso deve ser feito para arquiteturas não AMD64 para compatibilidade futura, caso essas arquiteturas eventualmente ofereçam suporte ao mecanismo de expedição de CFG de alguma forma.</span><span class="sxs-lookup"><span data-stu-id="a2a49-138">This should be done for non-AMD64 architectures for future compatibility, in case these architectures eventually support the CFG dispatch mechanism in some form.</span></span> <span data-ttu-id="a2a49-139">Observe que Windows 8.1 AMD64 não oferecia suporte à expedição de CFG e deixaria o ponteiro de função padrão em vigor para GuardCFDispatchFunctionPointer.</span><span class="sxs-lookup"><span data-stu-id="a2a49-139">Note that Windows 8.1 AMD64 did not support CFG dispatch and would leave the default function pointer in place for GuardCFDispatchFunctionPointer.</span></span> <span data-ttu-id="a2a49-140">A expedição de CFG só tem suporte em sistemas operacionais Windows 10 e posteriores.</span><span class="sxs-lookup"><span data-stu-id="a2a49-140">CFG dispatch is only supported on Windows 10 and later operating systems.</span></span>

- <span data-ttu-id="a2a49-141">O modo de usuário CFG só pode ser imposto para imagens marcadas como compatíveis com ASLR (Address Space layout Randomization) (especificado pela opção/DYNAMICBASE com o Microsoft Linker).</span><span class="sxs-lookup"><span data-stu-id="a2a49-141">User mode CFG might only be enforced for images that are marked as address space layout randomization (ASLR) compatible (specified by the /DYNAMICBASE option with the Microsoft linker).</span></span> <span data-ttu-id="a2a49-142">Isso ocorre devido a como o sistema operacional manipula o CFG internamente, onde ele é essencialmente conectado à infraestrutura ASLR.</span><span class="sxs-lookup"><span data-stu-id="a2a49-142">This is due to how the OS internally handles CFG where it is essentially wired in to the ASLR infrastructure.</span></span> <span data-ttu-id="a2a49-143">Em geral, os usuários do CFG devem habilitar a ASLR para suas imagens como uma primeira etapa.</span><span class="sxs-lookup"><span data-stu-id="a2a49-143">In general, users of CFG should enable ASLR for their images as a first step.</span></span> <span data-ttu-id="a2a49-144">As ferramentas não devem pressupor que o sistema operacional sempre ignorará CFG sem o ASLR definido, mas deve geralmente definir ambos ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="a2a49-144">Tools should not assume that the OS will always ignore CFG without ASLR set but should generally set both at the same time.</span></span>

## <a name="compiler-directives"></a><span data-ttu-id="a2a49-145">Diretivas do compilador</span><span class="sxs-lookup"><span data-stu-id="a2a49-145">Compiler directives</span></span>

- <span data-ttu-id="a2a49-146">Os destinos de chamada podem ser marcados como suprimidos explicitamente com o modificador de __declspec (proteção (supressão)) ou com a diretiva de vinculador/guardsym: symname, S (para o código ASM, por exemplo).</span><span class="sxs-lookup"><span data-stu-id="a2a49-146">Call targets can be marked as explicitly suppressed with the __declspec(guard(suppress)) modifier, or with the /guardsym:symname,S linker directive (for asm code for example).</span></span> <span data-ttu-id="a2a49-147">Isso faz com que o destino da chamada seja incluído na tabela **GFIDS** , mas marcado de forma que o sistema operacional trate o destino da chamada como inválida.</span><span class="sxs-lookup"><span data-stu-id="a2a49-147">This causes the call target to be included in the **GFIDS** table but marked in such a way that the OS will treat the call target as not valid.</span></span> <span data-ttu-id="a2a49-148">Alguns cenários de não produção, como com determinada instrumentação do Application Verifier habilitada em alguns sistemas operacionais mais antigos, podem habilitar destinos de chamada suprimidos para serem tratados como válidos, mas em geral esses cenários não devem ser cenários de produção.</span><span class="sxs-lookup"><span data-stu-id="a2a49-148">Some non-production scenarios, such as with certain application verifier instrumentation enabled on some older operating systems, may enable suppressed call targets to be treated as valid, but in general these scenarios are not expected to be production scenarios.</span></span> <span data-ttu-id="a2a49-149">Essa diretiva é útil para anotar funções "perigosas" que não devem ser consideradas como destinos de chamada válidos, embora a regra de CFG normal as inclua.</span><span class="sxs-lookup"><span data-stu-id="a2a49-149">This directive is useful for annotating “dangerous” functions that should not be considered as valid call targets, even though the normal CFG rule would include them.</span></span>

- <span data-ttu-id="a2a49-150">O código pode indicar que as verificações de CFG não são desejadas com o modificador de __declspec (Guard (nocf)).</span><span class="sxs-lookup"><span data-stu-id="a2a49-150">Code can indicate CFG checks are not wanted with the __declspec(guard(nocf)) modifier.</span></span> <span data-ttu-id="a2a49-151">Isso instrui o compilador a não inserir nenhuma verificação de CFG para a função inteira.</span><span class="sxs-lookup"><span data-stu-id="a2a49-151">This directs the compiler to not insert any CFG checks for the entire function.</span></span> <span data-ttu-id="a2a49-152">O compilador deve tomar cuidado para propagar essa diretiva para qualquer código contribuído por uma função embutida que está marcada como não desejo de cheques de CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-152">The compiler should take care to propagate this directive to any code contributed by an inlined function that is marked as not wanting CFG checks.</span></span> <span data-ttu-id="a2a49-153">Essa abordagem é normalmente usada apenas com moderação em situações específicas em que o programador inseriu manualmente a proteção "CFG-equivalente".</span><span class="sxs-lookup"><span data-stu-id="a2a49-153">This approach is typically used only sparingly in specific situations where the programmer has manually inserted “CFG-equivalent” protection.</span></span> <span data-ttu-id="a2a49-154">O programador sabe que eles estão chamando por meio de uma tabela de função somente leitura cujo endereço é obtido por meio de referências de memória somente leitura e para a qual o índice é mascarado para o limite da tabela de funções.</span><span class="sxs-lookup"><span data-stu-id="a2a49-154">The programmer knows that they are calling through some read only function table whose address is obtained through read only memory references and for which the index is masked to the function table limit.</span></span> <span data-ttu-id="a2a49-155">Essa abordagem também pode ser aplicada a pequenas funções de invólucro que não são embutidas e que não fazem nada mais do que fazer uma chamada por meio de um ponteiro de função.</span><span class="sxs-lookup"><span data-stu-id="a2a49-155">This approach may also be applied to small wrapper functions that are not inlined and that do nothing more than make a call through a function pointer.</span></span> <span data-ttu-id="a2a49-156">Como o uso incorreto dessa diretiva pode comprometer a segurança de CFG, o programador deve ser muito cuidadoso ao usar a diretiva.</span><span class="sxs-lookup"><span data-stu-id="a2a49-156">Since incorrect usage of this directive can compromise the security of CFG, the programmer must be very careful using the directive.</span></span> <span data-ttu-id="a2a49-157">Normalmente, esse uso é limitado a funções muito pequenas que chamam apenas uma função.</span><span class="sxs-lookup"><span data-stu-id="a2a49-157">Typically, this usage is limited to very small functions that only call one function.</span></span>

## <a name="import-handling"></a><span data-ttu-id="a2a49-158">Tratamento de importação</span><span class="sxs-lookup"><span data-stu-id="a2a49-158">Import handling</span></span>

- <span data-ttu-id="a2a49-159">Chamadas por meio de IAT não devem usar a proteção CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-159">Calls through the IAT should not use CFG protection.</span></span> <span data-ttu-id="a2a49-160">O IAT é somente leitura em imagens modernas (supondo que a IAT seja declarada nos cabeçalhos PE, nesse caso, ela deve estar em suas próprias páginas).</span><span class="sxs-lookup"><span data-stu-id="a2a49-160">The IAT is read only in modern images (assuming that the IAT is declared in the PE headers in which case it must be on its own pages).</span></span> <span data-ttu-id="a2a49-161">O IAT pode ser usado para alcançar funções que são suprimidas por proteção, portanto, esse é um requisito de correção.</span><span class="sxs-lookup"><span data-stu-id="a2a49-161">The IAT can be used to reach functions that are guard suppressed, so this is a correctness requirement.</span></span> <span data-ttu-id="a2a49-162">A proteção de memória somente leitura por meio do IAT substitui a de CFG, uma vez que a associação de destino de chamada é imutável depois que os snaps de importação de imagem são resolvidos e a resolução de associação é refinada.</span><span class="sxs-lookup"><span data-stu-id="a2a49-162">Read only memory protection through the IAT supersedes that of CFG since the call target binding is immutable after the image import snaps are resolved, and the binding resolution is fine grained.</span></span>

- <span data-ttu-id="a2a49-163">Carga de atraso protegida: chamadas por meio do IAT de carga de atraso não devem usar a proteção CFG, pelos mesmos motivos que o IAT padrão.</span><span class="sxs-lookup"><span data-stu-id="a2a49-163">Protected delay load: Calls through the delay load IAT should not use CFG protection, for the same reasons as the standard IAT.</span></span> <span data-ttu-id="a2a49-164">O IAT de carga de atraso deve estar em sua própria seção e a imagem deve definir o IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span><span class="sxs-lookup"><span data-stu-id="a2a49-164">The delay load IAT should be in its own section and the image should set the IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span></span> <span data-ttu-id="a2a49-165">Isso indica que o carregador de DLL do sistema operacional deve alterar as proteções para o atraso de carga IAT durante a resolução de exportação se estiver usando o suporte de carregamento de atraso do sistema operacional nativo para o Windows 8 e sistemas operacionais posteriores.</span><span class="sxs-lookup"><span data-stu-id="a2a49-165">This indicates that the operating system’s DLL loader should change protections for the delay load IAT during export resolution if using the operating system’s delay load support native to Windows 8 and later operating systems.</span></span> <span data-ttu-id="a2a49-166">A sincronização desta etapa será gerenciada pelo carregador de DLL do sistema operacional se o suporte à carga de atraso do sistema operacional nativo estiver em uso (por exemplo, ResolveDelayLoadedAPI), portanto, nenhum outro componente deve proteger novamente as páginas que abrangem a carga de atraso declarada IAT.</span><span class="sxs-lookup"><span data-stu-id="a2a49-166">The synchronization of this step is managed by the operating system DLL loader if native operating system delay load support is in use (e.g. ResolveDelayLoadedAPI) so no other component should reprotect the pages spanning the declared delay load IAT.</span></span> <span data-ttu-id="a2a49-167">Para compatibilidade com versões anteriores, com sistemas operacionais anteriores ao CFG, as ferramentas podem habilitar a opção de mover o IAT de carregamento de atraso para sua própria seção (canônicamente ". didat"), protegido como leitura/gravação nos cabeçalhos da imagem e, além disso, definir o sinalizador de IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION.</span><span class="sxs-lookup"><span data-stu-id="a2a49-167">For backwards compatibility with older pre-CFG operating systems, tools may enable the option to move the delay load IAT into its own section (canonically “.didat”), protected as read/write in the image headers, and additionally set the IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION flag.</span></span> <span data-ttu-id="a2a49-168">Essa configuração fará com que os carregadores da DLL do sistema operacional com reconhecimento de CFG protejam novamente a seção inteira que contém a tabela IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT para ler apenas a memória durante o carregamento da imagem.</span><span class="sxs-lookup"><span data-stu-id="a2a49-168">This setting will cause CFG-aware operating system DLL loaders to reprotect the entire section containing the IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT table to read only memory during image loading.</span></span> <span data-ttu-id="a2a49-169">A opção de colocar o IAT de carga de atraso em sua própria seção pode não ser necessária se você não se importa com a execução de uma imagem em sistemas operacionais que precedam o suporte a CFG, mas as ferramentas devem tomar essa decisão com base no suporte mínimo de sistema operacional que uma imagem precisa.</span><span class="sxs-lookup"><span data-stu-id="a2a49-169">The option to place the delay load IAT in its own section may not be required if you do not care about running an image on operating systems that predate CFG support, but tools should make that decision based on the minimum operating system support that an image needs.</span></span>

  <span data-ttu-id="a2a49-170">Se uma imagem não usar o suporte de carregamento de atraso nativo do sistema operacional, ela ainda poderá definir os bits de GuardFlags relacionados à carga de atraso protegido.</span><span class="sxs-lookup"><span data-stu-id="a2a49-170">If an image does not use the operating system’s native delay load support, it can still set the protected delay load related GuardFlags bits.</span></span> <span data-ttu-id="a2a49-171">Nessa configuração, o carregador do sistema operacional apenas fornecerá suporte para proteger a carga de atraso IAT como somente leitura no tempo de execução, se houver suporte da plataforma, e se tornará a responsabilidade dos stubs de resolução de carga de atraso interno da imagem para sincronizar e gerenciar a proteção do IAT de carga de atraso.</span><span class="sxs-lookup"><span data-stu-id="a2a49-171">In this configuration, the operating system loader will just provide support to protect the delay load IAT as read only at runtime if supported by the platform, and it becomes the responsibility of the image’s internal delay load resolution stubs to synchronize and manage protection of the delay load IAT.</span></span> <span data-ttu-id="a2a49-172">Desde que a tabela de configuração de carregamento esteja armazenada em memória somente leitura (o que é recomendado), a presença ou a ausência do bit de IAT de carga de atraso protegido no campo GuardFlags da imagem pode ser útil como uma dica interna para os stubs de resolução de carregamento de atraso interno da imagem para indicar se ele deve ou não proteger a carga de atraso IAT.</span><span class="sxs-lookup"><span data-stu-id="a2a49-172">Provided that the load configuration table is stored in read only memory (which is recommended), the presence or absence of the protected delay load IAT bit in the image’s GuardFlags field might be useful as an internal hint to the image’s internal delay load resolution stubs to indicate whether or not it should protect the delay load IAT.</span></span>

  <span data-ttu-id="a2a49-173">É recomendável que a carga de atraso protegida seja habilitada por padrão se o CFG estiver habilitado.</span><span class="sxs-lookup"><span data-stu-id="a2a49-173">It is recommended that protected delay load be enabled by default if CFG is enabled.</span></span> <span data-ttu-id="a2a49-174">Imagens que são executadas em versões mais antigas do sistema operacional e que usam o suporte nativo para carregamento de atraso do sistema operacional, como observado, podem usar o IAT de carregamento de atraso em sua própria seção de suporte para compatibilidade com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="a2a49-174">Images that run on older operating system versions and that use the operating system’s native delay load support, as noted, may use the delay load IAT in its own section support for backwards compatibility.</span></span> <span data-ttu-id="a2a49-175">Isso é para marcar o IAT de carregamento de atraso como somente leitura e mesclá-lo com outra seção, que pode ser interrompida em sistemas operacionais mais antigos que não entendem cargas de atraso protegidas e que fornecem suporte à resolução de carregamento de atraso nativo.</span><span class="sxs-lookup"><span data-stu-id="a2a49-175">This is opposed to marking the delay load IAT as read only and merging it with another section, which would break on older operating system’s that do not understand protected delay loads and which provide native delay load resolution support.</span></span> <span data-ttu-id="a2a49-176">Todas as versões do Windows 10 e as primeiras compilações do Windows 8.1/Windows Server 2012 R2 com suporte para CFG (ou seja, a atualização de novembro de 2014) introduzem o suporte à carga de atraso protegida no sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="a2a49-176">All Windows 10 releases and the first Windows 8.1/Windows Server 2012 R2 builds that supported CFG (meaning the November 2014 update) introduce support for protected delay load in the operating system.</span></span>

## <a name="function-alignment"></a><span data-ttu-id="a2a49-177">Alinhamento de função</span><span class="sxs-lookup"><span data-stu-id="a2a49-177">Function alignment</span></span>

- <span data-ttu-id="a2a49-178">As funções que são obtidas pelo endereço e, portanto, são incluídas na tabela **GFIDS** devem se tornar alinhadas em 16 bytes, se possível.</span><span class="sxs-lookup"><span data-stu-id="a2a49-178">Functions that are address taken and are therefore included in the **GFIDS** table should be made 16-byte aligned, if possible.</span></span> <span data-ttu-id="a2a49-179">Isso nem sempre pode ser possível.</span><span class="sxs-lookup"><span data-stu-id="a2a49-179">This may not always be possible.</span></span> <span data-ttu-id="a2a49-180">Por exemplo, para funções não COMDAT que fazem parte de arquivos de objeto montados como uma unidade por ferramentas que não reconhecem o CFG, que alguns montadores podem produzir, o usuário da ferramenta que produziu os arquivos deve definir adequadamente o alinhamento.</span><span class="sxs-lookup"><span data-stu-id="a2a49-180">For example, for non-COMDAT functions that are a part of object files assembled together as one unit by non-CFG aware tools, which some assemblers may produce, the user of the tool that produced the files must appropriately set the alignment.</span></span> <span data-ttu-id="a2a49-181">As ferramentas podem optar por emitir um aviso de diagnóstico nessa situação para que o usuário possa executar a ação corretiva apropriada.</span><span class="sxs-lookup"><span data-stu-id="a2a49-181">Tools may elect to issue a diagnostic warning in this situation so that the user can take appropriate corrective action.</span></span> <span data-ttu-id="a2a49-182">O motivo disso é que CFG marca destinos como válidos ou não válidos em limites de 16 bytes para eficiência das verificações de CFG rápidas.</span><span class="sxs-lookup"><span data-stu-id="a2a49-182">The reason for this is that CFG marks call targets as valid or not valid on 16-byte boundaries for efficiency of fast CFG checks.</span></span> <span data-ttu-id="a2a49-183">Se uma função não estiver alinhada em 16 bytes, o slot inteiro de 16 bytes deverá ser marcado como válido, o que não é tão seguro, pois você pode chamar inalinhado ao código que não está no início de uma função.</span><span class="sxs-lookup"><span data-stu-id="a2a49-183">If a function is not 16-byte aligned, then the entire 16-byte slot must be marked as valid, which is not as secure since you can call misaligned into code that is not at the very start of a function.</span></span> <span data-ttu-id="a2a49-184">Esse cenário tem suporte para a facilidade de interoperabilidade ao trazer o CFG para um projeto pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="a2a49-184">This scenario is supported for ease of interoperability when first bringing CFG up for a project.</span></span> <span data-ttu-id="a2a49-185">Imagens com reconhecimento de não-CFG são marcadas da mesma forma como válidas para qualquer alinhamento de destino de chamada para compatibilidade.</span><span class="sxs-lookup"><span data-stu-id="a2a49-185">Non-CFG aware images are similarly marked as valid for any call target alignment for compatibility.</span></span> <span data-ttu-id="a2a49-186">Como antes, ter destinos de chamada desalinhados reduz os benefícios de segurança de CFG, portanto, as ferramentas devem alinhar-se automaticamente a um limite de 16 bytes para qualquer coisa na tabela **GFIDS** quando cfg for desejado para uma imagem.</span><span class="sxs-lookup"><span data-stu-id="a2a49-186">As before, having misaligned call targets reduces the security benefits of CFG, so tools should automatically align to a 16-byte boundary for anything in the **GFIDS** table when CFG is desired for an image.</span></span> <span data-ttu-id="a2a49-187">Os símbolos que não estão na tabela **GFIDS** não precisam ter alinhamentos específicos para cfg.</span><span class="sxs-lookup"><span data-stu-id="a2a49-187">Symbols that are not in the **GFIDS** table do not need to have particular alignments for CFG.</span></span>

## <a name="export-suppression"></a><span data-ttu-id="a2a49-188">Supressão de exportação</span><span class="sxs-lookup"><span data-stu-id="a2a49-188">Export suppression</span></span>

- <span data-ttu-id="a2a49-189">A supressão de exportação do CFG (CFG) é um modo opcional que permite que um processo indique que os destinos de chamada que só eram válidos porque eram dllexport símbolos e que ainda não foram resolvidos dinamicamente por GetProcAddress, serão considerados como inválidos para fins de CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-189">CFG export suppression (CFG ES) is an optional mode that enables a process to indicate that call targets which were only valid because they were dllexport symbols, and which have not yet been dynamically resolved by GetProcAddress, will be considered as not valid for purposes of CFG.</span></span> <span data-ttu-id="a2a49-190">Isso reduz a área de superfície de CFG de exportações de DLL do sistema.</span><span class="sxs-lookup"><span data-stu-id="a2a49-190">This reduces the surface area of CFG from system DLL exports.</span></span> <span data-ttu-id="a2a49-191">A supressão de exportação envolve a comunicação de destinos de chamada dllexport qualificados "exportar suprimidos" marcando-os com os sinalizadores de **GFIDS** de IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED.</span><span class="sxs-lookup"><span data-stu-id="a2a49-191">Export suppression involves communicating eligible “export suppressed” dllexport call targets by marking them with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flags.</span></span> <span data-ttu-id="a2a49-192">Os símbolos dllexport e o ponto de entrada de imagem PE devem ser considerados um endereço assumido implicitamente pelas ferramentas para fins de geração da tabela **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="a2a49-192">Dllexport symbols and the PE image entry point should be implicitly considered address taken by tools for purposes of generating the **GFIDS** table.</span></span>  <span data-ttu-id="a2a49-193">Se um símbolo de exportação estiver alinhado em 16 bytes e o endereço for tomado por nenhum outro motivo de ser um dllexport, ele poderá ser marcado com o sinalizador exportar **GFIDS** suprimido na tabela de funções.</span><span class="sxs-lookup"><span data-stu-id="a2a49-193">If an export symbol is 16-byte aligned and it is address taken for no other reason than being a dllexport, then it can be marked with the export suppressed **GFIDS** flag in the function table.</span></span> <span data-ttu-id="a2a49-194">Os destinos de chamada que não são alinhados em 16 bytes **não devem** ser marcados com o sinalizador IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** e não podem ser restritos para serem habilitados dinamicamente como destinos de chamada válidos em tempo de GetProcAddress.</span><span class="sxs-lookup"><span data-stu-id="a2a49-194">Call targets that are not 16-byte aligned **must not** be marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag and cannot be restricted to only being dynamically enabled as valid call targets at GetProcAddress time.</span></span>

  <span data-ttu-id="a2a49-195">Uma imagem que dá suporte a CFG ES inclui um GuardAddressTakenIatEntryTable cuja contagem é fornecida pelo GuardAddressTakenIatEntryCount como parte de seu diretório de configuração de carga.</span><span class="sxs-lookup"><span data-stu-id="a2a49-195">An image that supports CFG ES includes a GuardAddressTakenIatEntryTable whose count is provided by the GuardAddressTakenIatEntryCount as part of its load configuration directory.</span></span> <span data-ttu-id="a2a49-196">Essa tabela é formatada estruturalmente da mesma forma que a tabela **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="a2a49-196">This table is structurally formatted the same as the **GFIDS** table.</span></span> <span data-ttu-id="a2a49-197">Ele usa o mesmo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK de GuardFlags para codificar bytes de metadados opcionais adicionais na tabela Address taked IAT, embora todos os bytes de metadados devam ser zero para o endereço obtido IAT tabela e são reservados.</span><span class="sxs-lookup"><span data-stu-id="a2a49-197">It uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode extra optional metadata bytes in the address taken IAT table, though all metadata bytes must be zero for the address taken IAT table and are reserved.</span></span> <span data-ttu-id="a2a49-198">A tabela Address takeed IAT indica uma matriz classificada de RVAs de conversões de importação que têm a importação como um endereço de símbolo obtido como destino de chamada.</span><span class="sxs-lookup"><span data-stu-id="a2a49-198">The address taken IAT table indicates a sorted array of RVAs of import thunks which have the imported as a symbol address taken call target.</span></span> <span data-ttu-id="a2a49-199">Essa construção dá suporte a símbolos de endereço tirados que existem em um módulo remoto e que são dllexports, com CFG ES em uso.</span><span class="sxs-lookup"><span data-stu-id="a2a49-199">This construct supports address taken symbols that exist in a remote module, and which are dllexports, with CFG ES in use.</span></span> <span data-ttu-id="a2a49-200">Um exemplo de tal construção de código seria:</span><span class="sxs-lookup"><span data-stu-id="a2a49-200">An example of such a code construct would be:</span></span>

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  <span data-ttu-id="a2a49-201">Todas essas conversões de importação obtidas por endereço devem ser enumeradas para que o carregador do sistema operacional possa encontrá-las e fazer com que os destinos de chamada apropriados sejam válidos ao carregar uma imagem e ajustar suas importações.</span><span class="sxs-lookup"><span data-stu-id="a2a49-201">All such address taken import thunks must be enumerated so that the operating system loader can find them and make the appropriate call targets valid when loading an image and snapping its imports.</span></span> <span data-ttu-id="a2a49-202">A tabela e a contagem podem ser 0 se não houver conversões de importação que foram obtidas por endereço.</span><span class="sxs-lookup"><span data-stu-id="a2a49-202">The table and count can be 0 if there are no import thunks that were address taken.</span></span>

  <span data-ttu-id="a2a49-203">Um módulo define o IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT bit GuardFlags para indicar que ele enumerou todas as conversões de endereço obtidas em seu endereço IAT tabela obtida e que todas as exportações que estão qualificadas são marcadas com o sinalizador **GFIDS** de IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED.</span><span class="sxs-lookup"><span data-stu-id="a2a49-203">A module sets the IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags bit to indicate that it has enumerated all address taken thunks in its address taken IAT table and that all exports that are CFG ES eligible are marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag.</span></span> <span data-ttu-id="a2a49-204">Observe que pode haver zero conversão dessas conversões e que também pode haver zero símbolos dllexport.</span><span class="sxs-lookup"><span data-stu-id="a2a49-204">Note that there may be zero such thunks and that there may also be zero such dllexport symbols.</span></span> <span data-ttu-id="a2a49-205">A falha na manutenção do endereço obtido pela tabela IAT pode ser um problema de correção, pois alguns destinos de chamada podem não ser válidos quando devem estar no tempo de carregamento da DLL.</span><span class="sxs-lookup"><span data-stu-id="a2a49-205">Failure to maintain the address taken IAT table can be a correctness issue as some call targets might not be made valid when they should be at DLL load time.</span></span>

  <span data-ttu-id="a2a49-206">Um módulo define o IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION bit GuardFlags para indicar que deseja habilitar CFG ES para o processo.</span><span class="sxs-lookup"><span data-stu-id="a2a49-206">A module sets the IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags bit to indicate that it wants to enable CFG ES for the process.</span></span> <span data-ttu-id="a2a49-207">Na prática, isso só é significativo para os EXEs atuais.</span><span class="sxs-lookup"><span data-stu-id="a2a49-207">In practice, this is only meaningful for EXEs today.</span></span> <span data-ttu-id="a2a49-208">Um processo que habilita o CFG ES não deve carregar DLLs não criadas com CFG ES ou falhas de tempo de execução podem ocorrer devido a endereços não designados IAT símbolos de uso.</span><span class="sxs-lookup"><span data-stu-id="a2a49-208">A process enabling CFG ES should not load DLLs not built with CFG ES or runtime failures may occur because of undesignated address taken IAT symbols.</span></span> <span data-ttu-id="a2a49-209">O suporte para habilitar CFG ES deve ser uma opção de aceitação separada da habilitação de CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-209">Support for enabling CFG ES should be a separate opt-in option from enabling CFG.</span></span> <span data-ttu-id="a2a49-210">Fornecer metadados de CFG ES é seguro e recomendado por padrão com CFG, embora os conjuntos de ferramentas devam ter cuidado para garantir que eles produzam metadados corretos.</span><span class="sxs-lookup"><span data-stu-id="a2a49-210">Providing CFG ES metadata is safe and recommended by default with CFG, though toolsets must take care to ensure they produce correct metadata.</span></span> <span data-ttu-id="a2a49-211">Caso contrário, suas imagens geradas podem não ser executadas corretamente em um processo CFG ES.</span><span class="sxs-lookup"><span data-stu-id="a2a49-211">If not, their generated images may not run properly in a CFG ES process.</span></span> <span data-ttu-id="a2a49-212">Esse suporte deve ser totalmente testado em um processo de teste que impõe CFG ES.</span><span class="sxs-lookup"><span data-stu-id="a2a49-212">Such support should be thoroughly tested in a test process that enforces CFG ES.</span></span> <span data-ttu-id="a2a49-213">As DLLs do sistema interno do sistema operacional dão suporte aos metadados de CFG ES para versões modernas do sistema operacional Windows 10 que entendem CFG ES.</span><span class="sxs-lookup"><span data-stu-id="a2a49-213">The operating system built-in system DLLs support CFG ES metadata for modern Windows 10 operating system versions that understand CFG ES.</span></span> <span data-ttu-id="a2a49-214">As versões do sistema operacional anteriores a esse suporte não entendem o CFG ES e ignorarão quaisquer diretivas relacionadas a CFG ES na imagem.</span><span class="sxs-lookup"><span data-stu-id="a2a49-214">Operating system versions prior to this support do not understand CFG ES at all and will ignore any CFG ES related directives in the image.</span></span> <span data-ttu-id="a2a49-215">Essas imagens ainda são compatíveis com versões anteriores do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="a2a49-215">Such images are still backwards compatible to older operating system versions.</span></span>

  <span data-ttu-id="a2a49-216">O suporte ao CFG ES é opcional de uma perspectiva do conjunto de ferramentas, mas é recomendável que os conjuntos de ferramentas, pelo menos, incluam suporte para enumerar informações suficientes para que as imagens sejam executadas em um processo que queira CFG ES.</span><span class="sxs-lookup"><span data-stu-id="a2a49-216">CFG ES support is optional from a toolset perspective, but it is recommended that toolsets at least include support to enumerate enough information for images to run in a process that desires CFG ES.</span></span> <span data-ttu-id="a2a49-217">Conforme mencionado, é essencial que o suporte do conjunto de ferramentas seja totalmente testado para garantir que ele seja compatível com CFG ES, pois a maioria dos processos ainda não habilitam o CFG ES.</span><span class="sxs-lookup"><span data-stu-id="a2a49-217">As mentioned, it is critical that toolset support be thoroughly tested to ensure that it is compatible with CFG ES, as most processes don’t yet enable CFG ES.</span></span>

## <a name="exception-handling-and-unwinding"></a><span data-ttu-id="a2a49-218">Manipulação e desenrolamento de exceção</span><span class="sxs-lookup"><span data-stu-id="a2a49-218">Exception handling and unwinding</span></span>

- <span data-ttu-id="a2a49-219">Manipuladores de idioma específicos como __C_specific_handler, conforme designado pelas informações do manipulador de exceção em um registro. pData, não devem ser marcados como destinos de chamada válidos na tabela **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="a2a49-219">Language specific handlers like __C_specific_handler, as designated by the exception handler information in a .pdata registration, should not be marked as valid call targets in the **GFIDS** table.</span></span> <span data-ttu-id="a2a49-220">Em vez disso, eles são pesquisados atravessando a memória somente leitura.</span><span class="sxs-lookup"><span data-stu-id="a2a49-220">They are instead looked up by traversing read only memory.</span></span> <span data-ttu-id="a2a49-221">Da mesma forma, o manipulador específico da linguagem Microsoft C usa pesquisas de memória somente leitura para localizar funclets para manipuladores de exceção e, portanto, não declara seu funclets como destinos de chamada válidos na tabela **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="a2a49-221">Similarly, the Microsoft C language specific handler uses read only memory searches to locate funclets for exception handlers and thus does not declare its funclets as valid call targets in the **GFIDS** table.</span></span>

- <span data-ttu-id="a2a49-222">Tratamento de salto longo (para destinos não x86 como AMD64): os conjuntos de ferramentas que compilam com CFG e dão suporte a setjmp ()/longjmp () devem implementar um longo salto como "salto longo seguro" que interopera com o SEH (tratamento de exceção estruturada).</span><span class="sxs-lookup"><span data-stu-id="a2a49-222">Long jump handling (for non-x86 targets like AMD64):  Toolsets compiling with CFG and supporting setjmp()/longjmp() should implement long jump as “safe long jump” that interoperates with structured exception handling (SEH).</span></span> <span data-ttu-id="a2a49-223">Isso significa que o salto longo é implementado como uma chamada para RtlUnwindEx com STATUS_LONGJUMP como o código de status no registro de exceção fornecido e um _JUMP_BUFFER padrão apontado por ExceptionInformation [0].</span><span class="sxs-lookup"><span data-stu-id="a2a49-223">This means long jump is implemented as a call to RtlUnwindEx with STATUS_LONGJUMP as the status code in the supplied exception record and a standard _JUMP_BUFFER pointed to by ExceptionInformation[0].</span></span> <span data-ttu-id="a2a49-224">O destino de desenrolamento de salto deve ser o TargetIp do desenrolamento.</span><span class="sxs-lookup"><span data-stu-id="a2a49-224">The jump unwind target should be the TargetIp of the unwind.</span></span> <span data-ttu-id="a2a49-225">O buffer de salto representa o contexto de registro que é restaurado pelo sistema operacional após a conclusão do salto longo.</span><span class="sxs-lookup"><span data-stu-id="a2a49-225">The jump buffer represents the register context that is restored by the operating system after the long jump has completed.</span></span> <span data-ttu-id="a2a49-226">RtlUnwind (ex) quando chamado com STATUS_LONGJUMP tem um significado especial exclusivo para CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-226">RtlUnwind(Ex) when called with STATUS_LONGJUMP has special significance unique to CFG.</span></span> <span data-ttu-id="a2a49-227">O destino de salto longo (_JUMP_BUFFER. Rip ou _JUMP_BUFFER. LR em ARM64) é pesquisada na lista de módulos carregados mantida pelo sistema operacional em memória somente leitura.</span><span class="sxs-lookup"><span data-stu-id="a2a49-227">The long jump target (_JUMP_BUFFER.Rip or _JUMP_BUFFER.Lr on ARM64) is looked up in the loaded module list maintained by the operating system in read only memory.</span></span> <span data-ttu-id="a2a49-228">Se o módulo que o contém para o destino de salto (o "módulo de destino") tiver o sinalizador IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT definido em seu campo GuardFlags, o diretório de configuração de carga terá um GuardLongJumpTargetTable whith uma contagem de elementos especificada pelo campo carregar configuração GuardLongJumpTargetCount.</span><span class="sxs-lookup"><span data-stu-id="a2a49-228">If the containing module for the jump target (the “target module”) has the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag set in its GuardFlags field, then the load configuration directory has a GuardLongJumpTargetTable whith an element count specified by the load configuration GuardLongJumpTargetCount field.</span></span> <span data-ttu-id="a2a49-229">Essa tabela é formatada estruturalmente da mesma forma que a tabela **GFIDS** e usa o mesmo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags para codificar bytes de metadados extras opcionais na tabela de salto longo.</span><span class="sxs-lookup"><span data-stu-id="a2a49-229">This table is structurally formatted the same as the **GFIDS** table and uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode optional extra metadata bytes in the long jump table.</span></span> <span data-ttu-id="a2a49-230">Todos os bytes de metadados devem ser zero para a tabela de salto longa e são reservados.</span><span class="sxs-lookup"><span data-stu-id="a2a49-230">All metadata bytes must be zero for the long jump table and are reserved.</span></span>

  <span data-ttu-id="a2a49-231">A tabela de salto longo representa uma matriz classificada de RVAs que são destinos de salto longos válidos.</span><span class="sxs-lookup"><span data-stu-id="a2a49-231">The long jump table represents a sorted array of RVAs that are valid long jump targets.</span></span> <span data-ttu-id="a2a49-232">Se um módulo de destino de salto longo definir IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT em seu campo GuardFlags, todos os destinos de salto longos deverão ser enumerados no LongJumpTargetTable.</span><span class="sxs-lookup"><span data-stu-id="a2a49-232">If a long jump target module sets IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT in its GuardFlags field, then all long jump targets must be enumerated in the LongJumpTargetTable.</span></span> <span data-ttu-id="a2a49-233">Mesmo que um módulo tenha zero destinos de salto longos, ele ainda deverá definir o sinalizador IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT se o conjunto de ferramentas der suporte à proteção de salto longo para o CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-233">Even if a module has zero long jump targets, it should still set the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag if the toolset supports long jump hardening for CFG.</span></span> <span data-ttu-id="a2a49-234">Isso significa explicitamente que a imagem não tem destinos de salto longos e não é uma imagem antiga que o sistema operacional deve assumir pode ter destinos de salto longos válidos em locais desmarcados para os quais ele não pode executar a verificação de destino de salto longo.</span><span class="sxs-lookup"><span data-stu-id="a2a49-234">This explicitly means that the image has no long jump targets and is not an old image that the operating system must assume could have valid long jump targets at unmarked locations for which it cannot perform long jump target checking.</span></span>

  <span data-ttu-id="a2a49-235">A proteção de salto longo é recomendável para ser habilitada por padrão se o CFG tiver suporte.</span><span class="sxs-lookup"><span data-stu-id="a2a49-235">Long jump hardening is recommended to be enabled by default if CFG is supported.</span></span> <span data-ttu-id="a2a49-236">Esta é a disposição dos compiladores da Microsoft.</span><span class="sxs-lookup"><span data-stu-id="a2a49-236">This is the disposition of Microsoft compilers.</span></span> <span data-ttu-id="a2a49-237">Os sistemas operacionais que não entendem a proteção de salto longo (versões anteriores do Windows 10 ou anteriores do Windows 10) não executarão verificações longas de proteção de salto e ignorarão todos os metadados de proteção de longo prazo, de modo que a proteção de salto longo é compatível com versões anteriores do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="a2a49-237">Operating systems that do not understand long jump hardening (pre-Windows 10 or older Windows 10 versions) will not perform long jump hardening checks and ignore any long jump hardening metadata, so long jump hardening is backwards compatible with older operating system releases.</span></span>

  <span data-ttu-id="a2a49-238">Para imagens de modo kernel, a tabela de destino de salto longo de proteção não deve ser incluída em uma seção que pode ser descartada.</span><span class="sxs-lookup"><span data-stu-id="a2a49-238">For kernel mode images, the guard long jump target table should not be included in a discardable section.</span></span> <span data-ttu-id="a2a49-239">A tabela de destino de salto longo de proteção sempre deve ser armazenada em memória somente leitura para que suas propriedades de segurança sejam efetivas.</span><span class="sxs-lookup"><span data-stu-id="a2a49-239">The guard long jump target table should always be stored in read only memory for its security properties to be effective.</span></span>

## <a name="coff-information"></a><span data-ttu-id="a2a49-240">Informações COFF</span><span class="sxs-lookup"><span data-stu-id="a2a49-240">COFF information</span></span>

- <span data-ttu-id="a2a49-241">Há marcações de arquivo de objeto para declarar se um arquivo de objeto está de acordo com CFG ou não.</span><span class="sxs-lookup"><span data-stu-id="a2a49-241">There are object file markings to declare whether an object file conforms to CFG or not.</span></span> <span data-ttu-id="a2a49-242">Um arquivo de objeto que está de acordo com o CFG listará os destinos de chamada válidos que ele produz, explicitamente, bem como qualquer endereço obtido de metadados IAT.</span><span class="sxs-lookup"><span data-stu-id="a2a49-242">An object file that conforms to CFG will list the valid call targets that it produces, explicitly, as well as any address taken IAT metadata.</span></span> <span data-ttu-id="a2a49-243">Um arquivo de objeto que não está em conformidade com o CFG deve ter destinos de chamada inferidos examinando as realocações COFF do arquivo obj para encontrar realocações que apontam para o início de um símbolo de função.</span><span class="sxs-lookup"><span data-stu-id="a2a49-243">An object file that does not conform to CFG must have call targets inferred by examining the COFF relocations of the obj file to find relocations that point to the start of a function symbol.</span></span> <span data-ttu-id="a2a49-244">Isso pode sobreaproximar destinos de chamada CFG válidos, portanto, é desejável que as ferramentas Marquem seus arquivos obj que reconhecem o CFG e incluam os metadados do arquivo CFG obj se estiverem compilando com CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-244">This may overapproximate valid CFG call targets so it is desirable that tools mark their obj files that are CFG-aware and include the CFG obj file metadata if compiling with CFG.</span></span>

- <span data-ttu-id="a2a49-245">Há marcações de arquivo de objeto para declarar destinos longos de salto para o salto longo protegido por CFG, que deve ser preenchido para o modo de compilação de CFG.</span><span class="sxs-lookup"><span data-stu-id="a2a49-245">There are object file markings to declare long jump targets for CFG hardened long jump which should be populated for CFG compilation mode.</span></span>
