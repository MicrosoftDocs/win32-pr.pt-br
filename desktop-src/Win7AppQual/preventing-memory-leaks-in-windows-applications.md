---
description: Saiba como evitar vazamentos de memória em aplicativos do Windows para plataformas Windows 7 e Windows Server 2008 R2.
ms.assetid: c5dedcab-3e6f-433f-95de-d741321c683e
title: Evitando vazamentos de memória em aplicativos do Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e973da19d075ac94824df340d1741fd9cefb3486
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/06/2021
ms.locfileid: "104552864"
---
# <a name="preventing-memory-leaks-in-windows-applications"></a><span data-ttu-id="7c528-103">Evitando vazamentos de memória em aplicativos do Windows</span><span class="sxs-lookup"><span data-stu-id="7c528-103">Preventing Memory Leaks in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="7c528-104">Plataformas afetadas</span><span class="sxs-lookup"><span data-stu-id="7c528-104">Affected Platforms</span></span>

<span data-ttu-id="7c528-105">**Clientes** -Windows 7</span><span class="sxs-lookup"><span data-stu-id="7c528-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="7c528-106">**Servidores** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="7c528-106">**Servers** - Windows Server 2008 R2</span></span>  

## <a name="description"></a><span data-ttu-id="7c528-107">Descrição</span><span class="sxs-lookup"><span data-stu-id="7c528-107">Description</span></span>

<span data-ttu-id="7c528-108">Vazamentos de memória são uma classe de bugs em que o aplicativo falha ao liberar memória quando não é mais necessário.</span><span class="sxs-lookup"><span data-stu-id="7c528-108">Memory leaks are a class of bugs where the application fails to release memory when no longer needed.</span></span> <span data-ttu-id="7c528-109">Com o tempo, as perdas de memória afetam o desempenho do aplicativo específico, bem como o sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="7c528-109">Over time, memory leaks affect the performance of both the particular application as well as the operating system.</span></span> <span data-ttu-id="7c528-110">Um grande vazamento pode resultar em tempos de resposta inaceitáveis devido à paginação excessiva.</span><span class="sxs-lookup"><span data-stu-id="7c528-110">A large leak might result in unacceptable response times due to excessive paging.</span></span> <span data-ttu-id="7c528-111">Eventualmente, o aplicativo, bem como outras partes do sistema operacional, apresentarão falhas.</span><span class="sxs-lookup"><span data-stu-id="7c528-111">Eventually the application as well as other parts of the operating system will experience failures.</span></span>

<span data-ttu-id="7c528-112">O Windows liberará toda a memória alocada pelo aplicativo no término do processo, portanto, os aplicativos de curta execução não afetarão significativamente o desempenho geral do sistema.</span><span class="sxs-lookup"><span data-stu-id="7c528-112">Windows will free all memory allocated by the application on process termination, so short-running applications will not affect overall system performance significantly.</span></span> <span data-ttu-id="7c528-113">No entanto, vazamentos em processos de execução longa, como serviços ou pares de plug-ins do Explorer, podem afetar significativamente a confiabilidade do sistema e podem forçar o usuário a reinicializar o Windows para tornar o sistema utilizável novamente.</span><span class="sxs-lookup"><span data-stu-id="7c528-113">However, leaks in long-running processes like services or even Explorer plug-ins can greatly impact system reliability and might force the user to reboot Windows in order to make the system usable again.</span></span>

<span data-ttu-id="7c528-114">Os aplicativos podem alocar memória em seu nome por vários meios.</span><span class="sxs-lookup"><span data-stu-id="7c528-114">Applications can allocate memory on their behalf by multiple means.</span></span> <span data-ttu-id="7c528-115">Cada tipo de alocação pode resultar em um vazamento se não liberado após o uso.</span><span class="sxs-lookup"><span data-stu-id="7c528-115">Each type of allocation can result in a leak if not freed after use.</span></span> <span data-ttu-id="7c528-116">Aqui estão alguns exemplos de padrões de alocação comuns:</span><span class="sxs-lookup"><span data-stu-id="7c528-116">Here are some examples of common allocation patterns:</span></span>

-   <span data-ttu-id="7c528-117">Memória de heap por meio da função [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) ou seu tempo de execução do C/C++ equivalentes **malloc** ou **New**</span><span class="sxs-lookup"><span data-stu-id="7c528-117">Heap memory via the [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) function or its C/C++ runtime equivalents **malloc** or **new**</span></span>
-   <span data-ttu-id="7c528-118">Alocações diretas do sistema operacional por meio da função [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) .</span><span class="sxs-lookup"><span data-stu-id="7c528-118">Direct allocations from the operating system via the [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function.</span></span>
-   <span data-ttu-id="7c528-119">Os identificadores de kernel criados por meio de APIs do Kernel32, como [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)ou [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), mantêm a memória do kernel em nome do aplicativo</span><span class="sxs-lookup"><span data-stu-id="7c528-119">Kernel handles created via Kernel32 APIs such as [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa), or [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), hold kernel memory on behalf of the application</span></span>
-   <span data-ttu-id="7c528-120">Os identificadores GDI e USER criados por meio de APIs user32 e GDI32 (por padrão, cada processo tem uma cota de identificadores 10.000)</span><span class="sxs-lookup"><span data-stu-id="7c528-120">GDI and USER handles created via User32 and Gdi32 APIs (by default, each process has a quota of 10,000 handles)</span></span>

## <a name="best-practices"></a><span data-ttu-id="7c528-121">Práticas Recomendadas</span><span class="sxs-lookup"><span data-stu-id="7c528-121">Best Practices</span></span>

<span data-ttu-id="7c528-122">O monitoramento do consumo de recursos do seu aplicativo ao longo do tempo é a primeira etapa na detecção e no diagnóstico de vazamentos de memória.</span><span class="sxs-lookup"><span data-stu-id="7c528-122">Monitoring the resource consumption of your application over time is the first step in detecting and diagnosing memory leaks.</span></span> <span data-ttu-id="7c528-123">Use o Gerenciador de tarefas do Windows e adicione as seguintes colunas: "tamanho da confirmação", "identificadores", "objetos do usuário" e "objetos GDI".</span><span class="sxs-lookup"><span data-stu-id="7c528-123">Use Windows Task Manager and add the following columns: "Commit Size", "Handles", "User Objects", and "GDI Objects".</span></span> <span data-ttu-id="7c528-124">Isso permitirá que você estabeleça uma linha de base para seu aplicativo e monitore o uso de recursos ao longo do tempo.</span><span class="sxs-lookup"><span data-stu-id="7c528-124">This will allow you to establish a baseline for your application and monitor resource usage over time.</span></span>

![Captura de tela que mostra a página ' processos ' no Gerenciador de tarefas do Windows.](images/preventingmemoryleaks-windowstaskmanager.gif)

<span data-ttu-id="7c528-126">As ferramentas da Microsoft a seguir fornecem informações mais detalhadas e podem ajudar a detectar e diagnosticar vazamentos para os vários tipos de alocação em seu aplicativo:</span><span class="sxs-lookup"><span data-stu-id="7c528-126">The following Microsoft tools provide more-detailed information and can help to detect and diagnose leaks for the various allocation types in your application:</span></span>

-   <span data-ttu-id="7c528-127">O monitor de desempenho e Monitor de Recursos fazem parte do Windows 7 e podem monitorar e usar o recurso de grafo ao longo do tempo</span><span class="sxs-lookup"><span data-stu-id="7c528-127">Performance Monitor and Resource Monitor are part of Windows 7 and can monitor and graph resource use over time</span></span>
-   <span data-ttu-id="7c528-128">A versão mais recente do Application Verifier pode diagnosticar vazamentos de heap no Windows 7</span><span class="sxs-lookup"><span data-stu-id="7c528-128">The latest version of Application Verifier can diagnose heap leaks on Windows 7</span></span>
-   <span data-ttu-id="7c528-129">UMDH, que faz parte das ferramentas de depuração para Windows, analisa as alocações de memória de heap para um determinado processo e pode ajudar a encontrar vazamentos e outros padrões de uso incomuns</span><span class="sxs-lookup"><span data-stu-id="7c528-129">UMDH, which is part of the Debugging Tools for Windows, analyzes the heap memory allocations for a given process and can help find leaks and other unusual usage patterns</span></span>
-   <span data-ttu-id="7c528-130">Xperf é uma ferramenta de análise de desempenho sofisticada com suporte para rastreamentos de alocação de heap</span><span class="sxs-lookup"><span data-stu-id="7c528-130">Xperf is a sophisticated performance analysis tool with support for heap allocation traces</span></span>
-   <span data-ttu-id="7c528-131">O heap de depuração CRT rastreia as alocações de heap e pode ajudar a criar seus próprios recursos de depuração de heap</span><span class="sxs-lookup"><span data-stu-id="7c528-131">CRT Debug Heap tracks heap allocations and can help build your own heap debugging features</span></span>

<span data-ttu-id="7c528-132">Determinadas práticas de codificação e design podem limitar o número de vazamentos em seu código.</span><span class="sxs-lookup"><span data-stu-id="7c528-132">Certain coding and design practices can limit the number of leaks in your code.</span></span>

-   <span data-ttu-id="7c528-133">Use ponteiros inteligentes no código C++ para alocações de heap, bem como para recursos do Win32, como o **identificador** de kernel s.</span><span class="sxs-lookup"><span data-stu-id="7c528-133">Use smart pointers in C++ code both for heap allocations as well as for Win32 resources like kernel **HANDLE** s.</span></span> <span data-ttu-id="7c528-134">A biblioteca padrão C++ fornece a **classe \_ PTR automática** para alocações de heap.</span><span class="sxs-lookup"><span data-stu-id="7c528-134">The C++ Standard library provides the **auto\_ptr** class for heap allocations.</span></span> <span data-ttu-id="7c528-135">Para outros tipos de alocação, você precisará escrever suas próprias classes.</span><span class="sxs-lookup"><span data-stu-id="7c528-135">For other allocation types you will need to write your own classes.</span></span> <span data-ttu-id="7c528-136">A biblioteca do ATL fornece um conjunto avançado de classes para o gerenciamento automático de recursos para objetos de heap e identificadores de kernel</span><span class="sxs-lookup"><span data-stu-id="7c528-136">The ATL library provides a rich set of classes for automatic resource management for both heap objects and kernel handles</span></span>
-   <span data-ttu-id="7c528-137">Use recursos intrínsecos do compilador como **\_ com \_ PTR \_ t** para encapsular os ponteiros de interface com em "apontadores inteligentes" e auxiliar com a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="7c528-137">Use compiler intrinsic features like **\_com\_ptr\_t** to encapsulate your COM interface pointers into "smart pointers" and assist with reference counting.</span></span> <span data-ttu-id="7c528-138">Há classes semelhantes para outros tipos de dados COM: **\_ BSTR \_ t** e **\_ Variant \_ t**</span><span class="sxs-lookup"><span data-stu-id="7c528-138">There are similar classes for other COM data types: **\_bstr\_t** and **\_variant\_t**</span></span>
-   <span data-ttu-id="7c528-139">Monitore seu uso de memória incomum do código .NET.</span><span class="sxs-lookup"><span data-stu-id="7c528-139">Monitor your .NET code unusual memory usage.</span></span> <span data-ttu-id="7c528-140">O código gerenciado não é imune a vazamentos de memória.</span><span class="sxs-lookup"><span data-stu-id="7c528-140">Managed code is not immune to memory leaks.</span></span> <span data-ttu-id="7c528-141">Consulte ["rastrear vazamentos de memória gerenciada"](/archive/blogs/ricom/) sobre como encontrar vazamentos de GC</span><span class="sxs-lookup"><span data-stu-id="7c528-141">See ["Tracking down managed memory leaks"](/archive/blogs/ricom/) on how to find GC leaks</span></span>
-   <span data-ttu-id="7c528-142">Esteja atento aos padrões de vazamento no código do lado do cliente Web.</span><span class="sxs-lookup"><span data-stu-id="7c528-142">Be aware of leak patterns in web client-side code.</span></span> <span data-ttu-id="7c528-143">Referências circulares entre objetos COM e mecanismos de script como JScript podem causar grandes vazamentos em aplicativos Web.</span><span class="sxs-lookup"><span data-stu-id="7c528-143">Circular references between COM objects and scripting engines like JScript can cause large leaks in web applications.</span></span> <span data-ttu-id="7c528-144">["Compreendendo e resolvendo os padrões de vazamento do Internet Explorer"](/previous-versions/ms976398(v=msdn.10)) tem mais informações sobre esses tipos de vazamentos.</span><span class="sxs-lookup"><span data-stu-id="7c528-144">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10)) has more information on these kinds of leaks.</span></span> <span data-ttu-id="7c528-145">Você pode usar o detector de vazamento de memória do JavaScript para depurar vazamentos de memória em seu código.</span><span class="sxs-lookup"><span data-stu-id="7c528-145">You can use the JavaScript Memory Leak Detector to debug memory leaks in your code.</span></span> <span data-ttu-id="7c528-146">Embora o Windows Internet Explorer 8, que é fornecido com o Windows 7, reduz a maioria desses problemas, os navegadores mais antigos ainda são vulneráveis a esses bugs</span><span class="sxs-lookup"><span data-stu-id="7c528-146">While Windows Internet Explorer 8, which is shipping with Windows 7, mitigates most of these issues, older browsers are still vulnerable to these bugs</span></span>
-   <span data-ttu-id="7c528-147">Evite usar vários caminhos de saída de uma função.</span><span class="sxs-lookup"><span data-stu-id="7c528-147">Avoid using multiple exit paths from a function.</span></span> <span data-ttu-id="7c528-148">Alocações atribuídas a variáveis no escopo de função devem ser liberadas em um bloco específico no final da função</span><span class="sxs-lookup"><span data-stu-id="7c528-148">Allocations assigned to variables at function scope should be freed in one particular block at the end of the function</span></span>
-   <span data-ttu-id="7c528-149">Não use exceções em seu código sem liberar todas as variáveis locais em funções.</span><span class="sxs-lookup"><span data-stu-id="7c528-149">Do not use exceptions in your code without freeing all local variables in functions.</span></span> <span data-ttu-id="7c528-150">Se você usar exceções nativas, libere todas as suas alocações dentro do \_ \_ bloco finally.</span><span class="sxs-lookup"><span data-stu-id="7c528-150">If you use native exceptions, free all your allocations inside the \_\_finally block.</span></span> <span data-ttu-id="7c528-151">Se você usar exceções do C++, todas as alocações de heap e de identificador precisam ser encapsuladas em ponteiros inteligentes</span><span class="sxs-lookup"><span data-stu-id="7c528-151">If you use C++ exceptions, all your heap and handle allocations need to be wrapped in smart pointers</span></span>
-   <span data-ttu-id="7c528-152">Não descartar ou reinicializar um objeto [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) sem chamar a função [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)</span><span class="sxs-lookup"><span data-stu-id="7c528-152">Do not discard or reinitialize a [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) object without calling the [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) function</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="7c528-153">Links para recursos</span><span class="sxs-lookup"><span data-stu-id="7c528-153">Links to Resources</span></span>

<span data-ttu-id="7c528-154">*Padrões comuns de alocação:*</span><span class="sxs-lookup"><span data-stu-id="7c528-154">*Common Allocation Patterns:*</span></span>

-   [<span data-ttu-id="7c528-155">**Função de alocação de heap**</span><span class="sxs-lookup"><span data-stu-id="7c528-155">**Heap Allocation Function**</span></span>](/windows/win32/api/heapapi/nf-heapapi-heapalloc)
-   <span data-ttu-id="7c528-156">[**Função de alocação de memória**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-156">[**Memory Allocation Function**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="7c528-157">[**Novo operador (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-157">[**New Operator (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="7c528-158">**Função de alocação virtual**</span><span class="sxs-lookup"><span data-stu-id="7c528-158">**Virtual Allocation Function**</span></span>](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
-   [<span data-ttu-id="7c528-159">Objetos kernel</span><span class="sxs-lookup"><span data-stu-id="7c528-159">Kernel Objects</span></span>](../sysinfo/kernel-objects.md)
-   [<span data-ttu-id="7c528-160">Identificadores de objeto GDI</span><span class="sxs-lookup"><span data-stu-id="7c528-160">GDI Object Handles</span></span>](../sysinfo/gdi-objects.md)
-   [<span data-ttu-id="7c528-161">Identificadores de objeto da interface do usuário</span><span class="sxs-lookup"><span data-stu-id="7c528-161">User Interface Object Handles</span></span>](../sysinfo/user-objects.md)

<span data-ttu-id="7c528-162">*Ferramentas da Microsoft:*</span><span class="sxs-lookup"><span data-stu-id="7c528-162">*Microsoft Tools:*</span></span>

-   [<span data-ttu-id="7c528-163">Application Verifier</span><span class="sxs-lookup"><span data-stu-id="7c528-163">Application Verifier</span></span>](application-verifier.md)
-   [<span data-ttu-id="7c528-164">Ferramentas de Depuração para Windows</span><span class="sxs-lookup"><span data-stu-id="7c528-164">Debugging Tools for Windows</span></span>](/windows-hardware/drivers/debugger/)
-   [<span data-ttu-id="7c528-165">Heap de despejo do modo de usuário</span><span class="sxs-lookup"><span data-stu-id="7c528-165">User-Mode Dump Heap</span></span>](/windows-hardware/drivers/debugger/umdh)
-   [<span data-ttu-id="7c528-166">Ferramenta de captura, processamento e análise de rastreamento</span><span class="sxs-lookup"><span data-stu-id="7c528-166">Trace Capture, Processing, and Analysis Tool</span></span>](https://msdn.microsoft.com/performance/cc825801.aspx)
-   [<span data-ttu-id="7c528-167">Heap de depuração CRT</span><span class="sxs-lookup"><span data-stu-id="7c528-167">CRT Debug Heap</span></span>](/visualstudio/debugger/crt-debug-heap-details?view=vs-2015)

<span data-ttu-id="7c528-168">*Links adicionais:*</span><span class="sxs-lookup"><span data-stu-id="7c528-168">*Additional Links:*</span></span>

-   <span data-ttu-id="7c528-169">[**\_classe PTR automaticamente**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-169">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="7c528-170">[Classes de memória Active Template Library (ATL)](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-170">[Active Template Library (ATL) Memory Classes](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="7c528-171">[**\_\_objeto PTR \_ t**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-171">[**\_com\_ptr\_t Object**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="7c528-172">[**\_\_classe-t BSTR**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-172">[**\_bstr\_t Class**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="7c528-173">[**\_\_classe variante YT**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-173">[**\_variant\_yt Class**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="7c528-174">"Rastreando vazamentos de memória gerenciada"</span><span class="sxs-lookup"><span data-stu-id="7c528-174">"Tracking down managed memory leaks"</span></span>](/archive/blogs/ricom/)
-   <span data-ttu-id="7c528-175">["Compreendendo e resolvendo os padrões de vazamento do Internet Explorer"](/previous-versions/ms976398(v=msdn.10))</span><span class="sxs-lookup"><span data-stu-id="7c528-175">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10))</span></span>
-   [<span data-ttu-id="7c528-176">"Detector de vazamento de memória do JavaScript"</span><span class="sxs-lookup"><span data-stu-id="7c528-176">"JavaScript Memory Leak Detector"</span></span>](/archive/blogs/gpde/new-javascript-memory-leak-detector-from-our-team)
-   <span data-ttu-id="7c528-177">[Mitigação de vazamento de memória circular (em navegadores):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="7c528-177">[Circular Memory Leak Mitigation (in browsers):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span></span>
-   <span data-ttu-id="7c528-178">[**Instrução try-finally**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="7c528-178">[**try-finally statement**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="7c528-179">**Estrutura PROPVARIANT**</span><span class="sxs-lookup"><span data-stu-id="7c528-179">**PROPVARIANT Structure**</span></span>](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)
-   [<span data-ttu-id="7c528-180">**Função PropVariantClear**</span><span class="sxs-lookup"><span data-stu-id="7c528-180">**PropVariantClear Function**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)

 

 
