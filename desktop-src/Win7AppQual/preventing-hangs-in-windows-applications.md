---
description: Saiba como evitar interrupções em aplicativos do Windows para plataformas Windows 7 e Windows Server 2008 R2.
ms.assetid: 698a046b-1934-49cd-a717-d61e7e1ec534
title: Prevenção de interrupções em aplicativos do Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35a2d8fac95039f20c8c684c50138933c54750c3
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/06/2021
ms.locfileid: "104011896"
---
# <a name="preventing-hangs-in-windows-applications"></a><span data-ttu-id="34a22-103">Prevenção de interrupções em aplicativos do Windows</span><span class="sxs-lookup"><span data-stu-id="34a22-103">Preventing Hangs in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="34a22-104">Plataformas afetadas</span><span class="sxs-lookup"><span data-stu-id="34a22-104">Affected Platforms</span></span>

<span data-ttu-id="34a22-105">**Clientes** -Windows 7</span><span class="sxs-lookup"><span data-stu-id="34a22-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="34a22-106">**Servidores** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="34a22-106">**Servers** - Windows Server 2008 R2</span></span>  









## <a name="description"></a><span data-ttu-id="34a22-107">Descrição</span><span class="sxs-lookup"><span data-stu-id="34a22-107">Description</span></span>

<span data-ttu-id="34a22-108">**Travas – perspectiva do usuário**</span><span class="sxs-lookup"><span data-stu-id="34a22-108">**Hangs - User Perspective**</span></span>

<span data-ttu-id="34a22-109">Usuários como aplicativos responsivos.</span><span class="sxs-lookup"><span data-stu-id="34a22-109">Users like responsive applications.</span></span> <span data-ttu-id="34a22-110">Quando eles clicam em um menu, eles querem que o aplicativo reaja instantaneamente, mesmo que ele esteja imprimindo seu trabalho no momento.</span><span class="sxs-lookup"><span data-stu-id="34a22-110">When they click a menu, they want the application to react instantly, even if it is currently printing their work.</span></span> <span data-ttu-id="34a22-111">Quando eles salvam um documento longo em seu processador de palavras favoritas, eles querem continuar digitando enquanto o disco ainda está girando.</span><span class="sxs-lookup"><span data-stu-id="34a22-111">When they save a lengthy document in their favorite word processor, they want to continue typing while the disk is still spinning.</span></span> <span data-ttu-id="34a22-112">Os usuários obtêm impaciente bastante rapidamente quando o aplicativo não reage em tempo hábil à sua entrada.</span><span class="sxs-lookup"><span data-stu-id="34a22-112">Users get impatient rather quickly when the application does not react in a timely fashion to their input.</span></span>

<span data-ttu-id="34a22-113">Um programador pode reconhecer muitos motivos legítimos para que um aplicativo não responda instantaneamente à entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="34a22-113">A programmer might recognize many legitimate reasons for an application not to instantly respond to user input.</span></span> <span data-ttu-id="34a22-114">O aplicativo pode estar ocupado recalculando alguns dados ou simplesmente aguardando a conclusão de sua e/s de disco.</span><span class="sxs-lookup"><span data-stu-id="34a22-114">The application might be busy recalculating some data, or simply waiting for its disk I/O to complete.</span></span> <span data-ttu-id="34a22-115">No entanto, da pesquisa do usuário, sabemos que os usuários ficam irritativos e frustrados após apenas alguns segundos de falta de resposta.</span><span class="sxs-lookup"><span data-stu-id="34a22-115">However, from user research, we know that users get annoyed and frustrated after just a couple of seconds of unresponsiveness.</span></span> <span data-ttu-id="34a22-116">Após 5 segundos, eles tentarão encerrar um aplicativo suspenso.</span><span class="sxs-lookup"><span data-stu-id="34a22-116">After 5 seconds, they will try to terminate a hung application.</span></span> <span data-ttu-id="34a22-117">Ao lado de falhas, o aplicativo paralisa a fonte mais comum de interrupção do usuário ao trabalhar com aplicativos Win32.</span><span class="sxs-lookup"><span data-stu-id="34a22-117">Next to crashes, application hangs are the most common source of user disruption when working with Win32 applications.</span></span>

<span data-ttu-id="34a22-118">Há muitas causas raiz diferentes para o travamento do aplicativo, e nem todos eles se manifestam em uma interface do usuário sem resposta.</span><span class="sxs-lookup"><span data-stu-id="34a22-118">There are many different root causes for application hangs, and not all of them manifest themselves in an unresponsive UI.</span></span> <span data-ttu-id="34a22-119">No entanto, uma interface do usuário sem resposta é uma das experiências mais comuns de travamento, e esse cenário atualmente recebe a maior parte do suporte do sistema operacional para a detecção, bem como para a recuperação.</span><span class="sxs-lookup"><span data-stu-id="34a22-119">However, an unresponsive UI is one of the most common hang experiences, and this scenario currently receives the most operating system support for both detection as well as recovery.</span></span> <span data-ttu-id="34a22-120">O Windows detecta automaticamente, coleta informações de depuração e, opcionalmente, encerra ou reinicia os aplicativos suspensos.</span><span class="sxs-lookup"><span data-stu-id="34a22-120">Windows automatically detects, collects debug information, and optionally terminates or restarts hung applications.</span></span> <span data-ttu-id="34a22-121">Caso contrário, o usuário pode precisar reiniciar o computador para recuperar um aplicativo suspenso.</span><span class="sxs-lookup"><span data-stu-id="34a22-121">Otherwise, the user might have to restart the machine in order to recover a hung application.</span></span>

<span data-ttu-id="34a22-122">**Travas-perspectiva do sistema operacional**</span><span class="sxs-lookup"><span data-stu-id="34a22-122">**Hangs - Operating System Perspective**</span></span>

<span data-ttu-id="34a22-123">Quando um aplicativo (ou mais precisamente, um thread) cria uma janela na área de trabalho, ele entra em um contrato implícito com o Gerenciador de Janelas da Área de Trabalho (DWM) para processar mensagens de janela em tempo hábil.</span><span class="sxs-lookup"><span data-stu-id="34a22-123">When an application (or more accurately, a thread) creates a window on the desktop, it enters into an implicit contract with the Desktop Window Manager (DWM) to process window messages in a timely fashion.</span></span> <span data-ttu-id="34a22-124">O DWM posta mensagens (entrada de teclado/mouse e mensagens de outras janelas, bem como a si mesma) na fila de mensagens específica do thread.</span><span class="sxs-lookup"><span data-stu-id="34a22-124">The DWM posts messages (keyboard/mouse input and messages from other windows, as well as itself) into the thread-specific message queue.</span></span> <span data-ttu-id="34a22-125">O thread recupera e despacha essas mensagens por meio de sua fila de mensagens.</span><span class="sxs-lookup"><span data-stu-id="34a22-125">The thread retrieves and dispatches those messages via its message queue.</span></span> <span data-ttu-id="34a22-126">Se o thread não atender à fila chamando GetMessage (), as mensagens não serão processadas e a janela travará: ela não poderá redesenhar nem aceitar a entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="34a22-126">If the thread does not service the queue by calling GetMessage(), messages are not processed, and the window hangs: it can neither redraw nor can it accept input from the user.</span></span> <span data-ttu-id="34a22-127">O sistema operacional detecta esse estado anexando um temporizador a mensagens pendentes na fila de mensagens.</span><span class="sxs-lookup"><span data-stu-id="34a22-127">The operating system detects this state by attaching a timer to pending messages in the message queue.</span></span> <span data-ttu-id="34a22-128">Se uma mensagem não tiver sido recuperada em 5 segundos, o DWM declarará a janela a ser suspensa.</span><span class="sxs-lookup"><span data-stu-id="34a22-128">If a message has not been retrieved within 5 seconds, the DWM declares the window to be hung.</span></span> <span data-ttu-id="34a22-129">Você pode consultar esse estado de janela em particular por meio da API IsHungAppWindow ().</span><span class="sxs-lookup"><span data-stu-id="34a22-129">You can query this particular window state via the IsHungAppWindow() API.</span></span>

<span data-ttu-id="34a22-130">A detecção é apenas a primeira etapa.</span><span class="sxs-lookup"><span data-stu-id="34a22-130">Detection is only the first step.</span></span> <span data-ttu-id="34a22-131">Neste ponto, o usuário ainda não pode até encerrar o aplicativo – clicar no botão X (fechar) resultaria em uma mensagem de fechamento do WM \_ , que estaria presa na fila de mensagens, assim como qualquer outra mensagem.</span><span class="sxs-lookup"><span data-stu-id="34a22-131">At this point, the user still cannot even terminate the application - clicking the X (Close) button would result in a WM\_CLOSE message, which would be stuck in the message queue just like any other message.</span></span> <span data-ttu-id="34a22-132">O Gerenciador de Janelas da Área de Trabalho ajuda por ocultar e, em seguida, substituir a janela suspensa por uma cópia ' fantasma ' exibindo um bitmap da área do cliente anterior da janela original (e adicionando "não respondendo" à barra de título).</span><span class="sxs-lookup"><span data-stu-id="34a22-132">The Desktop Window Manager assists by seamlessly hiding and then replacing the hung window with a 'ghost' copy displaying a bitmap of the original window's previous client area (and adding "Not Responding" to the title bar).</span></span> <span data-ttu-id="34a22-133">Desde que o thread da janela original não recupere as mensagens, o DWM gerenciará ambas as janelas simultaneamente, mas permitirá que o usuário interaja apenas com a cópia fantasma.</span><span class="sxs-lookup"><span data-stu-id="34a22-133">As long as the original window's thread does not retrieve messages, the DWM manages both windows simultaneously, but allows the user to interact only with the ghost copy.</span></span> <span data-ttu-id="34a22-134">Usando essa janela fantasma, o usuário só pode mover, minimizar e, mais importante, fechar o aplicativo sem resposta, mas não alterar seu estado interno.</span><span class="sxs-lookup"><span data-stu-id="34a22-134">Using this ghost window, the user can only move, minimize, and - most importantly - close the unresponsive application, but not change its internal state.</span></span>

<span data-ttu-id="34a22-135">A experiência de fantasma inteira tem esta aparência:</span><span class="sxs-lookup"><span data-stu-id="34a22-135">The whole ghost experience looks like this:</span></span>

![Captura de tela que mostra a caixa de diálogo ' o bloco de notas não está respondendo '.](images/preventinghangs-ghostwindow.gif)

<span data-ttu-id="34a22-137">A Gerenciador de Janelas da Área de Trabalho faz uma última coisa; Ele se integra com Relatório de Erros do Windows, permitindo que o usuário não apenas feche e, opcionalmente, reinicie o aplicativo, mas também envie dados de depuração valiosos de volta à Microsoft.</span><span class="sxs-lookup"><span data-stu-id="34a22-137">The Desktop Window Manager does one last thing; it integrates with Windows Error Reporting, allowing the user to not only close and optionally restart the application, but also send valuable debugging data back to Microsoft.</span></span> <span data-ttu-id="34a22-138">Você pode obter esses dados de suspensão para seus próprios aplicativos inscrevendo-se no site do winqual.</span><span class="sxs-lookup"><span data-stu-id="34a22-138">You can get this hang data for your own applications by signing up at the Winqual website.</span></span>

<span data-ttu-id="34a22-139">O Windows 7 adicionou um novo recurso a essa experiência.</span><span class="sxs-lookup"><span data-stu-id="34a22-139">Windows 7 added one new feature to this experience.</span></span> <span data-ttu-id="34a22-140">O sistema operacional analisa o aplicativo suspenso e, em determinadas circunstâncias, dá ao usuário a opção de cancelar uma operação de bloqueio e fazer com que o aplicativo responda novamente.</span><span class="sxs-lookup"><span data-stu-id="34a22-140">The operating system analyzes the hung application and, under certain circumstances, gives the user the option to cancel a blocking operation and make the application responsive again.</span></span> <span data-ttu-id="34a22-141">A implementação atual dá suporte ao cancelamento de bloqueio de chamadas de soquete; mais operações serão canceladas pelo usuário em versões futuras.</span><span class="sxs-lookup"><span data-stu-id="34a22-141">The current implementation supports cancellation of blocking Socket calls; more operations will be user-cancelable in future releases.</span></span>

<span data-ttu-id="34a22-142">Para integrar seu aplicativo com a experiência de recuperação de suspensão e tirar o máximo proveito dos dados disponíveis, siga estas etapas:</span><span class="sxs-lookup"><span data-stu-id="34a22-142">To integrate your application with the hang recovery experience and to make the most out of the available data, follow these steps:</span></span>

-   <span data-ttu-id="34a22-143">Certifique-se de que seu aplicativo seja registrado para reinicialização e recuperação, fazendo com que o usuário fique mais livre possível.</span><span class="sxs-lookup"><span data-stu-id="34a22-143">Ensure that your application registers for restart and recovery, making a hang as pain-free as possible to the user.</span></span> <span data-ttu-id="34a22-144">Um aplicativo registrado corretamente pode ser reiniciado automaticamente com a maioria de seus dados não salvos intactos.</span><span class="sxs-lookup"><span data-stu-id="34a22-144">A properly registered application can automatically restart with most of its unsaved data intact.</span></span> <span data-ttu-id="34a22-145">Isso funciona para travamentos e falhas do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="34a22-145">This works for both application hangs and crashes.</span></span>
-   <span data-ttu-id="34a22-146">Obtenha informações de frequência, bem como depuração de dados para seus aplicativos suspensos e com falha do site winqual.</span><span class="sxs-lookup"><span data-stu-id="34a22-146">Get frequency information as well as debugging data for your hung and crashed applications from the Winqual website.</span></span> <span data-ttu-id="34a22-147">Você pode usar essas informações mesmo durante sua versão beta para melhorar seu código.</span><span class="sxs-lookup"><span data-stu-id="34a22-147">You can use this information even during your Beta to improve your code.</span></span> <span data-ttu-id="34a22-148">Consulte "introdução ao Relatório de Erros do Windows" para obter uma breve visão geral.</span><span class="sxs-lookup"><span data-stu-id="34a22-148">See "Introducing Windows Error Reporting" for a brief overview.</span></span>
-   <span data-ttu-id="34a22-149">Você pode desabilitar o recurso de fantasma em seu aplicativo por meio de uma chamada para DisableProcessWindowsGhosting ().</span><span class="sxs-lookup"><span data-stu-id="34a22-149">You can disable the ghosting feature in your application via a call to DisableProcessWindowsGhosting ().</span></span> <span data-ttu-id="34a22-150">No entanto, isso impede que o usuário médio feche e reinicie um aplicativo suspenso e, muitas vezes, termina em uma reinicialização.</span><span class="sxs-lookup"><span data-stu-id="34a22-150">However, this prevents the average user from closing and restarting a hung application and often ends in a reboot.</span></span>

<span data-ttu-id="34a22-151">**Travas – perspectiva do desenvolvedor**</span><span class="sxs-lookup"><span data-stu-id="34a22-151">**Hangs - Developer Perspective**</span></span>

<span data-ttu-id="34a22-152">O sistema operacional define um bloqueio de aplicativo como um thread de interface do usuário que não processou mensagens por pelo menos 5 segundos.</span><span class="sxs-lookup"><span data-stu-id="34a22-152">The operating system defines an application hang as a UI thread that has not processed messages for at least 5 seconds.</span></span> <span data-ttu-id="34a22-153">Bugs óbvios causam algumas travas, por exemplo, um thread aguardando um evento que nunca é sinalizado e dois threads que mantêm um bloqueio e tentando adquirir os outros.</span><span class="sxs-lookup"><span data-stu-id="34a22-153">Obvious bugs cause some hangs, for example, a thread waiting for an event that is never signaled, and two threads each holding a lock and trying to acquire the others.</span></span> <span data-ttu-id="34a22-154">Você pode corrigir esses bugs sem muito esforço.</span><span class="sxs-lookup"><span data-stu-id="34a22-154">You can fix those bugs without too much effort.</span></span> <span data-ttu-id="34a22-155">No entanto, muitos travamentos não são tão claros.</span><span class="sxs-lookup"><span data-stu-id="34a22-155">However, many hangs are not so clear.</span></span> <span data-ttu-id="34a22-156">Sim, o thread da interface do usuário não está recuperando mensagens, mas está igualmente ocupado fazendo outro trabalho "importante" e, eventualmente, voltará a processar mensagens.</span><span class="sxs-lookup"><span data-stu-id="34a22-156">Yes, the UI thread is not retrieving messages - but it is equally busy doing other 'important' work and will eventually come back to processing messages.</span></span>

<span data-ttu-id="34a22-157">No entanto, o usuário percebe isso como um bug.</span><span class="sxs-lookup"><span data-stu-id="34a22-157">However, the user perceives this as a bug.</span></span> <span data-ttu-id="34a22-158">O design deve corresponder às expectativas do usuário.</span><span class="sxs-lookup"><span data-stu-id="34a22-158">The design should match the user's expectations.</span></span> <span data-ttu-id="34a22-159">Se o projeto do aplicativo leva a um aplicativo sem resposta, o design precisará ser alterado.</span><span class="sxs-lookup"><span data-stu-id="34a22-159">If the application's design leads to an unresponsive application, the design will have to change.</span></span> <span data-ttu-id="34a22-160">Finalmente, e isso é importante, a falta de resposta não pode ser corrigida como um bug de código; Ele requer trabalho inicial durante a fase de design.</span><span class="sxs-lookup"><span data-stu-id="34a22-160">Finally, and this is important, unresponsiveness cannot be fixed like a code bug; it requires upfront work during the design phase.</span></span> <span data-ttu-id="34a22-161">Tentar adaptar a base de código existente de um aplicativo para tornar a interface do usuário mais responsiva geralmente é muito cara.</span><span class="sxs-lookup"><span data-stu-id="34a22-161">Trying to retrofit an application's existing code base to make the UI more responsive is often too expensive.</span></span> <span data-ttu-id="34a22-162">As diretrizes de design a seguir podem ajudar.</span><span class="sxs-lookup"><span data-stu-id="34a22-162">The following design guidelines might help.</span></span>

-   <span data-ttu-id="34a22-163">Tornar a capacidade de resposta da interface do usuário um requisito de nível superior; o usuário deve sempre se sentir no controle do seu aplicativo</span><span class="sxs-lookup"><span data-stu-id="34a22-163">Make UI responsiveness a top-level requirement; the user should always feel in control of your application</span></span>
-   <span data-ttu-id="34a22-164">Verifique se os usuários podem cancelar operações que levam mais de um segundo para serem concluídas e/ou que as operações podem ser concluídas em segundo plano; fornecer a interface do usuário de progresso apropriada, se necessário</span><span class="sxs-lookup"><span data-stu-id="34a22-164">Ensure that users can cancel operations that take longer than one second to complete and/or that operations can complete in the background; provide appropriate progress UI if necessary</span></span>

![Captura de tela que mostra a caixa de diálogo ' copiando itens '.](images/preventinghangs-progressbar.gif)

-   <span data-ttu-id="34a22-166">Enfileirar operações de execução longa ou bloqueio como tarefas em segundo plano (isso requer um mecanismo de mensagens bem pensado para informar o thread da interface do usuário quando o trabalho for concluído)</span><span class="sxs-lookup"><span data-stu-id="34a22-166">Queue long-running or blocking operations as background tasks (this requires a well-thought out messaging mechanism to inform the UI thread when work has been completed)</span></span>
-   <span data-ttu-id="34a22-167">Mantenha o código para threads de interface do usuário simples; remover o máximo possível de chamadas à API de bloqueio</span><span class="sxs-lookup"><span data-stu-id="34a22-167">Keep the code for UI threads simple; remove as many blocking API calls as possible</span></span>
-   <span data-ttu-id="34a22-168">Mostrar janelas e caixas de diálogo somente quando estiverem prontas e totalmente operacionais.</span><span class="sxs-lookup"><span data-stu-id="34a22-168">Show windows and dialogs only when they are ready and fully operational.</span></span> <span data-ttu-id="34a22-169">Se a caixa de diálogo precisar exibir informações com muitos recursos para calcular, mostre algumas informações genéricas primeiro e atualize-as imediatamente quando mais dados forem disponibilizados.</span><span class="sxs-lookup"><span data-stu-id="34a22-169">If the dialog needs to display information that is too resource-intensive to calculate, show some generic information first and update it on the fly when more data becomes available.</span></span> <span data-ttu-id="34a22-170">Um bom exemplo é a caixa de diálogo Propriedades da pasta do Windows Explorer.</span><span class="sxs-lookup"><span data-stu-id="34a22-170">A good example is the folder properties dialog from Windows Explorer.</span></span> <span data-ttu-id="34a22-171">Ele precisa exibir o tamanho total da pasta, informações que não estão prontamente disponíveis no sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="34a22-171">It needs to display the folder's total size, information that is not readily available from the file system.</span></span> <span data-ttu-id="34a22-172">A caixa de diálogo aparece imediatamente e o campo "tamanho" é atualizado de um thread de trabalho:</span><span class="sxs-lookup"><span data-stu-id="34a22-172">The dialog shows up right away and the "size" field is updated from a worker thread:</span></span>

![Captura de tela que mostra a página ' geral ' das propriedades do Windows com o texto ' tamanho ', ' tamanho em disco ' e ' contém ' circulado.](images/preventinghangs-updatingdialog.gif)

<span data-ttu-id="34a22-174">Infelizmente, não há uma maneira simples de criar e escrever um aplicativo responsivo.</span><span class="sxs-lookup"><span data-stu-id="34a22-174">Unfortunately, there is no simple way to design and write a responsive application.</span></span> <span data-ttu-id="34a22-175">O Windows não fornece uma estrutura assíncrona simples que permitisse o agendamento fácil de operações de bloqueio ou execução demorada.</span><span class="sxs-lookup"><span data-stu-id="34a22-175">Windows does not provide a simple asynchronous framework that would allow for easy scheduling of blocking or long-running operations.</span></span> <span data-ttu-id="34a22-176">As seções a seguir introduzem algumas das práticas recomendadas para evitar interrupções e destacar algumas das armadilhas comuns.</span><span class="sxs-lookup"><span data-stu-id="34a22-176">The following sections introduce some of the best practices in preventing hangs and highlight some of the common pitfalls.</span></span>

## <a name="best-practices"></a><span data-ttu-id="34a22-177">Práticas Recomendadas</span><span class="sxs-lookup"><span data-stu-id="34a22-177">Best Practices</span></span>

<span data-ttu-id="34a22-178">**Mantenha o thread da interface do usuário simples**</span><span class="sxs-lookup"><span data-stu-id="34a22-178">**Keep the UI Thread Simple**</span></span>

<span data-ttu-id="34a22-179">A principal responsabilidade do thread de interface do usuário é recuperar e distribuir mensagens.</span><span class="sxs-lookup"><span data-stu-id="34a22-179">The UI thread's primary responsibility is to retrieve and dispatch messages.</span></span> <span data-ttu-id="34a22-180">Qualquer outro tipo de trabalho apresenta o risco de desligar as janelas pertencentes a esse thread.</span><span class="sxs-lookup"><span data-stu-id="34a22-180">Any other kind of work introduces the risk of hanging the windows owned by this thread.</span></span>

<span data-ttu-id="34a22-181">**Coincide**</span><span class="sxs-lookup"><span data-stu-id="34a22-181">**Do:**</span></span>

-   <span data-ttu-id="34a22-182">Mover algoritmos com uso intensivo de recursos ou não vinculados que resultam em operações de longa execução para threads de trabalho</span><span class="sxs-lookup"><span data-stu-id="34a22-182">Move resource-intensive or unbounded algorithms that result in long-running operations to worker threads</span></span>
-   <span data-ttu-id="34a22-183">Identifique quantas chamadas de função de bloqueio forem possíveis e tente movê-las para threads de trabalho; qualquer função que chame em outra DLL deve ser suspeita</span><span class="sxs-lookup"><span data-stu-id="34a22-183">Identify as many blocking function calls as possible and try to move them to worker threads; any function calling into another DLL should be suspicious</span></span>
-   <span data-ttu-id="34a22-184">Tome um esforço extra para remover todas as chamadas de API de rede e e/s de arquivo do seu thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="34a22-184">Make an extra effort to remove all file I/O and networking API calls from your worker thread.</span></span> <span data-ttu-id="34a22-185">Essas funções podem ser bloqueadas por muitos segundos, se não forem minutos.</span><span class="sxs-lookup"><span data-stu-id="34a22-185">These functions can block for many seconds if not minutes.</span></span> <span data-ttu-id="34a22-186">Se você precisar fazer qualquer tipo de e/s no thread da interface do usuário, considere O uso de e/s assíncrona</span><span class="sxs-lookup"><span data-stu-id="34a22-186">If you need to do any kind of I/O in the UI thread, consider using asynchronous I/O</span></span>
-   <span data-ttu-id="34a22-187">Lembre-se de que seu thread de interface do usuário também está atendendo a todos os servidores COM de Sta (single-threaded apartment) hospedados pelo seu processo; Se você fizer uma chamada de bloqueio, esses servidores COM deixarão de responder até que você atenda à fila de mensagens novamente</span><span class="sxs-lookup"><span data-stu-id="34a22-187">Be aware that your UI thread is also servicing all single-threaded apartment (STA) COM servers hosted by your process; if you make a blocking call, these COM servers will be unresponsive until you service the message queue again</span></span>

<span data-ttu-id="34a22-188">**Não:**</span><span class="sxs-lookup"><span data-stu-id="34a22-188">**Do not:**</span></span>

-   <span data-ttu-id="34a22-189">Aguardar qualquer objeto de kernel (como evento ou mutex) por mais de um período muito curto; Se você precisar esperar, considere o uso de MsgWaitForMultipleObjects (), que será desbloqueado quando uma nova mensagem chegar</span><span class="sxs-lookup"><span data-stu-id="34a22-189">Wait on any kernel object (like Event or Mutex) for more than a very short amount of time; if you have to wait at all, consider using MsgWaitForMultipleObjects(), which will unblock when a new message arrives</span></span>
-   <span data-ttu-id="34a22-190">Compartilhe a fila de mensagens da janela de um thread com outro thread usando a função AttachThreadInput ().</span><span class="sxs-lookup"><span data-stu-id="34a22-190">Share a thread's window message queue with another thread by using the AttachThreadInput() function.</span></span> <span data-ttu-id="34a22-191">Não é muito difícil sincronizar corretamente o acesso à fila, também pode impedir que o sistema operacional Windows detecte corretamente uma janela suspensa</span><span class="sxs-lookup"><span data-stu-id="34a22-191">It is not only extremely difficult to properly synchronize access to the queue, it also can prevent the Windows operating system from properly detecting a hung window</span></span>
-   <span data-ttu-id="34a22-192">Use TerminateThread () em qualquer um de seus threads de trabalho.</span><span class="sxs-lookup"><span data-stu-id="34a22-192">Use TerminateThread() on any of your worker threads.</span></span> <span data-ttu-id="34a22-193">Encerrar um thread dessa maneira não permitirá que ele libere bloqueios ou eventos de sinal e possa resultar facilmente em objetos de sincronização órfãos</span><span class="sxs-lookup"><span data-stu-id="34a22-193">Terminating a thread in this way will not allow it to release locks or signal events and can easily result in orphaned synchronization objects</span></span>
-   <span data-ttu-id="34a22-194">Chame qualquer código "desconhecido" do seu thread de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="34a22-194">Call into any 'unknown' code from your UI thread.</span></span> <span data-ttu-id="34a22-195">Isso é especialmente verdadeiro se seu aplicativo tiver um modelo de extensibilidade; Não há nenhuma garantia de que o código de terceiros siga suas diretrizes de capacidade de resposta</span><span class="sxs-lookup"><span data-stu-id="34a22-195">This is especially true if your application has an extensibility model; there is no guarantee that 3rd-party code follows your responsiveness guidelines</span></span>
-   <span data-ttu-id="34a22-196">Faça qualquer tipo de bloqueio de chamada de difusão; SendMessage ( \_ difusão HWND) coloca você no mercê de todos os aplicativos mal escritos em execução no momento</span><span class="sxs-lookup"><span data-stu-id="34a22-196">Make any kind of blocking broadcast call; SendMessage(HWND\_BROADCAST) puts you at the mercy of every ill-written application currently running</span></span>

<span data-ttu-id="34a22-197">**Implementar padrões assíncronos**</span><span class="sxs-lookup"><span data-stu-id="34a22-197">**Implement Asynchronous Patterns**</span></span>

<span data-ttu-id="34a22-198">Remover operações de execução longa ou de bloqueio do thread da interface do usuário requer a implementação de uma estrutura assíncrona que permita o descarregamento dessas operações para threads de trabalho.</span><span class="sxs-lookup"><span data-stu-id="34a22-198">Removing long-running or blocking operations from the UI thread requires implementing an asynchronous framework that allows offloading those operations to worker threads.</span></span>

<span data-ttu-id="34a22-199">**Coincide**</span><span class="sxs-lookup"><span data-stu-id="34a22-199">**Do:**</span></span>

-   <span data-ttu-id="34a22-200">Use APIs assíncronas de mensagem de janela em seu thread de interface do usuário, especialmente substituindo SendMessage por um de seus pares sem bloqueio: SendNotifyMessage ou SendMessageCallback</span><span class="sxs-lookup"><span data-stu-id="34a22-200">Use asynchronous window message APIs in your UI thread, especially by replacing SendMessage with one of its non-blocking peers: PostMessage, SendNotifyMessage, or SendMessageCallback</span></span>
-   <span data-ttu-id="34a22-201">Use threads em segundo plano para executar tarefas de execução longa ou de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="34a22-201">Use background threads to execute long-running or blocking tasks.</span></span> <span data-ttu-id="34a22-202">Usar a nova API do pool de threads para implementar seus threads de trabalho</span><span class="sxs-lookup"><span data-stu-id="34a22-202">Use the new thread pool API to implement your worker threads</span></span>
-   <span data-ttu-id="34a22-203">Fornecer suporte ao cancelamento para tarefas em segundo plano de execução longa.</span><span class="sxs-lookup"><span data-stu-id="34a22-203">Provide cancellation support for long-running background tasks.</span></span> <span data-ttu-id="34a22-204">Para bloquear operações de e/s, use o cancelamento de e/s, mas somente como último recurso; Não é fácil cancelar a operação ' direita '</span><span class="sxs-lookup"><span data-stu-id="34a22-204">For blocking I/O operations, use I/O cancellation, but only as a last resort; it's not easy to cancel the 'right' operation</span></span>
-   <span data-ttu-id="34a22-205">Implementar um design assíncrono para código gerenciado usando o padrão IAsyncResult ou usando eventos</span><span class="sxs-lookup"><span data-stu-id="34a22-205">Implement an asynchronous design for managed code by using the IAsyncResult pattern or by using Events</span></span>

<span data-ttu-id="34a22-206">**Usar os bloqueios com sabedoria**</span><span class="sxs-lookup"><span data-stu-id="34a22-206">**Use Locks Wisely**</span></span>

<span data-ttu-id="34a22-207">Seu aplicativo ou DLL precisa de bloqueios para sincronizar o acesso às suas estruturas de dados internas.</span><span class="sxs-lookup"><span data-stu-id="34a22-207">Your application or DLL needs locks to synchronize access to its internal data structures.</span></span> <span data-ttu-id="34a22-208">O uso de vários bloqueios aumenta o paralelismo e torna seu aplicativo mais responsivo.</span><span class="sxs-lookup"><span data-stu-id="34a22-208">Using multiple locks increases parallelism and makes your application more responsive.</span></span> <span data-ttu-id="34a22-209">No entanto, o uso de vários bloqueios também aumenta a chance de adquirir esses bloqueios em diferentes ordens e causar o deadlock de seus threads.</span><span class="sxs-lookup"><span data-stu-id="34a22-209">However, using multiple locks also increases the chance of acquiring those locks in different orders and causing your threads to deadlock.</span></span> <span data-ttu-id="34a22-210">Se dois threads mantiverem um bloqueio e, em seguida, tentarem adquirir o bloqueio do outro thread, suas operações irão formar uma espera circular que bloqueia qualquer progresso de encaminhamento para esses threads.</span><span class="sxs-lookup"><span data-stu-id="34a22-210">If two threads each hold a lock and then try to acquire the other thread's lock, their operations will form a circular wait that blocks any forward progress for these threads.</span></span> <span data-ttu-id="34a22-211">Você pode evitar esse deadlock somente garantindo que todos os threads no aplicativo sempre adquirem todos os bloqueios na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="34a22-211">You can avoid this deadlock only by ensuring that all threads in the application always acquire all locks in the same order.</span></span> <span data-ttu-id="34a22-212">No entanto, nem sempre é fácil adquirir bloqueios na ordem ' direita '.</span><span class="sxs-lookup"><span data-stu-id="34a22-212">However, it isn't always easy to acquire locks in the 'right' order.</span></span> <span data-ttu-id="34a22-213">Os componentes de software podem ser compostos, mas as aquisições de bloqueio não podem.</span><span class="sxs-lookup"><span data-stu-id="34a22-213">Software components can be composed, but lock acquisitions cannot.</span></span> <span data-ttu-id="34a22-214">Se o seu código chamar algum outro componente, os bloqueios desse componente agora se tornarão parte de sua ordem de bloqueio implícita, mesmo que você não tenha visibilidade nesses bloqueios.</span><span class="sxs-lookup"><span data-stu-id="34a22-214">If your code calls some other component, that component's locks now become part of your implicit lock order - even if you have no visibility into those locks.</span></span>

<span data-ttu-id="34a22-215">As coisas ficam ainda mais difíceis porque as operações de bloqueio incluem muito mais do que as funções usuais para seções críticas, mutexes e outros bloqueios tradicionais.</span><span class="sxs-lookup"><span data-stu-id="34a22-215">Things get even harder because locking operations include far more than the usual functions for Critical Sections, Mutexes, and other traditional locks.</span></span> <span data-ttu-id="34a22-216">Qualquer chamada de bloqueio que cruza os limites de thread tem propriedades de sincronização que podem resultar em um deadlock.</span><span class="sxs-lookup"><span data-stu-id="34a22-216">Any blocking call that crosses thread boundaries has synchronization properties that can result in a deadlock.</span></span> <span data-ttu-id="34a22-217">O thread de chamada executa uma operação com a semântica ' Acquire ' e não pode desbloquear até que o thread de destino seja chamado.</span><span class="sxs-lookup"><span data-stu-id="34a22-217">The calling thread performs an operation with 'acquire' semantics and cannot unblock until the target thread 'releases' that call.</span></span> <span data-ttu-id="34a22-218">Algumas funções user32 (por exemplo, SendMessage), bem como muitas chamadas COM de bloqueio se enquadram nessa categoria.</span><span class="sxs-lookup"><span data-stu-id="34a22-218">Quite a few User32 functions (for example SendMessage), as well as many blocking COM calls fall into this category.</span></span>

<span data-ttu-id="34a22-219">Pior ainda, o sistema operacional tem seu próprio bloqueio específico de processo interno que às vezes é mantido enquanto seu código é executado.</span><span class="sxs-lookup"><span data-stu-id="34a22-219">Worse yet, the operating system has its own internal process-specific lock that sometimes is held while your code executes.</span></span> <span data-ttu-id="34a22-220">Esse bloqueio é adquirido quando as DLLs são carregadas no processo e, portanto, são chamadas de "bloqueio de carregador".</span><span class="sxs-lookup"><span data-stu-id="34a22-220">This lock is acquired when DLLs are loaded into the process, and is therefore called the 'loader lock.'</span></span> <span data-ttu-id="34a22-221">A função DllMain sempre é executada sob o bloqueio do carregador; Se você adquirir bloqueios em DllMain (e não deve), será necessário fazer com que o carregador trave a parte da sua ordem de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="34a22-221">The DllMain function always executes under the loader lock; if you acquire any locks in DllMain (and you should not), you need to make the loader lock part of your lock order.</span></span> <span data-ttu-id="34a22-222">Chamar determinadas APIs do Win32 também pode adquirir o bloqueio de carregador em suas funções de nome, como LoadLibraryEx, GetModuleHandle e especialmente CoCreateInstance.</span><span class="sxs-lookup"><span data-stu-id="34a22-222">Calling certain Win32 APIs might also acquire the loader lock on your behalf - functions like LoadLibraryEx, GetModuleHandle, and especially CoCreateInstance.</span></span>

<span data-ttu-id="34a22-223">Para reunir tudo isso, examine o código de exemplo abaixo.</span><span class="sxs-lookup"><span data-stu-id="34a22-223">To tie all of this together, look at the sample code below.</span></span> <span data-ttu-id="34a22-224">Essa função adquire vários objetos de sincronização e define implicitamente uma ordem de bloqueio, algo que não é necessariamente óbvio na inspeção de cursores.</span><span class="sxs-lookup"><span data-stu-id="34a22-224">This function acquires multiple synchronization objects and implicitly defines a lock order, something that is not necessarily obvious on cursory inspection.</span></span> <span data-ttu-id="34a22-225">Na entrada da função, o código adquire uma seção crítica e não a libera até que a função saia, tornando-a o nó superior em nossa hierarquia de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="34a22-225">On function entry, the code acquires a Critical Section and does not release it until function exit, thereby making it the top node in our lock hierarchy.</span></span> <span data-ttu-id="34a22-226">Em seguida, o código chama a função do Win32 LoadIcon (), que, nos bastidores, pode chamar o carregador do sistema operacional para carregar esse binário.</span><span class="sxs-lookup"><span data-stu-id="34a22-226">The code then calls the Win32 function LoadIcon(), which under the covers might call into the Operating System Loader to load this binary.</span></span> <span data-ttu-id="34a22-227">Essa operação adquiriria o bloqueio de carregador, que agora também se torna parte dessa hierarquia de bloqueio (verifique se a função DllMain não adquire o \_ bloqueio g cs).</span><span class="sxs-lookup"><span data-stu-id="34a22-227">This operation would acquire the loader lock, which now also becomes part of this lock hierarchy (make sure the DllMain function does not acquire the g\_cs lock).</span></span> <span data-ttu-id="34a22-228">Em seguida, o código chama SendMessage (), uma operação de bloqueio entre threads, que não será retornada, a menos que o thread da interface do usuário responda.</span><span class="sxs-lookup"><span data-stu-id="34a22-228">Next the code calls SendMessage(), a blocking cross-thread operation, which will not return unless the UI thread responds.</span></span> <span data-ttu-id="34a22-229">Novamente, verifique se o thread da interface do usuário nunca adquire o g \_ cs.</span><span class="sxs-lookup"><span data-stu-id="34a22-229">Again, make sure that the UI thread never acquires g\_cs.</span></span>

```
bool foo::bar (char* buffer)  
{  
      EnterCriticalSection(&g_cs);  
      // Get 'new data' icon  
      this.m_Icon = LoadIcon(hInst, MAKEINTRESOURCE(5));  
      // Let UI thread know to update icon SendMessage(hWnd,WM_COMMAND,IDM_ICON,NULL);  
      this.m_Params = GetParams(buffer);  
      LeaveCriticalSection(&g_cs);
      return true;  
}  
```

<span data-ttu-id="34a22-230">Observando esse código, parece claro que tornamos implicitamente g \_ cs o bloqueio de nível superior em nossa hierarquia de bloqueio, mesmo se quiséssemos apenas sincronizar o acesso às variáveis de membro de classe.</span><span class="sxs-lookup"><span data-stu-id="34a22-230">Looking at this code it seems clear that we implicitly made g\_cs the top-level lock in our lock hierarchy, even if we only wanted to synchronize access to the class member variables.</span></span>

<span data-ttu-id="34a22-231">**Coincide**</span><span class="sxs-lookup"><span data-stu-id="34a22-231">**Do:**</span></span>

-   <span data-ttu-id="34a22-232">Crie uma hierarquia de bloqueio e obedeça a ela.</span><span class="sxs-lookup"><span data-stu-id="34a22-232">Design a lock hierarchy and obey it.</span></span> <span data-ttu-id="34a22-233">Adicione todos os bloqueios necessários.</span><span class="sxs-lookup"><span data-stu-id="34a22-233">Add all the necessary locks.</span></span> <span data-ttu-id="34a22-234">Há muito mais primitivos de sincronização do que apenas mutex e CriticalSections; todos eles precisam ser incluídos.</span><span class="sxs-lookup"><span data-stu-id="34a22-234">There are many more synchronization primitives than just Mutex and CriticalSections; they all need to be included.</span></span> <span data-ttu-id="34a22-235">Inclua o bloqueio de carregador em sua hierarquia se você usar bloqueios em DllMain ()</span><span class="sxs-lookup"><span data-stu-id="34a22-235">Include the loader lock in your hierarchy if you take any locks in DllMain()</span></span>
-   <span data-ttu-id="34a22-236">Concorde com o protocolo de bloqueio com suas dependências.</span><span class="sxs-lookup"><span data-stu-id="34a22-236">Agree on locking protocol with your dependencies.</span></span> <span data-ttu-id="34a22-237">Qualquer código que seu aplicativo chama ou que possa chamar seu aplicativo precisa compartilhar a mesma hierarquia de bloqueio</span><span class="sxs-lookup"><span data-stu-id="34a22-237">Any code your application calls or that might call your application needs to share the same lock hierarchy</span></span>
-   <span data-ttu-id="34a22-238">Bloquear estruturas de dados não funções.</span><span class="sxs-lookup"><span data-stu-id="34a22-238">Lock data structures not functions.</span></span> <span data-ttu-id="34a22-239">Mova as aquisições de bloqueios para longe dos pontos de entrada de função e proteja apenas o acesso a dados com bloqueios.</span><span class="sxs-lookup"><span data-stu-id="34a22-239">Move lock acquisitions away from function entry points and guard only data access with locks.</span></span> <span data-ttu-id="34a22-240">Se menos código operar sob um bloqueio, haverá menos chances de deadlocks</span><span class="sxs-lookup"><span data-stu-id="34a22-240">If less code operates under a lock, there is less of a chance for deadlocks</span></span>
-   <span data-ttu-id="34a22-241">Analise as aquisições e as liberações de bloqueio no código de tratamento de erros.</span><span class="sxs-lookup"><span data-stu-id="34a22-241">Analyze lock acquisitions and releases in your error handling code.</span></span> <span data-ttu-id="34a22-242">Geralmente, a hierarquia de bloqueio se esqueceu ao tentar se recuperar de uma condição de erro</span><span class="sxs-lookup"><span data-stu-id="34a22-242">Often the lock hierarchy if forgotten when trying to recover from an error condition</span></span>
-   <span data-ttu-id="34a22-243">Substituir bloqueios aninhados por contadores de referência-eles não podem deadlock.</span><span class="sxs-lookup"><span data-stu-id="34a22-243">Replace nested locks with reference counters - they cannot deadlock.</span></span> <span data-ttu-id="34a22-244">Elementos bloqueados individualmente em listas e tabelas são bons candidatos</span><span class="sxs-lookup"><span data-stu-id="34a22-244">Individually locked elements in lists and tables are good candidates</span></span>
-   <span data-ttu-id="34a22-245">Tenha cuidado ao aguardar um identificador de thread de uma DLL.</span><span class="sxs-lookup"><span data-stu-id="34a22-245">Be careful when waiting on a thread handle from a DLL.</span></span> <span data-ttu-id="34a22-246">Sempre assuma que seu código pode ser chamado sob o bloqueio do carregador.</span><span class="sxs-lookup"><span data-stu-id="34a22-246">Always assume that your code could be called under the loader lock.</span></span> <span data-ttu-id="34a22-247">É melhor fazer referência a seus recursos e permitir que o thread de trabalho faça sua própria limpeza (e, em seguida, use FreeLibraryAndExitThread para terminar de forma limpa)</span><span class="sxs-lookup"><span data-stu-id="34a22-247">It's better to reference-count your resources and let the worker thread do its own cleanup (and then use FreeLibraryAndExitThread to terminate cleanly)</span></span>
-   <span data-ttu-id="34a22-248">Use a API de passagem da cadeia de espera se desejar diagnosticar seus próprios deadlocks</span><span class="sxs-lookup"><span data-stu-id="34a22-248">Use the Wait Chain Traversal API if you want to diagnose your own deadlocks</span></span>

<span data-ttu-id="34a22-249">**Não:**</span><span class="sxs-lookup"><span data-stu-id="34a22-249">**Do not:**</span></span>

-   <span data-ttu-id="34a22-250">Faça algo além do trabalho de inicialização muito simples em sua função DllMain ().</span><span class="sxs-lookup"><span data-stu-id="34a22-250">Do anything other than very simple initialization work in your DllMain() function.</span></span> <span data-ttu-id="34a22-251">Consulte a função de retorno de chamada DllMain para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="34a22-251">See DllMain Callback Function for more details.</span></span> <span data-ttu-id="34a22-252">Especialmente não chame LoadLibraryEx ou CoCreateInstance</span><span class="sxs-lookup"><span data-stu-id="34a22-252">Especially do not call LoadLibraryEx or CoCreateInstance</span></span>
-   <span data-ttu-id="34a22-253">Escreva seus próprios primitivos de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="34a22-253">Write your own locking primitives.</span></span> <span data-ttu-id="34a22-254">O código de sincronização personalizado pode facilmente introduzir Bugs sutis em sua base de código.</span><span class="sxs-lookup"><span data-stu-id="34a22-254">Custom synchronization code can easily introduce subtle bugs into your code base.</span></span> <span data-ttu-id="34a22-255">Use a seleção avançada de objetos de sincronização de sistema operacional em vez disso</span><span class="sxs-lookup"><span data-stu-id="34a22-255">Use the rich selection of operating system synchronization objects instead</span></span>
-   <span data-ttu-id="34a22-256">Fazer qualquer trabalho nos construtores e destruidores para variáveis globais, eles são executados sob o bloqueio do carregador</span><span class="sxs-lookup"><span data-stu-id="34a22-256">Do any work in the constructors and destructors for global variables, they are executed under the loader lock</span></span>

<span data-ttu-id="34a22-257">**Tenha cuidado com exceções**</span><span class="sxs-lookup"><span data-stu-id="34a22-257">**Be Careful with Exceptions**</span></span>

<span data-ttu-id="34a22-258">As exceções permitem a separação do fluxo normal do programa e do tratamento de erros.</span><span class="sxs-lookup"><span data-stu-id="34a22-258">Exceptions allow the separation of normal program flow and error handling.</span></span> <span data-ttu-id="34a22-259">Por causa dessa separação, pode ser difícil saber o estado preciso do programa antes da exceção, e o manipulador de exceção pode perder etapas cruciais na restauração de um estado válido.</span><span class="sxs-lookup"><span data-stu-id="34a22-259">Because of this separation, it can be difficult to know the precise state of the program prior to the exception and the exception handler might miss crucial steps in restoring a valid state.</span></span> <span data-ttu-id="34a22-260">Isso é especialmente verdadeiro para aquisições de bloqueio que precisam ser liberadas no manipulador para evitar deadlocks futuros.</span><span class="sxs-lookup"><span data-stu-id="34a22-260">This is especially true for lock acquisitions that need to be released in the handler to prevent future deadlocks.</span></span>

<span data-ttu-id="34a22-261">O código de exemplo a seguir ilustra esse problema.</span><span class="sxs-lookup"><span data-stu-id="34a22-261">The sample code below illustrates this issue.</span></span> <span data-ttu-id="34a22-262">O acesso não associado à variável "buffer" eventualmente resultará em uma violação de acesso (AV).</span><span class="sxs-lookup"><span data-stu-id="34a22-262">The unbounded access to the "buffer" variable will occasionally result in an access violation (AV).</span></span> <span data-ttu-id="34a22-263">Esse AV é capturado pelo manipulador de exceção nativa, mas não tem uma maneira fácil de determinar se a seção crítica já foi adquirida no momento da exceção (o AV poderia até mesmo ocorrer em algum lugar no código EnterCriticalSection).</span><span class="sxs-lookup"><span data-stu-id="34a22-263">This AV is caught by the native exception handler, but it has no easy way of determining if the critical section was already acquired at the time of the exception (the AV could even have taken place somewhere in the EnterCriticalSection code).</span></span>

```
 BOOL bar (char* buffer)  
{  
   BOOL rc = FALSE;  
   __try {  
      EnterCriticalSection(&cs);  
      while (*buffer++ != '&') ;  
      rc = GetParams(buffer);  
      LeaveCriticalSection(&cs);  
   } __except (EXCEPTION_EXECUTE_HANDLER)  
   {  
      return FALSE;  
   } 
   return rc;  
}  
```

<span data-ttu-id="34a22-264">**Coincide**</span><span class="sxs-lookup"><span data-stu-id="34a22-264">**Do:**</span></span>

-   <span data-ttu-id="34a22-265">Remover \_ \_ try/ \_ \_ Except sempre que possível; não use SetUnhandledExceptionFilter</span><span class="sxs-lookup"><span data-stu-id="34a22-265">Remove \_\_try/\_\_except whenever possible; do not use SetUnhandledExceptionFilter</span></span>
-   <span data-ttu-id="34a22-266">Empacote seus bloqueios em modelos de PTR automáticos personalizados \_ se você usar exceções de C++.</span><span class="sxs-lookup"><span data-stu-id="34a22-266">Wrap your locks in custom auto\_ptr-like templates if you use C++ exceptions.</span></span> <span data-ttu-id="34a22-267">O bloqueio deve ser liberado no destruidor.</span><span class="sxs-lookup"><span data-stu-id="34a22-267">The lock should be released in the destructor.</span></span> <span data-ttu-id="34a22-268">Para exceções nativas, libere os bloqueios em sua \_ \_ instrução Finally</span><span class="sxs-lookup"><span data-stu-id="34a22-268">For native exceptions release the locks in your \_\_finally statement</span></span>
-   <span data-ttu-id="34a22-269">Tenha cuidado com o código em execução em um manipulador de exceção nativa; a exceção pode ter vazado muitos bloqueios, portanto, o manipulador não deve adquirir nenhum</span><span class="sxs-lookup"><span data-stu-id="34a22-269">Be careful with the code executing in a native exception handler; the exception might have leaked many locks, so your handler should not acquire any</span></span>

<span data-ttu-id="34a22-270">**Não:**</span><span class="sxs-lookup"><span data-stu-id="34a22-270">**Do not:**</span></span>

-   <span data-ttu-id="34a22-271">Manipule exceções nativas se elas não forem necessárias ou requeridas pelas APIs do Win32.</span><span class="sxs-lookup"><span data-stu-id="34a22-271">Handle native exceptions if not necessary or required by the Win32 APIs.</span></span> <span data-ttu-id="34a22-272">Se você usar manipuladores de exceção nativa para relatórios ou recuperação de dados após falhas catastróficas, considere usar o mecanismo do sistema operacional padrão de Relatório de Erros do Windows em vez disso</span><span class="sxs-lookup"><span data-stu-id="34a22-272">If you use native exception handlers for reporting or data recovery after catastrophic failures, consider using the default operating system mechanism of Windows Error Reporting instead</span></span>
-   <span data-ttu-id="34a22-273">Usar exceções do C++ com qualquer tipo de código de interface do usuário (user32); uma exceção gerada em um retorno de chamada percorrerá as camadas do código C fornecido pelo sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="34a22-273">Use C++ exceptions with any kind of UI (user32) code; an exception thrown in a callback will travel through layers of C code provided by the operating system.</span></span> <span data-ttu-id="34a22-274">Esse código não sabe sobre a semântica de desroll do C++</span><span class="sxs-lookup"><span data-stu-id="34a22-274">That code does not know about C++ unroll semantics</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="34a22-275">Links para recursos</span><span class="sxs-lookup"><span data-stu-id="34a22-275">Links to Resources</span></span>

-   [<span data-ttu-id="34a22-276">Relatório de Erros do Windows</span><span class="sxs-lookup"><span data-stu-id="34a22-276">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   <span data-ttu-id="34a22-277">[Design assíncrono](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="34a22-277">[Asynchronous Design](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="34a22-278">E/s assíncrona</span><span class="sxs-lookup"><span data-stu-id="34a22-278">Asynchronous I/O</span></span>](../fileio/synchronous-and-asynchronous-i-o.md)
-   [<span data-ttu-id="34a22-279">**Função AttachThreadInput**</span><span class="sxs-lookup"><span data-stu-id="34a22-279">**AttachThreadInput Function**</span></span>](/windows/win32/api/winuser/nf-winuser-attachthreadinput)
-   <span data-ttu-id="34a22-280">[**\_classe PTR automaticamente**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="34a22-280">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="34a22-281">**Função DisableProcessWindowsGhosting**</span><span class="sxs-lookup"><span data-stu-id="34a22-281">**DisableProcessWindowsGhosting Function**</span></span>](/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting)
-   [<span data-ttu-id="34a22-282">**Função de retorno de chamada DllMain**</span><span class="sxs-lookup"><span data-stu-id="34a22-282">**DllMain Callback Function**</span></span>](../dlls/dllmain.md)
-   <span data-ttu-id="34a22-283">[Eventos](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="34a22-283">[Events](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="34a22-284">**Função GetMessage**</span><span class="sxs-lookup"><span data-stu-id="34a22-284">**GetMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-getmessage)
-   [<span data-ttu-id="34a22-285">Cancelamento de e/s</span><span class="sxs-lookup"><span data-stu-id="34a22-285">I/O cancellation</span></span>](../fileio/canceling-pending-i-o-operations.md)
-   [<span data-ttu-id="34a22-286">**Função IsHungAppWindow**</span><span class="sxs-lookup"><span data-stu-id="34a22-286">**IsHungAppWindow Function**</span></span>](/windows/win32/api/winuser/nf-winuser-ishungappwindow)
-   [<span data-ttu-id="34a22-287">Fila de mensagens</span><span class="sxs-lookup"><span data-stu-id="34a22-287">Message Queue</span></span>](../winmsg/using-messages-and-message-queues.md)
-   [<span data-ttu-id="34a22-288">**Função MsgWaitForMultipleObjects**</span><span class="sxs-lookup"><span data-stu-id="34a22-288">**MsgWaitForMultipleObjects Function**</span></span>](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects)
-   [<span data-ttu-id="34a22-289">Nova API do pool de threads</span><span class="sxs-lookup"><span data-stu-id="34a22-289">New Thread Pool API</span></span>](../procthread/thread-pool-api.md)
-   [<span data-ttu-id="34a22-290">**Função de mensagem**</span><span class="sxs-lookup"><span data-stu-id="34a22-290">**PostMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-postmessagea)
-   [<span data-ttu-id="34a22-291">Reinicialização e recuperação</span><span class="sxs-lookup"><span data-stu-id="34a22-291">Restart and Recovery</span></span>](../recovery/registering-for-application-restart.md)
-   [<span data-ttu-id="34a22-292">**Função SendMessageCallback**</span><span class="sxs-lookup"><span data-stu-id="34a22-292">**SendMessageCallback Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka)
-   [<span data-ttu-id="34a22-293">**Função SendNotifyMessage**</span><span class="sxs-lookup"><span data-stu-id="34a22-293">**SendNotifyMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendnotifymessagea)
-   [<span data-ttu-id="34a22-294">Objetos de sincronização</span><span class="sxs-lookup"><span data-stu-id="34a22-294">Synchronization Objects</span></span>](../sync/about-synchronization.md)
-   [<span data-ttu-id="34a22-295">**Função TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="34a22-295">**TerminateThread Function**</span></span>](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread)
-   [<span data-ttu-id="34a22-296">Relatório de Erros do Windows</span><span class="sxs-lookup"><span data-stu-id="34a22-296">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   [<span data-ttu-id="34a22-297">Winqual</span><span class="sxs-lookup"><span data-stu-id="34a22-297">Winqual</span></span>](/windows-hardware/drivers/dashboard/winqual-submission-tool--winqualexe-)

 

 
