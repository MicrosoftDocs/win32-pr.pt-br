---
description: Este tópico descreve como escrever um processador de vídeo personalizado para o DirectShow.
ms.assetid: abba5113-125f-4dac-b566-99c0d9b5978c
title: Renderizadores de vídeo alternativos
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 070e55375d9d1d5a32c306853aafcb431a76c368
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/06/2021
ms.locfileid: "103646094"
---
# <a name="alternative-video-renderers"></a><span data-ttu-id="d0362-103">Renderizadores de vídeo alternativos</span><span class="sxs-lookup"><span data-stu-id="d0362-103">Alternative Video Renderers</span></span>

<span data-ttu-id="d0362-104">Este tópico descreve como escrever um processador de vídeo personalizado para o DirectShow.</span><span class="sxs-lookup"><span data-stu-id="d0362-104">This topic describes how to write a custom video renderer for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="d0362-105">Em vez de escrever um processador de vídeo personalizado, é recomendável que você escreva um apresentador de plug-in-Presenter para o processador de mixagem de vídeo (VMR) ou [**processador de vídeo avançado**](enhanced-video-renderer-filter.md) (EVR).</span><span class="sxs-lookup"><span data-stu-id="d0362-105">Instead of writing a custom video renderer, it is recommended that you write a plug-in allocator-presenter for the Video Mixing Renderer (VMR) or [**Enhanced Video Renderer**](enhanced-video-renderer-filter.md) (EVR).</span></span> <span data-ttu-id="d0362-106">Essa abordagem fornecerá a você todos os benefícios do VMR/EVR, incluindo suporte para a DXVA (aceleração de vídeo do DirectX), desentrelaçamento de hardware e revisão de quadros, e provavelmente será mais robusta do que um processador de vídeo personalizado.</span><span class="sxs-lookup"><span data-stu-id="d0362-106">This approach will give you all of the benefits of the VMR/EVR, including support for DirectX Video Acceleration (DXVA), hardware deinterlacing, and frame stepping, and is likely to be more robust than a custom video renderer.</span></span> <span data-ttu-id="d0362-107">Para mais informações, consulte os seguintes tópicos:</span><span class="sxs-lookup"><span data-stu-id="d0362-107">For more information, see the following topics:</span></span>
>
> -   [<span data-ttu-id="d0362-108">Modo de reprodução do VMR (alocador personalizado-apresentadores)</span><span class="sxs-lookup"><span data-stu-id="d0362-108">VMR Renderless Playback Mode (Custom Allocator-Presenters)</span></span>](vmr-renderless-playback-mode--custom-allocator-presenters.md)
> -   [<span data-ttu-id="d0362-109">Como escrever um apresentador EVR</span><span class="sxs-lookup"><span data-stu-id="d0362-109">How to Write an EVR Presenter</span></span>](/windows/desktop/medfound/how-to-write-an-evr-presenter)

 

## <a name="writing-an-alternative-renderer"></a><span data-ttu-id="d0362-110">Escrevendo um renderizador alternativo</span><span class="sxs-lookup"><span data-stu-id="d0362-110">Writing an Alternative Renderer</span></span>

<span data-ttu-id="d0362-111">O Microsoft DirectShow fornece um processador de vídeo baseado em janela; Ele também fornece um processador de tela inteira na instalação em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="d0362-111">Microsoft DirectShow provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation.</span></span> <span data-ttu-id="d0362-112">Você pode usar as classes base do DirectShow para escrever renderizadores de vídeo alternativos.</span><span class="sxs-lookup"><span data-stu-id="d0362-112">You can use the DirectShow base classes to write alternative video renderers.</span></span> <span data-ttu-id="d0362-113">Para que os renderizadores alternativos interajam corretamente com aplicativos baseados no DirectShow, os renderizadores devem aderir às diretrizes descritas neste artigo.</span><span class="sxs-lookup"><span data-stu-id="d0362-113">For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article.</span></span> <span data-ttu-id="d0362-114">Você pode usar as classes [**CBaseRenderer**](cbaserenderer.md) e [**CBaseVideoRenderer**](cbasevideorenderer.md) para ajudar a seguir essas diretrizes ao implementar uma renderização de vídeo alternativa.</span><span class="sxs-lookup"><span data-stu-id="d0362-114">You can use the [**CBaseRenderer**](cbaserenderer.md) and [**CBaseVideoRenderer**](cbasevideorenderer.md) classes to help follow these guidelines when implementing an alternative video render.</span></span> <span data-ttu-id="d0362-115">Devido ao desenvolvimento contínuo do DirectShow, revise sua implementação periodicamente para garantir que os renderizadores sejam compatíveis com a versão mais recente do DirectShow.</span><span class="sxs-lookup"><span data-stu-id="d0362-115">Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.</span></span>

<span data-ttu-id="d0362-116">Este tópico discute muitas notificações que um renderizador é responsável pelo manuseio.</span><span class="sxs-lookup"><span data-stu-id="d0362-116">This topic discusses many notifications that a renderer is responsible for handling.</span></span> <span data-ttu-id="d0362-117">Uma breve revisão das notificações do DirectShow pode ajudar a definir o estágio.</span><span class="sxs-lookup"><span data-stu-id="d0362-117">A brief review of DirectShow notifications might help to set the stage.</span></span> <span data-ttu-id="d0362-118">Há basicamente três tipos de notificações que ocorrem no DirectShow:</span><span class="sxs-lookup"><span data-stu-id="d0362-118">There are essentially three kinds of notifications that occur in DirectShow:</span></span>

-   <span data-ttu-id="d0362-119">*Notificações de fluxo*, que são eventos que ocorrem no fluxo de mídia e são passados de um filtro para o próximo.</span><span class="sxs-lookup"><span data-stu-id="d0362-119">*Stream notifications*, which are events that occur in the media stream and are passed from one filter to the next.</span></span> <span data-ttu-id="d0362-120">Elas podem ser de início-liberação, fim de liberação ou notificações de fim de fluxo e são enviadas chamando o método apropriado no pino de entrada do filtro downstream (por exemplo [**IPin:: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span><span class="sxs-lookup"><span data-stu-id="d0362-120">These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the downstream filter's input pin (for example [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span></span>
-   <span data-ttu-id="d0362-121">*Filtre notificações de grafo*, que são eventos enviados de um filtro para o Gerenciador de gráfico de filtro, como o [**EC \_ Complete**](ec-complete.md).</span><span class="sxs-lookup"><span data-stu-id="d0362-121">*Filter graph notifications*, which are events sent from a filter to the Filter Graph Manager such as [**EC\_COMPLETE**](ec-complete.md).</span></span> <span data-ttu-id="d0362-122">Isso é feito chamando o método [**IMediaEventSink:: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) no Gerenciador do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-122">This is accomplished by calling the [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) method on the Filter Graph Manager.</span></span>
-   <span data-ttu-id="d0362-123">*Notificações de aplicativo*, que são recuperadas do Gerenciador de gráfico de filtro pelo aplicativo de controle.</span><span class="sxs-lookup"><span data-stu-id="d0362-123">*Application notifications*, which are retrieved from the Filter Graph Manager by the controlling application.</span></span> <span data-ttu-id="d0362-124">Um aplicativo chama o método [**IMediaEvent:: GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) no Gerenciador de gráfico de filtro para recuperar esses eventos.</span><span class="sxs-lookup"><span data-stu-id="d0362-124">An application calls the [**IMediaEvent::GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) method on the Filter Graph Manager to retrieve these events.</span></span> <span data-ttu-id="d0362-125">Geralmente, o Gerenciador de gráficos de filtro passa pelos eventos que recebe para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d0362-125">Often, the Filter Graph Manager passes through the events it receives to the application.</span></span>

<span data-ttu-id="d0362-126">Este tópico discute a responsabilidade do filtro de renderizador no tratamento de notificações de fluxo que recebe e no envio de notificações de gráfico de filtro apropriadas.</span><span class="sxs-lookup"><span data-stu-id="d0362-126">This topic discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph notifications.</span></span>

## <a name="handling-end-of-stream-and-flushing-notifications"></a><span data-ttu-id="d0362-127">Tratamento de notificações de fim de fluxo e liberação</span><span class="sxs-lookup"><span data-stu-id="d0362-127">Handling End-of-stream and Flushing Notifications</span></span>

<span data-ttu-id="d0362-128">Uma notificação de fim de fluxo começa em um filtro upstream (como o filtro de origem) quando esse filtro detecta que ele pode não enviar mais dados.</span><span class="sxs-lookup"><span data-stu-id="d0362-128">An end-of-stream notification begins at an upstream filter (such as the source filter) when that filter detects that it can send no more data.</span></span> <span data-ttu-id="d0362-129">Ele é transmitido por cada filtro no grafo e, eventualmente, termina no renderizador, que é responsável por enviar posteriormente uma notificação de [**\_ conclusão do EC**](ec-complete.md) para o Gerenciador do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-129">It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="d0362-130">Os renderizadores têm responsabilidades especiais quando se trata de lidar com essas notificações.</span><span class="sxs-lookup"><span data-stu-id="d0362-130">Renderers have special responsibilities when it comes to handling these notifications.</span></span>

<span data-ttu-id="d0362-131">Um renderizador recebe uma notificação de fim de fluxo quando o método [**IPin:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) de seu PIN de entrada é chamado pelo filtro upstream.</span><span class="sxs-lookup"><span data-stu-id="d0362-131">A renderer receives an end-of-stream notification when its input pin's [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) method is called by the upstream filter.</span></span> <span data-ttu-id="d0362-132">Um renderizador deve observar essa notificação e continuar a renderizar os dados já recebidos.</span><span class="sxs-lookup"><span data-stu-id="d0362-132">A renderer should note this notification and continue to render any data it has already received.</span></span> <span data-ttu-id="d0362-133">Depois que todos os dados restantes tiverem sido recebidos, o processador deverá enviar uma notificação de [**\_ conclusão do EC**](ec-complete.md) para o Gerenciador do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-133">Once all remaining data has been received, the renderer should send an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="d0362-134">A notificação de **\_ conclusão do EC** deve ser enviada apenas uma vez por um processador sempre que atingir o final de um fluxo.</span><span class="sxs-lookup"><span data-stu-id="d0362-134">The **EC\_COMPLETE** notification should be sent only once by a renderer each time it reaches the end of a stream.</span></span> <span data-ttu-id="d0362-135">Além disso, as notificações **\_ completas do EC** nunca devem ser enviadas, exceto quando o grafo de filtro estiver em execução.</span><span class="sxs-lookup"><span data-stu-id="d0362-135">Furthermore, **EC\_COMPLETE** notifications must never be sent except when the filter graph is running.</span></span> <span data-ttu-id="d0362-136">Portanto, se o grafo de filtro for pausado quando um filtro de origem enviar uma notificação de fim de fluxo, o **EC \_ concluído** não deverá ser enviado até que o gráfico de filtro seja finalmente executado.</span><span class="sxs-lookup"><span data-stu-id="d0362-136">Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then **EC\_COMPLETE** should not be sent until the filter graph is finally run.</span></span>

<span data-ttu-id="d0362-137">Todas as chamadas para os métodos [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) ou [**IMemInputPin:: ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) após uma notificação de fim de fluxo são sinalizadas devem ser rejeitadas.</span><span class="sxs-lookup"><span data-stu-id="d0362-137">Any calls to the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) methods after an end-of-stream notification is signaled should be rejected.</span></span> <span data-ttu-id="d0362-138">**E \_ Inesperado** é a mensagem de erro mais apropriada para retornar nesse caso.</span><span class="sxs-lookup"><span data-stu-id="d0362-138">**E\_UNEXPECTED** is the most appropriate error message to return in this case.</span></span>

<span data-ttu-id="d0362-139">Quando um grafo de filtro é interrompido, todas as notificações de fim de fluxo em cache devem ser limpas e não reenviadas quando a próxima for iniciada.</span><span class="sxs-lookup"><span data-stu-id="d0362-139">When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started.</span></span> <span data-ttu-id="d0362-140">Isso ocorre porque o Gerenciador de gráfico de filtro sempre pausa todos os filtros antes de executá-los para que ocorra a liberação correta.</span><span class="sxs-lookup"><span data-stu-id="d0362-140">This is because the Filter Graph Manager always pauses all filters just before running them so that proper flushing occurs.</span></span> <span data-ttu-id="d0362-141">Portanto, por exemplo, se o grafo de filtro for pausado e uma notificação de fim de fluxo for recebida e, em seguida, o grafo de filtro for interrompido, o renderizador não deverá enviar uma notificação de [**\_ conclusão do EC**](ec-complete.md) quando for executado posteriormente.</span><span class="sxs-lookup"><span data-stu-id="d0362-141">So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an [**EC\_COMPLETE**](ec-complete.md) notification when it is subsequently run.</span></span> <span data-ttu-id="d0362-142">Se nenhuma busca tiver ocorrido, o filtro de origem enviará automaticamente outra notificação de fim de fluxo durante o estado de pausa que precede um estado de execução.</span><span class="sxs-lookup"><span data-stu-id="d0362-142">If no seeks have occurred, the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state.</span></span> <span data-ttu-id="d0362-143">Se, por outro lado, ocorrer uma busca enquanto o grafo de filtro for interrompido, o filtro de origem poderá ter dados a serem enviados, portanto, não enviará uma notificação de fim de fluxo.</span><span class="sxs-lookup"><span data-stu-id="d0362-143">If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.</span></span>

<span data-ttu-id="d0362-144">Os renderizadores de vídeo geralmente dependem de notificações de fim de fluxo para mais do que o envio de notificações de [**\_ conclusão do EC**](ec-complete.md) .</span><span class="sxs-lookup"><span data-stu-id="d0362-144">Video renderers often depend on end-of-stream notifications for more than the sending of [**EC\_COMPLETE**](ec-complete.md) notifications.</span></span> <span data-ttu-id="d0362-145">Por exemplo, se um fluxo tiver terminado a execução (ou seja, uma notificação de fim de fluxo for enviada) e outra janela for arrastada sobre uma janela de processador de vídeo, um número de mensagens da janela de [**\_ pintura do WM**](/windows/desktop/gdi/wm-paint) será gerado.</span><span class="sxs-lookup"><span data-stu-id="d0362-145">For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) window messages will be generated.</span></span> <span data-ttu-id="d0362-146">A prática típica para executar renderizadores de vídeo é evitar a repintura do quadro atual no recebimento de mensagens **de \_ pintura do WM** (com base na suposição de que outro quadro a ser desenhado será recebido).</span><span class="sxs-lookup"><span data-stu-id="d0362-146">The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of **WM\_PAINT** messages (based on the assumption that another frame to be drawn will be received).</span></span> <span data-ttu-id="d0362-147">No entanto, quando a notificação de fim de fluxo é enviada, o renderizador está em um estado de espera; Ele ainda está em execução, mas está ciente de que ele não receberá dados adicionais.</span><span class="sxs-lookup"><span data-stu-id="d0362-147">However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data.</span></span> <span data-ttu-id="d0362-148">Sob essas circunstâncias, o processador normalmente desenha a área de reprodução em preto.</span><span class="sxs-lookup"><span data-stu-id="d0362-148">Under these circumstances, the renderer customarily draws the playback area black.</span></span>

<span data-ttu-id="d0362-149">A manipulação da liberação é uma complicação adicional para os renderizadores.</span><span class="sxs-lookup"><span data-stu-id="d0362-149">Handling flushing is an additional complication for renderers.</span></span> <span data-ttu-id="d0362-150">A liberação é realizada por meio de um par de métodos [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) chamados [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) e [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="d0362-150">Flushing is carried out through a pair of [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) methods called [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) and [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span> <span data-ttu-id="d0362-151">A liberação é essencialmente um estado adicional que o renderizador deve manipular.</span><span class="sxs-lookup"><span data-stu-id="d0362-151">Flushing is essentially an additional state that the renderer must handle.</span></span> <span data-ttu-id="d0362-152">É ilegal para um filtro de origem chamar **BeginFlush** sem chamar **EndFlush**, portanto, espero que o estado seja curto e discreto; no entanto, o renderizador deve manipular corretamente os dados ou as notificações recebidas durante a transição de liberação.</span><span class="sxs-lookup"><span data-stu-id="d0362-152">It is illegal for a source filter to call **BeginFlush** without calling **EndFlush**, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.</span></span>

<span data-ttu-id="d0362-153">Todos os dados recebidos após chamar [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) devem ser rejeitados imediatamente retornando **S \_ false**.</span><span class="sxs-lookup"><span data-stu-id="d0362-153">Any data received after calling [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) should be rejected immediately by returning **S\_FALSE**.</span></span> <span data-ttu-id="d0362-154">Além disso, qualquer notificação de fim de fluxo em cache também deve ser limpa quando um renderizador é liberado.</span><span class="sxs-lookup"><span data-stu-id="d0362-154">Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed.</span></span> <span data-ttu-id="d0362-155">Um renderizador normalmente será liberado em resposta a uma busca.</span><span class="sxs-lookup"><span data-stu-id="d0362-155">A renderer will typically be flushed in response to a seek.</span></span> <span data-ttu-id="d0362-156">A liberação garante que os dados antigos sejam apagados do grafo de filtro antes que os novos exemplos sejam enviados.</span><span class="sxs-lookup"><span data-stu-id="d0362-156">The flush ensures that old data is cleared from the filter graph before fresh samples are sent.</span></span> <span data-ttu-id="d0362-157">(Normalmente, a execução de duas seções de um fluxo, uma após a outra, é melhor tratada por meio de comandos adiados em vez de esperar que uma seção seja concluída e, em seguida, emitir um comando de busca.)</span><span class="sxs-lookup"><span data-stu-id="d0362-157">(Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.)</span></span>

## <a name="handling-state-changes-and-pause-completion"></a><span data-ttu-id="d0362-158">Manipulando alterações de estado e pausar a conclusão</span><span class="sxs-lookup"><span data-stu-id="d0362-158">Handling State Changes and Pause Completion</span></span>

<span data-ttu-id="d0362-159">Um filtro de processador se comporta da mesma forma que qualquer outro filtro no grafo de filtro quando seu estado é alterado, com a seguinte exceção.</span><span class="sxs-lookup"><span data-stu-id="d0362-159">A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception.</span></span> <span data-ttu-id="d0362-160">Depois de ser pausado, o renderizador terá alguns dados em fila, prontos para serem renderizados quando executado subsequentemente.</span><span class="sxs-lookup"><span data-stu-id="d0362-160">After being paused, the renderer will have some data queued, ready to be rendered when subsequently run.</span></span> <span data-ttu-id="d0362-161">Quando o processador de vídeo é interrompido, ele mantém os dados na fila.</span><span class="sxs-lookup"><span data-stu-id="d0362-161">When the video renderer is stopped, it holds on to this queued data.</span></span> <span data-ttu-id="d0362-162">Essa é uma exceção à regra do DirectShow de que nenhum recurso deve ser mantido por filtros enquanto o grafo de filtro é interrompido.</span><span class="sxs-lookup"><span data-stu-id="d0362-162">This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.</span></span>

<span data-ttu-id="d0362-163">A razão para essa exceção é que, ao manter os recursos, o renderizador sempre terá uma imagem com a qual redesenhará a janela se receber uma mensagem do [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="d0362-163">The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message.</span></span> <span data-ttu-id="d0362-164">Ele também tem uma imagem para satisfazer métodos, como [**CBaseControlVideo:: GetStaticImage**](cbasecontrolvideo-getstaticimage.md), que solicita uma cópia da imagem atual.</span><span class="sxs-lookup"><span data-stu-id="d0362-164">It also has an image to satisfy methods, such as [**CBaseControlVideo::GetStaticImage**](cbasecontrolvideo-getstaticimage.md), that request a copy of the current image.</span></span> <span data-ttu-id="d0362-165">Outro efeito de conter recursos é que a ativação da imagem impede que o alocador seja deconfirmado, o que, por sua vez, faz com que a próxima alteração de estado ocorra muito mais rapidamente porque os buffers de imagem já estão alocados.</span><span class="sxs-lookup"><span data-stu-id="d0362-165">Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.</span></span>

<span data-ttu-id="d0362-166">Um processador de vídeo deve renderizar e liberar amostras somente durante a execução.</span><span class="sxs-lookup"><span data-stu-id="d0362-166">A video renderer should render and release samples only while running.</span></span> <span data-ttu-id="d0362-167">Enquanto estiver em pausa, o filtro poderá renderizá-los (por exemplo, ao desenhar uma imagem de pôster estática em uma janela), mas não deverá liberá-las.</span><span class="sxs-lookup"><span data-stu-id="d0362-167">While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them.</span></span> <span data-ttu-id="d0362-168">Os renderizadores de áudio não farão renderização enquanto estiverem em pausa (embora possam executar outras atividades, como preparar o dispositivo wave, por exemplo).</span><span class="sxs-lookup"><span data-stu-id="d0362-168">Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example).</span></span> <span data-ttu-id="d0362-169">A hora em que as amostras devem ser renderizadas é obtida pela combinação do tempo de transmissão no exemplo com o tempo de referência passado como um parâmetro para o método [**IMediaControl:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) .</span><span class="sxs-lookup"><span data-stu-id="d0362-169">The time at which the samples should be rendered is obtained by combining the stream time in the sample with the reference time passed as a parameter to the [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) method.</span></span> <span data-ttu-id="d0362-170">Os renderizadores devem rejeitar amostras com tempos de início menores ou iguais a horários de término.</span><span class="sxs-lookup"><span data-stu-id="d0362-170">Renderers should reject samples with start times less than or equal to end times.</span></span>

<span data-ttu-id="d0362-171">Quando um aplicativo pausa um gráfico de filtro, o grafo de filtro não retorna de seu método [**IMediaControl::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) até que haja dados na fila nos renderizadores.</span><span class="sxs-lookup"><span data-stu-id="d0362-171">When an application pauses a filter graph, the filter graph does not return from its [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) method until there is data queued at the renderers.</span></span> <span data-ttu-id="d0362-172">Para garantir isso, quando um renderizador é pausado, ele deve retornar S \_ false se não houver dados aguardando para serem renderizados.</span><span class="sxs-lookup"><span data-stu-id="d0362-172">In order to ensure this, when a renderer is paused, it should return S\_FALSE if there is no data waiting to be rendered.</span></span> <span data-ttu-id="d0362-173">Se ele tiver dados em fila, ele poderá retornar **S \_ OK**.</span><span class="sxs-lookup"><span data-stu-id="d0362-173">If it has data queued, then it can return **S\_OK**.</span></span>

<span data-ttu-id="d0362-174">O Gerenciador de gráfico de filtro verifica todos os valores de retorno ao pausar um gráfico de filtro, para garantir que os renderizadores tenham dados em fila.</span><span class="sxs-lookup"><span data-stu-id="d0362-174">The Filter Graph Manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued.</span></span> <span data-ttu-id="d0362-175">Se um ou mais filtros não estiverem prontos, o Gerenciador do grafo de filtro sondará os filtros no grafo chamando [**IMediaFilter:: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span><span class="sxs-lookup"><span data-stu-id="d0362-175">If one or more filters are not ready, then the Filter Graph Manager polls the filters in the graph by calling [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span></span> <span data-ttu-id="d0362-176">O método **GetState** usa um parâmetro de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="d0362-176">The **GetState** method takes a time-out parameter.</span></span> <span data-ttu-id="d0362-177">Um filtro (normalmente um renderizador) que ainda está aguardando a chegada dos dados antes de concluir a alteração de estado retorna **VFW \_ S \_ State \_ intermediário** se o método **GetState** expirar.</span><span class="sxs-lookup"><span data-stu-id="d0362-177">A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns **VFW\_S\_STATE\_INTERMEDIATE** if the **GetState** method expires.</span></span> <span data-ttu-id="d0362-178">Depois que os dados chegam ao renderizador, **GetState** deve ser retornado imediatamente com **S \_ OK**.</span><span class="sxs-lookup"><span data-stu-id="d0362-178">Once data arrives at the renderer, **GetState** should be returned immediately with **S\_OK**.</span></span>

<span data-ttu-id="d0362-179">No estado intermediário e concluído, o estado de filtro relatado será \_ pausado.</span><span class="sxs-lookup"><span data-stu-id="d0362-179">In both the intermediate and completed state, the reported filter state will be State\_Paused.</span></span> <span data-ttu-id="d0362-180">Somente o valor de retorno indica se o filtro está realmente pronto ou não.</span><span class="sxs-lookup"><span data-stu-id="d0362-180">Only the return value indicates whether the filter is really ready or not.</span></span> <span data-ttu-id="d0362-181">Se, enquanto um renderizador estiver aguardando a chegada de dados, seu filtro de origem enviará uma notificação de fim de fluxo, que também deverá concluir a alteração de estado.</span><span class="sxs-lookup"><span data-stu-id="d0362-181">If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.</span></span>

<span data-ttu-id="d0362-182">Depois que todos os filtros realmente têm dados aguardando para serem processados, o grafo de filtro concluirá sua alteração no estado de pausa.</span><span class="sxs-lookup"><span data-stu-id="d0362-182">Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.</span></span>

## <a name="handling-termination"></a><span data-ttu-id="d0362-183">Tratamento de encerramento</span><span class="sxs-lookup"><span data-stu-id="d0362-183">Handling Termination</span></span>

<span data-ttu-id="d0362-184">Os renderizadores de vídeo devem lidar corretamente com os eventos de encerramento do usuário.</span><span class="sxs-lookup"><span data-stu-id="d0362-184">Video renderers must correctly handle termination events from the user.</span></span> <span data-ttu-id="d0362-185">Isso implica ocultar corretamente a janela e saber o que fazer se uma janela for subsequentemente forçada a ser exibida.</span><span class="sxs-lookup"><span data-stu-id="d0362-185">This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed.</span></span> <span data-ttu-id="d0362-186">Além disso, os renderizadores de vídeo devem notificar o Gerenciador do grafo de filtro quando sua janela é destruída (ou mais precisamente, quando o renderizador é removido do gráfico de filtro) para liberar recursos.</span><span class="sxs-lookup"><span data-stu-id="d0362-186">Also, video renderers must notify the Filter Graph Manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.</span></span>

<span data-ttu-id="d0362-187">Se o usuário fechar a janela de vídeo (por exemplo pressionando ALT + F4), a Convenção será ocultar a janela imediatamente e enviar uma notificação do [**EC \_ userabort**](ec-userabort.md) para o Gerenciador do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-187">If the user closes the video window (for instance by pressing ALT+F4), the convention is to hide the window immediately and send an [**EC\_USERABORT**](ec-userabort.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="d0362-188">Essa notificação é passada para o aplicativo, o que irá parar a reprodução do grafo.</span><span class="sxs-lookup"><span data-stu-id="d0362-188">This notification is passed through to the application, which will stop the graph playing.</span></span> <span data-ttu-id="d0362-189">Depois de enviar o **EC \_ userabort**, um processador de vídeo deve rejeitar quaisquer exemplos adicionais entregues a ele.</span><span class="sxs-lookup"><span data-stu-id="d0362-189">After sending **EC\_USERABORT**, a video renderer should reject any additional samples delivered to it.</span></span>

<span data-ttu-id="d0362-190">O sinalizador de grafo parado deve ser deixado pelo renderizador até que seja interrompido posteriormente, ponto em que ele deve ser redefinido para que um aplicativo possa substituir a ação do usuário e continuar jogando o grafo se desejar.</span><span class="sxs-lookup"><span data-stu-id="d0362-190">The graph-stopped flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an application can override the user action and continue playing the graph if it desires.</span></span> <span data-ttu-id="d0362-191">Se ALT + F4 for pressionado enquanto o vídeo estiver em execução, a janela ficará oculta e todos os outros exemplos entregues serão rejeitados.</span><span class="sxs-lookup"><span data-stu-id="d0362-191">If ALT+F4 is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected.</span></span> <span data-ttu-id="d0362-192">Se a janela for mostrada subsequentemente (talvez por meio de [**IVideoWindow::p UT \_ Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), nenhuma notificação de [**\_ redesenho de EC**](ec-repaint.md) deverá ser gerada.</span><span class="sxs-lookup"><span data-stu-id="d0362-192">If the window is subsequently shown (perhaps through [**IVideoWindow::put\_Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), then no [**EC\_REPAINT**](ec-repaint.md) notifications should be generated.</span></span>

<span data-ttu-id="d0362-193">O processador de vídeo também deve enviar a notificação [**\_ \_ destruída da janela do EC**](ec-window-destroyed.md) para o grafo de filtro quando o processador de vídeo está sendo encerrado.</span><span class="sxs-lookup"><span data-stu-id="d0362-193">The video renderer should also send the [**EC\_WINDOW\_DESTROYED**](ec-window-destroyed.md) notification to the filter graph when the video renderer is terminating.</span></span> <span data-ttu-id="d0362-194">Na verdade, é melhor lidar com isso quando o método [**IBaseFilter:: JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) do processador é chamado com um parâmetro nulo (indicando que o processador está prestes a ser removido do grafo de filtro), em vez de esperar até que a janela de vídeo real seja destruída.</span><span class="sxs-lookup"><span data-stu-id="d0362-194">In fact, it is best to handle this when the renderer's [**IBaseFilter::JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed.</span></span> <span data-ttu-id="d0362-195">O envio dessa notificação permite que o distribuidor de plug-ins no Gerenciador de gráficos de filtro passe em recursos que dependem do foco da janela para outros filtros, como dispositivos de áudio.</span><span class="sxs-lookup"><span data-stu-id="d0362-195">Sending this notification enables the plug-in distributor in the Filter Graph Manager to pass on resources that depend on window focus to other filters, such as audio devices.</span></span>

## <a name="handling-dynamic-format-changes"></a><span data-ttu-id="d0362-196">Manipulando alterações de formato dinâmico</span><span class="sxs-lookup"><span data-stu-id="d0362-196">Handling Dynamic Format Changes</span></span>

<span data-ttu-id="d0362-197">Em alguns casos, o filtro upstream do renderizador pode tentar alterar o formato de vídeo durante a reprodução do vídeo.</span><span class="sxs-lookup"><span data-stu-id="d0362-197">In some cases, the renderer's upstream filter might try to change the video format while the video is playing.</span></span> <span data-ttu-id="d0362-198">Geralmente, é o descompactador de vídeo que inicia uma alteração de formato dinâmico.</span><span class="sxs-lookup"><span data-stu-id="d0362-198">It is most often the video decompressor that initiates a dynamic format change.</span></span>

<span data-ttu-id="d0362-199">Um filtro upstream que tenta alterar formatos dinamicamente sempre deve chamar o método [**IPin:: QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) no pino de entrada do processador.</span><span class="sxs-lookup"><span data-stu-id="d0362-199">An upstream filter attempting to change formats dynamically should always call the [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) method on the renderer input pin.</span></span> <span data-ttu-id="d0362-200">Um processador de vídeo tem algumas reserva para que tipos de alterações de formato dinâmico devem dar suporte.</span><span class="sxs-lookup"><span data-stu-id="d0362-200">A video renderer has some leeway as to what kinds of dynamic format changes it should support.</span></span> <span data-ttu-id="d0362-201">No mínimo, ele deve permitir que o filtro upstream altere as paletas.</span><span class="sxs-lookup"><span data-stu-id="d0362-201">At a minimum, it should allow the upstream filter to change palettes.</span></span> <span data-ttu-id="d0362-202">Quando um filtro upstream altera os tipos de mídia, ele anexa o tipo de mídia ao primeiro exemplo entregue no novo formato.</span><span class="sxs-lookup"><span data-stu-id="d0362-202">When an upstream filter changes media types, it attaches the media type to the first sample delivered in the new format.</span></span> <span data-ttu-id="d0362-203">Se o renderizador mantiver amostras em uma fila para renderização, ele não deverá alterar o formato até que ele processe o exemplo com a alteração de tipo.</span><span class="sxs-lookup"><span data-stu-id="d0362-203">If the renderer holds samples in a queue for rendering, it should not change the format until it renders the sample with the type change.</span></span>

<span data-ttu-id="d0362-204">Um processador de vídeo também pode solicitar uma alteração de formato do decodificador.</span><span class="sxs-lookup"><span data-stu-id="d0362-204">A video renderer can also request a format change from the decoder.</span></span> <span data-ttu-id="d0362-205">Por exemplo, ele pode solicitar que o decodificador forneça um formato compatível com o DirectDraw com uma **superaltura** negativa.</span><span class="sxs-lookup"><span data-stu-id="d0362-205">For example, it might ask the decoder to provide a DirectDraw-compatible format with a negative **biHeight**.</span></span> <span data-ttu-id="d0362-206">Quando o renderizador é pausado, ele deve chamar [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) no pino upstream para ver quais formatos o decodificador pode fornecer.</span><span class="sxs-lookup"><span data-stu-id="d0362-206">When the renderer is paused, it should call [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) on the upstream pin to see which formats the decoder can provide.</span></span> <span data-ttu-id="d0362-207">O decodificador pode não enumerar todos os tipos que ele pode aceitar, no entanto, portanto, o renderizador deve oferecer alguns tipos, mesmo que o decodificador não os Anuncie.</span><span class="sxs-lookup"><span data-stu-id="d0362-207">The decoder might not enumerate all of the types that it can accept, however, so the renderer should offer some types even if the decoder does not advertise them.</span></span>

<span data-ttu-id="d0362-208">Se o decodificador puder mudar para o formato solicitado, ele retornará **S \_ OK** de [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span><span class="sxs-lookup"><span data-stu-id="d0362-208">If the decoder can switch to the requested format, it returns **S\_OK** from [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span></span> <span data-ttu-id="d0362-209">Em seguida, o renderizador anexa o novo tipo de mídia ao exemplo de mídia seguinte no alocador upstream.</span><span class="sxs-lookup"><span data-stu-id="d0362-209">The renderer then attaches the new media type to the next media sample on the upstream allocator.</span></span> <span data-ttu-id="d0362-210">Para que isso funcione, o renderizador deve fornecer um alocador personalizado que implementa um método particular para anexar o tipo de mídia ao próximo exemplo.</span><span class="sxs-lookup"><span data-stu-id="d0362-210">For this to work, the renderer must provide a custom allocator that implements a private method for attaching the media type to the next sample.</span></span> <span data-ttu-id="d0362-211">(Dentro desse método particular, chame [**IMediaSample:: SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) para definir o tipo.)</span><span class="sxs-lookup"><span data-stu-id="d0362-211">(Within this private method, call [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to set the type.)</span></span>

<span data-ttu-id="d0362-212">O PIN de entrada do renderizador deve retornar o alocador personalizado do renderizador no método [**IMemInputPin:: Getalocador**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) .</span><span class="sxs-lookup"><span data-stu-id="d0362-212">The renderer's input pin should return the renderer's custom allocator in the [**IMemInputPin::GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) method.</span></span> <span data-ttu-id="d0362-213">Substitua [**IMemInputPin:: NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) para que falhe se o filtro upstream não usar o alocador do processador.</span><span class="sxs-lookup"><span data-stu-id="d0362-213">Override [**IMemInputPin::NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) so that it fails if the upstream filter does not use the renderer's allocator.</span></span>

<span data-ttu-id="d0362-214">Com alguns decodificadores, a configuração de **biHeight** para um número positivo em tipos YUV faz com que o decodificador desenhe a imagem de cabeça para baixo.</span><span class="sxs-lookup"><span data-stu-id="d0362-214">With some decoders, setting **biHeight** to a positive number on YUV types causes the decoder to draw the image upside down.</span></span> <span data-ttu-id="d0362-215">(Isso está incorreto e deve ser considerado um bug no decodificador.)</span><span class="sxs-lookup"><span data-stu-id="d0362-215">(This is incorrect, and should be considered a bug in the decoder.)</span></span>

<span data-ttu-id="d0362-216">Sempre que uma alteração de formato é detectada pelo processador de vídeo, ele deve enviar uma notificação de [**exibição de EC \_ \_ alterada**](ec-display-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="d0362-216">Whenever a format change is detected by the video renderer, it should send an [**EC\_DISPLAY\_CHANGED**](ec-display-changed.md) notification.</span></span> <span data-ttu-id="d0362-217">A maioria dos renderizadores de vídeo escolhe um formato durante a conexão para que o formato possa ser desenhado com eficiência por meio da GDI.</span><span class="sxs-lookup"><span data-stu-id="d0362-217">Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI.</span></span> <span data-ttu-id="d0362-218">Se o usuário alterar o modo de exibição atual sem reiniciar o computador, um processador poderá se encontrar com uma conexão de formato de imagem inadequada e deverá enviar essa notificação.</span><span class="sxs-lookup"><span data-stu-id="d0362-218">If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification.</span></span> <span data-ttu-id="d0362-219">O primeiro parâmetro deve ser o PIN que precisa ser reconectado.</span><span class="sxs-lookup"><span data-stu-id="d0362-219">The first parameter should be the pin that needs reconnecting.</span></span> <span data-ttu-id="d0362-220">O Gerenciador de gráfico de filtro irá organizar o gráfico de filtro a ser interrompido e o PIN reconectado.</span><span class="sxs-lookup"><span data-stu-id="d0362-220">The Filter Graph Manager will arrange for the filter graph to be stopped and the pin reconnected.</span></span> <span data-ttu-id="d0362-221">Durante a reconexão subsequente, o renderizador pode aceitar um formato mais apropriado.</span><span class="sxs-lookup"><span data-stu-id="d0362-221">During the subsequent reconnection, the renderer can accept a more appropriate format.</span></span>

<span data-ttu-id="d0362-222">Sempre que um processador de vídeo detectar uma alteração de paleta no fluxo, ele deverá enviar a notificação de alteração da [**\_ \_ paleta do EC**](ec-palette-changed.md) para o Gerenciador do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-222">Whenever a video renderer detects a palette change in the stream it should send the [**EC\_PALETTE\_CHANGED**](ec-palette-changed.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="d0362-223">Os renderizadores de vídeo do DirectShow detectam se uma paleta realmente foi alterada em formato dinâmico ou não.</span><span class="sxs-lookup"><span data-stu-id="d0362-223">The DirectShow video renderers detect whether a palette has really changed in dynamic format or not.</span></span> <span data-ttu-id="d0362-224">Os renderizadores de vídeo fazem isso não apenas para filtrar o número de **notificações \_ \_ alteradas da paleta do EC** enviadas, mas também para reduzir a quantidade de criação, instalação e exclusão da paleta necessária.</span><span class="sxs-lookup"><span data-stu-id="d0362-224">The video renderers do this not only to filter out the number of **EC\_PALETTE\_CHANGED** notifications sent but also to reduce the amount of palette creation, installation, and deletion required.</span></span>

<span data-ttu-id="d0362-225">Por fim, o processador de vídeo também pode detectar que o tamanho do vídeo foi alterado; nesse caso, ele deve enviar a notificação de [**alteração de tamanho de vídeo do EC \_ \_ \_**](ec-video-size-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="d0362-225">Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the [**EC\_VIDEO\_SIZE\_CHANGED**](ec-video-size-changed.md) notification.</span></span> <span data-ttu-id="d0362-226">Um aplicativo pode usar essa notificação para negociar espaço em um documento composto.</span><span class="sxs-lookup"><span data-stu-id="d0362-226">An application might use this notification to negotiate space in a compound document.</span></span> <span data-ttu-id="d0362-227">As dimensões de vídeo reais estão disponíveis por meio da interface de controle [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) .</span><span class="sxs-lookup"><span data-stu-id="d0362-227">The actual video dimensions are available through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) control interface.</span></span> <span data-ttu-id="d0362-228">Os renderizadores do DirectShow detectam se o vídeo realmente alterou o tamanho ou não antes de enviar esses eventos.</span><span class="sxs-lookup"><span data-stu-id="d0362-228">The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.</span></span>

## <a name="handling-persistent-properties"></a><span data-ttu-id="d0362-229">Manipulando propriedades persistentes</span><span class="sxs-lookup"><span data-stu-id="d0362-229">Handling Persistent Properties</span></span>

<span data-ttu-id="d0362-230">Todas as propriedades definidas por meio das interfaces [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) e [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) devem ser persistentes entre as conexões.</span><span class="sxs-lookup"><span data-stu-id="d0362-230">All properties set through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) interfaces are meant to be persistent across connections.</span></span> <span data-ttu-id="d0362-231">Portanto, desconectar e reconectar um renderizador não deve mostrar nenhum efeito sobre o tamanho, a posição ou os estilos da janela.</span><span class="sxs-lookup"><span data-stu-id="d0362-231">Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles.</span></span> <span data-ttu-id="d0362-232">No entanto, se as dimensões de vídeo mudarem entre as conexões, o renderizador deverá redefinir os retângulos de origem e de destino para seus padrões.</span><span class="sxs-lookup"><span data-stu-id="d0362-232">However, if the video dimensions change between connections, the renderer should reset the source and destination rectangles to their defaults.</span></span> <span data-ttu-id="d0362-233">As posições de origem e de destino são definidas por meio da interface **IBasicVideo** .</span><span class="sxs-lookup"><span data-stu-id="d0362-233">The source and destination positions are set through the **IBasicVideo** interface.</span></span>

<span data-ttu-id="d0362-234">[**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) e [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) fornecem acesso suficiente às propriedades para permitir que um aplicativo salve e restaure todos os dados na interface em um formato persistente.</span><span class="sxs-lookup"><span data-stu-id="d0362-234">Both [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format.</span></span> <span data-ttu-id="d0362-235">Isso será útil para aplicativos que devem salvar a configuração e as propriedades exatas dos grafos de filtro durante uma sessão de edição e restaurá-los mais tarde.</span><span class="sxs-lookup"><span data-stu-id="d0362-235">This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.</span></span>

## <a name="handling-ec_repaint-notifications"></a><span data-ttu-id="d0362-236">Lidando com \_ notificações de REdesenho de EC</span><span class="sxs-lookup"><span data-stu-id="d0362-236">Handling EC\_REPAINT Notifications</span></span>

<span data-ttu-id="d0362-237">A notificação de [**\_ redesenho do EC**](ec-repaint.md) é enviada somente quando o renderizador é pausado ou parado.</span><span class="sxs-lookup"><span data-stu-id="d0362-237">The [**EC\_REPAINT**](ec-repaint.md) notification is sent only when the renderer is either paused or stopped.</span></span> <span data-ttu-id="d0362-238">Essa notificação sinaliza para o Gerenciador do grafo de filtro que o renderizador precisa de dados.</span><span class="sxs-lookup"><span data-stu-id="d0362-238">This notification signals to the Filter Graph Manager that the renderer needs data.</span></span> <span data-ttu-id="d0362-239">Se o grafo de filtro for interrompido quando receber uma dessas notificações, ele pausará o gráfico de filtro, aguardará que todos os filtros recebam dados (chamando [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)) e, em seguida, o interromperá novamente.</span><span class="sxs-lookup"><span data-stu-id="d0362-239">If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), and then stop it again.</span></span> <span data-ttu-id="d0362-240">Quando parado, um renderizador de vídeo deve ser mantido na imagem para que as mensagens de [**\_ pintura do WM**](/windows/desktop/gdi/wm-paint) subsequentes possam ser tratadas.</span><span class="sxs-lookup"><span data-stu-id="d0362-240">When stopped, a video renderer should hold on to the image so that subsequent [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages can be handled.</span></span>

<span data-ttu-id="d0362-241">Portanto, se um renderizador de vídeo receber uma mensagem do [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) quando for interrompido ou pausado, e não tiver nada com o qual pintar sua janela, ele deverá enviar o [**EC \_ Repaint**](ec-repaint.md) para o Gerenciador do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-241">Therefore, if a video renderer receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message when stopped or paused, and it has nothing with which to paint its window, then it should send [**EC\_REPAINT**](ec-repaint.md) to the Filter Graph Manager.</span></span> <span data-ttu-id="d0362-242">Se uma **notificação \_ redesenhada do EC** for recebida enquanto estiver em pausa, o Gerenciador do grafo de filtro chamará [**IMediaPosition::p UT \_ CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) com a posição atual (ou seja, busca a posição atual).</span><span class="sxs-lookup"><span data-stu-id="d0362-242">If an **EC\_REPAINT** notification is received while paused, then the Filter Graph Manager calls [**IMediaPosition::put\_CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) with the current position (that is, seeks to the current position).</span></span> <span data-ttu-id="d0362-243">Isso faz com que os filtros de origem liberem o gráfico de filtro e que os novos dados sejam enviados por meio do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-243">This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.</span></span>

<span data-ttu-id="d0362-244">Um renderizador deve enviar apenas uma dessas notificações por vez.</span><span class="sxs-lookup"><span data-stu-id="d0362-244">A renderer must send only one of these notifications at a time.</span></span> <span data-ttu-id="d0362-245">Portanto, depois que o renderizador envia uma notificação, ele deve garantir que não seja mais enviado até que alguns exemplos sejam entregues.</span><span class="sxs-lookup"><span data-stu-id="d0362-245">Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered.</span></span> <span data-ttu-id="d0362-246">A maneira convencional de fazer isso é ter um sinalizador para significar que um redesenho pode ser enviado, que é desativado depois que uma notificação de [**\_ redesenho de EC**](ec-repaint.md) é enviada.</span><span class="sxs-lookup"><span data-stu-id="d0362-246">The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an [**EC\_REPAINT**](ec-repaint.md) notification is sent.</span></span> <span data-ttu-id="d0362-247">Esse sinalizador deve ser redefinido quando os dados são entregues ou quando o PIN de entrada é liberado, mas não se o fim do fluxo é sinalizado no pino de entrada.</span><span class="sxs-lookup"><span data-stu-id="d0362-247">This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.</span></span>

<span data-ttu-id="d0362-248">Se o renderizador não monitorar suas notificações de [**\_ redesenho de EC**](ec-repaint.md) , ele irá inundar o Gerenciador de gráficos de filtro com solicitações de **\_ redesenho de EC** (que são relativamente caras de processar).</span><span class="sxs-lookup"><span data-stu-id="d0362-248">If the renderer does not monitor its [**EC\_REPAINT**](ec-repaint.md) notifications, it will flood the Filter Graph Manager with **EC\_REPAINT** requests (which are relatively expensive to process).</span></span> <span data-ttu-id="d0362-249">Por exemplo, se um renderizador não tiver nenhuma imagem para desenhar e outra janela for arrastada pela janela do processador em uma operação de arrastar completo, o renderizador receberá várias mensagens de [**\_ pintura do WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="d0362-249">For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages.</span></span> <span data-ttu-id="d0362-250">Somente o primeiro deles deve gerar uma notificação de evento do **EC \_ Repaint** do renderizador para o Gerenciador do grafo de filtro.</span><span class="sxs-lookup"><span data-stu-id="d0362-250">Only the first of these should generate an **EC\_REPAINT** event notification from the renderer to the Filter Graph Manager.</span></span>

<span data-ttu-id="d0362-251">Um processador deve enviar seu PIN de entrada como o primeiro parâmetro para a notificação de [**\_ redesenho do EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="d0362-251">A renderer should send its input pin as the first parameter to the [**EC\_REPAINT**](ec-repaint.md) notification.</span></span> <span data-ttu-id="d0362-252">Ao fazer isso, o pino de saída anexado será consultado por [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink)e, se houver suporte, a notificação de **\_ redesenho do EC** será enviada primeiro.</span><span class="sxs-lookup"><span data-stu-id="d0362-252">By doing this, the attached output pin will be queried for [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), and if supported, the **EC\_REPAINT** notification will be sent there first.</span></span> <span data-ttu-id="d0362-253">Isso permite que os Pins de saída manipulem repinturas antes que o gráfico de filtro seja tocado.</span><span class="sxs-lookup"><span data-stu-id="d0362-253">This enables output pins to handle repaints before the filter graph must be touched.</span></span> <span data-ttu-id="d0362-254">Isso não será feito se o grafo de filtro for interrompido, porque nenhum buffer estaria disponível no alocador de processador descomprometido.</span><span class="sxs-lookup"><span data-stu-id="d0362-254">This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.</span></span>

<span data-ttu-id="d0362-255">Se o pino de saída não puder tratar a solicitação e o grafo de filtro estiver em execução, a notificação de [**\_ redesenho do EC**](ec-repaint.md) será ignorada.</span><span class="sxs-lookup"><span data-stu-id="d0362-255">If the output pin cannot handle the request and the filter graph is running, then the [**EC\_REPAINT**](ec-repaint.md) notification is ignored.</span></span> <span data-ttu-id="d0362-256">Um pino de saída deve retornar **S \_ OK** de [**IMediaEventSink:: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) para sinalizar que ele processou a solicitação redesenhada com êxito.</span><span class="sxs-lookup"><span data-stu-id="d0362-256">An output pin must return **S\_OK** from [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) to signal that it processed the repaint request successfully.</span></span> <span data-ttu-id="d0362-257">O pino de saída será chamado no thread de trabalho do Gerenciador do grafo de filtro, que evita que o renderizador chame o pino de saída diretamente e, portanto, evita quaisquer problemas de deadlock.</span><span class="sxs-lookup"><span data-stu-id="d0362-257">The output pin will be called on the Filter Graph Manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues.</span></span> <span data-ttu-id="d0362-258">Se o grafo de filtro for interrompido ou pausado e a saída não tratar a solicitação, o processamento padrão será feito.</span><span class="sxs-lookup"><span data-stu-id="d0362-258">If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.</span></span>

## <a name="handling-notifications-in-full-screen-mode"></a><span data-ttu-id="d0362-259">Manipulando notificações no modo de Full-Screen</span><span class="sxs-lookup"><span data-stu-id="d0362-259">Handling Notifications in Full-Screen Mode</span></span>

<span data-ttu-id="d0362-260">O distribuidor de plug-in do [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) (PID) no gráfico de filtro gerencia a reprodução em tela inteira.</span><span class="sxs-lookup"><span data-stu-id="d0362-260">The [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) plug-in distributor (PID) in the filter graph manages full-screen playback.</span></span> <span data-ttu-id="d0362-261">Ele alternará um processador de vídeo para um processador de tela inteira de especialista, ampliará uma janela de um renderizador para tela inteira ou fará com que o renderizador implemente a reprodução de tela inteira diretamente.</span><span class="sxs-lookup"><span data-stu-id="d0362-261">It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer implement full-screen playback directly.</span></span> <span data-ttu-id="d0362-262">Para interagir em protocolos de tela inteira, um processador de vídeo deve enviar uma notificação de [**\_ ativação do EC**](ec-activate.md) sempre que sua janela for ativada ou desativada.</span><span class="sxs-lookup"><span data-stu-id="d0362-262">To interact in full-screen protocols, a video renderer should send an [**EC\_ACTIVATE**](ec-activate.md) notification whenever its window is either activated or deactivated.</span></span> <span data-ttu-id="d0362-263">Em outras palavras, uma notificação de **\_ ativação do EC** deve ser enviada para cada mensagem do WM \_ ACTIVATEAPP que um processador recebe.</span><span class="sxs-lookup"><span data-stu-id="d0362-263">In other words, an **EC\_ACTIVATE** notification should be sent for each WM\_ACTIVATEAPP message a renderer receives.</span></span>

<span data-ttu-id="d0362-264">Quando um processador está sendo usado no modo de tela inteira, essas notificações gerenciam a alternância para dentro e fora desse modo de tela inteira.</span><span class="sxs-lookup"><span data-stu-id="d0362-264">When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode.</span></span> <span data-ttu-id="d0362-265">A desativação de janela geralmente ocorre quando um usuário pressiona ALT + TAB para alternar para outra janela, que o processador de tela cheia do DirectShow usa como uma indicação para retornar ao modo de renderização típico.</span><span class="sxs-lookup"><span data-stu-id="d0362-265">Window deactivation typically occurs when a user presses ALT+TAB to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.</span></span>

<span data-ttu-id="d0362-266">Quando a notificação de [**\_ ativação do EC**](ec-activate.md) é enviada para o Gerenciador do grafo de filtro após a alternância do modo de tela inteira, o Gerenciador do grafo de filtro envia uma notificação de [**\_ \_ tela**](ec-fullscreen-lost.md) de ecrã do EC para o aplicativo de controle.</span><span class="sxs-lookup"><span data-stu-id="d0362-266">When the [**EC\_ACTIVATE**](ec-activate.md) notification is sent to the Filter Graph Manager upon switching out of full-screen mode, the Filter Graph Manager sends an [**EC\_FULLSCREEN\_LOST**](ec-fullscreen-lost.md) notification to the controlling application.</span></span> <span data-ttu-id="d0362-267">O aplicativo pode usar essa notificação para restaurar o estado de um botão de tela inteira, por exemplo.</span><span class="sxs-lookup"><span data-stu-id="d0362-267">The application might use this notification to restore the state of a full-screen button, for example.</span></span> <span data-ttu-id="d0362-268">As notificações de **\_ ativação do EC** são usadas internamente pelo DirectShow para gerenciar a alternância de tela inteira em indicações dos renderizadores de vídeo.</span><span class="sxs-lookup"><span data-stu-id="d0362-268">The **EC\_ACTIVATE** notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers.</span></span>

## <a name="summary-of-notifications"></a><span data-ttu-id="d0362-269">Resumo de notificações</span><span class="sxs-lookup"><span data-stu-id="d0362-269">Summary of Notifications</span></span>

<span data-ttu-id="d0362-270">Esta seção lista as notificações de gráfico de filtro que um renderizador pode enviar.</span><span class="sxs-lookup"><span data-stu-id="d0362-270">This section lists the filter graph notifications that a renderer can send.</span></span>



| <span data-ttu-id="d0362-271">Notificação de eventos</span><span class="sxs-lookup"><span data-stu-id="d0362-271">Event notification</span></span>                                        | <span data-ttu-id="d0362-272">Descrição</span><span class="sxs-lookup"><span data-stu-id="d0362-272">Description</span></span>                                                                                                                                                                                       |
|-----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="d0362-273">**ativação do EC \_**</span><span class="sxs-lookup"><span data-stu-id="d0362-273">**EC\_ACTIVATE**</span></span>](ec-activate.md)                       | <span data-ttu-id="d0362-274">Enviado por renderizadores de vídeo no modo de renderização de tela inteira para cada mensagem de ACTIVATEAPP do WM \_ recebida.</span><span class="sxs-lookup"><span data-stu-id="d0362-274">Sent by video renderers in full-screen rendering mode for each WM\_ACTIVATEAPP message received.</span></span>                                                                                                  |
| [<span data-ttu-id="d0362-275">**EC \_ concluído**</span><span class="sxs-lookup"><span data-stu-id="d0362-275">**EC\_COMPLETE**</span></span>](ec-complete.md)                       | <span data-ttu-id="d0362-276">Enviado por renderizadores após a renderização de todos os dados.</span><span class="sxs-lookup"><span data-stu-id="d0362-276">Sent by renderers after all data has been rendered.</span></span>                                                                                                                                               |
| [<span data-ttu-id="d0362-277">**exibição do EC \_ \_ alterada**</span><span class="sxs-lookup"><span data-stu-id="d0362-277">**EC\_DISPLAY\_CHANGED**</span></span>](ec-display-changed.md)        | <span data-ttu-id="d0362-278">Enviado por renderizadores de vídeo quando um formato de exibição é alterado.</span><span class="sxs-lookup"><span data-stu-id="d0362-278">Sent by video renderers when a display format changes.</span></span>                                                                                                                                            |
| [<span data-ttu-id="d0362-279">**paleta do EC \_ \_ alterada**</span><span class="sxs-lookup"><span data-stu-id="d0362-279">**EC\_PALETTE\_CHANGED**</span></span>](ec-palette-changed.md)        | <span data-ttu-id="d0362-280">Enviado sempre que um processador de vídeo detecta uma alteração de paleta no fluxo.</span><span class="sxs-lookup"><span data-stu-id="d0362-280">Sent whenever a video renderer detects a palette change in the stream.</span></span>                                                                                                                            |
| [<span data-ttu-id="d0362-281">**redesenho de EC \_**</span><span class="sxs-lookup"><span data-stu-id="d0362-281">**EC\_REPAINT**</span></span>](ec-repaint.md)                         | <span data-ttu-id="d0362-282">Enviado por renderizadores de vídeo interrompidos ou pausados quando uma mensagem de pintura do WM \_ é recebida e não há dados a serem exibidos.</span><span class="sxs-lookup"><span data-stu-id="d0362-282">Sent by stopped or paused video renderers when a WM\_PAINT message is received and there is no data to display.</span></span> <span data-ttu-id="d0362-283">Isso faz com que o Gerenciador de gráfico de filtro gere um quadro para pintar para a exibição.</span><span class="sxs-lookup"><span data-stu-id="d0362-283">This causes the Filter Graph Manager to generate a frame to paint to the display.</span></span> |
| [<span data-ttu-id="d0362-284">**autoanulação do EC \_**</span><span class="sxs-lookup"><span data-stu-id="d0362-284">**EC\_USERABORT**</span></span>](ec-userabort.md)                     | <span data-ttu-id="d0362-285">Enviado por renderizadores de vídeo para sinalizar um fechamento solicitado pelo usuário (por exemplo, um usuário fechando a janela de vídeo).</span><span class="sxs-lookup"><span data-stu-id="d0362-285">Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window).</span></span>                                                                               |
| [<span data-ttu-id="d0362-286">**tamanho de vídeo do EC \_ \_ \_ alterado**</span><span class="sxs-lookup"><span data-stu-id="d0362-286">**EC\_VIDEO\_SIZE\_CHANGED**</span></span>](ec-video-size-changed.md) | <span data-ttu-id="d0362-287">Enviado por renderizadores de vídeo sempre que uma alteração no tamanho de vídeo nativo é detectada.</span><span class="sxs-lookup"><span data-stu-id="d0362-287">Sent by video renderers whenever a change in native video size is detected.</span></span>                                                                                                                       |
| [<span data-ttu-id="d0362-288">**janela do EC \_ \_ destruída**</span><span class="sxs-lookup"><span data-stu-id="d0362-288">**EC\_WINDOW\_DESTROYED**</span></span>](ec-window-destroyed.md)      | <span data-ttu-id="d0362-289">Enviado por renderizadores de vídeo quando o filtro é removido ou destruído para que os recursos que dependem do foco da janela possam ser passados para outros filtros.</span><span class="sxs-lookup"><span data-stu-id="d0362-289">Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.</span></span>                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="d0362-290">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="d0362-290">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d0362-291">Escrevendo renderizadores de vídeo</span><span class="sxs-lookup"><span data-stu-id="d0362-291">Writing Video Renderers</span></span>](writing-video-renderers.md)
</dt> </dl>

 

 
