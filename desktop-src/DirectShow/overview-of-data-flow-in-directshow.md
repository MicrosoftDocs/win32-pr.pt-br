---
description: Visão geral do fluxo de dados no DirectShow
ms.assetid: a1b30592-5106-44f5-8ee0-577573670167
title: Visão geral do fluxo de dados no DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5a34444991d6cba62026935f5ec2d7aa4eba77
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/06/2021
ms.locfileid: "104456759"
---
# <a name="overview-of-data-flow-in-directshow"></a><span data-ttu-id="79dd3-103">Visão geral do fluxo de dados no DirectShow</span><span class="sxs-lookup"><span data-stu-id="79dd3-103">Overview of Data Flow in DirectShow</span></span>

<span data-ttu-id="79dd3-104">Esta seção fornece uma ampla visão geral de como funciona o fluxo de dados no DirectShow.</span><span class="sxs-lookup"><span data-stu-id="79dd3-104">This section gives a broad overview of how data flow works in DirectShow.</span></span> <span data-ttu-id="79dd3-105">Os detalhes podem ser encontrados em outras seções da documentação.</span><span class="sxs-lookup"><span data-stu-id="79dd3-105">Details can be found in other sections of the documentation.</span></span>

<span data-ttu-id="79dd3-106">Os dados são mantidos em buffers, que são simplesmente matrizes de bytes.</span><span class="sxs-lookup"><span data-stu-id="79dd3-106">Data is held in buffers, which are simply arrays of bytes.</span></span> <span data-ttu-id="79dd3-107">Cada buffer é encapsulado por um objeto COM chamado de *exemplo de mídia*, que implementa a interface [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="79dd3-107">Each buffer is wrapped by a COM object called a *media sample*, which implements the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="79dd3-108">Os exemplos são criados por outro tipo de objeto, chamado de alocador, que implementa a interface [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="79dd3-108">Samples are created by another type of object, called an allocator, which implements the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="79dd3-109">Um alocador é atribuído a cada conexão de PIN, embora duas ou mais conexões de PIN possam compartilhar o mesmo alocador.</span><span class="sxs-lookup"><span data-stu-id="79dd3-109">An allocator is assigned for every pin connection, although two or more pin connections might share the same allocator.</span></span> <span data-ttu-id="79dd3-110">A imagem a seguir ilustra esse processo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-110">The following image illustrates this process.</span></span>

![buffers, amostras e alocadores](images/dataflow.png)

<span data-ttu-id="79dd3-112">Cada alocador cria um pool de amostras de mídia e aloca os buffers para cada amostra.</span><span class="sxs-lookup"><span data-stu-id="79dd3-112">Each allocator creates a pool of media samples and allocates the buffers for each sample.</span></span> <span data-ttu-id="79dd3-113">Sempre que um filtro precisa preencher um buffer com dados, ele solicita um exemplo do alocador chamando [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="79dd3-113">Whenever a filter needs to fill a buffer with data, it requests a sample from the allocator by calling [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="79dd3-114">Se o alocador tiver exemplos que não estão atualmente em uso por outro filtro, o método **GetBuffer** retornará imediatamente com um ponteiro para o exemplo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-114">If the allocator has any samples that are not currently in use by another filter, the **GetBuffer** method returns immediately with a pointer to the sample.</span></span> <span data-ttu-id="79dd3-115">Se todas as amostras do alocador estiverem em uso, o método será bloqueado até que um exemplo se torne disponível.</span><span class="sxs-lookup"><span data-stu-id="79dd3-115">If all of the allocator's samples are in use, the method blocks until a sample becomes available.</span></span> <span data-ttu-id="79dd3-116">Quando o método retorna um exemplo, o filtro coloca os dados no buffer, define os sinalizadores apropriados no exemplo (normalmente incluindo um carimbo de data/hora) e entrega o exemplo downstream.</span><span class="sxs-lookup"><span data-stu-id="79dd3-116">When the method does return a sample, the filter puts data into the buffer, sets the appropriate flags on the sample (typically including a time stamp), and delivers the sample downstream.</span></span>

<span data-ttu-id="79dd3-117">Quando um filtro de renderizador recebe um exemplo, ele verifica o carimbo de data/hora e se mantém na amostra até que o relógio de referência do grafo de filtro indique que os dados devem ser renderizados.</span><span class="sxs-lookup"><span data-stu-id="79dd3-117">When a renderer filter receives a sample, it checks the time stamp and holds onto the sample until the filter graph's reference clock indicates that the data should be rendered.</span></span> <span data-ttu-id="79dd3-118">Depois que o filtro renderiza os dados, ele libera o exemplo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-118">After the filter renders the data, it releases the sample.</span></span> <span data-ttu-id="79dd3-119">O exemplo não volta para o pool de exemplos do alocador até que a contagem de referência da amostra seja zero, o que significa que cada filtro liberou o exemplo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-119">The sample does not go back into the allocator's pool of samples until the sample's reference count is zero, meaning that every filter has released the sample.</span></span> <span data-ttu-id="79dd3-120">A imagem a seguir ilustra esse processo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-120">The following image illustrates this process.</span></span>

![decodificador aguardando um exemplo de mídia livre](images/dataflow2.png)

<span data-ttu-id="79dd3-122">O filtro upstream pode ser executado antes do renderizador, ou seja, ele pode preencher buffers mais rápido do que o renderizador consumi-los.</span><span class="sxs-lookup"><span data-stu-id="79dd3-122">The upstream filter might run ahead of the renderer — that is, it might fill buffers faster than the renderer consumes them.</span></span> <span data-ttu-id="79dd3-123">Mesmo assim, os exemplos não são renderizados antecipadamente, porque o renderizador mantém cada um até seu tempo de apresentação.</span><span class="sxs-lookup"><span data-stu-id="79dd3-123">Even so, samples do not get rendered early, because the renderer holds each until its presentation time.</span></span> <span data-ttu-id="79dd3-124">Além disso, o filtro upstream não substituirá os buffers acidentalmente, porque **getsample** retorna apenas exemplos que não estão em uso de outra forma.</span><span class="sxs-lookup"><span data-stu-id="79dd3-124">Moreover, the upstream filter will not overwrite buffers accidentally, because **GetSample** only returns samples that are not otherwise in use.</span></span> <span data-ttu-id="79dd3-125">O valor pelo qual o filtro upstream pode ser executado à frente é determinado pelo número de amostras no pool do alocador.</span><span class="sxs-lookup"><span data-stu-id="79dd3-125">The amount by which the upstream filter can run ahead is determined by the number of samples in the allocator's pool.</span></span>

<span data-ttu-id="79dd3-126">O diagrama anterior mostra apenas um alocador, mas normalmente há vários alocadores por fluxo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-126">The previous diagram only shows one allocator, but typically there are several allocators per stream.</span></span> <span data-ttu-id="79dd3-127">Assim, quando o renderizador libera um exemplo, ele pode ter um efeito em cascata.</span><span class="sxs-lookup"><span data-stu-id="79dd3-127">Thus, when the renderer releases a sample, it can have a cascading effect.</span></span> <span data-ttu-id="79dd3-128">O diagrama a seguir mostra uma situação em que um decodificador mantém um quadro de vídeo compactado enquanto aguarda o processador liberar um exemplo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-128">The following diagram shows a situation where a decoder holds a compressed video frame while it waits for the renderer to release a sample.</span></span> <span data-ttu-id="79dd3-129">Um filtro do analisador também está aguardando que o decodificador Libere um exemplo.</span><span class="sxs-lookup"><span data-stu-id="79dd3-129">A parser filter is also waiting for the decoder to release a sample.</span></span>

![dois filtros aguardando exemplos](images/dataflow3.png)

<span data-ttu-id="79dd3-131">Quando o renderizador libera seu exemplo, a chamada pendente do decodificador para **GetBuffer** retorna.</span><span class="sxs-lookup"><span data-stu-id="79dd3-131">When the renderer releases its sample, the decoder's pending call to **GetBuffer** returns.</span></span> <span data-ttu-id="79dd3-132">O decodificador pode, então, decodificar o quadro de vídeo compactado e liberar o exemplo que estava segurando, desbloqueando, assim, a chamada **GetBuffer** pendente do analisador.</span><span class="sxs-lookup"><span data-stu-id="79dd3-132">The decoder can then decode the compressed video frame and release the sample it was holding, thereby unblocking the parser's pending **GetBuffer** call.</span></span>

## <a name="related-topics"></a><span data-ttu-id="79dd3-133">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="79dd3-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="79dd3-134">Fluxo de dados no grafo de filtro</span><span class="sxs-lookup"><span data-stu-id="79dd3-134">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



