---
description: Exemplos e alocadores
ms.assetid: 1fbea741-f29a-4815-9885-94ca9cf4bb95
title: Exemplos e alocadores
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6f9132ff2c70b5ade63f8853b5c03bacb7a25371
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/06/2021
ms.locfileid: "104551410"
---
# <a name="samples-and-allocators"></a><span data-ttu-id="d3616-103">Exemplos e alocadores</span><span class="sxs-lookup"><span data-stu-id="d3616-103">Samples and Allocators</span></span>

<span data-ttu-id="d3616-104">Quando um PIN entrega dados de mídia para outro PIN, ele não passa um ponteiro direto para o buffer de memória.</span><span class="sxs-lookup"><span data-stu-id="d3616-104">When a pin delivers media data to another pin, it does not pass a direct pointer to the memory buffer.</span></span> <span data-ttu-id="d3616-105">Em vez disso, ele fornece um ponteiro para um objeto COM que gerencia a memória.</span><span class="sxs-lookup"><span data-stu-id="d3616-105">Instead, it delivers a pointer to a COM object that manages the memory.</span></span> <span data-ttu-id="d3616-106">Esse objeto, chamado de *exemplo de mídia*, expõe a interface [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="d3616-106">This object, called a *media sample*, exposes the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="d3616-107">O PIN de recebimento acessa o buffer de memória chamando métodos **IMediaSample** , como [**IMediaSample:: getpointr**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample:: GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize)e [**IMediaSample:: GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span><span class="sxs-lookup"><span data-stu-id="d3616-107">The receiving pin accesses the memory buffer by calling **IMediaSample** methods, such as [**IMediaSample::GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample::GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize), and [**IMediaSample::GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span></span>

<span data-ttu-id="d3616-108">Os exemplos sempre viajam downstream, do pino de saída para o pino de entrada.</span><span class="sxs-lookup"><span data-stu-id="d3616-108">Samples always travel downstream, from output pin to input pin.</span></span> <span data-ttu-id="d3616-109">No modelo de push, o pino de saída entrega um exemplo chamando [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) no pino de entrada.</span><span class="sxs-lookup"><span data-stu-id="d3616-109">In the push model, the output pin delivers a sample by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the input pin.</span></span> <span data-ttu-id="d3616-110">O PIN de entrada processará os dados de forma síncrona (ou seja, completamente dentro do método **Receive** ) ou o processará de maneira assíncrona em um thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="d3616-110">The input pin will either process the data synchronously (that is, completely inside the **Receive** method), or process it asynchronously on a worker thread.</span></span> <span data-ttu-id="d3616-111">O PIN de entrada tem permissão para bloquear dentro do método **Receive** , se precisar aguardar recursos.</span><span class="sxs-lookup"><span data-stu-id="d3616-111">The input pin is allowed to block within the **Receive** method, if it needs to wait for resources.</span></span>

<span data-ttu-id="d3616-112">Outro objeto COM, chamado de *alocador*, é responsável por criar e gerenciar exemplos de mídia.</span><span class="sxs-lookup"><span data-stu-id="d3616-112">Another COM object, called an *allocator*, is responsible for creating and managing media samples.</span></span> <span data-ttu-id="d3616-113">Os alocadores expõem a interface [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="d3616-113">Allocators expose the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="d3616-114">Sempre que um filtro precisa de um exemplo de mídia com um buffer vazio, ele chama o método [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , que retorna um ponteiro para o exemplo.</span><span class="sxs-lookup"><span data-stu-id="d3616-114">Whenever a filter needs a media sample with an empty buffer, it calls the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, which returns a pointer to the sample.</span></span> <span data-ttu-id="d3616-115">Cada conexão de PIN compartilha um alocador.</span><span class="sxs-lookup"><span data-stu-id="d3616-115">Every pin connection shares one allocator.</span></span> <span data-ttu-id="d3616-116">Quando dois Pins se conectam, eles decidem qual filtro fornecerá o alocador.</span><span class="sxs-lookup"><span data-stu-id="d3616-116">When two pins connect, they decide which filter will provide the allocator.</span></span> <span data-ttu-id="d3616-117">Os Pins também definem as propriedades no alocador, como o número de buffers e o tamanho de cada buffer.</span><span class="sxs-lookup"><span data-stu-id="d3616-117">The pins also set properties on the allocator, such as the number of buffers and the size of each buffer.</span></span> <span data-ttu-id="d3616-118">(Para obter detalhes, consulte [como os filtros se conectam](how-filters-connect.md) e [negociam os alocadores](negotiating-allocators.md).)</span><span class="sxs-lookup"><span data-stu-id="d3616-118">(For details, see [How Filters Connect](how-filters-connect.md) and [Negotiating Allocators](negotiating-allocators.md).)</span></span>

<span data-ttu-id="d3616-119">A ilustração a seguir mostra as relações entre o alocador, os exemplos de mídia e o filtro.</span><span class="sxs-lookup"><span data-stu-id="d3616-119">The following illustration shows the relationships among the allocator, the media samples, and the filter.</span></span>

![exemplos de mídia e alocadores](images/mediasamples.png)

<span data-ttu-id="d3616-121">**Contagens de referência de exemplo de mídia**</span><span class="sxs-lookup"><span data-stu-id="d3616-121">**Media Sample Reference Counts**</span></span>

<span data-ttu-id="d3616-122">Um alocador cria um pool finito de exemplos.</span><span class="sxs-lookup"><span data-stu-id="d3616-122">An allocator creates a finite pool of samples.</span></span> <span data-ttu-id="d3616-123">A qualquer momento, alguns exemplos podem estar em uso, enquanto outros estão disponíveis para chamadas **GetBuffer** .</span><span class="sxs-lookup"><span data-stu-id="d3616-123">At any time, some samples may be in use, while others are available for **GetBuffer** calls.</span></span> <span data-ttu-id="d3616-124">O alocador usa a contagem de referência para acompanhar os exemplos.</span><span class="sxs-lookup"><span data-stu-id="d3616-124">The allocator uses reference counting to keep track of the samples.</span></span> <span data-ttu-id="d3616-125">O método **GetBuffer** retorna um exemplo com uma contagem de referência de 1.</span><span class="sxs-lookup"><span data-stu-id="d3616-125">The **GetBuffer** method returns a sample with a reference count of 1.</span></span> <span data-ttu-id="d3616-126">Se a contagem de referência chegar a zero, o exemplo voltará para o pool do alocador, onde ele poderá ser usado na próxima chamada **GetBuffer** .</span><span class="sxs-lookup"><span data-stu-id="d3616-126">If the reference count goes to zero, the sample goes back into the allocator's pool, where it can be used in the next **GetBuffer** call.</span></span> <span data-ttu-id="d3616-127">Desde que a contagem de referência permaneça acima de zero, o exemplo não estará disponível para **GetBuffer**.</span><span class="sxs-lookup"><span data-stu-id="d3616-127">As long as the reference count remains above zero, the sample is not available to **GetBuffer**.</span></span> <span data-ttu-id="d3616-128">Se cada amostra pertencente ao alocador estiver em uso, o método **GetBuffer** será bloqueado até que um exemplo se torne disponível.</span><span class="sxs-lookup"><span data-stu-id="d3616-128">If every sample belonging to the allocator is in use, the **GetBuffer** method blocks until a sample becomes available.</span></span>

<span data-ttu-id="d3616-129">Por exemplo, suponha que um PIN de entrada receba um exemplo.</span><span class="sxs-lookup"><span data-stu-id="d3616-129">For example, suppose that an input pin receives a sample.</span></span> <span data-ttu-id="d3616-130">Se ele processa o exemplo de forma síncrona, dentro do método **Receive** , ele não incrementa a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="d3616-130">If it processes the sample synchronously, inside the **Receive** method, it does not increment the reference count.</span></span> <span data-ttu-id="d3616-131">Após **Receive** Returns, o pino de saída libera o exemplo, a contagem de referência vai para zero e o exemplo retorna ao pool do alocador.</span><span class="sxs-lookup"><span data-stu-id="d3616-131">After **Receive** returns, the output pin releases the sample, the reference count goes to zero, and the sample returns to the allocator's pool.</span></span> <span data-ttu-id="d3616-132">Por outro lado, se o pino de entrada processar o exemplo em um thread de trabalho, ele incrementará a contagem de referência antes de sair do método **Receive** .</span><span class="sxs-lookup"><span data-stu-id="d3616-132">On the other hand, if the input pin processes the sample on a worker thread, it increments the reference count before leaving the **Receive** method.</span></span> <span data-ttu-id="d3616-133">A contagem de referência agora é 2.</span><span class="sxs-lookup"><span data-stu-id="d3616-133">The reference count is now 2.</span></span> <span data-ttu-id="d3616-134">Quando o pino de saída libera o exemplo, a contagem vai para 1; o exemplo ainda não retorna ao pool.</span><span class="sxs-lookup"><span data-stu-id="d3616-134">When the output pin releases the sample, the count goes to 1; the sample does not yet return to the pool.</span></span> <span data-ttu-id="d3616-135">Depois que o thread de trabalho é concluído com o exemplo, ele chama **Release** para liberar o exemplo.</span><span class="sxs-lookup"><span data-stu-id="d3616-135">After the worker thread is done with the sample, it calls **Release** to free the sample.</span></span> <span data-ttu-id="d3616-136">Agora, o exemplo retorna ao pool.</span><span class="sxs-lookup"><span data-stu-id="d3616-136">Now the sample returns to the pool.</span></span>

<span data-ttu-id="d3616-137">Quando um PIN recebe um exemplo, ele pode copiar os dados para outro exemplo ou pode modificar o exemplo original e entregá-lo para o próximo filtro.</span><span class="sxs-lookup"><span data-stu-id="d3616-137">When a pin receives a sample, it can copy the data to another sample, or it can modify the original sample and deliver that one to the next filter.</span></span> <span data-ttu-id="d3616-138">Potencialmente, um exemplo pode viajar toda a duração do grafo, cada filtro chamando **AddRef** e **Release** por vez.</span><span class="sxs-lookup"><span data-stu-id="d3616-138">Potentially, a sample can travel the entire length of the graph, each filter calling **AddRef** and **Release** in turn.</span></span> <span data-ttu-id="d3616-139">Portanto, o pino de saída nunca deve reutilizar um exemplo depois de chamar **Receive**, pois um filtro downstream pode estar usando o exemplo.</span><span class="sxs-lookup"><span data-stu-id="d3616-139">Therefore, the output pin must never re-use a sample after it calls **Receive**, because a downstream filter may be using the sample.</span></span> <span data-ttu-id="d3616-140">O pino de saída deve sempre chamar **GetBuffer** para obter um novo exemplo.</span><span class="sxs-lookup"><span data-stu-id="d3616-140">The output pin must always call **GetBuffer** to get a new sample.</span></span>

<span data-ttu-id="d3616-141">Esse mecanismo reduz a quantidade de alocação de memória, pois os filtros reutilizam os mesmos buffers.</span><span class="sxs-lookup"><span data-stu-id="d3616-141">This mechanism reduces the amount of memory allocation, because filters re-use the same buffers.</span></span> <span data-ttu-id="d3616-142">Ele também impede que os filtros gravem acidentalmente dados que não foram processados, pois o alocador mantém uma lista de exemplos disponíveis.</span><span class="sxs-lookup"><span data-stu-id="d3616-142">It also prevents filters from accidentally writing over data that has not been processed, because the allocator maintains a list of available samples.</span></span>

<span data-ttu-id="d3616-143">Um filtro pode usar alocadores separados para entrada e saída.</span><span class="sxs-lookup"><span data-stu-id="d3616-143">A filter can use separate allocators for input and output.</span></span> <span data-ttu-id="d3616-144">Isso poderá fazer isso se expandir os dados de entrada (por exemplo, descompactando-os).</span><span class="sxs-lookup"><span data-stu-id="d3616-144">It might do this if it expands the input data (for example, by decompressing it).</span></span> <span data-ttu-id="d3616-145">Se a saída não for maior que a entrada, um filtro poderá processar os dados no local, sem copiá-los para um novo exemplo.</span><span class="sxs-lookup"><span data-stu-id="d3616-145">If the output is no larger than the input, a filter might process the data in place, without copying it to a new sample.</span></span> <span data-ttu-id="d3616-146">Nesse caso, duas ou mais conexões de PIN podem compartilhar um alocador.</span><span class="sxs-lookup"><span data-stu-id="d3616-146">In that case, two or more pin connections can share one allocator.</span></span>

<span data-ttu-id="d3616-147">**Confirmando e confirmando alocadores**</span><span class="sxs-lookup"><span data-stu-id="d3616-147">**Committing and Decommitting Allocators**</span></span>

<span data-ttu-id="d3616-148">Quando um filtro cria primeiro um alocador, o alocador não reservou nenhum buffer de memória.</span><span class="sxs-lookup"><span data-stu-id="d3616-148">When a filter first creates an allocator, the allocator has not reserved any memory buffers.</span></span> <span data-ttu-id="d3616-149">Neste ponto, todas as chamadas para o método **GetBuffer** falharão.</span><span class="sxs-lookup"><span data-stu-id="d3616-149">At this point, any calls to the **GetBuffer** method will fail.</span></span> <span data-ttu-id="d3616-150">Quando o streaming começa, o pino de saída chama [**IMemAllocator:: Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), que confirma o alocador, fazendo com que ele aloque memória.</span><span class="sxs-lookup"><span data-stu-id="d3616-150">When streaming starts, the output pin calls [**IMemAllocator::Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), which commits the allocator, causing it to allocate memory.</span></span> <span data-ttu-id="d3616-151">Os Pins agora podem chamar **GetBuffer**.</span><span class="sxs-lookup"><span data-stu-id="d3616-151">Pins can now call **GetBuffer**.</span></span>

<span data-ttu-id="d3616-152">Quando o streaming é interrompido, o PIN chama [**IMemAllocator::D ecommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), que desconfirma o alocador.</span><span class="sxs-lookup"><span data-stu-id="d3616-152">When streaming stops, the pin calls [**IMemAllocator::Decommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), which decommits the allocator.</span></span> <span data-ttu-id="d3616-153">Todas as chamadas subsequentes para **GetBuffer** falham até que o alocador seja confirmado novamente.</span><span class="sxs-lookup"><span data-stu-id="d3616-153">All subsequent calls to **GetBuffer** fail until the allocator is committed again.</span></span> <span data-ttu-id="d3616-154">Além disso, se todas as chamadas para **GetBuffer** estiverem atualmente bloqueadas aguardando um exemplo, elas retornarão imediatamente um código de falha.</span><span class="sxs-lookup"><span data-stu-id="d3616-154">Also, if any calls to **GetBuffer** are currently blocked waiting for a sample, they immediately return a failure code.</span></span> <span data-ttu-id="d3616-155">O método de **desconfirmação** pode ou não liberar a memória, dependendo da implementação.</span><span class="sxs-lookup"><span data-stu-id="d3616-155">The **Decommit** method may or may not free the memory, depending on the implementation.</span></span> <span data-ttu-id="d3616-156">Por exemplo, a classe [**CMemAllocator**](cmemallocator.md) aguarda até que seu método destruidor Libere memória.</span><span class="sxs-lookup"><span data-stu-id="d3616-156">For example, the [**CMemAllocator**](cmemallocator.md) class waits until its destructor method to free memory.</span></span>

## <a name="related-topics"></a><span data-ttu-id="d3616-157">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="d3616-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d3616-158">Fluxo de dados no grafo de filtro</span><span class="sxs-lookup"><span data-stu-id="d3616-158">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 
