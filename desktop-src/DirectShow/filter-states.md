---
description: Estados de filtro
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: Estados de filtro
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d61f66e1446d97d289f7e489f116f747f339d9a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/06/2021
ms.locfileid: "105750636"
---
# <a name="filter-states"></a><span data-ttu-id="2cb6b-103">Estados de filtro</span><span class="sxs-lookup"><span data-stu-id="2cb6b-103">Filter States</span></span>

<span data-ttu-id="2cb6b-104">Os filtros têm três estados possíveis: parado, em pausa e em execução.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-104">Filters have three possible states: stopped, paused, and running.</span></span> <span data-ttu-id="2cb6b-105">A finalidade do estado de pausa é a indicação de dados no grafo, para que um comando de execução responda imediatamente.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-105">The purpose of the paused state is to cue data in the graph, so that a run command responds immediately.</span></span> <span data-ttu-id="2cb6b-106">O Gerenciador de gráfico de filtro controla todas as transições de estado.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-106">The Filter Graph Manager controls all state transitions.</span></span> <span data-ttu-id="2cb6b-107">Quando um aplicativo chama [**IMediaControl:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)ou [**IMediaControl:: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), o Gerenciador de grafo de filtro chama o método [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) correspondente em todos os filtros.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-107">When an application calls [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause), or [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), the Filter Graph Manager calls the corresponding [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) method on all of the filters.</span></span> <span data-ttu-id="2cb6b-108">As transições entre a parada e a execução sempre passam pelo estado pausado, portanto, se o aplicativo chamar **executar** em um grafo parado, o Gerenciador de gráfico de filtro pausará o grafo antes de executá-lo.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-108">Transitions between stopped and running always go through the paused state, so if the application calls **Run** on a stopped graph, the Filter Graph Manager pauses the graph before running it.</span></span>

<span data-ttu-id="2cb6b-109">Para a maioria dos filtros, os Estados em execução e em pausa são idênticos.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-109">For most filters, the running and paused states are identical.</span></span> <span data-ttu-id="2cb6b-110">Considere o seguinte grafo de filtro:</span><span class="sxs-lookup"><span data-stu-id="2cb6b-110">Consider the following filter graph:</span></span>

<span data-ttu-id="2cb6b-111">Processador de > de transformação de > de origem</span><span class="sxs-lookup"><span data-stu-id="2cb6b-111">Source > Transform > Renderer</span></span>

<span data-ttu-id="2cb6b-112">Suponha que, por enquanto, o filtro de origem não seja uma origem de captura dinâmica.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-112">Assume for now that the source filter is not a live capture source.</span></span> <span data-ttu-id="2cb6b-113">Quando o filtro de origem pausa, ele cria um thread que gera novos dados e grava-os em amostras de mídia o mais rápido possível.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-113">When the source filter pauses, it creates a thread that generates new data and writes it into media samples as quickly as possible.</span></span> <span data-ttu-id="2cb6b-114">O thread "envia por push" as amostras downstream chamando [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) no pino de entrada do filtro de transformação.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-114">The thread "pushes" the samples downstream by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the transform filter's input pin.</span></span> <span data-ttu-id="2cb6b-115">O filtro de transformação recebe os exemplos no thread do filtro de origem.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-115">The transform filter receives the samples on the source filter's thread.</span></span> <span data-ttu-id="2cb6b-116">Ele pode usar um thread de trabalho para entregar os exemplos para o renderizador, mas normalmente os entrega no mesmo thread.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-116">It may use a worker thread to deliver the samples to the renderer, but typically it delivers them on the same thread.</span></span> <span data-ttu-id="2cb6b-117">Enquanto o renderizador está em pausa, ele aguarda para receber um exemplo.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-117">While the renderer is paused, it waits to receive a sample.</span></span> <span data-ttu-id="2cb6b-118">Depois de receber um, ele bloqueia e mantém esse exemplo indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-118">After it receives one, it blocks and holds that sample indefinitely.</span></span> <span data-ttu-id="2cb6b-119">Se for um processador de vídeo, ele exibirá o exemplo como uma imagem de pôster, redesenhando a imagem conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-119">If it is a video renderer, it displays the sample as a poster image, repainting the image as necessary.</span></span>

<span data-ttu-id="2cb6b-120">Neste ponto, o fluxo é totalmente cued e está pronto para renderização.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-120">At this point, the stream is fully cued and ready for rendering.</span></span> <span data-ttu-id="2cb6b-121">Se o grafo permanecer em pausa, os exemplos serão "acumulados" no grafo atrás do primeiro exemplo, até que cada filtro seja bloqueado em [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) ou [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="2cb6b-121">If the graph remains paused, samples will "pile up" in the graph behind the first sample, until every filter is blocked in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="2cb6b-122">No entanto, nenhum dado é perdido.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-122">No data is lost, though.</span></span> <span data-ttu-id="2cb6b-123">Depois que o thread de origem é desbloqueado, ele simplesmente retoma a partir do ponto em que ele foi bloqueado.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-123">Once the source thread is unblocked, it simply resumes from the point where it blocked.</span></span>

<span data-ttu-id="2cb6b-124">O filtro de origem e o filtro de transformação ignoram a transição de em pausa para em execução – eles simplesmente continuam processando os dados o mais rápido possível.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-124">The source filter and the transform filter ignore the transition from paused to running—they simply continue to process data as fast as possible.</span></span> <span data-ttu-id="2cb6b-125">Mas quando o processador é executado, ele inicia a renderização de exemplos.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-125">But when the renderer runs, it starts rendering samples.</span></span> <span data-ttu-id="2cb6b-126">Primeiro, ele renderiza o exemplo mantido enquanto ele estava em pausa.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-126">First it renders the sample it held while it was paused.</span></span> <span data-ttu-id="2cb6b-127">Em seguida, sempre que receber um novo exemplo, ele calculará o tempo de apresentação do exemplo.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-127">Then, each time it receives a new sample, it calculates the sample's presentation time.</span></span> <span data-ttu-id="2cb6b-128">(Para obter detalhes, consulte [tempo e relógios no DirectShow](time-and-clocks-in-directshow.md).) O renderizador mantém cada amostra até o momento da apresentação, ponto em que ele renderiza o exemplo.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-128">(For details, see [Time and Clocks in DirectShow](time-and-clocks-in-directshow.md).) The renderer holds each sample until the presentation time, at which point it renders the sample.</span></span> <span data-ttu-id="2cb6b-129">Enquanto ele aguarda o tempo de apresentação, ele é bloqueado no método [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) ou recebe novos exemplos em um thread de trabalho com uma fila.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-129">While it waits for the presentation time, it either blocks in the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, or receives new samples on a worker thread with a queue.</span></span> <span data-ttu-id="2cb6b-130">Os filtros upstream do renderizador não estão envolvidos no agendamento.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-130">Filters upstream from the renderer are not involved in scheduling.</span></span>

<span data-ttu-id="2cb6b-131">Fontes dinâmicas, como dispositivos de captura, são uma exceção para essa arquitetura geral.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-131">Live sources, such as capture devices, are an exception to this general architecture.</span></span> <span data-ttu-id="2cb6b-132">Com uma fonte dinâmica, não é apropriado marcar os dados com antecedência.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-132">With a live source, it is not appropriate to cue any data in advance.</span></span> <span data-ttu-id="2cb6b-133">O aplicativo pode pausar o grafo e aguardar um longo tempo antes de executá-lo.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-133">The application might pause the graph and then wait for a long time before running it.</span></span> <span data-ttu-id="2cb6b-134">O grafo não deve renderizar exemplos "obsoletos".</span><span class="sxs-lookup"><span data-stu-id="2cb6b-134">The graph should not render "stale" samples.</span></span> <span data-ttu-id="2cb6b-135">Portanto, uma fonte dinâmica não produz amostras enquanto está em pausa, somente durante a execução.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-135">Therefore, a live source produces no samples while paused, only while running.</span></span> <span data-ttu-id="2cb6b-136">Para sinalizar esse fato com o Gerenciador do grafo de filtro, o método [**IMediaFilter:: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) do filtro de origem retorna VFW s não está \_ \_ \_ cue.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-136">To signal this fact to the Filter Graph Manager, the source filter's [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) method returns VFW\_S\_CANT\_CUE.</span></span> <span data-ttu-id="2cb6b-137">Esse código de retorno indica que o filtro mudou para o estado em pausa, embora o renderizador não tenha recebido nenhum dado.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-137">This return code indicates that the filter has switched to the paused state, even though the renderer did not receive any data.</span></span>

<span data-ttu-id="2cb6b-138">Quando um filtro é interrompido, ele rejeita mais exemplos entregues a ele.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-138">When a filter stops, it rejects any more samples delivered to it.</span></span> <span data-ttu-id="2cb6b-139">Os filtros de origem desligam seus threads de streaming e outros filtros desligam quaisquer threads de trabalho que eles possam ter criado.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-139">Source filters shut down their streaming threads, and other filters shut down any worker threads they may have created.</span></span> <span data-ttu-id="2cb6b-140">Os Pins desconfirmam seus alocadores.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-140">Pins decommit their allocators.</span></span>

### <a name="state-transitions"></a><span data-ttu-id="2cb6b-141">Transições de estado</span><span class="sxs-lookup"><span data-stu-id="2cb6b-141">State Transitions</span></span>

<span data-ttu-id="2cb6b-142">O Gerenciador de grafo de filtro executa todas as transições de estado na ordem de upstream, começando do renderizador e trabalhando de volta para o filtro de origem.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-142">The Filter Graph Manager carries out all state transitions in upstream order, starting from the renderer and working backward to the source filter.</span></span> <span data-ttu-id="2cb6b-143">Essa ordenação é necessária para evitar que amostras sejam descartadas e impedir que o grafo seja bloqueado.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-143">This ordering is necessary to prevent samples from being dropped and to prevent the graph from deadlocking.</span></span> <span data-ttu-id="2cb6b-144">As transições de estado mais cruciais ficam entre pausa e parada:</span><span class="sxs-lookup"><span data-stu-id="2cb6b-144">The most crucial state transitions are between paused and stopped:</span></span>

-   <span data-ttu-id="2cb6b-145">Parado para pausado: como cada filtro é pausado, ele fica pronto para receber amostras do próximo filtro.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-145">Stopped to paused: As each filter pauses, it becomes ready to receive samples from the next filter.</span></span> <span data-ttu-id="2cb6b-146">O filtro de origem é o último a ser pausado.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-146">The source filter is the last to pause.</span></span> <span data-ttu-id="2cb6b-147">Ele cria o thread de streaming e começa a fornecer exemplos.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-147">It creates the streaming thread and begins delivering samples.</span></span> <span data-ttu-id="2cb6b-148">Como todos os filtros downstream estão em pausa, nenhum filtro rejeita nenhuma amostra.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-148">Because all of the downstream filters are paused, no filter rejects any samples.</span></span> <span data-ttu-id="2cb6b-149">O Gerenciador do grafo de filtro não conclui a transição até que todos os renderizadores no grafo tenham recebido um exemplo (com exceção das fontes dinâmicas, conforme descrito anteriormente).</span><span class="sxs-lookup"><span data-stu-id="2cb6b-149">The Filter Graph Manager does not complete the transition until every renderer in the graph has received a sample (with the exception of live sources, as described earlier).</span></span>
-   <span data-ttu-id="2cb6b-150">Em pausa para parado: quando um filtro é interrompido, ele libera todos os exemplos que ele contém, o que desbloqueia quaisquer filtros upstream aguardando em [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="2cb6b-150">Paused to stopped: When a filter stops, it releases any samples that it holds, which unblocks any upstream filters waiting in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="2cb6b-151">Se o filtro estiver aguardando um recurso dentro do método [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , ele interromperá a espera e retornará de **Receive**, que desbloqueará o filtro de chamada.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-151">If the filter is waiting for a resource inside the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, it stops waiting and returns from **Receive**, which unblocks the calling filter.</span></span> <span data-ttu-id="2cb6b-152">Portanto, quando o Gerenciador de gráfico de filtro para o próximo filtro upstream, esse filtro não é bloqueado em **GetBuffer** ou **Receive** e pode responder ao comando Stop.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-152">Therefore, when the Filter Graph Manager stops the next upstream filter, that filter is not blocked in either **GetBuffer** or **Receive**, and can respond to the stop command.</span></span> <span data-ttu-id="2cb6b-153">O filtro upstream pode fornecer alguns exemplos extras antes de obter o comando Stop, mas o filtro downstream simplesmente os rejeita, pois ele já parou.</span><span class="sxs-lookup"><span data-stu-id="2cb6b-153">The upstream filter might deliver a few extra samples before it gets the stop command, but the downstream filter simply rejects them, because it already stopped.</span></span>

## <a name="related-topics"></a><span data-ttu-id="2cb6b-154">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="2cb6b-154">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="2cb6b-155">Fluxo de dados no grafo de filtro</span><span class="sxs-lookup"><span data-stu-id="2cb6b-155">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



