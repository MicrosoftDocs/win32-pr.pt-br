---
description: Os threads de streaming e aplicativo
ms.assetid: 954f7abd-fe06-430a-b6f7-d60852826bc9
title: Os threads de streaming e aplicativo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 432e613ff0322377c042e796d84ef7affdda99c2
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104506258"
---
# <a name="the-streaming-and-application-threads"></a><span data-ttu-id="5bb83-103">Os threads de streaming e aplicativo</span><span class="sxs-lookup"><span data-stu-id="5bb83-103">The Streaming and Application Threads</span></span>

<span data-ttu-id="5bb83-104">Qualquer aplicativo do DirectShow contém pelo menos dois threads importantes: o thread do aplicativo e um ou mais threads de streaming.</span><span class="sxs-lookup"><span data-stu-id="5bb83-104">Any DirectShow application contains at least two important threads: the application thread, and one or more streaming threads.</span></span> <span data-ttu-id="5bb83-105">Os exemplos são entregues nos threads de streaming e as alterações de estado acontecem no thread do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="5bb83-105">Samples are delivered on the streaming threads, and state changes happen on the application thread.</span></span> <span data-ttu-id="5bb83-106">O thread de streaming principal é criado por um filtro de origem ou analisador.</span><span class="sxs-lookup"><span data-stu-id="5bb83-106">The main streaming thread is created by a source or parser filter.</span></span> <span data-ttu-id="5bb83-107">Outros filtros podem criar threads de trabalho que entregam amostras, e esses são considerados threads de streaming também.</span><span class="sxs-lookup"><span data-stu-id="5bb83-107">Other filters might create worker threads that deliver samples, and these are considered streaming threads as well.</span></span>

<span data-ttu-id="5bb83-108">Alguns métodos são chamados no thread do aplicativo, enquanto outros são chamados em um thread de streaming.</span><span class="sxs-lookup"><span data-stu-id="5bb83-108">Some methods are called on the application thread, while others are called on a streaming thread.</span></span> <span data-ttu-id="5bb83-109">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="5bb83-109">For example:</span></span>

-   <span data-ttu-id="5bb83-110">Thread (s) de streaming: [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin:: ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPin:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="5bb83-110">Streaming thread(s): [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span>
-   <span data-ttu-id="5bb83-111">Thread do aplicativo: [**IMediaFilter::P ause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter:: Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter:: Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking:: setposições**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPin:: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPin:: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="5bb83-111">Application thread: [**IMediaFilter::Pause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter::Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter::Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking::SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span>
-   <span data-ttu-id="5bb83-112">Ou: [**IPin:: NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span><span class="sxs-lookup"><span data-stu-id="5bb83-112">Either: [**IPin::NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span></span>

<span data-ttu-id="5bb83-113">Ter um thread de streaming separado permite que os dados fluam por meio do grafo, enquanto o thread do aplicativo aguarda a entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="5bb83-113">Having a separate streaming thread allows data to flow through the graph while the application thread waits for user input.</span></span> <span data-ttu-id="5bb83-114">No entanto, o perigo de vários threads é que um filtro pode criar recursos quando pausa (no thread do aplicativo), usá-los dentro de um método de streaming e destruí-los quando ele parar (também no thread do aplicativo).</span><span class="sxs-lookup"><span data-stu-id="5bb83-114">The danger of multiple threads, however, is that a filter may create resources when it pauses (on the application thread), use them inside a streaming method, and destroy them when it stops (also on the application thread).</span></span> <span data-ttu-id="5bb83-115">Se você não tiver cuidado, o thread de streaming poderá tentar usar os recursos depois que eles forem destruídos.</span><span class="sxs-lookup"><span data-stu-id="5bb83-115">If you are not careful, the streaming thread might try to use the resources after they are destroyed.</span></span> <span data-ttu-id="5bb83-116">A solução é proteger os recursos usando seções críticas e sincronizar métodos de streaming com alterações de estado.</span><span class="sxs-lookup"><span data-stu-id="5bb83-116">The solution is to protect resources using critical sections, and synchronize streaming methods with state changes.</span></span>

<span data-ttu-id="5bb83-117">Um filtro precisa de uma seção crítica para proteger o estado do filtro.</span><span class="sxs-lookup"><span data-stu-id="5bb83-117">A filter needs one critical section to protect the filter state.</span></span> <span data-ttu-id="5bb83-118">A classe [**CBaseFilter**](cbasefilter.md) tem uma variável de membro para essa seção crítica, [**CBaseFilter:: m \_ pLock**](cbasefilter-m-plock.md).</span><span class="sxs-lookup"><span data-stu-id="5bb83-118">The [**CBaseFilter**](cbasefilter.md) class has a member variable for this critical section, [**CBaseFilter::m\_pLock**](cbasefilter-m-plock.md).</span></span> <span data-ttu-id="5bb83-119">Essa seção crítica é chamada de bloqueio de filtro.</span><span class="sxs-lookup"><span data-stu-id="5bb83-119">This critical section is called the filter lock.</span></span> <span data-ttu-id="5bb83-120">Além disso, cada PIN de entrada precisa de uma seção crítica para proteger os recursos usados pelo thread de streaming.</span><span class="sxs-lookup"><span data-stu-id="5bb83-120">Also, each input pin needs a critical section to protect resources used by the streaming thread.</span></span> <span data-ttu-id="5bb83-121">Essas seções críticas são chamadas de bloqueios de streaming; Você deve declará-los em sua classe de PIN derivada.</span><span class="sxs-lookup"><span data-stu-id="5bb83-121">These critical sections are called streaming locks; you must declare them in your derived pin class.</span></span> <span data-ttu-id="5bb83-122">É mais fácil usar a classe [**CCritSec**](ccritsec.md) , que encapsula um objeto de **\_ seção crítica** do Windows e pode ser bloqueado usando a classe [**CAutoLock**](cautolock.md) .</span><span class="sxs-lookup"><span data-stu-id="5bb83-122">It is easiest to use the [**CCritSec**](ccritsec.md) class, which wraps a Windows **CRITICAL\_SECTION** object and can be locked using the [**CAutoLock**](cautolock.md) class.</span></span> <span data-ttu-id="5bb83-123">A classe **CCritSec** também fornece algumas funções de depuração úteis.</span><span class="sxs-lookup"><span data-stu-id="5bb83-123">The **CCritSec** class also provides some useful debugging functions.</span></span> <span data-ttu-id="5bb83-124">Para obter mais informações, consulte [funções críticas de depuração de seção](critical-section-debugging-functions.md).</span><span class="sxs-lookup"><span data-stu-id="5bb83-124">For more information, see [Critical Section Debugging Functions](critical-section-debugging-functions.md).</span></span>

<span data-ttu-id="5bb83-125">Quando um filtro é interrompido ou liberado, ele deve sincronizar o thread do aplicativo com o thread de streaming.</span><span class="sxs-lookup"><span data-stu-id="5bb83-125">When a filter stops or flushes, it must synchronize the application thread with the streaming thread.</span></span> <span data-ttu-id="5bb83-126">Para evitar deadlocks, primeiro ele deve desbloquear o thread de streaming, que pode ser bloqueado por vários motivos:</span><span class="sxs-lookup"><span data-stu-id="5bb83-126">To avoid deadlocking, it must first unblock the streaming thread, which might be blocked for several reasons:</span></span>

-   <span data-ttu-id="5bb83-127">Está esperando obter um exemplo dentro do método [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , pois todas as amostras do alocador estão em uso.</span><span class="sxs-lookup"><span data-stu-id="5bb83-127">It is waiting to get a sample inside the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, because all of the allocator's samples are in use.</span></span>
-   <span data-ttu-id="5bb83-128">Ele está aguardando que outro filtro retorne de um método de streaming, como **Receive**.</span><span class="sxs-lookup"><span data-stu-id="5bb83-128">It is waiting for another filter to return from a streaming method, such as **Receive**.</span></span>
-   <span data-ttu-id="5bb83-129">Ele está esperando dentro de um de seus próprios métodos de streaming, para que algum recurso fique disponível.</span><span class="sxs-lookup"><span data-stu-id="5bb83-129">It is waiting inside one of its own streaming methods, for some resource to become available.</span></span>
-   <span data-ttu-id="5bb83-130">É um filtro de processador aguardando o tempo de apresentação do próximo exemplo</span><span class="sxs-lookup"><span data-stu-id="5bb83-130">It is a renderer filter waiting for the presentation time of the next sample</span></span>
-   <span data-ttu-id="5bb83-131">É um filtro de processador esperando dentro do método **Receive** enquanto estiver em pausa.</span><span class="sxs-lookup"><span data-stu-id="5bb83-131">It is a renderer filter waiting inside the **Receive** method while paused.</span></span>

<span data-ttu-id="5bb83-132">Portanto, quando o filtro for interrompido ou liberado, ele deverá fazer o seguinte:</span><span class="sxs-lookup"><span data-stu-id="5bb83-132">Therefore, when the filter stops or flushes, it must do the following:</span></span>

-   <span data-ttu-id="5bb83-133">Libere qualquer amostra que esteja mantendo por qualquer motivo.</span><span class="sxs-lookup"><span data-stu-id="5bb83-133">Release any sample it is holding for any reason.</span></span> <span data-ttu-id="5bb83-134">Fazer isso desbloqueia o método **GetBuffer** .</span><span class="sxs-lookup"><span data-stu-id="5bb83-134">Doing so unblocks the **GetBuffer** method.</span></span>
-   <span data-ttu-id="5bb83-135">Retornar de qualquer método de streaming o mais rápido possível.</span><span class="sxs-lookup"><span data-stu-id="5bb83-135">Return from any streaming method as quickly as possible.</span></span> <span data-ttu-id="5bb83-136">Se um método de streaming estiver aguardando um recurso, ele deverá parar de esperar imediatamente.</span><span class="sxs-lookup"><span data-stu-id="5bb83-136">If a streaming method is waiting for a resource, it must stop waiting immediately.</span></span>
-   <span data-ttu-id="5bb83-137">Comece a rejeitar amostras em **recebimento**, para que o thread de streaming não acesse mais recursos.</span><span class="sxs-lookup"><span data-stu-id="5bb83-137">Start rejecting samples in **Receive**, so that the streaming thread does not access any more resources.</span></span> <span data-ttu-id="5bb83-138">(A classe [**CBaseInputPin**](cbaseinputpin.md) lida com isso automaticamente.)</span><span class="sxs-lookup"><span data-stu-id="5bb83-138">(The [**CBaseInputPin**](cbaseinputpin.md) class handles this automatically.)</span></span>
-   <span data-ttu-id="5bb83-139">O método **Stop** deve desconfirmar todos os alocadores do filtro.</span><span class="sxs-lookup"><span data-stu-id="5bb83-139">The **Stop** method must decommit all of the filter's allocators.</span></span> <span data-ttu-id="5bb83-140">(A classe **CBaseInputPin** lida com isso automaticamente.)</span><span class="sxs-lookup"><span data-stu-id="5bb83-140">(The **CBaseInputPin** class handles this automatically.)</span></span>

<span data-ttu-id="5bb83-141">A liberação e a interrupção de ambos acontecem no thread do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="5bb83-141">Flushing and stopping both happen on the application thread.</span></span> <span data-ttu-id="5bb83-142">Um filtro é interrompido em resposta ao método [**IMediaControl:: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) .</span><span class="sxs-lookup"><span data-stu-id="5bb83-142">A filter stops in response to the [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) method.</span></span> <span data-ttu-id="5bb83-143">O Gerenciador de gráfico de filtro emite o comando parar na ordem de upstream, começando dos renderizadores e trabalhando de volta para os filtros de origem.</span><span class="sxs-lookup"><span data-stu-id="5bb83-143">The Filter Graph Manager issues the stop command in upstream order, starting from the renderers and working backward to the source filters.</span></span> <span data-ttu-id="5bb83-144">O comando Stop ocorre completamente dentro do método **CBaseFilter:: Stop** do filtro.</span><span class="sxs-lookup"><span data-stu-id="5bb83-144">The stop command happens completely inside the filter's **CBaseFilter::Stop** method.</span></span> <span data-ttu-id="5bb83-145">Quando o método retorna, o filtro deve estar em um estado parado.</span><span class="sxs-lookup"><span data-stu-id="5bb83-145">When the method returns, the filter should be in a stopped state.</span></span>

<span data-ttu-id="5bb83-146">A liberação normalmente ocorre devido a um comando de busca.</span><span class="sxs-lookup"><span data-stu-id="5bb83-146">Flushing typically occurs because of a seek command.</span></span> <span data-ttu-id="5bb83-147">Um comando flush inicia a partir do filtro de origem ou do analisador e viaja para o downstream.</span><span class="sxs-lookup"><span data-stu-id="5bb83-147">A flush command starts from the source or parser filter, and travels downstream.</span></span> <span data-ttu-id="5bb83-148">A liberação ocorre em dois estágios: o método [**IPin:: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) informa um filtro para descartar todos os dados pendentes e recebidos; o método [**IPin:: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) sinaliza o filtro para aceitar dados novamente.</span><span class="sxs-lookup"><span data-stu-id="5bb83-148">Flushing happens in two stages: The [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) method informs a filter to discard all pending and incoming data; the [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) method signals the filter to accept data again.</span></span> <span data-ttu-id="5bb83-149">A liberação requer dois estágios porque a chamada **BeginFlush** está no thread do aplicativo, durante o qual o thread de streaming continua a entregar dados.</span><span class="sxs-lookup"><span data-stu-id="5bb83-149">Flushing requires two stages because the **BeginFlush** call is on the application thread, during which the streaming thread continues to deliver data.</span></span> <span data-ttu-id="5bb83-150">Portanto, alguns exemplos podem chegar após a chamada **BeginFlush** .</span><span class="sxs-lookup"><span data-stu-id="5bb83-150">Therefore, some samples may arrive after the **BeginFlush** call.</span></span> <span data-ttu-id="5bb83-151">O filtro deve descartá-los.</span><span class="sxs-lookup"><span data-stu-id="5bb83-151">The filter should discard these.</span></span> <span data-ttu-id="5bb83-152">Todos os exemplos que chegam após a chamada de **EndFlush** são novos e devem ser entregues.</span><span class="sxs-lookup"><span data-stu-id="5bb83-152">Any samples that arrive after the **EndFlush** call are guaranteed to be new, and should be delivered.</span></span>

<span data-ttu-id="5bb83-153">As seções a seguir contêm exemplos de código que mostram como implementar os métodos de filtro mais importantes, como **Pause**, **Receive** e assim por diante, de maneiras que evitem deadlocks e condições de corrida.</span><span class="sxs-lookup"><span data-stu-id="5bb83-153">The sections that follow contain code samples showing how to implement the most important filter methods, such as **Pause**, **Receive**, and so forth, in ways that avoid deadlocks and race conditions.</span></span> <span data-ttu-id="5bb83-154">No entanto, cada filtro tem requisitos diferentes, portanto, você precisará adaptar esses exemplos ao seu filtro específico.</span><span class="sxs-lookup"><span data-stu-id="5bb83-154">Every filter has different requirements, however, so you will need to adapt these examples to your particular filter.</span></span>

> [!Note]  
> <span data-ttu-id="5bb83-155">As classes base [**CTransformFilter**](ctransformfilter.md) e [**CTransInPlaceFilter**](ctransinplacefilter.md) lidam com muitos dos problemas descritos neste artigo.</span><span class="sxs-lookup"><span data-stu-id="5bb83-155">The [**CTransformFilter**](ctransformfilter.md) and [**CTransInPlaceFilter**](ctransinplacefilter.md) base classes handle many of the issues described in this article.</span></span> <span data-ttu-id="5bb83-156">Se você estiver escrevendo um filtro de transformação e o filtro não aguardar eventos dentro de um método de streaming ou mantiver amostras fora do **recebimento**, essas classes base devem ser suficientes.</span><span class="sxs-lookup"><span data-stu-id="5bb83-156">If you are writing a transform filter, and your filter does not wait on events inside a streaming method, or hold onto samples outside of **Receive**, then these base classes should be sufficient.</span></span>

 

 

 



