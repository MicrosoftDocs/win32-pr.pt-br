---
description: Há muitos aplicativos que criam threads que passam muito tempo no estado de suspensão aguardando a ocorrência de um evento.
ms.assetid: a5e52080-35d4-47f5-9050-90889e3bf2f8
title: Pooling de thread
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcf3565401dc57b077e333043861d42b683e810c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "103828354"
---
# <a name="thread-pooling"></a><span data-ttu-id="103e7-103">Pooling de thread</span><span class="sxs-lookup"><span data-stu-id="103e7-103">Thread Pooling</span></span>

<span data-ttu-id="103e7-104">Há muitos aplicativos que criam threads que passam muito tempo no estado de suspensão aguardando a ocorrência de um evento.</span><span class="sxs-lookup"><span data-stu-id="103e7-104">There are many applications that create threads that spend a great deal of time in the sleeping state waiting for an event to occur.</span></span> <span data-ttu-id="103e7-105">Outros threads podem entrar em estado de suspensão apenas para serem despertados periodicamente para sondar informações de status de alteração ou atualização.</span><span class="sxs-lookup"><span data-stu-id="103e7-105">Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="103e7-106">O *pool de threads* permite que você use threads com mais eficiência, fornecendo ao aplicativo um pool de threads de trabalho que são gerenciados pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="103e7-106">*Thread pooling* enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="103e7-107">Pelo menos um thread monitora o status de todas as operações de espera enfileiradas para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="103e7-107">At least one thread monitors the status of all wait operations queued to the thread pool.</span></span> <span data-ttu-id="103e7-108">Quando uma operação de espera for concluída, um thread de trabalho do pool de threads executará a função de retorno de chamada correspondente.</span><span class="sxs-lookup"><span data-stu-id="103e7-108">When a wait operation has completed, a worker thread from the thread pool executes the corresponding callback function.</span></span>

<span data-ttu-id="103e7-109">Este tópico descreve a API do pool de threads original.</span><span class="sxs-lookup"><span data-stu-id="103e7-109">This topic describes the original thread pool API.</span></span> <span data-ttu-id="103e7-110">A API do pool de threads introduzida no Windows Vista é mais simples, mais confiável, tem melhor desempenho e fornece mais flexibilidade para os desenvolvedores.</span><span class="sxs-lookup"><span data-stu-id="103e7-110">The thread pool API introduced in Windows Vista is simpler, more reliable, has better performance, and provides more flexibility for developers.</span></span> <span data-ttu-id="103e7-111">Para obter informações sobre a API do pool de threads atual, consulte [pools de threads](thread-pools.md).</span><span class="sxs-lookup"><span data-stu-id="103e7-111">For information on the current thread pool API, see [Thread Pools](thread-pools.md).</span></span>

<span data-ttu-id="103e7-112">Você também pode enfileirar itens de trabalho que não estão relacionados a uma operação de espera para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="103e7-112">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="103e7-113">Para solicitar que um item de trabalho seja manipulado por um thread no pool de threads, chame a função [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) .</span><span class="sxs-lookup"><span data-stu-id="103e7-113">To request that a work item be handled by a thread in the thread pool, call the [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) function.</span></span> <span data-ttu-id="103e7-114">Essa função usa um parâmetro para a função que será chamada pelo thread selecionado no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="103e7-114">This function takes a parameter to the function that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="103e7-115">Não é possível cancelar um item de trabalho após ele ter sido enfileirado.</span><span class="sxs-lookup"><span data-stu-id="103e7-115">There is no way to cancel a work item after it has been queued.</span></span>

<span data-ttu-id="103e7-116">[Temporizador-temporizadores de fila](../sync/timer-queues.md) e [operações de espera registradas](../sync/wait-functions.md) também usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="103e7-116">[Timer-queue timers](../sync/timer-queues.md) and [registered wait operations](../sync/wait-functions.md) also use the thread pool.</span></span> <span data-ttu-id="103e7-117">Suas funções de retorno de chamada são enfileiradas para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="103e7-117">Their callback functions are queued to the thread pool.</span></span> <span data-ttu-id="103e7-118">Você também pode usar a função [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) para postar operações de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="103e7-118">You can also use the [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) function to post asynchronous I/O operations.</span></span> <span data-ttu-id="103e7-119">Na conclusão da e/s, o retorno de chamada é executado por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="103e7-119">On completion of the I/O , the callback is executed by a thread pool thread.</span></span>

<span data-ttu-id="103e7-120">O pool de threads é criado na primeira vez que você chama [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) ou [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), ou quando um timer de fila de temporizador ou uma operação de espera registrada enfileira uma função de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="103e7-120">The thread pool is created the first time you call [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) or [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), or when a timer-queue timer or registered wait operation queues a callback function.</span></span> <span data-ttu-id="103e7-121">Por padrão, o número de threads que podem ser criados no pool de threads é de cerca de 500.</span><span class="sxs-lookup"><span data-stu-id="103e7-121">By default, the number of threads that can be created in the thread pool is about 500.</span></span> <span data-ttu-id="103e7-122">Cada thread usa o tamanho de pilha padrão e é executado com a prioridade padrão.</span><span class="sxs-lookup"><span data-stu-id="103e7-122">Each thread uses the default stack size and runs at the default priority.</span></span>

<span data-ttu-id="103e7-123">Há dois tipos de threads de trabalho no pool de threads: e/s e não-e/s.</span><span class="sxs-lookup"><span data-stu-id="103e7-123">There are two types of worker threads in the thread pool: I/O and non-I/O.</span></span> <span data-ttu-id="103e7-124">Um *thread de trabalho de e/s* é um thread que aguarda um estado de espera alertável.</span><span class="sxs-lookup"><span data-stu-id="103e7-124">An *I/O worker thread* is a thread that waits in an alertable wait state.</span></span> <span data-ttu-id="103e7-125">Os itens de trabalho são enfileirados em threads de trabalho de e/s como APC (chamadas de procedimento assíncrono).</span><span class="sxs-lookup"><span data-stu-id="103e7-125">Work items are queued to I/O worker threads as asynchronous procedure calls (APC).</span></span> <span data-ttu-id="103e7-126">Você deve enfileirar um item de trabalho para um thread de trabalho de e/s se ele deve ser executado em um thread que aguarda um estado de alerta.</span><span class="sxs-lookup"><span data-stu-id="103e7-126">You should queue a work item to an I/O worker thread if it should be executed in a thread that waits in an alertable state.</span></span>

<span data-ttu-id="103e7-127">Um *thread de trabalho que não é de e/s* aguarda em portas de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="103e7-127">A *non-I/O worker thread* waits on I/O completion ports.</span></span> <span data-ttu-id="103e7-128">Usar threads de trabalho que não são de e/s é mais eficiente do que usar threads de trabalho de e/s.</span><span class="sxs-lookup"><span data-stu-id="103e7-128">Using non-I/O worker threads is more efficient than using I/O worker threads.</span></span> <span data-ttu-id="103e7-129">Portanto, você deve usar threads de trabalho que não sejam de e/s sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="103e7-129">Therefore, you should use non-I/O worker threads whenever possible.</span></span> <span data-ttu-id="103e7-130">Os threads de trabalho de e/s e não de e/s não serão encerrados se houver solicitações de e/s assíncronas pendentes.</span><span class="sxs-lookup"><span data-stu-id="103e7-130">Both I/O and non-I/O worker threads do not exit if there are pending asynchronous I/O requests.</span></span> <span data-ttu-id="103e7-131">Ambos os tipos de threads podem ser usados por itens de trabalho que iniciam solicitações de conclusão de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="103e7-131">Both types of threads can be used by work items that initiate asynchronous I/O completion requests.</span></span> <span data-ttu-id="103e7-132">No entanto, evite postar solicitações de conclusão de e/s assíncrona em threads de trabalho que não sejam de e/s se demorarem muito tempo para serem concluídas.</span><span class="sxs-lookup"><span data-stu-id="103e7-132">However, avoid posting asynchronous I/O completion requests in non-I/O worker threads if they could take a long time to complete.</span></span>

<span data-ttu-id="103e7-133">Para usar o pool de threads, os itens de trabalho e todas as funções que eles chamam devem ser seguros ao pool de threads.</span><span class="sxs-lookup"><span data-stu-id="103e7-133">To use thread pooling, the work items and all the functions they call must be thread-pool safe.</span></span> <span data-ttu-id="103e7-134">Uma função segura não pressupõe que o thread que a executa é um thread dedicado ou persistente.</span><span class="sxs-lookup"><span data-stu-id="103e7-134">A safe function does not assume that the thread executing it is a dedicated or persistent thread.</span></span> <span data-ttu-id="103e7-135">Em geral, você deve evitar usar o [armazenamento local de thread](thread-local-storage.md) ou fazer uma chamada assíncrona que exija um thread persistente, como a função [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) .</span><span class="sxs-lookup"><span data-stu-id="103e7-135">In general, you should avoid using [thread local storage](thread-local-storage.md) or making an asynchronous call that requires a persistent thread, such as the [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) function.</span></span> <span data-ttu-id="103e7-136">No entanto, essas funções podem ser chamadas em um thread dedicado (criado pelo aplicativo) ou enfileiradas em um thread de trabalho persistente (usando [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) com a \_ opção WT EXECUTEINPERSISTENTTHREAD).</span><span class="sxs-lookup"><span data-stu-id="103e7-136">However, such functions can be called on a dedicated thread (created by the application) or queued to a persistent worker thread (using [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) with the WT\_EXECUTEINPERSISTENTTHREAD option).</span></span>

## <a name="related-topics"></a><span data-ttu-id="103e7-137">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="103e7-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="103e7-138">E/s alertável</span><span class="sxs-lookup"><span data-stu-id="103e7-138">Alertable I/O</span></span>](../fileio/alertable-i-o.md)
</dt> <dt>

[<span data-ttu-id="103e7-139">Chamadas de procedimento assíncrono</span><span class="sxs-lookup"><span data-stu-id="103e7-139">Asynchronous Procedure Calls</span></span>](../sync/asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="103e7-140">Portas de conclusão de e/s</span><span class="sxs-lookup"><span data-stu-id="103e7-140">I/O Completion Ports</span></span>](../fileio/i-o-completion-ports.md)
</dt> <dt>

[<span data-ttu-id="103e7-141">Pools de threads</span><span class="sxs-lookup"><span data-stu-id="103e7-141">Thread Pools</span></span>](thread-pools.md)
</dt> </dl>

 

 
