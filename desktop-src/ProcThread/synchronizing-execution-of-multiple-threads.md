---
description: Para evitar condições de corrida e deadlocks, é necessário sincronizar o acesso por vários threads para recursos compartilhados. A sincronização também é necessária para garantir que o código interdependentes seja executado na sequência correta.
ms.assetid: 74af0502-dae1-438c-8e4b-7663093b3fe3
title: Sincronizando a execução de vários threads
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c6a1b3dd51d666d507771476792e679f7980fab8
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "105770129"
---
# <a name="synchronizing-execution-of-multiple-threads"></a><span data-ttu-id="0e41a-104">Sincronizando a execução de vários threads</span><span class="sxs-lookup"><span data-stu-id="0e41a-104">Synchronizing Execution of Multiple Threads</span></span>

<span data-ttu-id="0e41a-105">Para evitar condições de corrida e deadlocks, é necessário sincronizar o acesso por vários threads para recursos compartilhados.</span><span class="sxs-lookup"><span data-stu-id="0e41a-105">To avoid race conditions and deadlocks, it is necessary to synchronize access by multiple threads to shared resources.</span></span> <span data-ttu-id="0e41a-106">A sincronização também é necessária para garantir que o código interdependentes seja executado na sequência correta.</span><span class="sxs-lookup"><span data-stu-id="0e41a-106">Synchronization is also necessary to ensure that interdependent code is executed in the proper sequence.</span></span>

<span data-ttu-id="0e41a-107">Há uma série de objetos cujos identificadores podem ser usados para sincronizar vários threads.</span><span class="sxs-lookup"><span data-stu-id="0e41a-107">There are a number of objects whose handles can be used to synchronize multiple threads.</span></span> <span data-ttu-id="0e41a-108">Esses objetos incluem:</span><span class="sxs-lookup"><span data-stu-id="0e41a-108">These objects include:</span></span>

-   <span data-ttu-id="0e41a-109">Buffers de entrada do console</span><span class="sxs-lookup"><span data-stu-id="0e41a-109">Console input buffers</span></span>
-   <span data-ttu-id="0e41a-110">Eventos</span><span class="sxs-lookup"><span data-stu-id="0e41a-110">Events</span></span>
-   <span data-ttu-id="0e41a-111">Mutexes</span><span class="sxs-lookup"><span data-stu-id="0e41a-111">Mutexes</span></span>
-   <span data-ttu-id="0e41a-112">Processos</span><span class="sxs-lookup"><span data-stu-id="0e41a-112">Processes</span></span>
-   <span data-ttu-id="0e41a-113">Semáforos</span><span class="sxs-lookup"><span data-stu-id="0e41a-113">Semaphores</span></span>
-   <span data-ttu-id="0e41a-114">Threads</span><span class="sxs-lookup"><span data-stu-id="0e41a-114">Threads</span></span>
-   <span data-ttu-id="0e41a-115">Temporizadores</span><span class="sxs-lookup"><span data-stu-id="0e41a-115">Timers</span></span>

<span data-ttu-id="0e41a-116">O estado de cada um desses objetos é sinalizado ou não sinalizado.</span><span class="sxs-lookup"><span data-stu-id="0e41a-116">The state of each of these objects is either signaled or not signaled.</span></span> <span data-ttu-id="0e41a-117">Quando você especifica um identificador para qualquer um desses objetos em uma chamada para uma das [funções de espera](../sync/wait-functions.md), a execução do thread de chamada é bloqueada até que o estado do objeto especificado fique sinalizado.</span><span class="sxs-lookup"><span data-stu-id="0e41a-117">When you specify a handle to any of these objects in a call to one of the [wait functions](../sync/wait-functions.md), the execution of the calling thread is blocked until the state of the specified object becomes signaled.</span></span>

<span data-ttu-id="0e41a-118">Alguns desses objetos são úteis no bloqueio de um thread até que ocorra algum evento.</span><span class="sxs-lookup"><span data-stu-id="0e41a-118">Some of these objects are useful in blocking a thread until some event occurs.</span></span> <span data-ttu-id="0e41a-119">Por exemplo, um identificador de buffer de entrada de console é sinalizado quando há entrada não lida, como um clique com o botão do mouse ou tecla.</span><span class="sxs-lookup"><span data-stu-id="0e41a-119">For example, a console input buffer handle is signaled when there is unread input, such as a keystroke or mouse button click.</span></span> <span data-ttu-id="0e41a-120">Identificadores de thread e processo são sinalizados quando o processo ou thread é encerrado.</span><span class="sxs-lookup"><span data-stu-id="0e41a-120">Process and thread handles are signaled when the process or thread terminates.</span></span> <span data-ttu-id="0e41a-121">Isso permite que um processo, por exemplo, crie um processo filho e, em seguida, bloqueie sua própria execução até que o novo processo seja encerrado.</span><span class="sxs-lookup"><span data-stu-id="0e41a-121">This allows a process, for example, to create a child process and then block its own execution until the new process has terminated.</span></span>

<span data-ttu-id="0e41a-122">Outros objetos são úteis para proteger recursos compartilhados de acesso simultâneo.</span><span class="sxs-lookup"><span data-stu-id="0e41a-122">Other objects are useful in protecting shared resources from simultaneous access.</span></span> <span data-ttu-id="0e41a-123">Por exemplo, vários threads podem ter um identificador para um objeto mutex.</span><span class="sxs-lookup"><span data-stu-id="0e41a-123">For example, multiple threads can each have a handle to a mutex object.</span></span> <span data-ttu-id="0e41a-124">Antes de acessar um recurso compartilhado, os threads devem chamar uma das [funções Wait](../sync/wait-functions.md) para aguardar o estado do mutex ser sinalizado.</span><span class="sxs-lookup"><span data-stu-id="0e41a-124">Before accessing a shared resource, the threads must call one of the [wait functions](../sync/wait-functions.md) to wait for the state of the mutex to be signaled.</span></span> <span data-ttu-id="0e41a-125">Quando o mutex torna-se sinalizado, apenas um thread em espera é liberado para acessar o recurso.</span><span class="sxs-lookup"><span data-stu-id="0e41a-125">When the mutex becomes signaled, only one waiting thread is released to access the resource.</span></span> <span data-ttu-id="0e41a-126">O estado do mutex é imediatamente redefinido para não ser sinalizado para que quaisquer outros threads em espera permaneçam bloqueados.</span><span class="sxs-lookup"><span data-stu-id="0e41a-126">The state of the mutex is immediately reset to not signaled so any other waiting threads remain blocked.</span></span> <span data-ttu-id="0e41a-127">Quando o thread é concluído com o recurso, ele deve definir o estado do mutex como sinalizado para permitir que outros threads acessem o recurso.</span><span class="sxs-lookup"><span data-stu-id="0e41a-127">When the thread is finished with the resource, it must set the state of the mutex to signaled to allow other threads to access the resource.</span></span>

<span data-ttu-id="0e41a-128">Para os threads de um único processo, os objetos de seção crítica fornecem um meio mais eficiente de sincronização do que os mutexes.</span><span class="sxs-lookup"><span data-stu-id="0e41a-128">For the threads of a single process, critical-section objects provide a more efficient means of synchronization than mutexes.</span></span> <span data-ttu-id="0e41a-129">Uma seção crítica é usada como um mutex para habilitar um thread por vez para usar o recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="0e41a-129">A critical section is used like a mutex to enable one thread at a time to use the protected resource.</span></span> <span data-ttu-id="0e41a-130">Um thread pode usar a função [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) para solicitar a propriedade de uma seção crítica.</span><span class="sxs-lookup"><span data-stu-id="0e41a-130">A thread can use the [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) function to request ownership of a critical section.</span></span> <span data-ttu-id="0e41a-131">Se já pertencer a outro thread, o thread solicitante será bloqueado.</span><span class="sxs-lookup"><span data-stu-id="0e41a-131">If it is already owned by another thread, the requesting thread is blocked.</span></span> <span data-ttu-id="0e41a-132">Um thread pode usar a função [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) para solicitar a propriedade de uma seção crítica, sem bloqueio após a falha de obter a seção crítica.</span><span class="sxs-lookup"><span data-stu-id="0e41a-132">A thread can use the [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) function to request ownership of a critical section, without blocking upon failure to obtain the critical section.</span></span> <span data-ttu-id="0e41a-133">Depois de receber a propriedade, o thread está livre para usar o recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="0e41a-133">After it receives ownership, the thread is free to use the protected resource.</span></span> <span data-ttu-id="0e41a-134">A execução dos outros threads do processo não é afetada, a menos que eles tentem inserir a mesma seção crítica.</span><span class="sxs-lookup"><span data-stu-id="0e41a-134">The execution of the other threads of the process is not affected unless they attempt to enter the same critical section.</span></span>

<span data-ttu-id="0e41a-135">A função [**WaitForInputIdle**](/windows/desktop/api/Winuser/nf-winuser-waitforinputidle) faz um thread aguardar até que um processo especificado seja inicializado e aguardando a entrada do usuário sem nenhuma entrada pendente.</span><span class="sxs-lookup"><span data-stu-id="0e41a-135">The [**WaitForInputIdle**](/windows/desktop/api/Winuser/nf-winuser-waitforinputidle) function makes a thread wait until a specified process is initialized and waiting for user input with no input pending.</span></span> <span data-ttu-id="0e41a-136">Chamar **WaitForInputIdle** pode ser útil para sincronizar processos pai e filho, porque [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) retorna sem esperar que o processo filho conclua sua inicialização.</span><span class="sxs-lookup"><span data-stu-id="0e41a-136">Calling **WaitForInputIdle** can be useful for synchronizing parent and child processes, because [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) returns without waiting for the child process to complete its initialization.</span></span>

<span data-ttu-id="0e41a-137">Para obter mais informações, consulte [sincronização](../sync/synchronization.md).</span><span class="sxs-lookup"><span data-stu-id="0e41a-137">For more information, see [Synchronization](../sync/synchronization.md).</span></span>

 

 
