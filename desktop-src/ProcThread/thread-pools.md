---
description: Um pool de threads é uma coleção de threads de trabalho que executam com eficiência retornos de chamada assíncronos em nome do aplicativo.
ms.assetid: abe0798a-0b60-4bdb-a61e-45393f1e958d
title: Pools de threads
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 690aa3eb6fd3ce7a99d71e0f57118529ef79113f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "105757741"
---
# <a name="thread-pools"></a><span data-ttu-id="6609d-103">Pools de threads</span><span class="sxs-lookup"><span data-stu-id="6609d-103">Thread Pools</span></span>

<span data-ttu-id="6609d-104">Um *pool de threads* é uma coleção de threads de trabalho que executam com eficiência retornos de chamada assíncronos em nome do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="6609d-104">A *thread pool* is a collection of worker threads that efficiently execute asynchronous callbacks on behalf of the application.</span></span> <span data-ttu-id="6609d-105">O pool de threads é usado principalmente para reduzir o número de threads do aplicativo e fornecer gerenciamento dos threads de trabalho.</span><span class="sxs-lookup"><span data-stu-id="6609d-105">The thread pool is primarily used to reduce the number of application threads and provide management of the worker threads.</span></span> <span data-ttu-id="6609d-106">Os aplicativos podem enfileirar itens de trabalho, associar o trabalho a identificadores de espera, enfileirar automaticamente com base em um temporizador e associar a e/s.</span><span class="sxs-lookup"><span data-stu-id="6609d-106">Applications can queue work items, associate work with waitable handles, automatically queue based on a timer, and bind with I/O.</span></span>

## <a name="thread-pool-architecture"></a><span data-ttu-id="6609d-107">Arquitetura do pool de threads</span><span class="sxs-lookup"><span data-stu-id="6609d-107">Thread Pool Architecture</span></span>

<span data-ttu-id="6609d-108">Os aplicativos a seguir podem se beneficiar do uso de um pool de threads:</span><span class="sxs-lookup"><span data-stu-id="6609d-108">The following applications can benefit from using a thread pool:</span></span>

-   <span data-ttu-id="6609d-109">Um aplicativo que é altamente paralelo e pode distribuir um grande número de itens de trabalho pequenos de forma assíncrona (como a pesquisa de índice distribuído ou e/s de rede).</span><span class="sxs-lookup"><span data-stu-id="6609d-109">An application that is highly parallel and can dispatch a large number of small work items asynchronously (such as distributed index search or network I/O).</span></span>
-   <span data-ttu-id="6609d-110">Um aplicativo que cria e destrói um grande número de threads que cada um é executado por um curto período de tempo.</span><span class="sxs-lookup"><span data-stu-id="6609d-110">An application that creates and destroys a large number of threads that each run for a short time.</span></span> <span data-ttu-id="6609d-111">O uso do pool de threads pode reduzir a complexidade do gerenciamento de threads e a sobrecarga envolvida na criação e destruição de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-111">Using the thread pool can reduce the complexity of thread management and the overhead involved in thread creation and destruction.</span></span>
-   <span data-ttu-id="6609d-112">Um aplicativo que processa itens de trabalho independentes em segundo plano e em paralelo (como carregar várias guias).</span><span class="sxs-lookup"><span data-stu-id="6609d-112">An application that processes independent work items in the background and in parallel (such as loading multiple tabs).</span></span>
-   <span data-ttu-id="6609d-113">Um aplicativo que deve executar uma espera exclusiva em objetos de kernel ou bloquear eventos de entrada em um objeto.</span><span class="sxs-lookup"><span data-stu-id="6609d-113">An application that must perform an exclusive wait on kernel objects or block on incoming events on an object.</span></span> <span data-ttu-id="6609d-114">O uso do pool de threads pode reduzir a complexidade do gerenciamento de threads e aumentar o desempenho, reduzindo o número de alternâncias de contexto.</span><span class="sxs-lookup"><span data-stu-id="6609d-114">Using the thread pool can reduce the complexity of thread management and increase performance by reducing the number of context switches.</span></span>
-   <span data-ttu-id="6609d-115">Um aplicativo que cria threads de WaIter personalizados para aguardar eventos.</span><span class="sxs-lookup"><span data-stu-id="6609d-115">An application that creates custom waiter threads to wait on events.</span></span>

<span data-ttu-id="6609d-116">O pool de threads original foi totalmente rearquitetado no Windows Vista.</span><span class="sxs-lookup"><span data-stu-id="6609d-116">The original thread pool has been completely rearchitected in Windows Vista.</span></span> <span data-ttu-id="6609d-117">O novo pool de segmentos é melhorado porque fornece um único tipo de thread de trabalho (dá suporte a e/s e não e/s), não usa um thread de temporizador, fornece uma fila de temporizador único e fornece um thread persistente dedicado.</span><span class="sxs-lookup"><span data-stu-id="6609d-117">The new thread pool is improved because it provides a single worker thread type (supports both I/O and non-I/O), does not use a timer thread, provides a single timer queue, and provides a dedicated persistent thread.</span></span> <span data-ttu-id="6609d-118">Ele também fornece grupos de limpeza, melhor desempenho, vários pools por processo que são agendados de forma independente e uma nova API de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-118">It also provides clean-up groups, higher performance, multiple pools per process that are scheduled independently, and a new thread pool API.</span></span>

<span data-ttu-id="6609d-119">A arquitetura do pool de threads consiste no seguinte:</span><span class="sxs-lookup"><span data-stu-id="6609d-119">The thread pool architecture consists of the following:</span></span>

-   <span data-ttu-id="6609d-120">Threads de trabalho que executam as funções de retorno de chamada</span><span class="sxs-lookup"><span data-stu-id="6609d-120">Worker threads that execute the callback functions</span></span>
-   <span data-ttu-id="6609d-121">Threads de WaIter que esperam em vários identificadores de espera</span><span class="sxs-lookup"><span data-stu-id="6609d-121">Waiter threads that wait on multiple wait handles</span></span>
-   <span data-ttu-id="6609d-122">Uma fila de trabalho</span><span class="sxs-lookup"><span data-stu-id="6609d-122">A work queue</span></span>
-   <span data-ttu-id="6609d-123">Um pool de threads padrão para cada processo</span><span class="sxs-lookup"><span data-stu-id="6609d-123">A default thread pool for each process</span></span>
-   <span data-ttu-id="6609d-124">Uma fábrica de trabalho que gerencia os threads de trabalho</span><span class="sxs-lookup"><span data-stu-id="6609d-124">A worker factory that manages the worker threads</span></span>

## <a name="best-practices"></a><span data-ttu-id="6609d-125">Práticas Recomendadas</span><span class="sxs-lookup"><span data-stu-id="6609d-125">Best Practices</span></span>

<span data-ttu-id="6609d-126">A nova [API do pool de threads](thread-pool-api.md) fornece mais flexibilidade e controle do que a [API do pool de threads original](thread-pooling.md).</span><span class="sxs-lookup"><span data-stu-id="6609d-126">The new [thread pool API](thread-pool-api.md) provides more flexibility and control than the [original thread pool API](thread-pooling.md).</span></span> <span data-ttu-id="6609d-127">No entanto, há algumas diferenças sutis, mas importantes.</span><span class="sxs-lookup"><span data-stu-id="6609d-127">However, there are a few subtle but important differences.</span></span> <span data-ttu-id="6609d-128">Na API original, a espera de redefinição era automática; na nova API, a espera deve ser redefinida explicitamente a cada vez.</span><span class="sxs-lookup"><span data-stu-id="6609d-128">In the original API, the wait reset was automatic; in the new API, the wait must be explicitly reset each time.</span></span> <span data-ttu-id="6609d-129">A API original tratou a representação automaticamente, transferindo o contexto de segurança do processo de chamada para o thread.</span><span class="sxs-lookup"><span data-stu-id="6609d-129">The original API handled impersonation automatically, transferring the security context of the calling process to the thread.</span></span> <span data-ttu-id="6609d-130">Com a nova API, o aplicativo deve definir explicitamente o contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="6609d-130">With the new API, the application must explicitly set the security context.</span></span>

<span data-ttu-id="6609d-131">Veja a seguir as práticas recomendadas ao usar um pool de threads:</span><span class="sxs-lookup"><span data-stu-id="6609d-131">The following are best practices when using a thread pool:</span></span>

-   <span data-ttu-id="6609d-132">Os threads de um processo compartilham o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-132">The threads of a process share the thread pool.</span></span> <span data-ttu-id="6609d-133">Um único thread de trabalho pode executar várias funções de retorno de chamada, uma de cada vez.</span><span class="sxs-lookup"><span data-stu-id="6609d-133">A single worker thread can execute multiple callback functions, one at a time.</span></span> <span data-ttu-id="6609d-134">Esses threads de trabalho são gerenciados pelo pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-134">These worker threads are managed by the thread pool.</span></span> <span data-ttu-id="6609d-135">Portanto, não encerre um thread do pool de threads chamando [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) no thread ou chamando [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) de uma função de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="6609d-135">Therefore, do not terminate a thread from the thread pool by calling [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) on the thread or by calling [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) from a callback function.</span></span>
-   <span data-ttu-id="6609d-136">Uma solicitação de e/s pode ser executada em qualquer thread no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-136">An I/O request can run on any thread in the thread pool.</span></span> <span data-ttu-id="6609d-137">Cancelar a e/s em um thread de pool de threads requer sincronização porque a função de cancelamento pode ser executada em um thread diferente daquele que está tratando a solicitação de e/s, o que pode resultar em cancelamento de uma operação desconhecida.</span><span class="sxs-lookup"><span data-stu-id="6609d-137">Canceling I/O on a thread pool thread requires synchronization because the cancel function might run on a different thread than the one that is handling the I/O request, which can result in cancellation of an unknown operation.</span></span> <span data-ttu-id="6609d-138">Para evitar isso, sempre forneça a estrutura [**sobreposta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) com a qual uma solicitação de e/s foi iniciada ao chamar [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) para e/s assíncrona, ou use sua própria sincronização para garantir que nenhuma outra e/s possa ser iniciada no thread de destino antes de chamar a função [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) ou **CancelIoEx** .</span><span class="sxs-lookup"><span data-stu-id="6609d-138">To avoid this, always provide the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure with which an I/O request was initiated when calling [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) for asynchronous I/O, or use your own synchronization to ensure that no other I/O can be started on the target thread before calling either the [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) or **CancelIoEx** function.</span></span>
-   <span data-ttu-id="6609d-139">Limpe todos os recursos criados na função de retorno de chamada antes de retornar da função.</span><span class="sxs-lookup"><span data-stu-id="6609d-139">Clean up all resources created in the callback function before returning from the function.</span></span> <span data-ttu-id="6609d-140">Isso inclui TLS, contextos de segurança, prioridade de thread e registro COM.</span><span class="sxs-lookup"><span data-stu-id="6609d-140">These include TLS, security contexts, thread priority, and COM registration.</span></span> <span data-ttu-id="6609d-141">As funções de retorno de chamada também devem restaurar o estado do thread antes de retornar.</span><span class="sxs-lookup"><span data-stu-id="6609d-141">Callback functions must also restore the thread state before returning.</span></span>
-   <span data-ttu-id="6609d-142">Mantenha os identificadores de espera e seus objetos associados ativos até que o pool de threads tenha sinalizado que ele foi concluído com o identificador.</span><span class="sxs-lookup"><span data-stu-id="6609d-142">Keep wait handles and their associated objects alive until the thread pool has signaled that it is finished with the handle.</span></span>
-   <span data-ttu-id="6609d-143">Marque todos os threads que estão aguardando por operações demoradas (como liberações de e/s ou limpeza de recursos) para que o pool de threads possa alocar novos threads em vez de aguardar este.</span><span class="sxs-lookup"><span data-stu-id="6609d-143">Mark all threads that are waiting on lengthy operations (such as I/O flushes or resource cleanup) so that the thread pool can allocate new threads instead of waiting for this one.</span></span>
-   <span data-ttu-id="6609d-144">Antes de descarregar uma DLL que usa o pool de threads, cancele todos os itens de trabalho, e/s, operações de espera e temporizadores e aguarde a conclusão da execução de retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="6609d-144">Before unloading a DLL that uses the thread pool, cancel all work items, I/O, wait operations, and timers, and wait for executing callbacks to complete.</span></span>
-   <span data-ttu-id="6609d-145">Evite deadlocks eliminando as dependências entre os itens de trabalho e entre os retornos de chamada, garantindo que um retorno de chamada não esteja aguardando a conclusão dele e preservando a prioridade do thread.</span><span class="sxs-lookup"><span data-stu-id="6609d-145">Avoid deadlocks by eliminating dependencies between work items and between callbacks, by ensuring a callback is not waiting for itself to complete, and by preserving the thread priority.</span></span>
-   <span data-ttu-id="6609d-146">Não enfileirar muitos itens muito rapidamente em um processo com outros componentes usando o pool de threads padrão.</span><span class="sxs-lookup"><span data-stu-id="6609d-146">Do not queue too many items too quickly in a process with other components using the default thread pool.</span></span> <span data-ttu-id="6609d-147">Há um pool de threads padrão por processo, incluindo Svchost.exe.</span><span class="sxs-lookup"><span data-stu-id="6609d-147">There is one default thread pool per process, including Svchost.exe.</span></span> <span data-ttu-id="6609d-148">Por padrão, cada pool de threads tem um máximo de 500 threads de trabalho.</span><span class="sxs-lookup"><span data-stu-id="6609d-148">By default, each thread pool has a maximum of 500 worker threads.</span></span> <span data-ttu-id="6609d-149">O pool de threads tenta criar mais threads de trabalho quando o número de threads de trabalho no estado pronto/em execução deve ser menor que o número de processadores.</span><span class="sxs-lookup"><span data-stu-id="6609d-149">The thread pool attempts to create more worker threads when the number of worker threads in the ready/running state must be less than the number of processors.</span></span>
-   <span data-ttu-id="6609d-150">Evite o modelo de apartamento de thread único COM, pois ele é incompatível com o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-150">Avoid the COM single-threaded apartment model, as it is incompatible with the thread pool.</span></span> <span data-ttu-id="6609d-151">O STA cria um estado de thread que pode afetar o próximo item de trabalho para o thread.</span><span class="sxs-lookup"><span data-stu-id="6609d-151">STA creates thread state which can affect the next work item for the thread.</span></span> <span data-ttu-id="6609d-152">O STA geralmente é de longa duração e tem afinidade de thread, que é o oposto do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-152">STA is generally long-lived and has thread affinity, which is the opposite of the thread pool.</span></span>
-   <span data-ttu-id="6609d-153">Crie um novo pool de threads para controlar a prioridade e o isolamento do thread, criar características personalizadas e possivelmente melhorar a capacidade de resposta.</span><span class="sxs-lookup"><span data-stu-id="6609d-153">Create a new thread pool to control thread priority and isolation, create custom characteristics, and possibly improve responsiveness.</span></span> <span data-ttu-id="6609d-154">No entanto, pools de threads adicionais exigem mais recursos do sistema (threads, memória do kernel).</span><span class="sxs-lookup"><span data-stu-id="6609d-154">However, additional thread pools require more system resources (threads, kernel memory).</span></span> <span data-ttu-id="6609d-155">Um número excessivo de pools aumenta o potencial de contenção de CPU.</span><span class="sxs-lookup"><span data-stu-id="6609d-155">Too many pools increases the potential for CPU contention.</span></span>
-   <span data-ttu-id="6609d-156">Se possível, use um objeto que pode ser aguardado em vez de um mecanismo baseado em APC para sinalizar um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="6609d-156">If possible, use a waitable object instead of an APC-based mechanism to signal a thread pool thread.</span></span> <span data-ttu-id="6609d-157">O APCs não funciona bem com threads de pool de threads como outros mecanismos de sinalização porque o sistema controla o tempo de vida dos threads do pool de threads, de modo que é possível que um thread seja encerrado antes de a notificação ser entregue.</span><span class="sxs-lookup"><span data-stu-id="6609d-157">APCs do not work as well with thread pool threads as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span>
-   <span data-ttu-id="6609d-158">Use a extensão do depurador do pool de threads,! TP.</span><span class="sxs-lookup"><span data-stu-id="6609d-158">Use the thread pool debugger extension, !tp.</span></span> <span data-ttu-id="6609d-159">Este comando tem o seguinte uso:</span><span class="sxs-lookup"><span data-stu-id="6609d-159">This command has the following usage:</span></span>

    -   <span data-ttu-id="6609d-160">*sinalizadores* de *endereço* do pool</span><span class="sxs-lookup"><span data-stu-id="6609d-160">pool *address* *flags*</span></span>
    -   <span data-ttu-id="6609d-161">*sinalizadores* de *endereço* do obj</span><span class="sxs-lookup"><span data-stu-id="6609d-161">obj *address* *flags*</span></span>
    -   <span data-ttu-id="6609d-162">*sinalizadores* de *endereço* Tnão</span><span class="sxs-lookup"><span data-stu-id="6609d-162">tqueue *address* *flags*</span></span>
    -   <span data-ttu-id="6609d-163">*endereço* de WaIter</span><span class="sxs-lookup"><span data-stu-id="6609d-163">waiter *address*</span></span>
    -   <span data-ttu-id="6609d-164">*endereço* do trabalhador</span><span class="sxs-lookup"><span data-stu-id="6609d-164">worker *address*</span></span>

    <span data-ttu-id="6609d-165">Para pool, WaIter e Worker, se o endereço for zero, o comando despejará todos os objetos.</span><span class="sxs-lookup"><span data-stu-id="6609d-165">For pool, waiter, and worker, if the address is zero, the command dumps all objects.</span></span> <span data-ttu-id="6609d-166">Para o WaIter e o trabalho, omitir o endereço despeja o thread atual.</span><span class="sxs-lookup"><span data-stu-id="6609d-166">For waiter and worker, omitting the address dumps the current thread.</span></span> <span data-ttu-id="6609d-167">Os seguintes sinalizadores são definidos: 0x1 (saída de linha única), 0x2 (membros de despejo) e 0x4 (fila de trabalho do pool de despejo).</span><span class="sxs-lookup"><span data-stu-id="6609d-167">The following flags are defined: 0x1 (single-line output), 0x2 (dump members), and 0x4 (dump pool work queue).</span></span>

## <a name="related-topics"></a><span data-ttu-id="6609d-168">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="6609d-168">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6609d-169">API do pool de threads</span><span class="sxs-lookup"><span data-stu-id="6609d-169">Thread Pool API</span></span>](thread-pool-api.md)
</dt> <dt>

[<span data-ttu-id="6609d-170">Usando as funções do pool de threads</span><span class="sxs-lookup"><span data-stu-id="6609d-170">Using the Thread Pool Functions</span></span>](using-the-thread-pool-functions.md)
</dt> </dl>

 

 
