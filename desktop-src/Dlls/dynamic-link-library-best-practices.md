---
description: A criação de DLLs apresenta vários desafios para os desenvolvedores.
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Práticas recomendadas da biblioteca de Dynamic-Link
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 88aba0999f3d0825c6d2f4df3afe09d766a82232
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2021
ms.locfileid: "105750868"
---
# <a name="dynamic-link-library-best-practices"></a><span data-ttu-id="069da-103">Práticas recomendadas da biblioteca de Dynamic-Link</span><span class="sxs-lookup"><span data-stu-id="069da-103">Dynamic-Link Library Best Practices</span></span>

<span data-ttu-id="069da-104">\* \* Atualizado: \* \*</span><span class="sxs-lookup"><span data-stu-id="069da-104">\*\*Updated: \*\*</span></span>

-   <span data-ttu-id="069da-105">17 de maio de 2006</span><span class="sxs-lookup"><span data-stu-id="069da-105">May 17, 2006</span></span>

<span data-ttu-id="069da-106">**APIs importantes**</span><span class="sxs-lookup"><span data-stu-id="069da-106">**Important APIs**</span></span>

-   [<span data-ttu-id="069da-107">**DllMain**</span><span class="sxs-lookup"><span data-stu-id="069da-107">**DllMain**</span></span>](dllmain.md)
-   [<span data-ttu-id="069da-108">**LoadLibraryEx**</span><span class="sxs-lookup"><span data-stu-id="069da-108">**LoadLibraryEx**</span></span>](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [<span data-ttu-id="069da-109">**CreateProcess**</span><span class="sxs-lookup"><span data-stu-id="069da-109">**CreateProcess**</span></span>](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

<span data-ttu-id="069da-110">A criação de DLLs apresenta vários desafios para os desenvolvedores.</span><span class="sxs-lookup"><span data-stu-id="069da-110">Creating DLLs presents a number of challenges for developers.</span></span> <span data-ttu-id="069da-111">DLLs não têm controle de versão imposta pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="069da-111">DLLs do not have system-enforced versioning.</span></span> <span data-ttu-id="069da-112">Quando existem várias versões de uma DLL em um sistema, a facilidade de ser substituída juntamente com a falta de um esquema de controle de versão cria conflitos de dependência e de API.</span><span class="sxs-lookup"><span data-stu-id="069da-112">When multiple versions of a DLL exist on a system, the ease of being overwritten coupled with the lack of a versioning schema creates dependency and API conflicts.</span></span> <span data-ttu-id="069da-113">A complexidade no ambiente de desenvolvimento, a implementação do carregador e as dependências de DLL criaram fragilidade em ordem de carregamento e comportamento do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="069da-113">Complexity in the development environment, the loader implementation, and the DLL dependencies has created fragility in load order and application behavior.</span></span> <span data-ttu-id="069da-114">Por fim, muitos aplicativos dependem de DLLs e têm conjuntos complexos de dependências que devem ser respeitadas para que os aplicativos funcionem corretamente.</span><span class="sxs-lookup"><span data-stu-id="069da-114">Lastly, many applications rely on DLLs and have complex sets of dependencies that must be honored for the applications to function properly.</span></span> <span data-ttu-id="069da-115">Este documento fornece diretrizes para desenvolvedores de DLL para ajudar na criação de DLLs mais robustas, portáteis e extensíveis.</span><span class="sxs-lookup"><span data-stu-id="069da-115">This document provides guidelines for DLL developers to help in building more robust, portable, and extensible DLLs.</span></span>

<span data-ttu-id="069da-116">A sincronização incorreta no [**DllMain**](dllmain.md) pode fazer com que um aplicativo seja bloqueado ou tenha acesso a dados ou código em uma dll não inicializada.</span><span class="sxs-lookup"><span data-stu-id="069da-116">Improper synchronization within [**DllMain**](dllmain.md) can cause an application to deadlock or access data or code in an uninitialized DLL.</span></span> <span data-ttu-id="069da-117">Chamar determinadas funções de no **DllMain** causa esses problemas.</span><span class="sxs-lookup"><span data-stu-id="069da-117">Calling certain functions from within **DllMain** causes such problems.</span></span>

![o que acontece quando uma biblioteca é carregada](images/fig1.png)

## <a name="general-best-practices"></a><span data-ttu-id="069da-119">Melhores práticas gerais</span><span class="sxs-lookup"><span data-stu-id="069da-119">General Best Practices</span></span>

<span data-ttu-id="069da-120">[**DllMain**](dllmain.md) é chamado enquanto o carregador de bloqueio é mantido.</span><span class="sxs-lookup"><span data-stu-id="069da-120">[**DllMain**](dllmain.md) is called while the loader-lock is held.</span></span> <span data-ttu-id="069da-121">Portanto, as restrições significativas são impostas nas funções que podem ser chamadas dentro de **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="069da-121">Therefore, significant restrictions are imposed on the functions that can be called within **DllMain**.</span></span> <span data-ttu-id="069da-122">Assim, o **DllMain** foi projetado para executar tarefas de inicialização mínimas, usando um pequeno subconjunto da API do Microsoft® Windows®.</span><span class="sxs-lookup"><span data-stu-id="069da-122">As such, **DllMain** is designed to perform minimal initialization tasks, by using a small subset of the Microsoft® Windows® API.</span></span> <span data-ttu-id="069da-123">Você não pode chamar nenhuma função em **DllMain** que tente adquirir o carregador de carregado direta ou indiretamente.</span><span class="sxs-lookup"><span data-stu-id="069da-123">You cannot call any function in **DllMain** that directly or indirectly tries to acquire the loader lock.</span></span> <span data-ttu-id="069da-124">Caso contrário, você apresentará a possibilidade de o aplicativo travar ou falhar.</span><span class="sxs-lookup"><span data-stu-id="069da-124">Otherwise, you will introduce the possibility that your application deadlocks or crashes.</span></span> <span data-ttu-id="069da-125">Um erro em uma implementação **DllMain** pode comprometer o processo inteiro e todos os seus threads.</span><span class="sxs-lookup"><span data-stu-id="069da-125">An error in a **DllMain** implementation can jeopardize the entire process and all of its threads.</span></span>

<span data-ttu-id="069da-126">O [**DllMain**](dllmain.md) ideal seria apenas um stub vazio.</span><span class="sxs-lookup"><span data-stu-id="069da-126">The ideal [**DllMain**](dllmain.md) would be just an empty stub.</span></span> <span data-ttu-id="069da-127">No entanto, considerando a complexidade de muitos aplicativos, isso geralmente é muito restritivo.</span><span class="sxs-lookup"><span data-stu-id="069da-127">However, given the complexity of many applications, this is generally too restrictive.</span></span> <span data-ttu-id="069da-128">Uma boa regra geral para **DllMain** é adiar o máximo de inicialização possível.</span><span class="sxs-lookup"><span data-stu-id="069da-128">A good rule of thumb for **DllMain** is to postpone as much initialization as possible.</span></span> <span data-ttu-id="069da-129">A inicialização lenta aumenta a robustez do aplicativo porque essa inicialização não é executada enquanto o bloqueio do carregador é mantido.</span><span class="sxs-lookup"><span data-stu-id="069da-129">Lazy initialization increases robustness of the application because this initialization is not performed while the loader lock is held.</span></span> <span data-ttu-id="069da-130">Além disso, a inicialização lenta permite que você use com segurança muito mais da API do Windows.</span><span class="sxs-lookup"><span data-stu-id="069da-130">Also, lazy initialization enables you to safely use much more of the Windows API.</span></span>

<span data-ttu-id="069da-131">Algumas tarefas de inicialização não podem ser adiadas.</span><span class="sxs-lookup"><span data-stu-id="069da-131">Some initialization tasks cannot be postponed.</span></span> <span data-ttu-id="069da-132">Por exemplo, uma DLL que depende de um arquivo de configuração deve falhar ao ser carregada se o arquivo estiver malformado ou contiver lixo.</span><span class="sxs-lookup"><span data-stu-id="069da-132">For example, a DLL that depends on a configuration file should fail to load if the file is malformed or contains garbage.</span></span> <span data-ttu-id="069da-133">Para esse tipo de inicialização, a DLL deve tentar a ação e falhar rapidamente, em vez de desperdiçar recursos, concluindo outro trabalho.</span><span class="sxs-lookup"><span data-stu-id="069da-133">For this type of initialization, the DLL should attempt the action and fail quickly rather than waste resources by completing other work.</span></span>

<span data-ttu-id="069da-134">Você nunca deve executar as seguintes tarefas em [**DllMain**](dllmain.md):</span><span class="sxs-lookup"><span data-stu-id="069da-134">You should never perform the following tasks from within [**DllMain**](dllmain.md):</span></span>

-   <span data-ttu-id="069da-135">Chame [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) ou [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (direta ou indiretamente).</span><span class="sxs-lookup"><span data-stu-id="069da-135">Call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (either directly or indirectly).</span></span> <span data-ttu-id="069da-136">Isso pode causar um deadlock ou uma falha.</span><span class="sxs-lookup"><span data-stu-id="069da-136">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="069da-137">Chame [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)ou [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (direta ou indiretamente).</span><span class="sxs-lookup"><span data-stu-id="069da-137">Call [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw), or [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (either directly or indirectly).</span></span> <span data-ttu-id="069da-138">Isso pode causar um deadlock ou uma falha.</span><span class="sxs-lookup"><span data-stu-id="069da-138">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="069da-139">Sincronizar com outros threads.</span><span class="sxs-lookup"><span data-stu-id="069da-139">Synchronize with other threads.</span></span> <span data-ttu-id="069da-140">Isso pode causar um deadlock.</span><span class="sxs-lookup"><span data-stu-id="069da-140">This can cause a deadlock.</span></span>
-   <span data-ttu-id="069da-141">Adquira um objeto de sincronização que pertença ao código que está aguardando para adquirir o bloqueio do carregador.</span><span class="sxs-lookup"><span data-stu-id="069da-141">Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock.</span></span> <span data-ttu-id="069da-142">Isso pode causar um deadlock.</span><span class="sxs-lookup"><span data-stu-id="069da-142">This can cause a deadlock.</span></span>
-   <span data-ttu-id="069da-143">Inicializar threads COM usando [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="069da-143">Initialize COM threads by using [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="069da-144">Em determinadas condições, essa função pode chamar [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span><span class="sxs-lookup"><span data-stu-id="069da-144">Under certain conditions, this function can call [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span>
-   <span data-ttu-id="069da-145">Chame as funções de registro.</span><span class="sxs-lookup"><span data-stu-id="069da-145">Call the registry functions.</span></span> <span data-ttu-id="069da-146">Essas funções são implementadas no Advapi32.dll.</span><span class="sxs-lookup"><span data-stu-id="069da-146">These functions are implemented in Advapi32.dll.</span></span> <span data-ttu-id="069da-147">Se Advapi32.dll não for inicializado antes da DLL, a DLL poderá acessar a memória não inicializada e causar falha no processo.</span><span class="sxs-lookup"><span data-stu-id="069da-147">If Advapi32.dll is not initialized before your DLL, the DLL can access uninitialized memory and cause the process to crash.</span></span>
-   <span data-ttu-id="069da-148">Chame [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span><span class="sxs-lookup"><span data-stu-id="069da-148">Call [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span></span> <span data-ttu-id="069da-149">A criação de um processo pode carregar outra DLL.</span><span class="sxs-lookup"><span data-stu-id="069da-149">Creating a process can load another DLL.</span></span>
-   <span data-ttu-id="069da-150">Chame [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span><span class="sxs-lookup"><span data-stu-id="069da-150">Call [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="069da-151">A saída de um thread durante a desanexação da DLL pode fazer com que o bloqueio do carregador seja adquirido novamente, causando um deadlock ou uma falha.</span><span class="sxs-lookup"><span data-stu-id="069da-151">Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</span></span>
-   <span data-ttu-id="069da-152">Chame [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span><span class="sxs-lookup"><span data-stu-id="069da-152">Call [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span></span> <span data-ttu-id="069da-153">Criar um thread pode funcionar se você não sincronizar com outros threads, mas for arriscado.</span><span class="sxs-lookup"><span data-stu-id="069da-153">Creating a thread can work if you do not synchronize with other threads, but it is risky.</span></span>
-   <span data-ttu-id="069da-154">Crie um pipe nomeado ou outro objeto nomeado (somente Windows 2000).</span><span class="sxs-lookup"><span data-stu-id="069da-154">Create a named pipe or other named object (Windows 2000 only).</span></span> <span data-ttu-id="069da-155">No Windows 2000, os objetos nomeados são fornecidos pela DLL de serviços de terminal.</span><span class="sxs-lookup"><span data-stu-id="069da-155">In Windows 2000, named objects are provided by the Terminal Services DLL.</span></span> <span data-ttu-id="069da-156">Se essa DLL não for inicializada, as chamadas para a DLL poderão fazer com que o processo falhe.</span><span class="sxs-lookup"><span data-stu-id="069da-156">If this DLL is not initialized, calls to the DLL can cause the process to crash.</span></span>
-   <span data-ttu-id="069da-157">Use a função de gerenciamento de memória do C Run-Time dinâmico (CRT).</span><span class="sxs-lookup"><span data-stu-id="069da-157">Use the memory management function from the dynamic C Run-Time (CRT).</span></span> <span data-ttu-id="069da-158">Se a DLL do CRT não for inicializada, as chamadas para essas funções poderão causar falha no processo.</span><span class="sxs-lookup"><span data-stu-id="069da-158">If the CRT DLL is not initialized, calls to these functions can cause the process to crash.</span></span>
-   <span data-ttu-id="069da-159">Chame funções em User32.dll ou Gdi32.dll.</span><span class="sxs-lookup"><span data-stu-id="069da-159">Call functions in User32.dll or Gdi32.dll.</span></span> <span data-ttu-id="069da-160">Algumas funções carregam outra DLL, que pode não ser inicializada.</span><span class="sxs-lookup"><span data-stu-id="069da-160">Some functions load another DLL, which may not be initialized.</span></span>
-   <span data-ttu-id="069da-161">Use código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="069da-161">Use managed code.</span></span>

<span data-ttu-id="069da-162">As seguintes tarefas são seguras para serem executadas no **DllMain**:</span><span class="sxs-lookup"><span data-stu-id="069da-162">The following tasks are safe to perform within **DllMain**:</span></span>

-   <span data-ttu-id="069da-163">Inicializar estruturas de dados estáticos e membros em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="069da-163">Initialize static data structures and members at compile time.</span></span>
-   <span data-ttu-id="069da-164">Criar e inicializar objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="069da-164">Create and initialize synchronization objects.</span></span>
-   <span data-ttu-id="069da-165">Aloque memória e inicialize estruturas de dados dinâmicos (evitando as funções listadas acima).</span><span class="sxs-lookup"><span data-stu-id="069da-165">Allocate memory and initialize dynamic data structures (avoiding the functions listed above.)</span></span>
-   <span data-ttu-id="069da-166">Configurar o armazenamento local de threads (TLS).</span><span class="sxs-lookup"><span data-stu-id="069da-166">Set up thread local storage (TLS).</span></span>
-   <span data-ttu-id="069da-167">Abra, leia de e grave em arquivos.</span><span class="sxs-lookup"><span data-stu-id="069da-167">Open, read from, and write to files.</span></span>
-   <span data-ttu-id="069da-168">Chame funções em Kernel32.dll (exceto as funções listadas acima).</span><span class="sxs-lookup"><span data-stu-id="069da-168">Call functions in Kernel32.dll (except the functions that are listed above).</span></span>
-   <span data-ttu-id="069da-169">Definir ponteiros globais como nulos, colocando a inicialização de membros dinâmicos.</span><span class="sxs-lookup"><span data-stu-id="069da-169">Set global pointers to NULL, putting off the initialization of dynamic members.</span></span> <span data-ttu-id="069da-170">No Microsoft Windows Vista™, você pode usar as funções de inicialização única para garantir que um bloco de código seja executado apenas uma vez em um ambiente multithread.</span><span class="sxs-lookup"><span data-stu-id="069da-170">In Microsoft Windows Vista™, you can use the one-time initialization functions to ensure that a block of code is executed only once in a multithreaded environment.</span></span>

## <a name="deadlocks-caused-by-lock-order-inversion"></a><span data-ttu-id="069da-171">Deadlocks causados pela inversão da ordem de bloqueio</span><span class="sxs-lookup"><span data-stu-id="069da-171">Deadlocks Caused by Lock Order Inversion</span></span>

<span data-ttu-id="069da-172">Quando você está implementando o código que usa vários objetos de sincronização, como bloqueios, é vital respeitar a ordem de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="069da-172">When you are implementing code that uses multiple synchronization objects such as locks, it is vital to respect lock order.</span></span> <span data-ttu-id="069da-173">Quando for necessário adquirir mais de um bloqueio por vez, você deve definir uma precedência explícita que seja chamada de hierarquia de bloqueio ou de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="069da-173">When it is necessary to acquire more than one lock at a time, you must define an explicit precedence that is called a lock hierarchy or lock order.</span></span> <span data-ttu-id="069da-174">Por exemplo, se o bloqueio A for adquirido antes do bloqueio B em algum lugar no código, e o bloqueio B for adquirido antes do bloqueio C em outro lugar no código, a ordem de bloqueio será a, B, C e essa ordem deverá ser seguida em todo o código.</span><span class="sxs-lookup"><span data-stu-id="069da-174">For example, if lock A is acquired before lock B somewhere in the code, and lock B is acquired before lock C elsewhere in the code, then the lock order is A, B, C and this order should be followed throughout the code.</span></span> <span data-ttu-id="069da-175">A inversão de ordem de bloqueio ocorre quando a ordem de bloqueio não é seguida — por exemplo, se o bloqueio B for adquirido antes do bloqueio A. A inversão de ordem de bloqueio pode causar deadlocks difíceis de depurar.</span><span class="sxs-lookup"><span data-stu-id="069da-175">Lock order inversion occurs when the locking order is not followed—for example, if lock B is acquired before lock A. Lock order inversion can cause deadlocks that are difficult to debug.</span></span> <span data-ttu-id="069da-176">Para evitar esses problemas, todos os threads devem adquirir bloqueios na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="069da-176">To avoid such problems, all threads must acquire locks in the same order.</span></span>

<span data-ttu-id="069da-177">É importante observar que o carregador chama [**DllMain**](dllmain.md) com o bloqueio de carregador já adquirido, portanto, o bloqueio do carregador deve ter a maior precedência na hierarquia de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="069da-177">It is important to note that the loader calls [**DllMain**](dllmain.md) with the loader lock already acquired, so the loader lock should have the highest precedence in the locking hierarchy.</span></span> <span data-ttu-id="069da-178">Observe também que o código só precisa adquirir os bloqueios necessários para a sincronização adequada; Ele não precisa adquirir todos os bloqueios que estão definidos na hierarquia.</span><span class="sxs-lookup"><span data-stu-id="069da-178">Also note that code only has to acquire the locks it requires for proper synchronization; it does not have to acquire every single lock that is defined in the hierarchy.</span></span> <span data-ttu-id="069da-179">Por exemplo, se uma seção de código exigir apenas bloqueios A e C para uma sincronização adequada, o código deverá adquirir bloqueio A antes de adquirir o bloqueio C; Não é necessário que o código também adquira o bloqueio B. Além disso, o código de DLL não pode adquirir explicitamente o bloqueio de carregador.</span><span class="sxs-lookup"><span data-stu-id="069da-179">For example, if a section of code requires only locks A and C for proper synchronization, then the code should acquire lock A before it acquires lock C; it is not necessary for the code to also acquire lock B. Furthermore, DLL code cannot explicitly acquire the loader lock.</span></span> <span data-ttu-id="069da-180">Se o código precisar chamar uma API como [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) que possa adquirir indiretamente o bloqueio do carregador e o código também precisar adquirir um bloqueio privado, o código deverá chamar **GetModuleFileName** antes de adquirir o bloqueio P, garantindo que a ordem de carregamento seja respeitada.</span><span class="sxs-lookup"><span data-stu-id="069da-180">If the code must call an API such as [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) that can indirectly acquire the loader lock and the code must also acquire a private lock, then the code should call **GetModuleFileName** before it acquires lock P, thus ensuring that load order is respected.</span></span>

<span data-ttu-id="069da-181">A Figura 2 é um exemplo que ilustra a inversão de ordem de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="069da-181">Figure 2 is an example that illustrates lock order inversion.</span></span> <span data-ttu-id="069da-182">Considere uma DLL cujo thread principal contém [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="069da-182">Consider a DLL whose main thread contains [**DllMain**](dllmain.md).</span></span> <span data-ttu-id="069da-183">O carregador de biblioteca adquire o bloqueio do carregador L e, em seguida, chama o **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="069da-183">The library loader acquires the loader lock L and then calls into **DllMain**.</span></span> <span data-ttu-id="069da-184">O thread principal cria objetos de sincronização A, B e G para serializar o acesso às suas estruturas de dados e, em seguida, tenta adquirir o bloqueio G. Um thread de trabalho que já adquiriu com êxito o bloqueio G chama uma função como GetModuleHandle que tenta adquirir o bloqueio do carregador L. Assim, o thread de trabalho é bloqueado em L e o thread principal é bloqueado em G, resultando em um deadlock.</span><span class="sxs-lookup"><span data-stu-id="069da-184">The main thread creates synchronization objects A, B, and G to serialize access to its data structures and then tries to acquire lock G. A worker thread that has already successfully acquired lock G then calls a function such as GetModuleHandle that attempts to acquire the loader lock L. Thus, the worker thread is blocked on L and the main thread is blocked on G, resulting in a deadlock.</span></span>

![deadlock causado por inversão de ordem de bloqueio](images/fig2.png)

<span data-ttu-id="069da-186">Para evitar deadlocks causados pela inversão de ordem de bloqueio, todos os threads devem tentar adquirir objetos de sincronização na ordem de carga definida em todos os momentos.</span><span class="sxs-lookup"><span data-stu-id="069da-186">To prevent deadlocks that are caused by lock order inversion, all threads should attempt to acquire synchronization objects in the defined load order at all times.</span></span>

## <a name="best-practices-for-synchronization"></a><span data-ttu-id="069da-187">Práticas recomendadas para sincronização</span><span class="sxs-lookup"><span data-stu-id="069da-187">Best Practices for Synchronization</span></span>

<span data-ttu-id="069da-188">Considere uma DLL que cria threads de trabalho como parte de sua inicialização.</span><span class="sxs-lookup"><span data-stu-id="069da-188">Consider a DLL that creates worker threads as part of its initialization.</span></span> <span data-ttu-id="069da-189">Após a limpeza da DLL, é necessário sincronizar com todos os threads de trabalho para garantir que as estruturas de dados estejam em um estado consistente e, em seguida, encerrar os threads de trabalho.</span><span class="sxs-lookup"><span data-stu-id="069da-189">Upon DLL cleanup, it is necessary to synchronize with all the worker threads to ensure that the data structures are in a consistent state and then terminate the worker threads.</span></span> <span data-ttu-id="069da-190">Hoje, não há uma maneira simples de resolver completamente o problema de sincronizar e desligar as DLLs de forma limpa em um ambiente multithread.</span><span class="sxs-lookup"><span data-stu-id="069da-190">Today, there is no straightforward way to completely solve the problem of cleanly synchronizing and shutting down DLLs in a multithreaded environment.</span></span> <span data-ttu-id="069da-191">Esta seção descreve as práticas recomendadas atuais para a sincronização de threads durante o desligamento de DLL.</span><span class="sxs-lookup"><span data-stu-id="069da-191">This section describes the current best practices for thread synchronizing during DLL shutdown.</span></span>

<span data-ttu-id="069da-192">Sincronização de threads no [**DllMain**](dllmain.md) durante a saída do processo</span><span class="sxs-lookup"><span data-stu-id="069da-192">Thread Synchronization in [**DllMain**](dllmain.md) during Process Exit</span></span>

-   <span data-ttu-id="069da-193">No momento em que [**DllMain**](dllmain.md) é chamado na saída do processo, todos os threads do processo foram limpos forçosamente e há uma chance de que o espaço de endereço seja inconsistente.</span><span class="sxs-lookup"><span data-stu-id="069da-193">By the time [**DllMain**](dllmain.md) is called at process exit, all the process’s threads have been forcibly cleaned up and there is a chance that the address space is inconsistent.</span></span> <span data-ttu-id="069da-194">A sincronização não é necessária nesse caso.</span><span class="sxs-lookup"><span data-stu-id="069da-194">Synchronization is not required in this case.</span></span> <span data-ttu-id="069da-195">Em outras palavras, o manipulador de \_ desanexação de processo dll ideal \_ está vazio.</span><span class="sxs-lookup"><span data-stu-id="069da-195">In other words, the ideal DLL\_PROCESS\_DETACH handler is empty.</span></span>
-   <span data-ttu-id="069da-196">O Windows Vista garante que as estruturas de dados principais (variáveis de ambiente, diretório atual, heap de processo e assim por diante) estejam em um estado consistente.</span><span class="sxs-lookup"><span data-stu-id="069da-196">Windows Vista ensures that core data structures (environment variables, current directory, process heap, and so on) are in a consistent state.</span></span> <span data-ttu-id="069da-197">No entanto, outras estruturas de dados podem ser corrompidas, portanto a memória de limpeza não é segura.</span><span class="sxs-lookup"><span data-stu-id="069da-197">However, other data structures can be corrupted, so cleaning memory is not safe.</span></span>
-   <span data-ttu-id="069da-198">O estado persistente que precisa ser salvo deve ser liberado para o armazenamento permanente.</span><span class="sxs-lookup"><span data-stu-id="069da-198">Persistent state that needs to be saved must be flushed to permanent storage.</span></span>

<span data-ttu-id="069da-199">Sincronização de threads em **DllMain** para \_ desanexar thread de dll \_ durante o descarregamento de dll</span><span class="sxs-lookup"><span data-stu-id="069da-199">Thread Synchronization in **DllMain** for DLL\_THREAD\_DETACH during DLL Unload</span></span>

-   <span data-ttu-id="069da-200">Quando a DLL é descarregada, o espaço de endereço não é jogado fora.</span><span class="sxs-lookup"><span data-stu-id="069da-200">When the DLL is unloaded, the address space is not thrown away.</span></span> <span data-ttu-id="069da-201">Portanto, espera-se que a DLL execute um desligamento normal.</span><span class="sxs-lookup"><span data-stu-id="069da-201">Therefore, the DLL is expected to perform a clean shutdown.</span></span> <span data-ttu-id="069da-202">Isso inclui a sincronização de threads, os identificadores abertos, o estado persistente e os recursos alocados.</span><span class="sxs-lookup"><span data-stu-id="069da-202">This includes thread synchronization, open handles, persistent state, and allocated resources.</span></span>
-   <span data-ttu-id="069da-203">A sincronização de threads é complicada porque aguardar a saída de threads no [**DllMain**](dllmain.md) pode causar um deadlock.</span><span class="sxs-lookup"><span data-stu-id="069da-203">Thread synchronization is tricky because waiting on threads to exit in [**DllMain**](dllmain.md) can cause a deadlock.</span></span> <span data-ttu-id="069da-204">Por exemplo, a DLL A mantém o bloqueio do carregador.</span><span class="sxs-lookup"><span data-stu-id="069da-204">For example, DLL A holds the loader lock.</span></span> <span data-ttu-id="069da-205">Ele sinaliza ao thread T para sair e aguarda até que o thread saia.</span><span class="sxs-lookup"><span data-stu-id="069da-205">It signals thread T to exit and waits for the thread to exit.</span></span> <span data-ttu-id="069da-206">O thread T sai e o carregador tenta adquirir o bloqueio do carregador para chamar o **DllMain** da dll a com a \_ desanexação do thread de dll \_ .</span><span class="sxs-lookup"><span data-stu-id="069da-206">Thread T exits and the loader tries to acquire the loader lock to call into DLL A’s **DllMain** with DLL\_THREAD\_DETACH.</span></span> <span data-ttu-id="069da-207">Isso causa um deadlock.</span><span class="sxs-lookup"><span data-stu-id="069da-207">This causes a deadlock.</span></span> <span data-ttu-id="069da-208">Para minimizar o risco de um deadlock:</span><span class="sxs-lookup"><span data-stu-id="069da-208">To minimize the risk of a deadlock:</span></span>
    -   <span data-ttu-id="069da-209">A DLL A Obtém uma \_ \_ mensagem de desanexação de thread de dll em seu [**DllMain**](dllmain.md) e define um evento para thread T, sinalizando-a para sair.</span><span class="sxs-lookup"><span data-stu-id="069da-209">DLL A gets a DLL\_THREAD\_DETACH message in its [**DllMain**](dllmain.md) and sets an event for thread T, signaling it to exit.</span></span>
    -   <span data-ttu-id="069da-210">O thread T conclui sua tarefa atual, se apresenta a um estado consistente, sinaliza a DLL A e aguarda infinitamente.</span><span class="sxs-lookup"><span data-stu-id="069da-210">Thread T finishes its current task, brings itself to a consistent state, signals DLL A, and waits infinitely.</span></span> <span data-ttu-id="069da-211">Observe que as rotinas de verificação de consistência devem seguir as mesmas restrições que o [**DllMain**](dllmain.md) para evitar o deadlock.</span><span class="sxs-lookup"><span data-stu-id="069da-211">Note that the consistency-checking routines should follow the same restrictions as [**DllMain**](dllmain.md) to avoid deadlocking.</span></span>
    -   <span data-ttu-id="069da-212">A DLL A encerra o T, sabendo que ele está em um estado consistente.</span><span class="sxs-lookup"><span data-stu-id="069da-212">DLL A terminates T, knowing that it is in a consistent state.</span></span>

<span data-ttu-id="069da-213">Se uma DLL for descarregada depois que todos os seus threads tiverem sido criados, mas antes de começarem a execução, os threads poderão falhar.</span><span class="sxs-lookup"><span data-stu-id="069da-213">If a DLL is unloaded after all its threads have been created, but before they begin executing, the threads may crash.</span></span> <span data-ttu-id="069da-214">Se a DLL criou threads em seu **DllMain** como parte de sua inicialização, alguns threads podem não ter concluído a inicialização e sua \_ mensagem de anexação de thread de dll \_ ainda está aguardando para ser entregue à dll.</span><span class="sxs-lookup"><span data-stu-id="069da-214">If the DLL created threads in its **DllMain** as part of its initialization, some threads may not have finished initialization and their DLL\_THREAD\_ATTACH message is still waiting to be delivered to the DLL.</span></span> <span data-ttu-id="069da-215">Nessa situação, se a DLL for descarregada, ela começará a encerrar os threads.</span><span class="sxs-lookup"><span data-stu-id="069da-215">In this situation, if the DLL is unloaded, it will begin terminating threads.</span></span> <span data-ttu-id="069da-216">No entanto, alguns threads podem ser bloqueados por trás do bloqueio do carregador.</span><span class="sxs-lookup"><span data-stu-id="069da-216">However, some threads may be blocked behind the loader lock.</span></span> <span data-ttu-id="069da-217">Suas \_ mensagens de anexação de thread de dll \_ são processadas após o cancelamento do mapeamento da dll, causando a falha do processo.</span><span class="sxs-lookup"><span data-stu-id="069da-217">Their DLL\_THREAD\_ATTACH messages are processed after the DLL has been unmapped, causing the process to crash.</span></span>

## <a name="recommendations"></a><span data-ttu-id="069da-218">Recomendações</span><span class="sxs-lookup"><span data-stu-id="069da-218">Recommendations</span></span>

<span data-ttu-id="069da-219">Estas são as diretrizes recomendadas:</span><span class="sxs-lookup"><span data-stu-id="069da-219">The following are recommended guidelines:</span></span>

-   <span data-ttu-id="069da-220">Use Application Verifier para capturar os erros mais comuns em [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="069da-220">Use Application Verifier to catch the most common errors in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="069da-221">Se estiver usando um bloqueio privado dentro de [**DllMain**](dllmain.md), defina uma hierarquia de bloqueio e use-a consistentemente.</span><span class="sxs-lookup"><span data-stu-id="069da-221">If using a private lock inside [**DllMain**](dllmain.md), define a locking hierarchy and use it consistently.</span></span> <span data-ttu-id="069da-222">O bloqueio do carregador deve estar na parte inferior desta hierarquia.</span><span class="sxs-lookup"><span data-stu-id="069da-222">The loader lock must be at the bottom of this hierarchy.</span></span>
-   <span data-ttu-id="069da-223">Verifique se nenhuma chamada depende de outra DLL que talvez ainda não tenha sido totalmente carregada.</span><span class="sxs-lookup"><span data-stu-id="069da-223">Verify that no calls depend on another DLL that may not have been fully loaded yet.</span></span>
-   <span data-ttu-id="069da-224">Executar inicializações simples estaticamente no tempo de compilação, em vez de em [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="069da-224">Perform simple initializations statically at compile time, rather than in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="069da-225">Adie todas as chamadas em [**DllMain**](dllmain.md) que podem esperar até mais tarde.</span><span class="sxs-lookup"><span data-stu-id="069da-225">Defer any calls in [**DllMain**](dllmain.md) that can wait until later.</span></span>
-   <span data-ttu-id="069da-226">Adie as tarefas de inicialização que podem esperar até mais tarde.</span><span class="sxs-lookup"><span data-stu-id="069da-226">Defer initialization tasks that can wait until later.</span></span> <span data-ttu-id="069da-227">Determinadas condições de erro devem ser detectadas antecipadamente para que o aplicativo possa manipular erros normalmente.</span><span class="sxs-lookup"><span data-stu-id="069da-227">Certain error conditions must be detected early so that the application can handle errors gracefully.</span></span> <span data-ttu-id="069da-228">No entanto, há compensações entre essa detecção antecipada e a perda de robustez que pode resultar dela.</span><span class="sxs-lookup"><span data-stu-id="069da-228">However, there are tradeoffs between this early detection and the loss of robustness that can result from it.</span></span> <span data-ttu-id="069da-229">Geralmente, a inicialização desreferenciada é a melhor.</span><span class="sxs-lookup"><span data-stu-id="069da-229">Deferring initialization is often best.</span></span>

 

 
