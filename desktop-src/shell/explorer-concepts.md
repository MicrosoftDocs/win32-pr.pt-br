---
description: Entenda os conceitos comuns quando você deseja estender Windows Explorer, que é uma das muitas opções de extensibilidade na interface do usuário do Windows Shell.
title: Conceitos do Common Explorer
ms.topic: article
ms.date: 05/31/2018
ms.assetid: 78136c36-bd3c-4114-8b69-fef4e307566d
api_name: ''
api_type: ''
api_location: ''
topic_type:
- kbArticle
ms.openlocfilehash: db9b46bf944992a16b6a1b8a9bcad581ec7d661b
ms.sourcegitcommit: 5d4e99f4c8f42f5f543e52cb9beb9fb13ec56c5f
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/19/2021
ms.locfileid: "112404929"
---
# <a name="common-explorer-concepts"></a><span data-ttu-id="af26a-103">Conceitos do Common Explorer</span><span class="sxs-lookup"><span data-stu-id="af26a-103">Common Explorer Concepts</span></span>

<span data-ttu-id="af26a-104">O *namespace do* Shell organiza o sistema de arquivos e outros objetos gerenciados pelo Shell em uma única hierarquia estruturada por árvore.</span><span class="sxs-lookup"><span data-stu-id="af26a-104">The Shell *namespace* organizes the file system and other objects managed by the Shell into a single tree-structured hierarchy.</span></span> <span data-ttu-id="af26a-105">Conceitualmente, é uma versão maior e mais inclusiva do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="af26a-105">Conceptually, it is a larger and more inclusive version of the file system.</span></span>

-   [<span data-ttu-id="af26a-106">Introdução</span><span class="sxs-lookup"><span data-stu-id="af26a-106">Introduction</span></span>](#introduction)
-   [<span data-ttu-id="af26a-107">Identificando objetos de namespace</span><span class="sxs-lookup"><span data-stu-id="af26a-107">Identifying Namespace Objects</span></span>](#identifying-namespace-objects)
    -   [<span data-ttu-id="af26a-108">Item IDs</span><span class="sxs-lookup"><span data-stu-id="af26a-108">Item IDs</span></span>](#item-ids)
    -   [<span data-ttu-id="af26a-109">Listas de IDs de Item</span><span class="sxs-lookup"><span data-stu-id="af26a-109">Item ID Lists</span></span>](#item-id-lists)
    -   [<span data-ttu-id="af26a-110">Pidls</span><span class="sxs-lookup"><span data-stu-id="af26a-110">PIDLs</span></span>](#pidls)
    -   [<span data-ttu-id="af26a-111">Alocando PIDLs</span><span class="sxs-lookup"><span data-stu-id="af26a-111">Allocating PIDLs</span></span>](#allocating-pidls)

## <a name="introduction"></a><span data-ttu-id="af26a-112">Introdução</span><span class="sxs-lookup"><span data-stu-id="af26a-112">Introduction</span></span>

<span data-ttu-id="af26a-113">Uma das principais responsabilidades do Shell é gerenciar e fornecer acesso à ampla variedade de objetos que compõe o sistema.</span><span class="sxs-lookup"><span data-stu-id="af26a-113">One of the primary responsibilities of the Shell is managing and providing access to the wide variety of objects that make up the system.</span></span> <span data-ttu-id="af26a-114">Os mais diversos e familiares desses objetos são as pastas e arquivos que residem em unidades de disco do computador.</span><span class="sxs-lookup"><span data-stu-id="af26a-114">The most numerous and familiar of these objects are the folders and files that reside on computer disk drives.</span></span> <span data-ttu-id="af26a-115">No entanto, o Shell também gerencia vários sistemas não arquivos ou *objetos* virtuais.</span><span class="sxs-lookup"><span data-stu-id="af26a-115">However, the Shell manages a number of nonfile system, or *virtual* objects, as well.</span></span> <span data-ttu-id="af26a-116">Alguns exemplos incluem:</span><span class="sxs-lookup"><span data-stu-id="af26a-116">Some examples include:</span></span>

-   <span data-ttu-id="af26a-117">Impressoras de rede</span><span class="sxs-lookup"><span data-stu-id="af26a-117">Network printers</span></span>
-   <span data-ttu-id="af26a-118">Outros computadores em rede</span><span class="sxs-lookup"><span data-stu-id="af26a-118">Other networked computers</span></span>
-   <span data-ttu-id="af26a-119">Painel de Controle aplicativos</span><span class="sxs-lookup"><span data-stu-id="af26a-119">Control Panel applications</span></span>
-   <span data-ttu-id="af26a-120">O Lixeira</span><span class="sxs-lookup"><span data-stu-id="af26a-120">The Recycle Bin</span></span>

<span data-ttu-id="af26a-121">Alguns objetos virtuais não envolvem armazenamento físico.</span><span class="sxs-lookup"><span data-stu-id="af26a-121">Some virtual objects do not involve physical storage at all.</span></span> <span data-ttu-id="af26a-122">O objeto de impressora, por exemplo, contém uma coleção de links para impressoras em rede.</span><span class="sxs-lookup"><span data-stu-id="af26a-122">The printer object, for instance, contains a collection of links to networked printers.</span></span> <span data-ttu-id="af26a-123">Outros objetos virtuais, como o Lixeira, podem conter dados armazenados em uma unidade de disco, mas precisam ser tratados de maneira diferente dos arquivos normais.</span><span class="sxs-lookup"><span data-stu-id="af26a-123">Other virtual objects, such as the Recycle Bin, may contain data that is stored on a disk drive, but needs to be handled differently than normal files.</span></span> <span data-ttu-id="af26a-124">Por exemplo, um objeto virtual pode ser usado para representar dados armazenados em um banco de dados.</span><span class="sxs-lookup"><span data-stu-id="af26a-124">For example, a virtual object can be used to represent data stored in a database.</span></span> <span data-ttu-id="af26a-125">Em termos de namespace, os vários itens no banco de dados podem aparecer no Windows Explorer como objetos separados, mesmo que todos eles sejam armazenados em um único arquivo de disco.</span><span class="sxs-lookup"><span data-stu-id="af26a-125">In terms of the namespace, the various items in the database could appear in the Windows Explorer as separate objects, even though they are all stored in a single disk file.</span></span>

<span data-ttu-id="af26a-126">Objetos virtuais podem até mesmo estar localizados em computadores remotos.</span><span class="sxs-lookup"><span data-stu-id="af26a-126">Virtual objects may even be located on remote computers.</span></span> <span data-ttu-id="af26a-127">Por exemplo, para facilitar o roaming, os arquivos de documento de um usuário podem ser armazenados em um servidor.</span><span class="sxs-lookup"><span data-stu-id="af26a-127">For instance, to facilitate roaming, a user's document files might be stored on a server.</span></span> <span data-ttu-id="af26a-128">Para dar aos usuários acesso aos arquivos de vários computadores desktop, a pasta Meus Documentos no computador desktop que eles estão usando no momento apontará para o servidor, não para o disco rígido do computador desktop.</span><span class="sxs-lookup"><span data-stu-id="af26a-128">To give users access to their files from multiple desktop PCs, the My Documents folder on the desktop PC they are currently using will point to the server, not the hard disk of the desktop PC.</span></span> <span data-ttu-id="af26a-129">Seu caminho incluirá uma unidade de rede mapeada ou um nome de caminho UNC.</span><span class="sxs-lookup"><span data-stu-id="af26a-129">Its path will include either a mapped network drive or a UNC path name.</span></span>

<span data-ttu-id="af26a-130">Assim como o sistema de arquivos, o namespace inclui dois tipos básicos de objeto: pastas e arquivos.</span><span class="sxs-lookup"><span data-stu-id="af26a-130">Like the file system, the namespace includes two basic types of object: folders and files.</span></span> <span data-ttu-id="af26a-131">Objetos de pasta são *os nós* da árvore; eles são contêineres para objetos de arquivo e outras pastas.</span><span class="sxs-lookup"><span data-stu-id="af26a-131">Folder objects are the *nodes* of the tree; they are containers for file objects and other folders.</span></span> <span data-ttu-id="af26a-132">Objetos de arquivo são *as folhas* da árvore; eles são arquivos de disco normais ou objetos virtuais, como links de impressora.</span><span class="sxs-lookup"><span data-stu-id="af26a-132">File objects are the *leaves* of the tree; they are either normal disk files or virtual objects, such as printer links.</span></span> <span data-ttu-id="af26a-133">As pastas que não fazem parte do sistema de arquivos às vezes são *conhecidas* como pastas virtuais .</span><span class="sxs-lookup"><span data-stu-id="af26a-133">Folders that are not part of the file system are sometimes referred to as *virtual folders*.</span></span>

<span data-ttu-id="af26a-134">Assim como as pastas do sistema de arquivos, a coleção de pastas virtuais geralmente varia de sistema para sistema.</span><span class="sxs-lookup"><span data-stu-id="af26a-134">Like file system folders, the collection of virtual folders generally varies from system to system.</span></span> <span data-ttu-id="af26a-135">Há três classes de pastas virtuais:</span><span class="sxs-lookup"><span data-stu-id="af26a-135">There are three classes of virtual folders:</span></span>

-   <span data-ttu-id="af26a-136">Pastas virtuais padrão, como o Lixeira, que são encontradas em todos os sistemas.</span><span class="sxs-lookup"><span data-stu-id="af26a-136">Standard virtual folders, such as the Recycle Bin, that are found on all systems.</span></span>
-   <span data-ttu-id="af26a-137">Pastas virtuais opcionais que têm nomes padrão e funcionalidade, mas podem não estar presentes em todos os sistemas.</span><span class="sxs-lookup"><span data-stu-id="af26a-137">Optional virtual folders that have standard names and functionality, but may not be present on all systems.</span></span>
-   <span data-ttu-id="af26a-138">Pastas não padrão instaladas pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="af26a-138">Non-standard folders that are installed by the user.</span></span>

<span data-ttu-id="af26a-139">Ao contrário das pastas do sistema de arquivos, os usuários não podem criar novas pastas virtuais por conta própria.</span><span class="sxs-lookup"><span data-stu-id="af26a-139">Unlike file system folders, users cannot create new virtual folders themselves.</span></span> <span data-ttu-id="af26a-140">Eles só podem instalar aqueles criados por desenvolvedores que não são da Microsoft.</span><span class="sxs-lookup"><span data-stu-id="af26a-140">They can only install ones created by non-Microsoft developers.</span></span> <span data-ttu-id="af26a-141">O número de pastas virtuais normalmente é muito menor do que o número de pastas do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="af26a-141">The number of virtual folders is thus normally much fewer than the number of file system folders.</span></span> <span data-ttu-id="af26a-142">Para ver uma discussão sobre como implementar pastas virtuais, consulte [Extensões de namespace](nse-works.md).</span><span class="sxs-lookup"><span data-stu-id="af26a-142">For a discussion of how to implement virtual folders see [Namespace Extensions](nse-works.md).</span></span>

<span data-ttu-id="af26a-143">Você pode ver uma representação visual de como o namespace é estruturado na Barra do Explorer do Windows Explorer.</span><span class="sxs-lookup"><span data-stu-id="af26a-143">You can see a visual representation of how the namespace is structured in the Explorer Bar of the Windows Explorer.</span></span> <span data-ttu-id="af26a-144">Por exemplo, a captura de tela a seguir Windows Explorer um namespace relativamente simples.</span><span class="sxs-lookup"><span data-stu-id="af26a-144">For example, the following screen shot of Windows Explorer shows a relatively simple namespace.</span></span>

![captura de tela mostrando uma exibição do namespace do shell](images/prog1.png)

<span data-ttu-id="af26a-146">A raiz final da hierarquia de namespace é a área de trabalho.</span><span class="sxs-lookup"><span data-stu-id="af26a-146">The ultimate root of the namespace hierarchy is the desktop.</span></span> <span data-ttu-id="af26a-147">Imediatamente abaixo da raiz estão várias pastas virtuais, como Meu Computador e Lixeira.</span><span class="sxs-lookup"><span data-stu-id="af26a-147">Immediately below the root are several virtual folders such as My Computer and the Recycle Bin.</span></span>

<span data-ttu-id="af26a-148">Os sistemas de arquivos das várias unidades de disco podem ser vistos como subconjunto da hierarquia de namespace maior.</span><span class="sxs-lookup"><span data-stu-id="af26a-148">The file systems of the various disk drives can be seen to be subsets of the larger namespace hierarchy.</span></span> <span data-ttu-id="af26a-149">As raízes desses sistemas de arquivos são subpastas da pasta Meu Computador dados.</span><span class="sxs-lookup"><span data-stu-id="af26a-149">The roots of these file systems are subfolders of the My Computer folder.</span></span> <span data-ttu-id="af26a-150">Meu Computador também inclui as raízes de todas as unidades de rede mapeadas.</span><span class="sxs-lookup"><span data-stu-id="af26a-150">My Computer also includes the roots of any mapped network drives.</span></span> <span data-ttu-id="af26a-151">Outros nós na árvore, como Meus Documentos, são pastas virtuais.</span><span class="sxs-lookup"><span data-stu-id="af26a-151">Other nodes in the tree, such as My Documents, are virtual folders.</span></span>

## <a name="identifying-namespace-objects"></a><span data-ttu-id="af26a-152">Identificando objetos de namespace</span><span class="sxs-lookup"><span data-stu-id="af26a-152">Identifying Namespace Objects</span></span>

<span data-ttu-id="af26a-153">Antes de usar um objeto de namespace, você deve primeiro ter uma maneira de identificá-lo.</span><span class="sxs-lookup"><span data-stu-id="af26a-153">Before you can use a namespace object, you must first have a way of identifying it.</span></span> <span data-ttu-id="af26a-154">Um objeto no sistema de arquivos pode ter um nome como MyFile.htm.</span><span class="sxs-lookup"><span data-stu-id="af26a-154">An object in the file system could have a name such as MyFile.htm.</span></span> <span data-ttu-id="af26a-155">Como pode haver outros arquivos com esse nome em outro lugar no sistema, identificar exclusivamente um arquivo ou pasta requer um caminho totalmente qualificado, como "C: \\ MyDocs \\MyFile.htm".</span><span class="sxs-lookup"><span data-stu-id="af26a-155">Because there might be other files with that name elsewhere in the system, uniquely identifying a file or folder requires a fully qualified path such as "C:\\MyDocs\\MyFile.htm".</span></span> <span data-ttu-id="af26a-156">Esse caminho é basicamente uma lista ordenada de todas as pastas em um caminho da raiz do sistema de arquivos, C: \\ , terminando com o arquivo .</span><span class="sxs-lookup"><span data-stu-id="af26a-156">This path is basically an ordered list of all folders in a path from the file system root, C:\\, ending with the file.</span></span>

<span data-ttu-id="af26a-157">No contexto do namespace, os caminhos ainda são muito úteis para identificar objetos localizados na parte do sistema de arquivos do namespace.</span><span class="sxs-lookup"><span data-stu-id="af26a-157">In the context of the namespace, paths are still quite useful for identifying objects located in the file system part of the namespace.</span></span> <span data-ttu-id="af26a-158">No entanto, eles não podem ser usados para objetos virtuais.</span><span class="sxs-lookup"><span data-stu-id="af26a-158">However, they cannot be used for virtual objects.</span></span> <span data-ttu-id="af26a-159">Em vez disso, o Shell fornece um meio alternativo de identificação que pode ser usado com qualquer objeto de namespace.</span><span class="sxs-lookup"><span data-stu-id="af26a-159">Instead, the Shell provides an alternative means of identification that can be used with any namespace object.</span></span>

### <a name="item-ids"></a><span data-ttu-id="af26a-160">Item IDs</span><span class="sxs-lookup"><span data-stu-id="af26a-160">Item IDs</span></span>

<span data-ttu-id="af26a-161">Em uma pasta, cada objeto tem uma *ID de item*, que é o equivalente funcional de um nome de arquivo ou pasta.</span><span class="sxs-lookup"><span data-stu-id="af26a-161">Within a folder, each object has an *item ID*, which is the functional equivalent of a file or folder name.</span></span> <span data-ttu-id="af26a-162">A ID do item é, na [**verdade, uma estrutura DEMID:**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid)</span><span class="sxs-lookup"><span data-stu-id="af26a-162">The item ID is actually a [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure:</span></span>


```
typedef struct _SHITEMID { 
    USHORT cb; 
    BYTE   abID[1]; 
} SHITEMID, * LPSHITEMID;
```



<span data-ttu-id="af26a-163">O **membro abID** é o identificador do objeto.</span><span class="sxs-lookup"><span data-stu-id="af26a-163">The **abID** member is the object's identifier.</span></span> <span data-ttu-id="af26a-164">O comprimento de **abID** não está definido e seu valor é determinado pela pasta que contém o objeto .</span><span class="sxs-lookup"><span data-stu-id="af26a-164">The length of **abID** is not defined, and its value is determined by the folder that contains the object.</span></span> <span data-ttu-id="af26a-165">Como não há nenhuma definição padrão de como os **valores abID** são atribuídos por pastas, eles são significativos apenas para o objeto de pasta associado.</span><span class="sxs-lookup"><span data-stu-id="af26a-165">Because there is no standard definition for how **abID** values are assigned by folders, they are only meaningful to the associated folder object.</span></span> <span data-ttu-id="af26a-166">Os aplicativos devem simplesmente tratá-los como um token que identifica um objeto em uma pasta específica.</span><span class="sxs-lookup"><span data-stu-id="af26a-166">Applications should simply treat them as a token that identifies an object in a particular folder.</span></span> <span data-ttu-id="af26a-167">Como o comprimento de **abID** varia, o **membro cb** mantém o tamanho da estrutura [**DEMID,**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) em bytes.</span><span class="sxs-lookup"><span data-stu-id="af26a-167">Because the length of **abID** varies, the **cb** member holds the size of the [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure, in bytes.</span></span>

<span data-ttu-id="af26a-168">Como as IDs de item não são úteis para fins de exibição, a pasta que contém o objeto normalmente atribui a ele um nome de exibição.</span><span class="sxs-lookup"><span data-stu-id="af26a-168">Because item IDs aren't useful for display purposes, the folder that contains the object normally assigns it a display name.</span></span> <span data-ttu-id="af26a-169">Esse é o nome usado pelo Windows Explorer quando exibe o conteúdo de uma pasta.</span><span class="sxs-lookup"><span data-stu-id="af26a-169">This is the name that is used by Windows Explorer when it displays the contents of a folder.</span></span> <span data-ttu-id="af26a-170">Para obter mais informações sobre como os nomes de exibição são tratados, consulte [Obter informações de uma pasta](folder-info.md).</span><span class="sxs-lookup"><span data-stu-id="af26a-170">For more information on how display names are handled, see [Getting Information From a Folder](folder-info.md).</span></span>

### <a name="item-id-lists"></a><span data-ttu-id="af26a-171">Listas de IDs de Item</span><span class="sxs-lookup"><span data-stu-id="af26a-171">Item ID Lists</span></span>

<span data-ttu-id="af26a-172">A ID do item raramente é usada por si só.</span><span class="sxs-lookup"><span data-stu-id="af26a-172">The item ID is rarely used by itself.</span></span> <span data-ttu-id="af26a-173">Normalmente, ele faz parte de uma lista de IDs de item, que serve para a mesma finalidade que um caminho do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="af26a-173">Normally, it is part of an item ID list, which serves the same purpose as a file system path.</span></span> <span data-ttu-id="af26a-174">No entanto, em vez da cadeia de caracteres usada para caminhos, uma lista de IDs de item é uma [**estrutura ITEMIDLIST.**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist)</span><span class="sxs-lookup"><span data-stu-id="af26a-174">However, instead of the character string used for paths, an item ID list is an [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure.</span></span> <span data-ttu-id="af26a-175">Essa estrutura é uma sequência ordenada de uma ou mais IDs de item, terminadas por um NULL de dois **byte.**</span><span class="sxs-lookup"><span data-stu-id="af26a-175">This structure is an ordered sequence of one or more item IDs, terminated by a two-byte **NULL**.</span></span> <span data-ttu-id="af26a-176">Cada ID de item na lista de IDs de item corresponde a um objeto de namespace.</span><span class="sxs-lookup"><span data-stu-id="af26a-176">Each item ID in the item ID list corresponds to a namespace object.</span></span> <span data-ttu-id="af26a-177">Sua ordem define um caminho no namespace, assim como um caminho do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="af26a-177">Their order defines a path in the namespace, much like a file system path.</span></span>

<span data-ttu-id="af26a-178">A ilustração a seguir mostra uma representação esquematizada da [**estrutura ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) que corresponde a C: \\ MyDocs \\MyFile.htm.</span><span class="sxs-lookup"><span data-stu-id="af26a-178">The following illustration shows a schematic representation of the [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure that corresponds to C:\\MyDocs\\MyFile.htm.</span></span> <span data-ttu-id="af26a-179">O nome de exibição de cada ID de item é mostrado acima dela.</span><span class="sxs-lookup"><span data-stu-id="af26a-179">The display name of each item ID is shown above it.</span></span> <span data-ttu-id="af26a-180">As larguras variáveis dos membros **abID** são arbitrárias; eles ilustram o fato de que o tamanho desse membro pode variar.</span><span class="sxs-lookup"><span data-stu-id="af26a-180">The varying widths of the **abID** members are arbitrary; they illustrate the fact that the size of this member can vary.</span></span>

![uma ilustração ilustrativa de um pidl](images/shell2.png)

### <a name="pidls"></a><span data-ttu-id="af26a-182">Pidls</span><span class="sxs-lookup"><span data-stu-id="af26a-182">PIDLs</span></span>

<span data-ttu-id="af26a-183">Para a API do Shell, os objetos de namespace geralmente são identificados por um ponteiro para sua estrutura [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) ou ponteiro para uma PIDL (lista de identificadores de item).</span><span class="sxs-lookup"><span data-stu-id="af26a-183">For the Shell API, namespace objects are usually identified by a pointer to their [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure, or pointer to an item identifier list (PIDL).</span></span> <span data-ttu-id="af26a-184">Para sua conveniência, o termo PIDL geralmente se referirá nesta documentação à própria estrutura em vez do ponteiro para ele.</span><span class="sxs-lookup"><span data-stu-id="af26a-184">For convenience, the term PIDL will generally refer in this documentation to the structure itself rather than the pointer to it.</span></span>

<span data-ttu-id="af26a-185">O PIDL mostrado na ilustração anterior é conhecido como um PIDL *completo* *ou* absoluto.</span><span class="sxs-lookup"><span data-stu-id="af26a-185">The PIDL shown in the preceding illustration is referred to as a *full*, or *absolute*, PIDL.</span></span> <span data-ttu-id="af26a-186">Um PIDL completo começa na área de trabalho e contém as IDs de item de todas as pastas intermediárias no caminho.</span><span class="sxs-lookup"><span data-stu-id="af26a-186">A full PIDL starts from the desktop, and contains the item IDs of all intermediate folders in the path.</span></span> <span data-ttu-id="af26a-187">Ele termina com a ID de item do objeto seguida por um NULL de dois byte **de terminação.**</span><span class="sxs-lookup"><span data-stu-id="af26a-187">It ends with the object's item ID followed by a terminating two-byte **NULL**.</span></span> <span data-ttu-id="af26a-188">Um PIDL completo é semelhante a um caminho totalmente qualificado e identifica exclusivamente o objeto no namespace shell.</span><span class="sxs-lookup"><span data-stu-id="af26a-188">A full PIDL is similar to a fully qualified path and uniquely identifies the object in the Shell namespace.</span></span>

<span data-ttu-id="af26a-189">As PIDLs completas são usadas com pouca pouca segurança.</span><span class="sxs-lookup"><span data-stu-id="af26a-189">Full PIDLs are used infrequently.</span></span> <span data-ttu-id="af26a-190">Muitas funções e métodos esperam um *PIDL relativo.*</span><span class="sxs-lookup"><span data-stu-id="af26a-190">Many functions and methods expect a *relative PIDL*.</span></span> <span data-ttu-id="af26a-191">A raiz de um PIDL relativo é uma pasta, não a área de trabalho.</span><span class="sxs-lookup"><span data-stu-id="af26a-191">The root of a relative PIDL is a folder, not the desktop.</span></span> <span data-ttu-id="af26a-192">Assim como com caminhos relativos, a série de IDs de item que compõe a estrutura define um caminho no namespace entre dois objetos.</span><span class="sxs-lookup"><span data-stu-id="af26a-192">As with relative paths, the series of item IDs that make up the structure define a path in the namespace between two objects.</span></span> <span data-ttu-id="af26a-193">Embora eles não identifiquem exclusivamente o objeto, geralmente são menores que um PIDL completo e suficientes para muitas finalidades.</span><span class="sxs-lookup"><span data-stu-id="af26a-193">Although they do not uniquely identify the object, they are usually smaller than a full PIDL and sufficient for many purposes.</span></span>

<span data-ttu-id="af26a-194">As PIDLs relativas mais usadas, *PIDLs* de nível único, são relativas à pasta pai do objeto.</span><span class="sxs-lookup"><span data-stu-id="af26a-194">The most commonly used relative PIDLs, *single-level PIDLs*, are relative to the object's parent folder.</span></span> <span data-ttu-id="af26a-195">Eles contêm apenas a ID do item do objeto e um **NULL de terminação.**</span><span class="sxs-lookup"><span data-stu-id="af26a-195">They contain only the object's item ID and a terminating **NULL**.</span></span> <span data-ttu-id="af26a-196">As PIDLs de vários níveis também são usadas para muitas finalidades.</span><span class="sxs-lookup"><span data-stu-id="af26a-196">Multi-level PIDLs are also used for many purposes.</span></span> <span data-ttu-id="af26a-197">Eles contêm duas ou mais IDs de item e normalmente definem um caminho de uma pasta pai para um objeto por meio de uma série de uma ou mais subpastas.</span><span class="sxs-lookup"><span data-stu-id="af26a-197">They contain two or more item IDs and typically define a path from a parent folder to an object through a series of one or more subfolders.</span></span> <span data-ttu-id="af26a-198">Observe que um PIDL de nível único ainda pode ser um PIDL totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="af26a-198">Note that a single-level PIDL can still be a fully qualified PIDL.</span></span> <span data-ttu-id="af26a-199">Em particular, os objetos da área de trabalho são filhos da área de trabalho, portanto, suas PIDLs totalmente qualificadas contêm apenas uma ID de item.</span><span class="sxs-lookup"><span data-stu-id="af26a-199">In particular, desktop objects are children of the desktop, so their fully qualified PIDLs contain only one item ID.</span></span>

<span data-ttu-id="af26a-200">Conforme discutido em [Obter a ID](folder-id.md)de uma pasta, a API do Shell fornece várias maneiras de recuperar o PIDL de um objeto.</span><span class="sxs-lookup"><span data-stu-id="af26a-200">As discussed in [Getting a Folder's ID](folder-id.md), the Shell API provides a number of ways to retrieve an object's PIDL.</span></span> <span data-ttu-id="af26a-201">Depois de tê-lo, você costuma apenas usá-lo para identificar o objeto ao chamar outras funções e métodos da API do Shell.</span><span class="sxs-lookup"><span data-stu-id="af26a-201">Once you have it, you commonly just use it to identify the object when you call other Shell API functions and methods.</span></span> <span data-ttu-id="af26a-202">Nesse contexto, o conteúdo interno de um PIDL é opaco e irrelevante.</span><span class="sxs-lookup"><span data-stu-id="af26a-202">In this context, a PIDL's internal contents are opaque and irrelevant.</span></span> <span data-ttu-id="af26a-203">Para os fins desta discussão, imagine PIDLs como tokens que representam objetos de namespace específicos e concentre-se em como usá-los para tarefas comuns.</span><span class="sxs-lookup"><span data-stu-id="af26a-203">For the purposes of this discussion, think of PIDLs as tokens that represent particular namespace objects, and focus on how to use them for common tasks.</span></span>

### <a name="allocating-pidls"></a><span data-ttu-id="af26a-204">Alocando PIDLs</span><span class="sxs-lookup"><span data-stu-id="af26a-204">Allocating PIDLs</span></span>

<span data-ttu-id="af26a-205">Embora PIDLs tenha alguma semelhança com os caminhos, usá-los requer uma abordagem um pouco diferente.</span><span class="sxs-lookup"><span data-stu-id="af26a-205">Although PIDLs have some similarity to paths, using them requires a somewhat different approach.</span></span> <span data-ttu-id="af26a-206">A principal diferença é em como alocar e desalocar memória para eles.</span><span class="sxs-lookup"><span data-stu-id="af26a-206">The primary difference is in how to allocate and deallocate memory for them.</span></span>

<span data-ttu-id="af26a-207">Assim como a cadeia de caracteres usada para um caminho, a memória deve ser alocada para um PIDL.</span><span class="sxs-lookup"><span data-stu-id="af26a-207">Like the string used for a path, memory must be allocated for a PIDL.</span></span> <span data-ttu-id="af26a-208">Se um aplicativo criar um PIDL, ele deverá alocar memória suficiente para a estrutura [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) .</span><span class="sxs-lookup"><span data-stu-id="af26a-208">If an application creates a PIDL, it must allocate sufficient memory for the [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure.</span></span> <span data-ttu-id="af26a-209">Para a maioria dos casos discutidos aqui, o Shell cria o PIDL e manipula a alocação de memória.</span><span class="sxs-lookup"><span data-stu-id="af26a-209">For most of the cases discussed here, the Shell creates the PIDL and handles memory allocation.</span></span> <span data-ttu-id="af26a-210">Independentemente do que alocou o PIDL, o aplicativo geralmente é responsável por desalocar o PIDL quando ele não é mais necessário.</span><span class="sxs-lookup"><span data-stu-id="af26a-210">Regardless of what allocated the PIDL, the application is usually responsible for deallocating the PIDL when it is no longer needed.</span></span>

<span data-ttu-id="af26a-211">Use a função [**CoTaskMemAlloc**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc) para alocar o PIDL e a função [**CoTaskMemFree**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemfree) para desalocá-lo.</span><span class="sxs-lookup"><span data-stu-id="af26a-211">Use the [**CoTaskMemAlloc**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc) function to allocate the PIDL, and the [**CoTaskMemFree**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemfree) function to deallocate it.</span></span>

 

 
