---
description: Embora esse mecanismo seja suficiente para aplicativos simples, ele não oferece suporte aos requisitos complexos de expedição de mensagens de aplicativos mais avançados, como aqueles que usam o modelo de interface de vários documentos (MDI).
ms.assetid: e4558e71-bbec-415a-a7c2-9025a4d6c474
title: Gancho de bloqueio
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2dcd098692784a662456c990a238bd309db0c321
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "105771354"
---
# <a name="blocking-hook"></a><span data-ttu-id="2fa96-103">Gancho de bloqueio</span><span class="sxs-lookup"><span data-stu-id="2fa96-103">Blocking Hook</span></span>

<span data-ttu-id="2fa96-104">Embora esse mecanismo seja suficiente para aplicativos simples, ele não oferece suporte aos requisitos complexos de expedição de mensagens de aplicativos mais avançados, como aqueles que usam o modelo de interface de vários documentos (MDI).</span><span class="sxs-lookup"><span data-stu-id="2fa96-104">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications such as those using the Multiple Document Interface (MDI) model.</span></span> <span data-ttu-id="2fa96-105">Para tais aplicativos, um gancho de bloqueio específico de thread pode ser instalado pelo aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2fa96-105">For such applications, a thread-specific blocking hook may be installed by the application.</span></span> <span data-ttu-id="2fa96-106">Isso será chamado pelo provedor de serviços, em vez do gancho de bloqueio padrão descrito no anterior.</span><span class="sxs-lookup"><span data-stu-id="2fa96-106">This will be called by the service provider instead of the default blocking hook described in the preceding.</span></span> <span data-ttu-id="2fa96-107">Um provedor de serviços deve recuperar um ponteiro para o gancho de bloqueio por thread do32.dll de ws2 \_ chamando [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span><span class="sxs-lookup"><span data-stu-id="2fa96-107">A service provider must retrieve a pointer to the per-thread blocking hook from the Ws2\_32.dll by calling [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span></span> <span data-ttu-id="2fa96-108">Se o aplicativo não tiver instalado seu próprio gancho de bloqueio, um ponteiro para a função de gancho de bloqueio padrão será retornado.</span><span class="sxs-lookup"><span data-stu-id="2fa96-108">If the application has not installed its own blocking hook a pointer to the default blocking hook function will be returned.</span></span>

<span data-ttu-id="2fa96-109">Um provedor de serviços do Windows Sockets não pode supor que um gancho de bloqueio fornecido pelo aplicativo permite que o processamento de mensagens continue como o gancho de bloqueio padrão.</span><span class="sxs-lookup"><span data-stu-id="2fa96-109">A Windows Sockets service provider cannot assume that an application-supplied blocking hook allows message processing to continue as the default blocking hook does.</span></span> <span data-ttu-id="2fa96-110">Alguns aplicativos não podem tolerar a possibilidade de mensagens reentrante enquanto uma operação de bloqueio está pendente.</span><span class="sxs-lookup"><span data-stu-id="2fa96-110">Some applications cannot tolerate the possibility of reentrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="2fa96-111">Essa função de gancho de bloqueio de um aplicativo simplesmente retorna **false**.</span><span class="sxs-lookup"><span data-stu-id="2fa96-111">Such an application's blocking hook function would simply return **FALSE**.</span></span> <span data-ttu-id="2fa96-112">Se um provedor de serviços depender de mensagens para sua operação interna, ele poderá executar **PeekMessage**(hMyWnd...) antes de executar o gancho de bloqueio do aplicativo para que ele possa obter suas próprias mensagens sem afetar o restante do sistema.</span><span class="sxs-lookup"><span data-stu-id="2fa96-112">If a service provider depends on messages for its internal operation, it may execute **PeekMessage**(hMyWnd...) before executing the application's blocking hook so that it can get its own messages without affecting the rest of the system.</span></span>

<span data-ttu-id="2fa96-113">Não há um gancho de bloqueio padrão instalado em versões multithreads preemptivas do Windows.</span><span class="sxs-lookup"><span data-stu-id="2fa96-113">There is no default blocking hook installed in preemptive multithreaded versions of Windows.</span></span> <span data-ttu-id="2fa96-114">Isso ocorre porque outros processos não serão bloqueados se um único aplicativo estiver aguardando a conclusão de uma operação (e, portanto, não chamar **PeekMessage** ou **GetMessage** , o que faz com que o aplicativo gere o processador em janelas não preventivas).</span><span class="sxs-lookup"><span data-stu-id="2fa96-114">This is because other processes will not be blocked if a single application is waiting for an operation to complete (and hence not calling **PeekMessage** or **GetMessage** which causes the application to yield the processor in nonpreemptive Windows).</span></span> <span data-ttu-id="2fa96-115">Quando o provedor de serviços chama [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) , um ponteiro nulo será retornado indicando que o provedor deve usar funções de bloqueio do sistema operacional nativo.</span><span class="sxs-lookup"><span data-stu-id="2fa96-115">When the service provider calls [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) a null pointer will be returned indicating that the provider is to use native operating system blocking functions.</span></span> <span data-ttu-id="2fa96-116">No entanto, para preservar a compatibilidade com versões anteriores, um gancho de bloqueio fornecido pelo aplicativo ainda pode ser instalado por thread no Windows.</span><span class="sxs-lookup"><span data-stu-id="2fa96-116">However, in order to preserve backward compatibility, an application-supplied blocking hook can still be installed on a per-thread basis in Windows.</span></span>

<span data-ttu-id="2fa96-117">O provedor de serviço Winsock chamará o gancho de bloqueio somente se todas as seguintes condições forem verdadeiras: a rotina é aquela que é definida como sendo capaz de bloquear, o soquete especificado é um soquete de bloqueio e a solicitação não pode ser concluída imediatamente.</span><span class="sxs-lookup"><span data-stu-id="2fa96-117">The Winsock service provider calls the blocking hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.</span></span> <span data-ttu-id="2fa96-118">Se apenas soquetes de não bloqueio e [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85)) / [**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) em vez de [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) forem usados, o gancho de bloqueio nunca será chamado.</span><span class="sxs-lookup"><span data-stu-id="2fa96-118">If only nonblocking sockets and [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85))/[**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) instead of [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) are used, then the blocking hook will never be called.</span></span>

> [!Note]  
> <span data-ttu-id="2fa96-119">Se, durante o tempo em que pseudoblocking estiver sendo usado para bloquear um thread, uma mensagem do Windows for recebida para o thread, haverá um risco de que o thread tente emitir outra chamada do Winsock.</span><span class="sxs-lookup"><span data-stu-id="2fa96-119">If, during the time pseudoblocking is being used to block a thread, a Windows message is received for the thread, there is a risk that the thread will attempt to issue another Winsock call.</span></span> <span data-ttu-id="2fa96-120">Devido à dificuldade de gerenciar essa condição com segurança, a especificação do Windows Sockets 1,1 não permitia esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="2fa96-120">Because of the difficulty of managing this condition safely, the Windows Sockets 1.1 specification disallowed this behavior.</span></span> <span data-ttu-id="2fa96-121">Não é permitido que um determinado thread faça várias chamadas de função Winsock aninhadas.</span><span class="sxs-lookup"><span data-stu-id="2fa96-121">It is not permissible for a given thread to make multiple, nested Winsock function calls.</span></span> <span data-ttu-id="2fa96-122">Somente uma chamada de função pendente é permitida para um thread específico.</span><span class="sxs-lookup"><span data-stu-id="2fa96-122">Only one outstanding function call is allowed for a particular thread.</span></span> <span data-ttu-id="2fa96-123">Qualquer chamada de função Winsock aninhada falha com o erro WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="2fa96-123">Any nested Winsock function calls fail with the error WSAEINPROGRESS.</span></span> <span data-ttu-id="2fa96-124">Deve-se enfatizar que essa restrição se aplica a operações de bloqueio e não bloqueio, mas somente em ambientes do Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="2fa96-124">It should be emphasized that this restriction applies to both blocking and nonblocking operations, but only in Windows Sockets 1.1 environments.</span></span> <span data-ttu-id="2fa96-125">Há algumas exceções a essa regra, incluindo duas funções que permitem a um aplicativo determinar se uma operação pseudoblocking está na verdade em andamento e para cancelar essa operação, se necessário.</span><span class="sxs-lookup"><span data-stu-id="2fa96-125">There are a few exceptions to this rule, including two functions that allow an application to determine whether a pseudoblocking operation is in fact in progress, and to cancel such an operation if need be.</span></span> <span data-ttu-id="2fa96-126">Eles são descritos a seguir.</span><span class="sxs-lookup"><span data-stu-id="2fa96-126">These are described in the following.</span></span>

 

 

 
