---
description: Um grande problema na portabilidade de aplicativos de um ambiente de soquetes Berkeley para um ambiente Windows envolve o bloqueio; ou seja, invocando uma função que não retorna até que a operação associada seja concluída.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Rotinas de bloqueio do Windows Sockets 1,1 e EINPROGRESS
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "105789410"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a><span data-ttu-id="01147-103">Rotinas de bloqueio do Windows Sockets 1,1 e EINPROGRESS</span><span class="sxs-lookup"><span data-stu-id="01147-103">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</span></span>

<span data-ttu-id="01147-104">Um grande problema na portabilidade de aplicativos de um ambiente de soquetes Berkeley para um ambiente Windows envolve o bloqueio; ou seja, invocando uma função que não retorna até que a operação associada seja concluída.</span><span class="sxs-lookup"><span data-stu-id="01147-104">One major issue in porting applications from a Berkeley Sockets environment to a Windows environment involves blocking; that is, invoking a function that does not return until the associated operation is completed.</span></span> <span data-ttu-id="01147-105">Um problema surge quando a operação leva um tempo arbitrariamente longo para ser concluída: um exemplo é uma função de [**recebimento**](/windows/desktop/api/winsock/nf-winsock-recv) , que pode ser bloqueada até que os dados sejam recebidos do sistema de mesmo nível.</span><span class="sxs-lookup"><span data-stu-id="01147-105">A problem arises when the operation takes an arbitrarily long time to complete: an example is a [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) function, which might block until data has been received from the peer system.</span></span> <span data-ttu-id="01147-106">O comportamento padrão dentro do modelo Berkeley Sockets é para um soquete operar no modo de bloqueio, a menos que o programador solicite explicitamente que as operações sejam tratadas como sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="01147-106">The default behavior within the Berkeley Sockets model is for a socket to operate in blocking mode unless the programmer explicitly requests that operations be treated as nonblocking.</span></span> <span data-ttu-id="01147-107">Os ambientes do Windows Sockets 1,1 não podem assumir o agendamento preventivo.</span><span class="sxs-lookup"><span data-stu-id="01147-107">Windows Sockets 1.1 environments could not assume preemptive scheduling.</span></span> <span data-ttu-id="01147-108">Portanto, era altamente recomendável que os programadores usem as operações de não bloqueio (assíncrono), se possível, com o Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="01147-108">Therefore, it was strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible with Windows Sockets 1.1.</span></span> <span data-ttu-id="01147-109">Como isso nem sempre foi possível, os recursos de pseudo-bloqueio descritos no seguinte foram fornecidos.</span><span class="sxs-lookup"><span data-stu-id="01147-109">Because this was not always possible, the pseudo-blocking facilities described in the following were provided.</span></span>

> [!Note]  
> <span data-ttu-id="01147-110">O Windows Sockets 2 só é executado em sistemas operacionais de 32 bits preemptivos em que os deadlocks não são um problema.</span><span class="sxs-lookup"><span data-stu-id="01147-110">Windows Sockets 2 only runs on preemptive 32-bit operating systems where deadlocks are not a problem.</span></span> <span data-ttu-id="01147-111">As práticas de programação recomendadas para o Windows Sockets 1,1 não são necessárias no Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="01147-111">Programming practices recommended for Windows Sockets 1.1 are not necessary in Windows Sockets 2.</span></span>

 

<span data-ttu-id="01147-112">Mesmo em um soquete de bloqueio, algumas funções — [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt)e [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) , por exemplo, são concluídas imediatamente.</span><span class="sxs-lookup"><span data-stu-id="01147-112">Even on a blocking socket, some functions — [**bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt), and [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) for example — complete immediately.</span></span> <span data-ttu-id="01147-113">Não há nenhuma diferença entre uma operação de bloqueio e de não bloqueio para essas funções.</span><span class="sxs-lookup"><span data-stu-id="01147-113">There is no difference between a blocking and a nonblocking operation for those functions.</span></span> <span data-ttu-id="01147-114">Outras operações, como [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), podem ser concluídas imediatamente ou levar um tempo arbitrário para serem concluídas, dependendo de várias condições de transporte.</span><span class="sxs-lookup"><span data-stu-id="01147-114">Other operations, such as [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), can complete immediately or take an arbitrary time to complete, depending on various transport conditions.</span></span> <span data-ttu-id="01147-115">Quando aplicado a um soquete de bloqueio, essas operações são conhecidas como operações de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="01147-115">When applied to a blocking socket, these operations are referred to as blocking operations.</span></span> <span data-ttu-id="01147-116">As seguintes funções podem bloquear:</span><span class="sxs-lookup"><span data-stu-id="01147-116">The following functions can block:</span></span>

-   [<span data-ttu-id="01147-117">**recebidos**</span><span class="sxs-lookup"><span data-stu-id="01147-117">**recv**</span></span>](/windows/desktop/api/winsock/nf-winsock-recv)
-   [<span data-ttu-id="01147-118">**recvfrom**</span><span class="sxs-lookup"><span data-stu-id="01147-118">**recvfrom**</span></span>](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [<span data-ttu-id="01147-119">**Enviar**</span><span class="sxs-lookup"><span data-stu-id="01147-119">**send**</span></span>](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [<span data-ttu-id="01147-120">**Enviar**</span><span class="sxs-lookup"><span data-stu-id="01147-120">**sendto**</span></span>](/windows/desktop/api/winsock/nf-winsock-sendto)

<span data-ttu-id="01147-121">Com o Windows Sockets de 16 bits 1,1, uma operação de bloqueio que não pode ser concluída imediatamente é manipulada pelo pseudo-bloqueio da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="01147-121">With 16-bit Windows Sockets 1.1, a blocking operation that cannot complete immediately is handled by pseudo-blocking as follows.</span></span>

<span data-ttu-id="01147-122">O provedor de serviços inicia a operação e, em seguida, entra em um loop no qual ele distribui todas as mensagens do Windows (produzindo o processador para outro thread, se necessário) e, em seguida, verifica a conclusão da função do Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="01147-122">The service provider initiates the operation, then enters a loop in which it dispatches any Windows messages (yielding the processor to another thread, if necessary), and then checks for the completion of the Windows Sockets function.</span></span> <span data-ttu-id="01147-123">Se a função tiver sido concluída, ou se [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) tiver sido invocado, a função de bloqueio será concluída com um resultado apropriado.</span><span class="sxs-lookup"><span data-stu-id="01147-123">If the function has completed, or if [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) has been invoked, the blocking function completes with an appropriate result.</span></span>

<span data-ttu-id="01147-124">Um provedor de serviços deve permitir a instalação de uma função de gancho de bloqueio que não processe mensagens para evitar a possibilidade de mensagens reentrante enquanto uma operação de bloqueio estiver pendente.</span><span class="sxs-lookup"><span data-stu-id="01147-124">A service provider must allow installation of a blocking hook function that does not process messages in order to avoid the possibility of re-entrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="01147-125">A função de gancho de bloqueio mais simples retornaria **false**.</span><span class="sxs-lookup"><span data-stu-id="01147-125">The simplest such blocking hook function would return **FALSE**.</span></span> <span data-ttu-id="01147-126">Se uma DLL do Windows Sockets depender de mensagens para operação interna, ela poderá executar **PeekMessage**(**hMyWnd**...) antes de executar o gancho de bloqueio de aplicativo para que ele possa obter suas mensagens sem afetar o restante do sistema.</span><span class="sxs-lookup"><span data-stu-id="01147-126">If a Windows Sockets DLL depends on messages for internal operation, it can execute **PeekMessage**(**hMyWnd**...) before executing the application blocking hook so that it can get its messages without affecting the rest of the system.</span></span>

<span data-ttu-id="01147-127">Em um ambiente Windows Sockets 1,1 de 16 bits, se uma mensagem do Windows for recebida para um processo para o qual uma operação de bloqueio está em andamento, haverá um risco de que o aplicativo tente emitir outra chamada do Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="01147-127">In a 16-bit Windows Sockets 1.1 environment, if a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.</span></span> <span data-ttu-id="01147-128">Devido à dificuldade de gerenciar essa condição com segurança, o Windows Sockets 1,1 não oferece suporte a esse comportamento de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="01147-128">Because of the difficulty in managing this condition safely, Windows Sockets 1.1 does not support such application behavior.</span></span> <span data-ttu-id="01147-129">Um aplicativo não tem permissão para fazer mais de uma chamada de função aninhada do Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="01147-129">An application is not permitted to make more than one nested Windows Sockets function call.</span></span> <span data-ttu-id="01147-130">Apenas uma chamada de função pendente é permitida para uma tarefa específica.</span><span class="sxs-lookup"><span data-stu-id="01147-130">Only one outstanding function call is allowed for a particular task.</span></span> <span data-ttu-id="01147-131">As únicas exceções são duas funções que são fornecidas para auxiliar o programador nessa situação: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) e [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span><span class="sxs-lookup"><span data-stu-id="01147-131">The only exceptions are two functions that are provided to assist the programmer in this situation: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) and [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span></span>

<span data-ttu-id="01147-132">A função [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) pode ser chamada a qualquer momento para determinar se uma chamada de bloqueio do Windows sockets 1,1 está em andamento.</span><span class="sxs-lookup"><span data-stu-id="01147-132">The [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) function can be called at any time to determine whether or not a blocking Windows Sockets 1.1 call is in progress.</span></span> <span data-ttu-id="01147-133">Da mesma forma, a função [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) pode ser chamada a qualquer momento para cancelar uma chamada de bloqueio em andamento.</span><span class="sxs-lookup"><span data-stu-id="01147-133">Similarly, the [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) function can be called at any time to cancel an in-progress blocking call.</span></span> <span data-ttu-id="01147-134">Qualquer outro aninhamento das funções do Windows Sockets falha com o erro WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="01147-134">Any other nesting of Windows Sockets functions fails with the error WSAEINPROGRESS.</span></span>

<span data-ttu-id="01147-135">Deve-se enfatizar que essa restrição se aplica a operações de bloqueio e não bloqueio.</span><span class="sxs-lookup"><span data-stu-id="01147-135">It should be emphasized that this restriction applies to both blocking and nonblocking operations.</span></span> <span data-ttu-id="01147-136">Para aplicativos do Windows Sockets 2 que negociam a versão 2,0 ou superior no momento da chamada de [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), nenhuma restrição sobre o aninhamento das operações é encerrada.</span><span class="sxs-lookup"><span data-stu-id="01147-136">For Windows Sockets 2 applications that negotiate version 2.0 or higher at the time of calling [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no restriction on the nesting of operations exits.</span></span> <span data-ttu-id="01147-137">As operações podem se tornar aninhadas em raras circunstâncias, como durante um retorno de chamada de aceitação condicional [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) ou se um provedor de serviços, por sua vez, invoca uma função do Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="01147-137">Operations can become nested under rare circumstances, such as during a [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) conditional-acceptance callback, or if a service provider in turn invokes a Windows Sockets 2 function.</span></span>

<span data-ttu-id="01147-138">Embora esse mecanismo seja suficiente para aplicativos simples, ele não oferece suporte aos requisitos complexos de expedição de mensagens de aplicativos mais avançados (por exemplo, aqueles que usam o modelo MDI).</span><span class="sxs-lookup"><span data-stu-id="01147-138">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).</span></span> <span data-ttu-id="01147-139">Para tais aplicativos, a API do Windows Sockets inclui a função [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), que permite ao aplicativo especificar uma rotina especial que pode ser chamada em vez da rotina de expedição de mensagem padrão descrita na discussão anterior.</span><span class="sxs-lookup"><span data-stu-id="01147-139">For such applications, the Windows Sockets API includes the function [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), which allows the application to specify a special routine which can be called instead of the default message dispatch routine described in the preceding discussion.</span></span>

<span data-ttu-id="01147-140">O provedor do Windows Sockets chamará o gancho de bloqueio somente se todas as seguintes opções forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="01147-140">The Windows Sockets provider calls the blocking hook only if all of the following are true:</span></span>

-   <span data-ttu-id="01147-141">A rotina é aquela que é definida como sendo capaz de bloquear.</span><span class="sxs-lookup"><span data-stu-id="01147-141">The routine is one that is defined as being able to block.</span></span>
-   <span data-ttu-id="01147-142">O soquete especificado é um soquete de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="01147-142">The specified socket is a blocking socket.</span></span>
-   <span data-ttu-id="01147-143">A solicitação não pode ser concluída imediatamente.</span><span class="sxs-lookup"><span data-stu-id="01147-143">The request cannot be completed immediately.</span></span>

<span data-ttu-id="01147-144">Um soquete é definido como bloqueio por padrão, mas a função [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) com o IOCTL **FIONBIO** ou a função [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) pode definir um soquete para o modo de não bloqueio.</span><span class="sxs-lookup"><span data-stu-id="01147-144">A socket is set to blocking by default, but the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) function with the **FIONBIO** IOCTL or the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) function can set a socket to nonblocking mode.</span></span>

<span data-ttu-id="01147-145">O gancho de bloqueio nunca é chamado e o aplicativo não precisa se preocupar com os problemas de nova entrada que o gancho de bloqueio pode introduzir, se um aplicativo seguir estas diretrizes:</span><span class="sxs-lookup"><span data-stu-id="01147-145">The blocking hook is never called and the application does not need to be concerned with the re-entrancy issues the blocking hook can introduce, if an application follows these guidelines:</span></span>

-   <span data-ttu-id="01147-146">Ele usa apenas soquetes de não bloqueio.</span><span class="sxs-lookup"><span data-stu-id="01147-146">It uses only nonblocking sockets.</span></span>
-   <span data-ttu-id="01147-147">Ele usa as rotinas [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) e/ou **WSAAsyncGetXByY** em vez de [**Select**](/windows/desktop/api/Winsock2/nf-winsock2-select) e **getXbyY** .</span><span class="sxs-lookup"><span data-stu-id="01147-147">It uses the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and/or the **WSAAsyncGetXByY** routines instead of [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and the **getXbyY** routines.</span></span>

<span data-ttu-id="01147-148">Se um aplicativo do Windows Sockets 1,1 invocar uma operação assíncrona ou sem bloqueio que usa um ponteiro para um objeto de memória (um buffer ou uma variável global, por exemplo) como um argumento, é responsabilidade do aplicativo garantir que o objeto esteja disponível para o Windows Sockets durante a operação.</span><span class="sxs-lookup"><span data-stu-id="01147-148">If a Windows Sockets 1.1 application invokes an asynchronous or nonblocking operation that takes a pointer to a memory object (a buffer or a global variable, for example) as an argument, it is the responsibility of the application to ensure that the object is available to Windows Sockets throughout the operation.</span></span> <span data-ttu-id="01147-149">O aplicativo não deve invocar nenhuma função do Windows que possa afetar a viabilidade de mapeamento ou endereço da memória envolvida.</span><span class="sxs-lookup"><span data-stu-id="01147-149">The application must not invoke any Windows function that might affect the mapping or address viability of the memory involved.</span></span>

 

 



