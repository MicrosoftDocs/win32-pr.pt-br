---
description: Este tópico descreve as considerações e as estratégias de otimização com a biblioteca DirectXMath.
ms.assetid: bcbf8ae1-ed49-fdf7-812d-b2089537ab28
title: Otimização de código com a biblioteca DirectXMath
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d11b331077e3d6538952a2f7956641b8b3919e14
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "105813510"
---
# <a name="code-optimization-with-the-directxmath-library"></a><span data-ttu-id="64f80-103">Otimização de código com a biblioteca DirectXMath</span><span class="sxs-lookup"><span data-stu-id="64f80-103">Code Optimization with the DirectXMath Library</span></span>

<span data-ttu-id="64f80-104">Este tópico descreve as considerações e as estratégias de otimização com a biblioteca DirectXMath.</span><span class="sxs-lookup"><span data-stu-id="64f80-104">This topic describes optimization considerations and strategies with the DirectXMath Library.</span></span>

-   [<span data-ttu-id="64f80-105">Usar acessadores com moderação</span><span class="sxs-lookup"><span data-stu-id="64f80-105">Use accessors sparingly</span></span>](#use-accessors-sparingly)
-   [<span data-ttu-id="64f80-106">Usar as configurações de compilação corretas</span><span class="sxs-lookup"><span data-stu-id="64f80-106">Use correct compilation settings</span></span>](#use-correct-compilation-settings)
-   [<span data-ttu-id="64f80-107">Use as funções de est quando apropriado</span><span class="sxs-lookup"><span data-stu-id="64f80-107">Use Est functions when appropriate</span></span>](#use-est-functions-when-appropriate)
-   [<span data-ttu-id="64f80-108">Usar operações e tipos de dados alinhados</span><span class="sxs-lookup"><span data-stu-id="64f80-108">Use Aligned Data Types and Operations</span></span>](#use-aligned-data-types-and-operations)
-   [<span data-ttu-id="64f80-109">Alinhar as alocações corretamente</span><span class="sxs-lookup"><span data-stu-id="64f80-109">Properly Align Allocations</span></span>](#properly-align-allocations)
-   [<span data-ttu-id="64f80-110">Evite sobrecargas de operador quando possível</span><span class="sxs-lookup"><span data-stu-id="64f80-110">Avoid Operator Overloads When Possible</span></span>](#avoid-operator-overloads-when-possible)
-   [<span data-ttu-id="64f80-111">Desnormalizado</span><span class="sxs-lookup"><span data-stu-id="64f80-111">Denormals</span></span>](#denormals)
-   [<span data-ttu-id="64f80-112">Aproveite a dupla de ponto flutuante de inteiro</span><span class="sxs-lookup"><span data-stu-id="64f80-112">Take Advantage of the Integer Floating Point Duality</span></span>](#take-advantage-of-the-integer-floating-point-duality)
-   [<span data-ttu-id="64f80-113">Preferir formulários de modelo</span><span class="sxs-lookup"><span data-stu-id="64f80-113">Prefer Template Forms</span></span>](#prefer-template-forms)
-   [<span data-ttu-id="64f80-114">Usando o DirectXMath com o Direct3D</span><span class="sxs-lookup"><span data-stu-id="64f80-114">Using DirectXMath with Direct3D</span></span>](#using-directxmath-with-direct3d)
-   [<span data-ttu-id="64f80-115">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="64f80-115">Related topics</span></span>](#related-topics)

## <a name="use-accessors-sparingly"></a><span data-ttu-id="64f80-116">Usar acessadores com moderação</span><span class="sxs-lookup"><span data-stu-id="64f80-116">Use accessors sparingly</span></span>

<span data-ttu-id="64f80-117">As operações baseadas em vetor usam os conjuntos de instruções SIMD e usam registros especiais.</span><span class="sxs-lookup"><span data-stu-id="64f80-117">Vector-based operations use the SIMD instruction sets and these make use of special registers.</span></span> <span data-ttu-id="64f80-118">O acesso a componentes individuais exige a mudança dos registros de SIMD para os Scalar e vice-versa.</span><span class="sxs-lookup"><span data-stu-id="64f80-118">Accessing individual components requires moving from the SIMD registers to the scalar ones and back again.</span></span>

<span data-ttu-id="64f80-119">Quando possível, é mais eficiente inicializar todos os componentes de um [**XMVECTOR**](xmvector-data-type.md) ao mesmo tempo, em vez de usar uma série de acessadores de vetores individuais.</span><span class="sxs-lookup"><span data-stu-id="64f80-119">When possible, it is more efficient to initialize all of the components of an [**XMVECTOR**](xmvector-data-type.md) at one time, instead of using a series of individual vector accessors.</span></span>

## <a name="use-correct-compilation-settings"></a><span data-ttu-id="64f80-120">Usar as configurações de compilação corretas</span><span class="sxs-lookup"><span data-stu-id="64f80-120">Use correct compilation settings</span></span>

<span data-ttu-id="64f80-121">Para destinos do Windows x86, habilite/Arch: SSE2.</span><span class="sxs-lookup"><span data-stu-id="64f80-121">For Windows x86 targets, enable /arch:SSE2.</span></span> <span data-ttu-id="64f80-122">Para todos os destinos do Windows, habilite/fp: Fast.</span><span class="sxs-lookup"><span data-stu-id="64f80-122">For all Windows targets, enable /fp:fast.</span></span>

<span data-ttu-id="64f80-123">Por padrão, a compilação na biblioteca DirectXMath para destinos do Windows x86 é feita com \_ XM \_ SSE \_ intrínsecos \_ definidos.</span><span class="sxs-lookup"><span data-stu-id="64f80-123">By default, compilation against the DirectXMath Library for Window x86 targets is done with \_XM\_SSE\_INTRINSICS\_ defined.</span></span> <span data-ttu-id="64f80-124">Isso significa que toda a funcionalidade do DirectXMath fará uso de instruções SSE2.</span><span class="sxs-lookup"><span data-stu-id="64f80-124">This means that all DirectXMath functionality will make use of SSE2 instructions.</span></span> <span data-ttu-id="64f80-125">No entanto, o mesmo não é verdadeiro para outro código.</span><span class="sxs-lookup"><span data-stu-id="64f80-125">However, the same is not true for other code.</span></span>

<span data-ttu-id="64f80-126">O código fora do DirectXMath é tratado usando padrões do compilador.</span><span class="sxs-lookup"><span data-stu-id="64f80-126">Code outside of DirectXMath is handled using compiler defaults.</span></span> <span data-ttu-id="64f80-127">Sem essa opção, o código gerado geralmente pode usar o código x87 menos eficiente.</span><span class="sxs-lookup"><span data-stu-id="64f80-127">Without this switch, the generated code may often use the less efficient x87 code.</span></span>

<span data-ttu-id="64f80-128">É altamente recomendável que você sempre use a versão mais recente disponível do compilador.</span><span class="sxs-lookup"><span data-stu-id="64f80-128">We highly recommend that you always use the latest available version of the compiler.</span></span>

## <a name="use-est-functions-when-appropriate"></a><span data-ttu-id="64f80-129">Use as funções de est quando apropriado</span><span class="sxs-lookup"><span data-stu-id="64f80-129">Use Est functions when appropriate</span></span>

<span data-ttu-id="64f80-130">Muitas funções têm uma função de estimativa equivalente que termina em est.</span><span class="sxs-lookup"><span data-stu-id="64f80-130">Many functions have an equivalent estimation function ending in Est.</span></span> <span data-ttu-id="64f80-131">Essas funções comercializam alguma precisão para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="64f80-131">These functions trade some accuracy for improved performance.</span></span> <span data-ttu-id="64f80-132">As funções de est são apropriadas para cálculos não críticos, onde a precisão pode ser sacrificada por velocidade.</span><span class="sxs-lookup"><span data-stu-id="64f80-132">Est functions are appropriate for non-critical calculations where accuracy can be sacrificed for speed.</span></span> <span data-ttu-id="64f80-133">A quantidade exata de precisão e aumento de velocidade perdido são dependentes da plataforma.</span><span class="sxs-lookup"><span data-stu-id="64f80-133">The exact amount of lost accuracy and speed increase are platform dependent.</span></span>

<span data-ttu-id="64f80-134">Por exemplo, a função [**XMVector3AngleBetweenNormalsEst**](/windows/win32/api/directxmath/nf-directxmath-xmvector3anglebetweennormalsest) pode ser usada no lugar da função [**XMVector3AngleBetweenNormals**](/windows/win32/api/directxmath/nf-directxmath-xmvector3anglebetweennormals) .</span><span class="sxs-lookup"><span data-stu-id="64f80-134">For example, the [**XMVector3AngleBetweenNormalsEst**](/windows/win32/api/directxmath/nf-directxmath-xmvector3anglebetweennormalsest) function could be used in place of the [**XMVector3AngleBetweenNormals**](/windows/win32/api/directxmath/nf-directxmath-xmvector3anglebetweennormals) function.</span></span>

## <a name="use-aligned-data-types-and-operations"></a><span data-ttu-id="64f80-135">Usar operações e tipos de dados alinhados</span><span class="sxs-lookup"><span data-stu-id="64f80-135">Use Aligned Data Types and Operations</span></span>

<span data-ttu-id="64f80-136">Os conjuntos de instruções SIMD em versões do Windows com suporte a SSE2 normalmente têm versões alinhadas e desalinhadas das operações de memória.</span><span class="sxs-lookup"><span data-stu-id="64f80-136">The SIMD instruction sets on versions of windows supporting SSE2 typically have aligned and unaligned versions of memory operations.</span></span> <span data-ttu-id="64f80-137">O uso das operações alinhadas é mais rápido e deve ser preferível sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="64f80-137">The use of the aligned operations is faster, and should be preferred wherever possible.</span></span>

<span data-ttu-id="64f80-138">A biblioteca DirectXMath fornece funcionalidade alinhada e não alinhada por meio de tipos de vetor variantes, estrutura e funções.</span><span class="sxs-lookup"><span data-stu-id="64f80-138">The DirectXMath Library provides access aligned and unaligned functionality through variant vector types, structure, and functions.</span></span> <span data-ttu-id="64f80-139">Essas variantes são indicadas por um "A" no final do nome.</span><span class="sxs-lookup"><span data-stu-id="64f80-139">These variants are indicated by an "A" at the end of the name.</span></span>

<span data-ttu-id="64f80-140">Por exemplo, há uma estrutura [**XMFLOAT4X4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4x4) não alinhada e uma estrutura [**XMFLOAT4X4A**](/previous-versions/windows/desktop/legacy/ee419623(v=vs.85)) alinhada, que são usadas pelas funções [**XMStoreFloat4**](/windows/win32/api/directxmath/nf-directxmath-xmstorefloat4) e [**XMStoreFloat4A**](/windows/win32/api/directxmath/nf-directxmath-xmstorefloat4a) , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="64f80-140">For example, there are an unaligned [**XMFLOAT4X4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4x4) structure and an aligned [**XMFLOAT4X4A**](/previous-versions/windows/desktop/legacy/ee419623(v=vs.85)) structure, which are used by the [**XMStoreFloat4**](/windows/win32/api/directxmath/nf-directxmath-xmstorefloat4) and [**XMStoreFloat4A**](/windows/win32/api/directxmath/nf-directxmath-xmstorefloat4a) functions respectively.</span></span>

## <a name="properly-align-allocations"></a><span data-ttu-id="64f80-141">Alinhar as alocações corretamente</span><span class="sxs-lookup"><span data-stu-id="64f80-141">Properly Align Allocations</span></span>

<span data-ttu-id="64f80-142">As versões alinhadas dos intrínsecores [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100)) subjacentes à biblioteca DirectXMath são mais rápidas do que as não alinhadas.</span><span class="sxs-lookup"><span data-stu-id="64f80-142">The aligned versions of the [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100)) intrinsics underlying the DirectXMath Library are faster than the unaligned.</span></span>

<span data-ttu-id="64f80-143">Por esse motivo, as operações de DirectXMath usando objetos [**XMVECTOR**](xmvector-data-type.md) e [**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) assumem que esses objetos são alinhados em 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="64f80-143">For this reason, DirectXMath operations using [**XMVECTOR**](xmvector-data-type.md) and [**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) objects assume those objects are 16-byte aligned.</span></span> <span data-ttu-id="64f80-144">Isso é automático para alocações baseadas em pilha, se o código for compilado na biblioteca DirectXMath usando as configurações de compilador recomendadas do Windows (consulte [usar configurações de compilação corretas](#use-correct-compilation-settings)).</span><span class="sxs-lookup"><span data-stu-id="64f80-144">This is automatic for stack based allocations, if code is compiled against the DirectXMath Library using the recommended Windows (see [Use Correct Compilation Settings](#use-correct-compilation-settings)) compiler settings.</span></span> <span data-ttu-id="64f80-145">No entanto, é importante garantir que a alocação de heap contendo objetos **XMVECTOR** e **XMMATRIX** , ou conversões para esses tipos, atenda a esses requisitos de alinhamento.</span><span class="sxs-lookup"><span data-stu-id="64f80-145">However, it is important to ensure that heap-allocation containing **XMVECTOR** and **XMMATRIX** objects, or casts to these types, meet these alignment requirements.</span></span>

<span data-ttu-id="64f80-146">Enquanto as alocações de memória do Windows de 64 bits são alinhadas em 16 bytes, por padrão, em versões de 32 bits da memória do Windows alocada, há apenas 8 bytes alinhados.</span><span class="sxs-lookup"><span data-stu-id="64f80-146">While 64-bit Windows memory allocations are 16-byte aligned, by default on 32 bit versions of Windows memory allocated is only 8-byte aligned.</span></span> <span data-ttu-id="64f80-147">Para obter informações sobre como controlar o alinhamento de memória, confira [ \_ \_ malloc alinhado](https://msdn.microsoft.com/library/8z34s9c6(VS.80).aspx).</span><span class="sxs-lookup"><span data-stu-id="64f80-147">For information on controlling memory alignment, see [\_aligned\_malloc](https://msdn.microsoft.com/library/8z34s9c6(VS.80).aspx).</span></span>

<span data-ttu-id="64f80-148">Ao usar tipos DirectXMath alinhados com a STL (Standard Template Library), você precisará fornecer um alocador personalizado que garanta o alinhamento de 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="64f80-148">When using aligned DirectXMath types with the Standard Template Library (STL), you will need to provide a custom allocator that ensures the 16-byte alignment.</span></span> <span data-ttu-id="64f80-149">Consulte o [blog](https://devblogs.microsoft.com/cppblog/the-mallocator/) da equipe Visual C++ para obter um exemplo de como escrever um alocador personalizado (em vez de malloc/Free, você desejará usar \_ \_ o malloc alinhado e \_ alinhado \_ gratuitamente em sua implementação).</span><span class="sxs-lookup"><span data-stu-id="64f80-149">See the Visual C++ Team [blog](https://devblogs.microsoft.com/cppblog/the-mallocator/) for an example of writing a custom allocator (instead of malloc/free you'll want to use \_aligned\_malloc and \_aligned\_free in your implementation).</span></span>

> [!Note]  
> <span data-ttu-id="64f80-150">Alguns modelos STL modificam o alinhamento do tipo fornecido.</span><span class="sxs-lookup"><span data-stu-id="64f80-150">Some STL templates modify the provided type's alignment.</span></span> <span data-ttu-id="64f80-151">Por exemplo, [Make \_ Shared<>](/cpp/standard-library/memory-functions?view=vs-2017&preserve-view=true) adiciona algumas informações de acompanhamento internas que podem ou não respeitar o alinhamento do tipo de usuário fornecido, resultando em membros de dados não alinhados.</span><span class="sxs-lookup"><span data-stu-id="64f80-151">For example, [make\_shared<>](/cpp/standard-library/memory-functions?view=vs-2017&preserve-view=true) adds some internal tracking information which may or may not respect the alignment of the provided user type, resulting in unaligned data members.</span></span> <span data-ttu-id="64f80-152">Nesse caso, você precisa usar tipos não alinhados em vez de tipos alinhados.</span><span class="sxs-lookup"><span data-stu-id="64f80-152">In this case, you need to use unaligned types instead of aligned types.</span></span> <span data-ttu-id="64f80-153">Se você derivar de classes existentes, incluindo muitos objetos Windows Runtime, também poderá modificar o alinhamento de uma classe ou estrutura.</span><span class="sxs-lookup"><span data-stu-id="64f80-153">If you derive from existing classes, including many Windows Runtime objects, you can also modify the alignment of a class or structure.</span></span>

 

## <a name="avoid-operator-overloads-when-possible"></a><span data-ttu-id="64f80-154">Evite sobrecargas de operador quando possível</span><span class="sxs-lookup"><span data-stu-id="64f80-154">Avoid Operator Overloads When Possible</span></span>

<span data-ttu-id="64f80-155">Como um recurso de conveniência, vários tipos, como [**XMVECTOR**](xmvector-data-type.md) e [**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) , têm sobrecargas de operador para operações aritméticas comuns.</span><span class="sxs-lookup"><span data-stu-id="64f80-155">As a convenience feature, a number of types such as [**XMVECTOR**](xmvector-data-type.md) and [**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) have operator overloads for common arithmetic operations.</span></span> <span data-ttu-id="64f80-156">Essas sobrecargas de operador tendem a criar vários objetos temporários.</span><span class="sxs-lookup"><span data-stu-id="64f80-156">Such operator overloads tend to create numerous temporary objects.</span></span> <span data-ttu-id="64f80-157">Recomendamos que você evite essas sobrecargas de operador no código sensível ao desempenho.</span><span class="sxs-lookup"><span data-stu-id="64f80-157">We recommend that you avoid these operator overloads in performance sensitive code.</span></span>

## <a name="denormals"></a><span data-ttu-id="64f80-158">Desnormalizado</span><span class="sxs-lookup"><span data-stu-id="64f80-158">Denormals</span></span>

<span data-ttu-id="64f80-159">Para dar suporte a cálculos próximos de 0, o padrão de ponto flutuante do IEEE 754 inclui suporte para estouro negativo.</span><span class="sxs-lookup"><span data-stu-id="64f80-159">To support computations close to 0, the IEEE 754 float-point standard includes support for gradual underflow.</span></span> <span data-ttu-id="64f80-160">O estouro negativo é implementado por meio do uso de valores desnormalizados e muitas implementações de hardware são lentas durante o tratamento de desnormals.</span><span class="sxs-lookup"><span data-stu-id="64f80-160">Gradual underflow is implemented through the use of denormalized values, and many hardware implementations are slow when handling denormals.</span></span> <span data-ttu-id="64f80-161">Uma otimização a ser considerada é desabilitar a manipulação de desnormalidades para as operações de vetor usadas pelo DirectXMath.</span><span class="sxs-lookup"><span data-stu-id="64f80-161">An optimization to consider is to disable the handling of denormals for the vector operations used by DirectXMath.</span></span>

<span data-ttu-id="64f80-162">A alteração da manipulação de desnormalidades é feita usando a rotina [ \_ controlfp \_ s](/cpp/c-runtime-library/reference/controlfp-s) em uma base pré-thread e pode resultar em melhorias de desempenho.</span><span class="sxs-lookup"><span data-stu-id="64f80-162">Changing the handling of denormals is done by using the [\_controlfp\_s](/cpp/c-runtime-library/reference/controlfp-s) routine on a pre-thread basis, and can result in performance improvements.</span></span> <span data-ttu-id="64f80-163">Use este código para alterar a manipulação de desnormals:</span><span class="sxs-lookup"><span data-stu-id="64f80-163">Use this code to change the handling of denormals:</span></span>


```
  #include <float.h>;
    unsigned int control_word;
    _controlfp_s( &control_word, _DN_FLUSH, _MCW_DN );
```



> [!Note]  
> <span data-ttu-id="64f80-164">Nas versões de 64 bits do Windows, as instruções [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100)) são usadas para todos os cálculos, não apenas para as operações de vetor.</span><span class="sxs-lookup"><span data-stu-id="64f80-164">On 64-bit versions of Windows, [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100)) instructions are used for all computations, not just the vector operations.</span></span> <span data-ttu-id="64f80-165">Alterar a manipulação desnormal afeta todos os cálculos de ponto flutuante em seu programa, não apenas as operações de vetor usadas pelo DirectXMath.</span><span class="sxs-lookup"><span data-stu-id="64f80-165">Changing the denormal handling affects all floating-point computations in your program, not just the vector operations used by DirectXMath.</span></span>

 

## <a name="take-advantage-of-the-integer-floating-point-duality"></a><span data-ttu-id="64f80-166">Aproveite a dupla de ponto flutuante de inteiro</span><span class="sxs-lookup"><span data-stu-id="64f80-166">Take Advantage of the Integer Floating Point Duality</span></span>

<span data-ttu-id="64f80-167">O DirectXMath dá suporte a vetores de 4 valores de ponto flutuante de precisão simples ou de 4 32 bits (assinados ou não assinados).</span><span class="sxs-lookup"><span data-stu-id="64f80-167">DirectXMath supports vectors of 4 single-precision floating-point or four 32-bit (signed or unsigned) values.</span></span>

<span data-ttu-id="64f80-168">Como os conjuntos de instruções usados para implementar a biblioteca DirectXMath têm a capacidade de tratar os mesmos dados de vários tipos diferentes, por exemplo, tratar o mesmo vetor como ponto flutuante e dados inteiros – determinadas otimizações podem ser obtidas.</span><span class="sxs-lookup"><span data-stu-id="64f80-168">Because the instruction sets used to implement the DirectXMath Library have the ability to treat the same data as multiple different types-for example, treat the same vector as floating-point and integer data-certain optimizations can be achieved.</span></span> <span data-ttu-id="64f80-169">Você pode obter essas otimizações usando as rotinas de inicialização de vetores inteiros e os operadores de bits para manipular valores de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="64f80-169">You can get these optimizations by using the integer vector initialization routines and bit-wise operators to manipulate floating-point values.</span></span>

<span data-ttu-id="64f80-170">O formato binário dos números de ponto flutuante de precisão simples usados pela biblioteca DirectXMath está totalmente em conformidade com o padrão IEEE 764:</span><span class="sxs-lookup"><span data-stu-id="64f80-170">The binary format of single-precision floating-point numbers used by the DirectXMath Library completely conforms to the IEEE 764 standard:</span></span>

``` syntax
     SIGN    EXPONENT   MANTISSA
     X       XXXXXXXX   XXXXXXXXXXXXXXXXXXXXXXX
     1 bit   8 bits     23 bits
```

<span data-ttu-id="64f80-171">Ao trabalhar com o número de ponto flutuante de precisão única do IEEE 764, é importante ter em mente que algumas representações têm um significado especial (ou seja, elas não estão em conformidade com a descrição anterior).</span><span class="sxs-lookup"><span data-stu-id="64f80-171">When working with the IEEE 764 single precision floating-point number, it is important to keep in mind, that some representations have special meaning (that is, they do not conform to the preceding description).</span></span> <span data-ttu-id="64f80-172">Os exemplos incluem:</span><span class="sxs-lookup"><span data-stu-id="64f80-172">Examples include:</span></span>

-   <span data-ttu-id="64f80-173">Zero positivo é 0</span><span class="sxs-lookup"><span data-stu-id="64f80-173">Positive zero is 0</span></span>
-   <span data-ttu-id="64f80-174">Zero negativo é 0x80000000</span><span class="sxs-lookup"><span data-stu-id="64f80-174">Negative zero is 0x80000000</span></span>
-   <span data-ttu-id="64f80-175">P \_ Nan é 07FC0000</span><span class="sxs-lookup"><span data-stu-id="64f80-175">Q\_NAN is 07FC0000</span></span>
-   <span data-ttu-id="64f80-176">+ INF é 0x7F800000</span><span class="sxs-lookup"><span data-stu-id="64f80-176">+INF is 0x7F800000</span></span>
-   <span data-ttu-id="64f80-177">-INF é 0xFF800000</span><span class="sxs-lookup"><span data-stu-id="64f80-177">-INF is 0xFF800000</span></span>

## <a name="prefer-template-forms"></a><span data-ttu-id="64f80-178">Preferir formulários de modelo</span><span class="sxs-lookup"><span data-stu-id="64f80-178">Prefer Template Forms</span></span>

<span data-ttu-id="64f80-179">O formulário de modelo existe para [**XMVectorSwizzle**](/windows/win32/api/directxmath/nf-directxmath-xmvectorswizzle), [**XMVectorPermute**](/windows/win32/api/directxmath/nf-directxmath-xmvectorpermute), [**XMVectorInsert**](/windows/win32/api/directxmath/nf-directxmath-xmvectorinsert), [**XMVectorShiftLeft**](/windows/win32/api/directxmath/nf-directxmath-xmvectorshiftleft), [**XMVectorRotateLeft**](/windows/win32/api/directxmath/nf-directxmath-xmvectorrotateleft)e [**XMVectorRotateRight**](/windows/win32/api/directxmath/nf-directxmath-xmvectorrotateright).</span><span class="sxs-lookup"><span data-stu-id="64f80-179">Template form exists for [**XMVectorSwizzle**](/windows/win32/api/directxmath/nf-directxmath-xmvectorswizzle), [**XMVectorPermute**](/windows/win32/api/directxmath/nf-directxmath-xmvectorpermute), [**XMVectorInsert**](/windows/win32/api/directxmath/nf-directxmath-xmvectorinsert), [**XMVectorShiftLeft**](/windows/win32/api/directxmath/nf-directxmath-xmvectorshiftleft), [**XMVectorRotateLeft**](/windows/win32/api/directxmath/nf-directxmath-xmvectorrotateleft), and [**XMVectorRotateRight**](/windows/win32/api/directxmath/nf-directxmath-xmvectorrotateright).</span></span> <span data-ttu-id="64f80-180">Usá-los em vez do formulário de função geral permite que o compilador crie implementações muito mais efficents.</span><span class="sxs-lookup"><span data-stu-id="64f80-180">Using these instead of the general function form allows the compiler to create much more efficent implementations.</span></span> <span data-ttu-id="64f80-181">Para a [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100)), isso geralmente se recolhe a um ou dois \_ valores de PS em \_ ordem aleatória de mm \_ .</span><span class="sxs-lookup"><span data-stu-id="64f80-181">For [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100)), this often collapses down to one or two \_mm\_shuffle\_ps values.</span></span> <span data-ttu-id="64f80-182">Para o ARM-NEON, o modelo **XMVectorSwizzle** pode utilizar vários casos especiais em vez do VTBL mais geral swizzle/permudo.</span><span class="sxs-lookup"><span data-stu-id="64f80-182">For ARM-NEON, the **XMVectorSwizzle** template can utilize a number of special cases rather than the more general VTBL swizzle/permute.</span></span>

## <a name="using-directxmath-with-direct3d"></a><span data-ttu-id="64f80-183">Usando o DirectXMath com o Direct3D</span><span class="sxs-lookup"><span data-stu-id="64f80-183">Using DirectXMath with Direct3D</span></span>

<span data-ttu-id="64f80-184">Um uso comum do DirectXMath é executar cálculos de gráficos para uso com o Direct3D.</span><span class="sxs-lookup"><span data-stu-id="64f80-184">A common use for DirectXMath is to perform graphics computations for use with Direct3D.</span></span> <span data-ttu-id="64f80-185">Com o Direct3D 10. x e o Direct3D 11. x, você pode usar a biblioteca DirectXMath dessas maneiras diretas:</span><span class="sxs-lookup"><span data-stu-id="64f80-185">With Direct3D 10.x and Direct3D 11.x, you can use the DirectXMath library in these direct ways:</span></span>

-   <span data-ttu-id="64f80-186">Use as [constantes](ovw-xnamath-reference-constants.md) de namespace Colors diretamente no parâmetro *ColorRGBA* em uma chamada para o método [**ID3D11DeviceContext:: ClearRenderTargetView**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-clearrendertargetview) ou [**ID3D10Device:: ClearRenderTargetView**](/windows/win32/api/d3d10/nf-d3d10-id3d10device-clearrendertargetview) .</span><span class="sxs-lookup"><span data-stu-id="64f80-186">Use the Colors namespace [constants](ovw-xnamath-reference-constants.md) directly in the *ColorRGBA* parameter in a call to the [**ID3D11DeviceContext::ClearRenderTargetView**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-clearrendertargetview) or [**ID3D10Device::ClearRenderTargetView**](/windows/win32/api/d3d10/nf-d3d10-id3d10device-clearrendertargetview) method.</span></span> <span data-ttu-id="64f80-187">Para o Direct3D 9, você deve converter para o tipo [**XMCOLOR**](/windows/desktop/api/DirectXPackedVector/ns-directxpackedvector-xmcolor) para usá-lo como o parâmetro de *cor* em uma chamada para o método [**IDirect3DDevice9:: Clear**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-clear) .</span><span class="sxs-lookup"><span data-stu-id="64f80-187">For Direct3D 9, you must convert to the [**XMCOLOR**](/windows/desktop/api/DirectXPackedVector/ns-directxpackedvector-xmcolor) type to use it as the *Color* parameter in a call to the [**IDirect3DDevice9::Clear**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-clear) method.</span></span>
-   <span data-ttu-id="64f80-188">Use os tipos [**XMFLOAT4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4) / [**XMVECTOR**](xmvector-data-type.md) e [**XMFLOAT4X4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4x4) / [**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) para configurar estruturas de buffer de constantes para referência por HLSL [**FLOAT4**](../direct3dhlsl/dx-graphics-hlsl-scalar.md) ou tipos de [**matriz**](../direct3dhlsl/dx-graphics-hlsl-matrix.md)/float4x4.</span><span class="sxs-lookup"><span data-stu-id="64f80-188">Use the [**XMFLOAT4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4)/[**XMVECTOR**](xmvector-data-type.md) and [**XMFLOAT4X4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4x4)/[**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) types to setup constant buffer structures for reference by HLSL [**float4**](../direct3dhlsl/dx-graphics-hlsl-scalar.md) or [**matrix**](../direct3dhlsl/dx-graphics-hlsl-matrix.md)/float4x4 types.</span></span>
    > [!Note]  
    > <span data-ttu-id="64f80-189">[**XMFLOAT4X4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4x4) / Os tipos [**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) estão no formato de linha-principal.</span><span class="sxs-lookup"><span data-stu-id="64f80-189">[**XMFLOAT4X4**](/windows/win32/api/directxmath/ns-directxmath-xmfloat4x4)/[**XMMATRIX**](/windows/win32/api/directxmath/ns-directxmath-xmmatrix) types are in row-major format.</span></span> <span data-ttu-id="64f80-190">Portanto, se você usar a opção de compilador/ZPR (o sinalizador de compilação [**principal da coluna de matriz do D3DCOMPILE \_ Pack \_ \_ \_**](../direct3dhlsl/d3dcompile-constants.md) ) ou omitir a \_ [palavra-chave](../direct3dhlsl/dx-graphics-hlsl-appendix-keywords.md) principal de linha ao declarar o tipo de matriz em HLSL, deverá transpor a matriz quando defini-la no buffer de constantes.</span><span class="sxs-lookup"><span data-stu-id="64f80-190">Therefore, if you use the /Zpr compiler switch (the [**D3DCOMPILE\_PACK\_MATRIX\_COLUMN\_MAJOR**](../direct3dhlsl/d3dcompile-constants.md) compile flag) or omit the row\_major [keyword](../direct3dhlsl/dx-graphics-hlsl-appendix-keywords.md) when you declare the matrix type in HLSL, you must transpose the matrix when you set it into the constant buffer.</span></span>

     

-   <span data-ttu-id="64f80-191">Com o Direct3D 10. x e o Direct3D 11. x, você pode pressupor que o ponteiro retornado pelo método MAP (por exemplo, [**ID3D11DeviceContext:: map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map)) no membro **pData** ([**d3d10 \_ mapeado \_ TEXTURE2D**](/windows/win32/api/d3d10/ns-d3d10-d3d10_mapped_texture2d).**pData**, [**d3d10 \_ mapeoud \_ TEXTURE3D**](/windows/win32/api/d3d10/ns-d3d10-d3d10_mapped_texture3d).\*\*\*\* Subrecurso pData [**ou \_ D3D11 \_ mapeado**](/windows/win32/api/d3d11/ns-d3d11-d3d11_mapped_subresource).**pData**) será alinhado em 16 bytes se você usar o [nível de recurso](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md) 10 \_ 0 ou superior ou sempre que usar os recursos de [**\_ \_ preparo de uso do D3D11**](/windows/win32/api/d3d11/ne-d3d11-d3d11_usage) .</span><span class="sxs-lookup"><span data-stu-id="64f80-191">With Direct3D 10.x and Direct3D 11.x, you can assume that the pointer returned by the Map method (for example, [**ID3D11DeviceContext::Map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map)) in the **pData** member ([**D3D10\_MAPPED\_TEXTURE2D**](/windows/win32/api/d3d10/ns-d3d10-d3d10_mapped_texture2d).**pData**, [**D3D10\_MAPPED\_TEXTURE3D**](/windows/win32/api/d3d10/ns-d3d10-d3d10_mapped_texture3d).**pData**, or [**D3D11\_MAPPED\_SUBRESOURCE**](/windows/win32/api/d3d11/ns-d3d11-d3d11_mapped_subresource).**pData**) is 16-byte aligned if you use [feature level](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md) 10\_0 or higher or whenever you use [**D3D11\_USAGE\_STAGING**](/windows/win32/api/d3d11/ne-d3d11-d3d11_usage) resources.</span></span>

## <a name="related-topics"></a><span data-ttu-id="64f80-192">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="64f80-192">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="64f80-193">Guia de programação do DirectXMath</span><span class="sxs-lookup"><span data-stu-id="64f80-193">DirectXMath Programming Guide</span></span>](ovw-xnamath-progguide.md)
</dt> </dl>

 

 
