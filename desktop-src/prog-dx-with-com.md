---
description: Programando DirectX com com.
title: Programando DirectX com com
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 67fc7a35f42439e1a9eeef1b2895d88dc0dbf5d4
ms.sourcegitcommit: f712e5fed19d6afe2762a77ffcdf8b5977f85901
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/26/2021
ms.locfileid: "103923018"
---
# <a name="programming-directx-with-com"></a><span data-ttu-id="763a9-103">Programando DirectX com com</span><span class="sxs-lookup"><span data-stu-id="763a9-103">Programming DirectX with COM</span></span>

<span data-ttu-id="763a9-104">O Microsoft Component Object Model (COM) é um modelo de programação orientado a objeto usado por várias tecnologias, incluindo a grande parte da superfície da API do DirectX.</span><span class="sxs-lookup"><span data-stu-id="763a9-104">The Microsoft Component Object Model (COM) is an object-oriented programming model used by several technologies, including the bulk of the DirectX API surface.</span></span> <span data-ttu-id="763a9-105">Por esse motivo, você (como um desenvolvedor do DirectX) usa inevitavelmente o COM ao programar o DirectX.</span><span class="sxs-lookup"><span data-stu-id="763a9-105">For that reason, you (as a DirectX developer) inevitably use COM when you program DirectX.</span></span>

> [!NOTE]
> <span data-ttu-id="763a9-106">O tópico [consumir componentes com com C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) mostra como consumir APIs do DirectX (e qualquer API com, para esse assunto) usando [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span><span class="sxs-lookup"><span data-stu-id="763a9-106">The topic [Consume COM components with C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) shows how to consume DirectX APIs (and any COM API, for that matter) by using [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span></span> <span data-ttu-id="763a9-107">Isso é, de longe, a tecnologia mais conveniente e recomendada para uso.</span><span class="sxs-lookup"><span data-stu-id="763a9-107">That's by far the most convenient and recommended technology to use.</span></span>

<span data-ttu-id="763a9-108">Como alternativa, você pode usar COM bruto, e é para isso que este tópico se trata.</span><span class="sxs-lookup"><span data-stu-id="763a9-108">Alternatively, you can use raw COM, and that's what this topic is about.</span></span> <span data-ttu-id="763a9-109">Você precisará de uma compreensão básica dos princípios e das técnicas de programação envolvidas no consumo de APIs COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-109">You'll need a basic understanding of the principles and programming techniques involved in consuming COM APIs.</span></span> <span data-ttu-id="763a9-110">Embora o COM tenha uma reputação de ser difícil e complexo, a programação COM exigida pela maioria dos aplicativos DirectX é simples.</span><span class="sxs-lookup"><span data-stu-id="763a9-110">Although COM has a reputation for being difficult and complex, the COM programming required by most DirectX applications is straightforward.</span></span> <span data-ttu-id="763a9-111">Em parte, isso ocorre porque você consumirá os objetos COM fornecidos pelo DirectX.</span><span class="sxs-lookup"><span data-stu-id="763a9-111">In part, this is because you'll be consuming the COM objects provided by DirectX.</span></span> <span data-ttu-id="763a9-112">Não há necessidade de você criar seus próprios objetos COM, que é normalmente o local em que a complexidade surge.</span><span class="sxs-lookup"><span data-stu-id="763a9-112">There's no need for you to author your own COM objects, which is typically where the complexity arises.</span></span>

## <a name="com-component-overview"></a><span data-ttu-id="763a9-113">Visão geral do componente COM</span><span class="sxs-lookup"><span data-stu-id="763a9-113">COM component overview</span></span>

<span data-ttu-id="763a9-114">Um objeto COM é essencialmente um componente encapsulado de funcionalidade que pode ser usado por aplicativos para executar uma ou mais tarefas.</span><span class="sxs-lookup"><span data-stu-id="763a9-114">A COM object is essentially an encapsulated component of functionality that can be used by applications to perform one or more tasks.</span></span> <span data-ttu-id="763a9-115">Para a implantação, um ou mais componentes COM são empacotados em um binário chamado servidor COM; com mais frequência do que não uma DLL.</span><span class="sxs-lookup"><span data-stu-id="763a9-115">For deployment, one or more COM components are packaged into a binary called a COM server; more often than not a DLL.</span></span>

<span data-ttu-id="763a9-116">Uma DLL tradicional exporta funções gratuitas.</span><span class="sxs-lookup"><span data-stu-id="763a9-116">A traditional DLL exports free functions.</span></span> <span data-ttu-id="763a9-117">Um servidor COM pode fazer o mesmo.</span><span class="sxs-lookup"><span data-stu-id="763a9-117">A COM server can do the same.</span></span> <span data-ttu-id="763a9-118">Mas os componentes COM dentro do servidor COM expõem interfaces COM e métodos de membro que pertencem a essas interfaces.</span><span class="sxs-lookup"><span data-stu-id="763a9-118">But the COM components inside the COM server expose COM interfaces and member methods belonging to those interfaces.</span></span> <span data-ttu-id="763a9-119">Seu aplicativo cria instâncias de componentes COM, recupera interfaces deles e chama métodos nessas interfaces para se beneficiar dos recursos implementados nos componentes COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-119">Your application creates instances of COM components, retrieves interfaces from them, and calls methods on those interfaces in order to benefit from the features implemented in the COM components.</span></span>

<span data-ttu-id="763a9-120">Na prática, isso parece ser semelhante à chamada de métodos em um objeto C++ regular.</span><span class="sxs-lookup"><span data-stu-id="763a9-120">In practice, this feels similar to calling methods on a regular C++ object.</span></span> <span data-ttu-id="763a9-121">Mas há algumas diferenças.</span><span class="sxs-lookup"><span data-stu-id="763a9-121">But there are some differences.</span></span>

- <span data-ttu-id="763a9-122">Um objeto COM impõe um encapsulamento mais estrito do que um objeto C++.</span><span class="sxs-lookup"><span data-stu-id="763a9-122">A COM object enforces stricter encapsulation than a C++ object does.</span></span> <span data-ttu-id="763a9-123">Você não pode apenas criar o objeto e, em seguida, chamar qualquer método público.</span><span class="sxs-lookup"><span data-stu-id="763a9-123">You can't just create the object, and then call any public method.</span></span> <span data-ttu-id="763a9-124">Em vez disso, os métodos públicos de um componente COM são agrupados em uma ou mais interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-124">Instead, a COM component's public methods are grouped into one or more COM interfaces.</span></span> <span data-ttu-id="763a9-125">Para chamar um método, você cria o objeto e recupera do objeto a interface que implementa o método.</span><span class="sxs-lookup"><span data-stu-id="763a9-125">To call a method, you create the object and retrieve from the object the interface that implements the method.</span></span> <span data-ttu-id="763a9-126">Uma interface normalmente implementa um conjunto relacionado de métodos que fornecem acesso a um recurso específico do objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-126">An interface typically implements a related set of methods that provide access to a particular feature of the object.</span></span> <span data-ttu-id="763a9-127">Por exemplo, a interface [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) representa um adaptador gráfico virtual e contém métodos que permitem criar recursos, por exemplo, e muitas outras tarefas relacionadas ao adaptador.</span><span class="sxs-lookup"><span data-stu-id="763a9-127">For example, the [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) interface represents a virtual graphics adapter, and it contains methods that enable you create resources, for example, and many other adapter-related tasks.</span></span>
- <span data-ttu-id="763a9-128">Um objeto COM não é criado da mesma maneira que um objeto C++.</span><span class="sxs-lookup"><span data-stu-id="763a9-128">A COM object is not created in the same way as a C++ object.</span></span> <span data-ttu-id="763a9-129">Há várias maneiras de criar um objeto COM, mas todos envolvem técnicas específicas de COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-129">There are several ways to create a COM object, but all involve COM-specific techniques.</span></span> <span data-ttu-id="763a9-130">A API do DirectX inclui uma variedade de funções auxiliares e métodos que simplificam a criação da maioria dos objetos COM do DirectX.</span><span class="sxs-lookup"><span data-stu-id="763a9-130">The DirectX API includes a variety of helper functions and methods that simplify creating most of the DirectX COM objects.</span></span>
- <span data-ttu-id="763a9-131">Você deve usar técnicas específicas do COM para controlar o tempo de vida de um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-131">You must use COM-specific techniques to control the lifetime of a COM object.</span></span>
- <span data-ttu-id="763a9-132">O servidor COM (normalmente uma DLL) não precisa ser carregado explicitamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-132">The COM server (typically a DLL) doesn't need to be explicitly loaded.</span></span> <span data-ttu-id="763a9-133">Não é possível vincular a uma biblioteca estática para usar um componente COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-133">Nor do you link to a static library in order to use a COM component.</span></span> <span data-ttu-id="763a9-134">Cada componente COM tem um identificador exclusivo registrado (um identificador global exclusivo, ou GUID), que seu aplicativo usa para identificar o objeto COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-134">Each COM component has a unique registered identifier (a globally-unique identifier, or GUID), which your application uses to identify the COM object.</span></span> <span data-ttu-id="763a9-135">Seu aplicativo identifica o componente e o tempo de execução COM carrega automaticamente a DLL correta do servidor COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-135">Your application identifies the component, and the COM runtime automatically loads the correct COM server DLL.</span></span>
- <span data-ttu-id="763a9-136">COM é uma especificação binária.</span><span class="sxs-lookup"><span data-stu-id="763a9-136">COM is a binary specification.</span></span> <span data-ttu-id="763a9-137">Objetos COM podem ser gravados e acessados em uma variedade de idiomas.</span><span class="sxs-lookup"><span data-stu-id="763a9-137">COM objects can be written in and accessed from a variety of languages.</span></span> <span data-ttu-id="763a9-138">Você não precisa saber nada sobre o código-fonte do objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-138">You don't need to know anything about the object's source code.</span></span> <span data-ttu-id="763a9-139">Por exemplo, Visual Basic aplicativos usam rotineiramente objetos COM que foram escritos em C++.</span><span class="sxs-lookup"><span data-stu-id="763a9-139">For example, Visual Basic applications routinely use COM objects that were written in C++.</span></span>

## <a name="component-object-and-interface"></a><span data-ttu-id="763a9-140">Componente, objeto e interface</span><span class="sxs-lookup"><span data-stu-id="763a9-140">Component, object, and interface</span></span>

<span data-ttu-id="763a9-141">É importante entender a distinção entre componentes, objetos e interfaces.</span><span class="sxs-lookup"><span data-stu-id="763a9-141">It's important to understand the distinction between components, objects, and interfaces.</span></span> <span data-ttu-id="763a9-142">Em uso casual, você pode ouvir um componente ou objeto referido pelo nome de sua interface principal.</span><span class="sxs-lookup"><span data-stu-id="763a9-142">In casual usage, you may hear a component or object referred to by the name of its principal interface.</span></span> <span data-ttu-id="763a9-143">Mas os termos não são intercambiáveis.</span><span class="sxs-lookup"><span data-stu-id="763a9-143">But the terms are not interchangeable.</span></span> <span data-ttu-id="763a9-144">Um componente pode implementar qualquer número de interfaces; e um objeto é uma instância de um componente.</span><span class="sxs-lookup"><span data-stu-id="763a9-144">A component can implement any number of interfaces; and an object is an instance of a component.</span></span> <span data-ttu-id="763a9-145">Por exemplo, embora todos os componentes devam implementar a [**interface IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), normalmente implementam pelo menos uma interface adicional e podem implementar muitos.</span><span class="sxs-lookup"><span data-stu-id="763a9-145">For example, while all components must implement the [**IUnknown interface**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), they normally implement at least one additional interface, and they might implement many.</span></span>

<span data-ttu-id="763a9-146">Para usar um método de interface específico, você não deve apenas criar uma instância de um objeto. você também deve obter a interface correta a partir dele.</span><span class="sxs-lookup"><span data-stu-id="763a9-146">To use a particular interface method, you must not only instantiate an object, you must also obtain the correct interface from it.</span></span>

<span data-ttu-id="763a9-147">Além disso, mais de um componente pode implementar a mesma interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-147">In addition, more than one component might implement the same interface.</span></span> <span data-ttu-id="763a9-148">Uma interface é um grupo de métodos que executam um conjunto de operações logicamente relacionadas.</span><span class="sxs-lookup"><span data-stu-id="763a9-148">An interface is a group of methods that perform a logically-related set of operations.</span></span> <span data-ttu-id="763a9-149">A definição de interface especifica apenas a sintaxe dos métodos e sua funcionalidade geral.</span><span class="sxs-lookup"><span data-stu-id="763a9-149">The interface definition specifies only the syntax of the methods and their general functionality.</span></span> <span data-ttu-id="763a9-150">Qualquer componente COM que precise dar suporte a um determinado conjunto de operações pode fazer isso implementando uma interface adequada.</span><span class="sxs-lookup"><span data-stu-id="763a9-150">Any COM component that needs to support a particular set of operations can do so by implementing a suitable interface.</span></span> <span data-ttu-id="763a9-151">Algumas interfaces são altamente especializadas e são implementadas somente por um único componente; outras são úteis em várias circunstâncias e são implementadas por vários componentes.</span><span class="sxs-lookup"><span data-stu-id="763a9-151">Some interfaces are highly specialized, and are implemented only by a single component; others are useful in a variety of circumstances, and are implemented by many components.</span></span>

<span data-ttu-id="763a9-152">Se um componente implementa uma interface, ele deve dar suporte a todos os métodos na definição de interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-152">If a component implements an interface, it must support every method in the interface definition.</span></span> <span data-ttu-id="763a9-153">Em outras palavras, você deve ser capaz de chamar qualquer método e ter certeza de que ele existe.</span><span class="sxs-lookup"><span data-stu-id="763a9-153">In other words, you must be able to call any method and be confident that it exists.</span></span> <span data-ttu-id="763a9-154">No entanto, os detalhes de como um método específico é implementado podem variar de um componente para outro.</span><span class="sxs-lookup"><span data-stu-id="763a9-154">However, the details of how a particular method is implemented may vary from one component to another.</span></span> <span data-ttu-id="763a9-155">Por exemplo, componentes diferentes podem usar algoritmos diferentes para chegar ao resultado final.</span><span class="sxs-lookup"><span data-stu-id="763a9-155">For example, different components may use different algorithms to arrive at the final result.</span></span> <span data-ttu-id="763a9-156">Também não há nenhuma garantia de que um método terá suporte de forma não trivial.</span><span class="sxs-lookup"><span data-stu-id="763a9-156">There is also no guarantee that a method will be supported in a nontrivial way.</span></span> <span data-ttu-id="763a9-157">Às vezes, um componente implementa uma interface comumente usada, mas precisa dar suporte a apenas um subconjunto dos métodos.</span><span class="sxs-lookup"><span data-stu-id="763a9-157">Sometimes, a component implements a commonly-used interface, but it needs to support only a subset of the methods.</span></span> <span data-ttu-id="763a9-158">Você ainda poderá chamar os métodos restantes com êxito, mas retornará um [**HRESULT**](#hresult-values) (que é um tipo com padrão que representa um código de resultado) que contém o valor **E_NOTIMPL**.</span><span class="sxs-lookup"><span data-stu-id="763a9-158">You will still be able to call the remaining methods successfully, but they will return an [**HRESULT**](#hresult-values) (which is a standard COM type representing a result code) containing the value **E_NOTIMPL**.</span></span> <span data-ttu-id="763a9-159">Você deve consultar sua documentação para ver como uma interface é implementada por qualquer componente específico.</span><span class="sxs-lookup"><span data-stu-id="763a9-159">You should refer to its documentation to see how an interface is implemented by any particular component.</span></span>

<span data-ttu-id="763a9-160">O padrão COM requer que uma definição de interface não deva ser alterada depois de ser publicada.</span><span class="sxs-lookup"><span data-stu-id="763a9-160">The COM standard requires that an interface definition must not change once it has been published.</span></span> <span data-ttu-id="763a9-161">O autor não pode, por exemplo, adicionar um novo método a uma interface existente.</span><span class="sxs-lookup"><span data-stu-id="763a9-161">The author cannot, for example, add a new method to an existing interface.</span></span> <span data-ttu-id="763a9-162">O autor deve, em vez disso, criar uma nova interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-162">The author must instead create a new interface.</span></span> <span data-ttu-id="763a9-163">Embora não haja restrições quanto aos métodos que devem estar nessa interface, uma prática comum é fazer com que a interface de próxima geração inclua todos os métodos da interface antiga, além de quaisquer novos métodos.</span><span class="sxs-lookup"><span data-stu-id="763a9-163">While there are no restrictions on what methods must be in that interface, a common practice is to have the next-generation interface include all the of the old interface's methods, plus any new methods.</span></span>

<span data-ttu-id="763a9-164">Não é incomum que uma interface tenha várias gerações.</span><span class="sxs-lookup"><span data-stu-id="763a9-164">It's not unusual for an interface to have several generations.</span></span> <span data-ttu-id="763a9-165">Normalmente, todas as gerações executam essencialmente a mesma tarefa geral, mas elas são diferentes em termos específicos.</span><span class="sxs-lookup"><span data-stu-id="763a9-165">Typically, all generations perform essentially the same overall task, but they're different in specifics.</span></span> <span data-ttu-id="763a9-166">Geralmente, um componente COM implementa todas as gerações atuais e anteriores de uma linhagem de interface específica.</span><span class="sxs-lookup"><span data-stu-id="763a9-166">Often, a COM component implements every current and prior generation of a given interface's lineage.</span></span> <span data-ttu-id="763a9-167">Isso permite que os aplicativos mais antigos continuem usando as interfaces mais antigas do objeto, enquanto os aplicativos mais recentes podem aproveitar os recursos das interfaces mais recentes.</span><span class="sxs-lookup"><span data-stu-id="763a9-167">Doing so allows older applications to continue using the object's older interfaces, while newer applications can take advantage of the features of the newer interfaces.</span></span> <span data-ttu-id="763a9-168">Normalmente, um grupo descendente de interfaces tem o mesmo nome, mais um inteiro que indica a geração.</span><span class="sxs-lookup"><span data-stu-id="763a9-168">Typically, a descent group of interfaces all have the same name, plus an integer that indicates the generation.</span></span> <span data-ttu-id="763a9-169">Por exemplo, se a interface original fosse nomeada **IMinhaInterface** (implicando a geração 1), as duas próximas gerações seriam chamadas **IMyInterface2** e **IMyInterface3**.</span><span class="sxs-lookup"><span data-stu-id="763a9-169">For example, if the original interface were named **IMyInterface** (implying generation 1), then the next two generations would be called **IMyInterface2** and **IMyInterface3**.</span></span> <span data-ttu-id="763a9-170">No caso de interfaces DirectX, gerações sucessivas são normalmente nomeadas para o número de versão do DirectX.</span><span class="sxs-lookup"><span data-stu-id="763a9-170">In the case of DirectX interfaces, successive generations are typically named for the version number of DirectX.</span></span>

## <a name="guids"></a><span data-ttu-id="763a9-171">GUIDs</span><span class="sxs-lookup"><span data-stu-id="763a9-171">GUIDs</span></span>

<span data-ttu-id="763a9-172">GUIDs são uma parte fundamental do modelo de programação COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-172">GUIDs are a key part of the COM programming model.</span></span> <span data-ttu-id="763a9-173">Em seu mais básico, um GUID é uma estrutura de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="763a9-173">At its most basic, a GUID is a 128-bit structure.</span></span> <span data-ttu-id="763a9-174">No entanto, os GUIDs são criados de forma a garantir que dois GUIDs sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="763a9-174">However, GUIDs are created in such a way as to guarantee that no two GUIDs are the same.</span></span> <span data-ttu-id="763a9-175">O COM usa os GUIDs extensivamente para duas finalidades principais.</span><span class="sxs-lookup"><span data-stu-id="763a9-175">COM uses GUIDs extensively for two primary purposes.</span></span>

- <span data-ttu-id="763a9-176">Para identificar exclusivamente um componente COM específico.</span><span class="sxs-lookup"><span data-stu-id="763a9-176">To uniquely identify a particular COM component.</span></span> <span data-ttu-id="763a9-177">Um GUID atribuído para identificar um componente COM é chamado de identificador de classe (CLSID) e você usa um CLSID quando deseja criar uma instância do componente COM associado.</span><span class="sxs-lookup"><span data-stu-id="763a9-177">A GUID that is assigned to identify a COM component is called a class identifier (CLSID), and you use a CLSID when you want to create an instance of the associated COM component.</span></span>
- <span data-ttu-id="763a9-178">Para identificar exclusivamente uma interface COM específica.</span><span class="sxs-lookup"><span data-stu-id="763a9-178">To uniquely identify a particular COM interface.</span></span> <span data-ttu-id="763a9-179">Um GUID atribuído para identificar uma interface COM é chamado de IID (identificador de interface) e você usa um IID quando solicita uma interface específica de uma instância de um componente (um objeto).</span><span class="sxs-lookup"><span data-stu-id="763a9-179">A GUID that is assigned to identify a COM interface is called an interface identifier (IID), and you use an IID when you request a particular interface from an instance of a component (an object).</span></span> <span data-ttu-id="763a9-180">O IID de uma interface será o mesmo, independentemente de qual componente implemente a interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-180">An interface's IID will be the same, regardless of which component implements the interface.</span></span>

<span data-ttu-id="763a9-181">Para sua conveniência, a documentação do DirectX normalmente se refere a componentes e interfaces por seus nomes descritivos (por exemplo, **ID3D12Device**) em vez de seus GUIDs.</span><span class="sxs-lookup"><span data-stu-id="763a9-181">For convenience, the DirectX documentation normally refers to components and interfaces by their descriptive names (for example, **ID3D12Device**) rather than by their GUIDs.</span></span> <span data-ttu-id="763a9-182">No contexto da documentação do DirectX, não há nenhuma ambiguidade.</span><span class="sxs-lookup"><span data-stu-id="763a9-182">Within the context of the DirectX documentation, there is no ambiguity.</span></span> <span data-ttu-id="763a9-183">É tecnicamente possível que uma terceira parte crie uma interface com o nome descritivo **ID3D12Device** (ela precisaria ter um IID diferente para ser válido).</span><span class="sxs-lookup"><span data-stu-id="763a9-183">It's technically possible for a third-party to author an interface with the descriptive name **ID3D12Device** (it would need to have a different IID in order to be valid).</span></span> <span data-ttu-id="763a9-184">No entanto, para fins de clareza, não recomendamos isso.</span><span class="sxs-lookup"><span data-stu-id="763a9-184">In the interest of clarity, though, we don't recommend that.</span></span>

<span data-ttu-id="763a9-185">Portanto, a única maneira não ambígua de se referir a um objeto ou interface específica é por seu GUID.</span><span class="sxs-lookup"><span data-stu-id="763a9-185">So, the only unambiguous way to refer to a particular object or interface is by its GUID.</span></span>

<span data-ttu-id="763a9-186">Embora um GUID seja uma estrutura, um GUID geralmente é expresso em forma de cadeia de caracteres equivalente.</span><span class="sxs-lookup"><span data-stu-id="763a9-186">Although a GUID is a structure, a GUID is often expressed in equivalent string form.</span></span> <span data-ttu-id="763a9-187">O formato geral da forma de cadeia de caracteres de um GUID é de 32 dígitos hexadecimais, no formato 8-4-4-4-12.</span><span class="sxs-lookup"><span data-stu-id="763a9-187">The general format of the string form of a GUID is 32 hexadecimal digits, in the format 8-4-4-4-12.</span></span> <span data-ttu-id="763a9-188">Ou seja, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, em que cada x corresponde a um dígito hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="763a9-188">That is, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, where each x corresponds to a hexadecimal digit.</span></span> <span data-ttu-id="763a9-189">Por exemplo, a forma de cadeia de caracteres do IID para a interface **ID3D12Device** é {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span><span class="sxs-lookup"><span data-stu-id="763a9-189">For example, the string form of the IID for the **ID3D12Device** interface is {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span></span>

<span data-ttu-id="763a9-190">Como o GUID real é um pouco atarefado para uso e fácil de digitar, um nome equivalente geralmente é fornecido também.</span><span class="sxs-lookup"><span data-stu-id="763a9-190">Because the actual GUID is somewhat clumsy to use and easy to mistype, an equivalent name is usually provided as well.</span></span> <span data-ttu-id="763a9-191">No seu código, você pode usar esse nome em vez da estrutura real ao chamar funções, por exemplo, quando você passa um argumento para o `riid` parâmetro para [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span><span class="sxs-lookup"><span data-stu-id="763a9-191">In your code, you can use this name instead of the actual structure when you call functions, for example when you pass an argument for the `riid` parameter to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span></span> <span data-ttu-id="763a9-192">A Convenção de nomenclatura personalizada é preceder IID_ ou CLSID_ ao nome descritivo da interface ou do objeto, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-192">The customary naming convention is to prepend either IID_ or CLSID_ to the descriptive name of the interface or object, respectively.</span></span> <span data-ttu-id="763a9-193">Por exemplo, o nome do IID da interface **ID3D12Device** é IID_ID3D12Device.</span><span class="sxs-lookup"><span data-stu-id="763a9-193">For example, the name of the **ID3D12Device** interface's IID is IID_ID3D12Device.</span></span>

> [!NOTE]
> <span data-ttu-id="763a9-194">Os aplicativos DirectX devem ser vinculados com ``dxguid.lib`` e ``uuid.lib`` para fornecer definições para os vários GUIDs de interface e de classe.</span><span class="sxs-lookup"><span data-stu-id="763a9-194">DirectX applications should link with ``dxguid.lib`` and ``uuid.lib`` to provide definitions for the various interface and class GUIDs.</span></span> <span data-ttu-id="763a9-195">Visual C++ e outros compiladores dão suporte à extensão de linguagem do operador de **__uuidof** , mas o vínculo C-Style explícito com essas bibliotecas de links também tem suporte e é totalmente portátil.</span><span class="sxs-lookup"><span data-stu-id="763a9-195">Visual C++ and other compilers support the **__uuidof** operator language extension, but explicit C-style linkage with these link libraries is also supported and fully portable.</span></span>

## <a name="hresult-values"></a><span data-ttu-id="763a9-196">Valores HRESULT</span><span class="sxs-lookup"><span data-stu-id="763a9-196">HRESULT values</span></span>

<span data-ttu-id="763a9-197">A maioria dos métodos COM retorna um inteiro de 32 bits chamado **HRESULT**.</span><span class="sxs-lookup"><span data-stu-id="763a9-197">Most COM methods return a 32-bit integer called an **HRESULT**.</span></span> <span data-ttu-id="763a9-198">Com a maioria dos métodos, o HRESULT é essencialmente uma estrutura que contém duas partes principais de informações.</span><span class="sxs-lookup"><span data-stu-id="763a9-198">With most methods, the HRESULT is essentially a structure that contains two primary pieces of information.</span></span>
- <span data-ttu-id="763a9-199">Se o método teve êxito ou falhou.</span><span class="sxs-lookup"><span data-stu-id="763a9-199">Whether the method succeeded or failed.</span></span>
- <span data-ttu-id="763a9-200">Informações mais detalhadas sobre o resultado da operação executada pelo método.</span><span class="sxs-lookup"><span data-stu-id="763a9-200">More detailed information about the outcome of the operation performed by the method.</span></span>

<span data-ttu-id="763a9-201">Alguns métodos retornam um valor **HRESULT** do conjunto padrão definido em `Winerror.h` .</span><span class="sxs-lookup"><span data-stu-id="763a9-201">Some methods return a **HRESULT** value from the standard set defined in `Winerror.h`.</span></span> <span data-ttu-id="763a9-202">No entanto, um método é gratuito para retornar um valor de **HRESULT** personalizado com informações mais especializadas.</span><span class="sxs-lookup"><span data-stu-id="763a9-202">However, a method is free to return a custom **HRESULT** value with more specialized information.</span></span> <span data-ttu-id="763a9-203">Esses valores normalmente estão documentados na página de referência do método.</span><span class="sxs-lookup"><span data-stu-id="763a9-203">These values are normally documented on the method's reference page.</span></span>

<span data-ttu-id="763a9-204">A lista de valores **HRESULT** que você encontra na página de referência de um método é geralmente apenas um subconjunto dos possíveis valores que podem ser retornados.</span><span class="sxs-lookup"><span data-stu-id="763a9-204">The list of **HRESULT** values that you find on a method's reference page is often only a subset of the possible values that may be returned.</span></span> <span data-ttu-id="763a9-205">A lista normalmente aborda apenas os valores que são específicos para o método, bem como os valores padrão que têm algum significado específico do método.</span><span class="sxs-lookup"><span data-stu-id="763a9-205">The list typically covers only those values that are specific to the method, as well as those standard values that have some method-specific meaning.</span></span> <span data-ttu-id="763a9-206">Você deve assumir que um método pode retornar uma variedade de valores **HRESULT** padrão, mesmo que eles não estejam documentados explicitamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-206">You should assume that a method may return a variety of standard **HRESULT** values, even if they're not explicitly documented.</span></span>

<span data-ttu-id="763a9-207">Embora os valores **HRESULT** geralmente sejam usados para retornar informações de erro, você não deve considerá-los como códigos de erro.</span><span class="sxs-lookup"><span data-stu-id="763a9-207">While **HRESULT** values are often used to return error information, you should not think of them as error codes.</span></span> <span data-ttu-id="763a9-208">O fato de que o bit que indica êxito ou falha é armazenado separadamente dos bits que contêm as informações detalhadas permite que os valores de **HRESULT** tenham qualquer número de códigos de êxito e de falha.</span><span class="sxs-lookup"><span data-stu-id="763a9-208">The fact that the bit that indicates success or failure is stored separately from the bits that contain the detailed information allows **HRESULT** values to have any number of success and failure codes.</span></span> <span data-ttu-id="763a9-209">Por convenção, os nomes de códigos de êxito são prefixados por S_ e códigos de falha por E_.</span><span class="sxs-lookup"><span data-stu-id="763a9-209">By convention, the names of success codes are prefixed by S_ and failure codes by E_.</span></span> <span data-ttu-id="763a9-210">Por exemplo, os dois códigos mais comumente usados são S_OK e E_FAIL, que indicam êxito ou falha simples, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-210">For example, the two most commonly used codes are S_OK and E_FAIL, which indicate simple success or failure, respectively.</span></span>

<span data-ttu-id="763a9-211">O fato de que os métodos COM podem retornar uma variedade de códigos de êxito ou de falha significam que você precisa ter cuidado ao testar o valor **HRESULT** .</span><span class="sxs-lookup"><span data-stu-id="763a9-211">The fact that COM methods may return a variety of success or failure codes means that you have to be careful how you test the **HRESULT** value.</span></span> <span data-ttu-id="763a9-212">Por exemplo, considere um método hipotético com valores de retorno documentados de S_OK se for bem-sucedido e E_FAIL se não for.</span><span class="sxs-lookup"><span data-stu-id="763a9-212">For example, consider a hypothetical method with documented return values of S_OK if successful and E_FAIL if not.</span></span> <span data-ttu-id="763a9-213">No entanto, lembre-se de que o método também pode retornar outros códigos de falha ou êxito.</span><span class="sxs-lookup"><span data-stu-id="763a9-213">However, remember that the method may also return other failure or success codes.</span></span> <span data-ttu-id="763a9-214">O fragmento de código a seguir ilustra o perigo de usar um teste simples, em que `hr` contém o valor **HRESULT** retornado pelo método.</span><span class="sxs-lookup"><span data-stu-id="763a9-214">The following code fragment illustrates the danger of using a simple test, where `hr` contains the **HRESULT** value returned by the method.</span></span>

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="763a9-215">Desde que, no caso de falha, esse método apenas retorne E_FAIL (e não algum outro código de falha), esse teste funciona.</span><span class="sxs-lookup"><span data-stu-id="763a9-215">As long as, in the failure case, this method only ever return E_FAIL (and not some other failure code), then this test works.</span></span> <span data-ttu-id="763a9-216">No entanto, é mais realista que um determinado método seja implementado para retornar um conjunto de códigos de falha específicos, talvez E_NOTIMPL ou E_INVALIDARG.</span><span class="sxs-lookup"><span data-stu-id="763a9-216">However, it's more realistic that a given method is implemented to return a set of specific failure codes, perhaps E_NOTIMPL or E_INVALIDARG.</span></span> <span data-ttu-id="763a9-217">Com o código acima, esses valores seriam interpretados incorretamente como um sucesso.</span><span class="sxs-lookup"><span data-stu-id="763a9-217">With the code above, those values would be incorrectly interpreted as a success.</span></span>

<span data-ttu-id="763a9-218">Se precisar de informações detalhadas sobre o resultado da chamada do método, você precisará testar cada valor **HRESULT** relevante.</span><span class="sxs-lookup"><span data-stu-id="763a9-218">If you need detailed information about the outcome of the method call, you need to test each relevant **HRESULT** value.</span></span> <span data-ttu-id="763a9-219">No entanto, você pode se interessar apenas se o método teve êxito ou falhou.</span><span class="sxs-lookup"><span data-stu-id="763a9-219">However, you may be interested only in whether the method succeeded or failed.</span></span> <span data-ttu-id="763a9-220">Uma maneira robusta de testar se um valor **HRESULT** indica êxito ou falha é passar o valor para uma das macros a seguir, definida em Winerror. h.</span><span class="sxs-lookup"><span data-stu-id="763a9-220">A robust way to test whether an **HRESULT** value indicates success or failure is to pass the value to the one of the following macros, defined in Winerror.h.</span></span>

- <span data-ttu-id="763a9-221">A `SUCCEEDED` macro retorna true para um código de êxito e false para um código de falha.</span><span class="sxs-lookup"><span data-stu-id="763a9-221">The `SUCCEEDED` macro returns TRUE for a success code, and FALSE for a failure code.</span></span>
- <span data-ttu-id="763a9-222">A `FAILED` macro retorna true para um código de falha e false para um código de êxito.</span><span class="sxs-lookup"><span data-stu-id="763a9-222">The `FAILED` macro returns TRUE for a failure code, and FALSE for a success code.</span></span>

<span data-ttu-id="763a9-223">Portanto, você pode corrigir o fragmento de código anterior usando a `FAILED` macro, conforme mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="763a9-223">So, you can fix the preceding code fragment by using the `FAILED` macro, as shown in the following code.</span></span>

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="763a9-224">Esse fragmento de código corrigido trata corretamente E_NOTIMPL e E_INVALIDARG como falhas.</span><span class="sxs-lookup"><span data-stu-id="763a9-224">This corrected code fragment properly treats E_NOTIMPL and E_INVALIDARG as failures.</span></span>

<span data-ttu-id="763a9-225">Embora a maioria dos métodos COM retorne valores de **HRESULT** estruturados, um pequeno número usa **HRESULT** para retornar um inteiro simples.</span><span class="sxs-lookup"><span data-stu-id="763a9-225">Although most COM methods return structured **HRESULT** values, a small number use the **HRESULT** to return a simple integer.</span></span> <span data-ttu-id="763a9-226">Implicitamente, esses métodos sempre são bem-sucedidos.</span><span class="sxs-lookup"><span data-stu-id="763a9-226">Implicitly, these methods are always successful.</span></span> <span data-ttu-id="763a9-227">Se você passar um **HRESULT** desse tipo para a macro SUCCEEDED, a macro sempre retornará true.</span><span class="sxs-lookup"><span data-stu-id="763a9-227">If you pass an **HRESULT** of this sort to the SUCCEEDED macro, then the macro always returns TRUE.</span></span> <span data-ttu-id="763a9-228">Um exemplo de um método chamado comumente que não retorna um **HRESULT** é o método **IUnknown:: Release** , que retorna um ULONG.</span><span class="sxs-lookup"><span data-stu-id="763a9-228">An example of a commonly-called method that doesn't return an **HRESULT** is the **IUnknown::Release** method, which returns a ULONG.</span></span> <span data-ttu-id="763a9-229">Esse método decrementa a contagem de referência de um objeto em um e retorna a contagem de referência atual.</span><span class="sxs-lookup"><span data-stu-id="763a9-229">This method decrements an object's reference count by one and returns the current reference count.</span></span> <span data-ttu-id="763a9-230">Consulte [Gerenciando um tempo de vida de um objeto com](#managing-a-com-objects-lifetime) para uma discussão de contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="763a9-230">See [Managing a COM object's lifetime](#managing-a-com-objects-lifetime) for a discussion of reference counting.</span></span>

## <a name="the-address-of-a-pointer"></a><span data-ttu-id="763a9-231">O endereço de um ponteiro</span><span class="sxs-lookup"><span data-stu-id="763a9-231">The address of a pointer</span></span>

<span data-ttu-id="763a9-232">Se você exibir algumas páginas de referência de método COM, provavelmente será executado em algo semelhante ao seguinte.</span><span class="sxs-lookup"><span data-stu-id="763a9-232">If you view a few COM method reference pages, you'll probably run across something like the following.</span></span>

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

<span data-ttu-id="763a9-233">Embora um ponteiro normal seja bastante familiar para qualquer desenvolvedor de C/C++, COM geralmente usa um nível adicional de indireção.</span><span class="sxs-lookup"><span data-stu-id="763a9-233">While a normal pointer is quite familiar to any C/C++ developer, COM often uses an additional level of indirection.</span></span> <span data-ttu-id="763a9-234">Esse segundo nível de indireção é indicado por dois asteriscos, `**` , após a declaração de tipo, e o nome da variável normalmente tem um prefixo de `pp` .</span><span class="sxs-lookup"><span data-stu-id="763a9-234">This second level of indirection is indicated by two asterisks, `**`, following the type declaration, and the variable name typically has a prefix of `pp`.</span></span> <span data-ttu-id="763a9-235">Para a função acima, o `ppDevice` parâmetro é normalmente referido como o endereço de um ponteiro para um void.</span><span class="sxs-lookup"><span data-stu-id="763a9-235">For the function above, the `ppDevice` parameter is typically referred to as the address of a pointer to a void.</span></span> <span data-ttu-id="763a9-236">Na prática, neste exemplo, `ppDevice` é o endereço de um ponteiro para uma interface **ID3D12Device** .</span><span class="sxs-lookup"><span data-stu-id="763a9-236">In practice, in this example, `ppDevice` is the address of a pointer to an **ID3D12Device** interface.</span></span>

<span data-ttu-id="763a9-237">Ao contrário de um objeto C++, você não acessa diretamente os métodos de um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-237">Unlike a C++ object, you don't access a COM object's methods directly.</span></span> <span data-ttu-id="763a9-238">Em vez disso, você deve obter um ponteiro para uma interface que expõe o método.</span><span class="sxs-lookup"><span data-stu-id="763a9-238">Instead, you must obtain a pointer to an interface that exposes the method.</span></span> <span data-ttu-id="763a9-239">Para invocar o método, você usa essencialmente a mesma sintaxe que faria para invocar um ponteiro para um método C++.</span><span class="sxs-lookup"><span data-stu-id="763a9-239">To invoke the method, you use essentially the same syntax as you would to invoke a pointer to a C++ method.</span></span> <span data-ttu-id="763a9-240">Por exemplo, para invocar o método **IMinhaInterface::D osomething** , você usaria a sintaxe a seguir.</span><span class="sxs-lookup"><span data-stu-id="763a9-240">For example, to invoke the **IMyInterface::DoSomething** method, you would use the following syntax.</span></span>

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

<span data-ttu-id="763a9-241">A necessidade de um segundo nível de indireção é o fato de que você não cria ponteiros de interface diretamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-241">The need for a second level of indirection comes from the fact that you don't create interface pointers directly.</span></span> <span data-ttu-id="763a9-242">Você deve chamar um de vários métodos, como o método **D3D12CreateDevice** mostrado acima.</span><span class="sxs-lookup"><span data-stu-id="763a9-242">You must call one of a variety of methods, such as the **D3D12CreateDevice** method shown above.</span></span> <span data-ttu-id="763a9-243">Para usar esse método para obter um ponteiro de interface, você declara uma variável como um ponteiro para a interface desejada e, em seguida, passa o endereço dessa variável para o método.</span><span class="sxs-lookup"><span data-stu-id="763a9-243">To use such a method to obtain an interface pointer, you declare a variable as a pointer to the desired interface, and then you pass the address of that variable to the method.</span></span> <span data-ttu-id="763a9-244">Em outras palavras, você passa o endereço de um ponteiro para o método.</span><span class="sxs-lookup"><span data-stu-id="763a9-244">In other words, you pass the address of a pointer to the method.</span></span> <span data-ttu-id="763a9-245">Quando o método retorna, a variável aponta para a interface solicitada e você pode usar esse ponteiro para chamar qualquer um dos métodos da interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-245">When the method returns, the variable points to the requested interface, and you can use that pointer to call any of the interface's methods.</span></span>

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a><span data-ttu-id="763a9-246">Criando um objeto COM</span><span class="sxs-lookup"><span data-stu-id="763a9-246">Creating a COM object</span></span>

<span data-ttu-id="763a9-247">Há várias maneiras de criar um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-247">There are several ways to create a COM object.</span></span> <span data-ttu-id="763a9-248">Esses são os dois mais comumente usados na programação do DirectX.</span><span class="sxs-lookup"><span data-stu-id="763a9-248">These are the two most commonly used in DirectX programming.</span></span>

- <span data-ttu-id="763a9-249">Indiretamente, chamando um método ou função DirectX que cria o objeto para você.</span><span class="sxs-lookup"><span data-stu-id="763a9-249">Indirectly, by calling a DirectX method or function that creates the object for you.</span></span> <span data-ttu-id="763a9-250">O método cria o objeto e retorna uma interface no objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-250">The method creates the object, and returns an interface on the object.</span></span> <span data-ttu-id="763a9-251">Quando você cria um objeto dessa forma, às vezes você pode especificar qual interface deve ser retornada, outras vezes a interface é implícita.</span><span class="sxs-lookup"><span data-stu-id="763a9-251">When you create an object this way, sometimes you can specify which interface should be returned, other times the interface is implied.</span></span> <span data-ttu-id="763a9-252">O exemplo de código acima mostra como criar indiretamente um objeto COM de dispositivo Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="763a9-252">The code example above shows how to indirectly create a Direct3D 12 device COM object.</span></span>
- <span data-ttu-id="763a9-253">Diretamente, passando o CLSID do objeto para a [**função CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="763a9-253">Directly, by passing the object's CLSID to the [**CoCreateInstance function**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span> <span data-ttu-id="763a9-254">A função cria uma instância do objeto e retorna um ponteiro para uma interface que você especifica.</span><span class="sxs-lookup"><span data-stu-id="763a9-254">The function creates an instance of the object, and it returns a pointer to an interface that you specify.</span></span>

<span data-ttu-id="763a9-255">Uma vez, antes de criar qualquer objeto COM, você deve inicializar COM chamando a [**função CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="763a9-255">One time, before you create any COM objects, you must initialize COM by calling the [**CoInitializeEx function**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="763a9-256">Se você estiver criando objetos indiretamente, o método de criação de objeto tratará essa tarefa.</span><span class="sxs-lookup"><span data-stu-id="763a9-256">If you're creating objects indirectly, then the object creation method handles this task.</span></span> <span data-ttu-id="763a9-257">Mas, se você precisar criar um objeto com **CoCreateInstance**, deverá chamar **CoInitializeEx** explicitamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-257">But, if you need to create an object with **CoCreateInstance**, then you must call **CoInitializeEx** explicitly.</span></span> <span data-ttu-id="763a9-258">Quando tiver terminado, o COM deve ser não inicializado chamando [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span><span class="sxs-lookup"><span data-stu-id="763a9-258">When you're finished, COM must be uninitialized by calling [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span></span> <span data-ttu-id="763a9-259">Se você fizer uma chamada para **CoInitializeEx** , deverá fazer a correspondência com uma chamada para **CoUninitialize**.</span><span class="sxs-lookup"><span data-stu-id="763a9-259">If you make a call to **CoInitializeEx** then you must match it with a call to **CoUninitialize**.</span></span> <span data-ttu-id="763a9-260">Normalmente, os aplicativos que precisam inicializar explicitamente o COM fazem isso em sua rotina de inicialização e não inicializam COM em sua rotina de limpeza.</span><span class="sxs-lookup"><span data-stu-id="763a9-260">Typically, applications that need to explicitly initialize COM do so in their startup routine, and they uninitialize COM in their cleanup routine.</span></span>

<span data-ttu-id="763a9-261">Para criar uma nova instância de um objeto com com **CoCreateInstance**, você deve ter o CLSID do objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-261">To create a new instance of a COM object with **CoCreateInstance**, you must have the object's CLSID.</span></span> <span data-ttu-id="763a9-262">Se esse CLSID estiver disponível publicamente, você o encontrará na documentação de referência ou no arquivo de cabeçalho apropriado.</span><span class="sxs-lookup"><span data-stu-id="763a9-262">If this CLSID is publicly available, you will find it in the reference documentation or the appropriate header file.</span></span> <span data-ttu-id="763a9-263">Se o CLSID não estiver disponível publicamente, você não poderá criar o objeto diretamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-263">If the CLSID is not publicly available, then you can't create the object directly.</span></span>

<span data-ttu-id="763a9-264">A função **CoCreateInstance** tem cinco parâmetros.</span><span class="sxs-lookup"><span data-stu-id="763a9-264">The **CoCreateInstance** function has five parameters.</span></span> <span data-ttu-id="763a9-265">Para os objetos COM que você usará com o DirectX, você pode normalmente definir os parâmetros da seguinte maneira.</span><span class="sxs-lookup"><span data-stu-id="763a9-265">For the COM objects you will be using with DirectX, you can normally set the parameters as follows.</span></span>

<span data-ttu-id="763a9-266">*rclsid* Defina isso para o CLSID do objeto que você deseja criar.</span><span class="sxs-lookup"><span data-stu-id="763a9-266">*rclsid* Set this to the CLSID of the object that you want to create.</span></span>

<span data-ttu-id="763a9-267">*pUnkOuter* Defina como `nullptr` .</span><span class="sxs-lookup"><span data-stu-id="763a9-267">*pUnkOuter* Set to `nullptr`.</span></span> <span data-ttu-id="763a9-268">Esse parâmetro será usado somente se você estiver agregando objetos.</span><span class="sxs-lookup"><span data-stu-id="763a9-268">This parameter is used only if you are aggregating objects.</span></span> <span data-ttu-id="763a9-269">Uma discussão sobre a agregação COM está fora do escopo deste tópico.</span><span class="sxs-lookup"><span data-stu-id="763a9-269">A discussion of COM aggregation is outside the scope of this topic.</span></span>

<span data-ttu-id="763a9-270">*dwClsContext* Defina como CLSCTX_INPROC_SERVER.</span><span class="sxs-lookup"><span data-stu-id="763a9-270">*dwClsContext* Set to CLSCTX_INPROC_SERVER.</span></span> <span data-ttu-id="763a9-271">Essa configuração indica que o objeto é implementado como uma DLL e é executado como parte do processo do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="763a9-271">This setting indicates that the object is implemented as a DLL and runs as part of your application's process.</span></span>

<span data-ttu-id="763a9-272">*riid* Defina como o IID da interface que você deseja que tenha retornado.</span><span class="sxs-lookup"><span data-stu-id="763a9-272">*riid* Set to the IID of the interface that you would like to have returned.</span></span> <span data-ttu-id="763a9-273">A função criará o objeto e retornará o ponteiro de interface solicitado no parâmetro PPV.</span><span class="sxs-lookup"><span data-stu-id="763a9-273">The function will create the object and return the requested interface pointer in the ppv parameter.</span></span>

<span data-ttu-id="763a9-274">*PPV* Defina isso para o endereço de um ponteiro que será definido para a interface especificada por `riid` quando a função retornar.</span><span class="sxs-lookup"><span data-stu-id="763a9-274">*ppv* Set this to the address of a pointer that will be set to the interface specified by `riid` when the function returns.</span></span> <span data-ttu-id="763a9-275">Essa variável deve ser declarada como um ponteiro para a interface solicitada, e a referência ao ponteiro na lista de parâmetros deve ser convertida como (LPVOID \*).</span><span class="sxs-lookup"><span data-stu-id="763a9-275">This variable should be declared as a pointer to the requested interface, and the reference to the pointer in the parameter list should be cast as (LPVOID \*).</span></span>

<span data-ttu-id="763a9-276">Criar um objeto indiretamente geralmente é muito mais simples, como vimos no exemplo de código acima.</span><span class="sxs-lookup"><span data-stu-id="763a9-276">Creating an object indirectly is usually much simpler, as we saw in the code example above.</span></span> <span data-ttu-id="763a9-277">Você passa o método de criação de objeto o endereço de um ponteiro de interface, e o método cria o objeto e retorna um ponteiro de interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-277">You pass the object creation method the address of an interface pointer, and the method then creates the object and returns an interface pointer.</span></span> <span data-ttu-id="763a9-278">Quando você cria um objeto indiretamente, mesmo que não possa escolher qual interface o método retorna, geralmente você ainda pode especificar uma variedade de coisas sobre como o objeto deve ser criado.</span><span class="sxs-lookup"><span data-stu-id="763a9-278">When you create an object indirectly, even if you can't choose which interface the method returns, often you can still specify a variety of things about how the object should be created.</span></span>

<span data-ttu-id="763a9-279">Por exemplo, você pode passar para **D3D12CreateDevice** um valor especificando o nível mínimo de recurso do D3D ao qual o dispositivo retornado deve dar suporte, conforme mostrado no exemplo de código acima.</span><span class="sxs-lookup"><span data-stu-id="763a9-279">For example, you can pass to **D3D12CreateDevice** a value specifying the minimum D3D feature level that the returned device should support, as shown in the code example above.</span></span>

## <a name="using-com-interfaces"></a><span data-ttu-id="763a9-280">Usando interfaces COM</span><span class="sxs-lookup"><span data-stu-id="763a9-280">Using COM interfaces</span></span>

<span data-ttu-id="763a9-281">Quando você cria um objeto COM, o método de criação retorna um ponteiro de interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-281">When you create a COM object, the creation method returns an interface pointer.</span></span> <span data-ttu-id="763a9-282">Em seguida, você pode usar esse ponteiro para acessar qualquer um dos métodos da interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-282">You can then use that pointer to access any of the interface's methods.</span></span> <span data-ttu-id="763a9-283">A sintaxe é idêntica à usada com um ponteiro para um método C++.</span><span class="sxs-lookup"><span data-stu-id="763a9-283">The syntax is identical to that used with a pointer to a C++ method.</span></span>

## <a name="requesting-additional-interfaces"></a><span data-ttu-id="763a9-284">Solicitando interfaces adicionais</span><span class="sxs-lookup"><span data-stu-id="763a9-284">Requesting Additional Interfaces</span></span>

<span data-ttu-id="763a9-285">Em muitos casos, o ponteiro de interface que você recebe do método de criação pode ser o único que você precisa.</span><span class="sxs-lookup"><span data-stu-id="763a9-285">In many cases, the interface pointer that you receive from the creation method may be the only one that you need.</span></span> <span data-ttu-id="763a9-286">Na verdade, é relativamente comum que um objeto exporte apenas uma interface diferente de **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="763a9-286">In fact, it's relatively common for an object to export only one interface other than **IUnknown**.</span></span> <span data-ttu-id="763a9-287">No entanto, muitos objetos exportam várias interfaces e você pode precisar de ponteiros para vários deles.</span><span class="sxs-lookup"><span data-stu-id="763a9-287">However, many objects export multiple interfaces, and you may need pointers to several of them.</span></span> <span data-ttu-id="763a9-288">Se você precisar de mais interfaces do que aquela retornada pelo método de criação, não será necessário criar um novo objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-288">If you need more interfaces than the one returned by the creation method, there's no need to create a new object.</span></span> <span data-ttu-id="763a9-289">Em vez disso, solicite outro ponteiro de interface usando o [**método IUnknown:: QueryInterface**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))do objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-289">Instead, request another interface pointer by using the object's [**IUnknown::QueryInterface method**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)).</span></span>

<span data-ttu-id="763a9-290">Se você criar o objeto com **CoCreateInstance**, poderá solicitar um ponteiro de interface **IUnknown** e, em seguida, chamar **IUnknown:: QueryInterface** para solicitar todas as interfaces necessárias.</span><span class="sxs-lookup"><span data-stu-id="763a9-290">If you create your object with **CoCreateInstance**, then you can request an **IUnknown** interface pointer and then call **IUnknown::QueryInterface** to request every interface you need.</span></span> <span data-ttu-id="763a9-291">No entanto, essa abordagem não é conveniente se você precisar apenas de uma interface única, e ela não funcionará se você usar um método de criação de objeto que não permita que você especifique qual ponteiro de interface deve ser retornado.</span><span class="sxs-lookup"><span data-stu-id="763a9-291">However, this approach is inconvenient if you need only a single interface, and it doesn't work at all if you use an object creation method that doesn't allow you to specify which interface pointer should be returned.</span></span> <span data-ttu-id="763a9-292">Na prática, normalmente você não precisa obter um ponteiro **IUnknown** explícito, pois todas as interfaces com estendem a interface **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="763a9-292">In practice, you usually don't need to obtain an explicit **IUnknown** pointer, because all COM interfaces extend the **IUnknown** interface.</span></span>

<span data-ttu-id="763a9-293">Estender uma interface é conceitualmente semelhante à herança de uma classe C++.</span><span class="sxs-lookup"><span data-stu-id="763a9-293">Extending an interface is conceptually similar to inheriting from a C++ class.</span></span> <span data-ttu-id="763a9-294">A interface filho expõe todos os métodos da interface pai, além de um ou mais de seus próprios.</span><span class="sxs-lookup"><span data-stu-id="763a9-294">The child interface exposes all of the parent interface's methods, plus one or more of its own.</span></span> <span data-ttu-id="763a9-295">Na verdade, você verá com frequência "herda de" usado em vez de "extends".</span><span class="sxs-lookup"><span data-stu-id="763a9-295">In fact, you will often see "inherits from" used instead of "extends".</span></span> <span data-ttu-id="763a9-296">O que você precisa lembrar é que a herança é interna ao objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-296">What you need to remember is that the inheritance is internal to the object.</span></span> <span data-ttu-id="763a9-297">Seu aplicativo não pode herdar de ou estender a interface de um objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-297">Your application can't inherit from or extend an object's interface.</span></span> <span data-ttu-id="763a9-298">No entanto, você pode usar a interface filho para chamar qualquer um dos métodos do filho ou pai.</span><span class="sxs-lookup"><span data-stu-id="763a9-298">However, you can use the child interface to call any of the methods of the child or parent.</span></span>

<span data-ttu-id="763a9-299">Como todas as interfaces são filhas de **IUnknown**, você pode chamar **QueryInterface** em qualquer um dos ponteiros de interface que você já tem para o objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-299">Because all interfaces are children of **IUnknown**, you can call **QueryInterface** on any of the interface pointers that you already have for the object.</span></span> <span data-ttu-id="763a9-300">Ao fazer isso, você deve fornecer o IID da interface que você está solicitando e o endereço de um ponteiro que conterá o ponteiro de interface quando o método retornar.</span><span class="sxs-lookup"><span data-stu-id="763a9-300">When you do so, you must provide the IID of the interface that you're requesting and the address of a pointer that will contain the interface pointer when the method returns.</span></span>

<span data-ttu-id="763a9-301">Por exemplo, o fragmento de código a seguir chama **IDXGIFactory2:: CreateSwapChainForHwnd** para criar um objeto de cadeia de permuta primário.</span><span class="sxs-lookup"><span data-stu-id="763a9-301">For example, the following code fragment calls **IDXGIFactory2::CreateSwapChainForHwnd** to create a primary swap chain object.</span></span> <span data-ttu-id="763a9-302">Esse objeto expõe várias interfaces.</span><span class="sxs-lookup"><span data-stu-id="763a9-302">This object exposes several interfaces.</span></span> <span data-ttu-id="763a9-303">O método **CreateSwapChainForHwnd** retorna uma interface **IDXGISwapChain1** .</span><span class="sxs-lookup"><span data-stu-id="763a9-303">The **CreateSwapChainForHwnd** method returns an **IDXGISwapChain1** interface.</span></span> <span data-ttu-id="763a9-304">Em seguida, o código subsequente usa a interface **IDXGISwapChain1** para chamar **QueryInterface** para solicitar uma interface **IDXGISwapChain3** .</span><span class="sxs-lookup"><span data-stu-id="763a9-304">The subsequent code then uses the **IDXGISwapChain1** interface to call **QueryInterface** to request an **IDXGISwapChain3** interface.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> <span data-ttu-id="763a9-305">Em C++, você pode fazer uso da ``IID_PPV_ARGS`` macro em vez do IID explícito e do ponteiro de conversão: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` .</span><span class="sxs-lookup"><span data-stu-id="763a9-305">In C++ you can make use of the ``IID_PPV_ARGS`` macro rather than the explicit IID and cast pointer: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));``.</span></span>
> <span data-ttu-id="763a9-306">Isso geralmente é usado para métodos de criação, bem como para **QueryInterface**.</span><span class="sxs-lookup"><span data-stu-id="763a9-306">This is often used for creation methods as well as **QueryInterface**.</span></span> <span data-ttu-id="763a9-307">Consulte [combaseapi. h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="763a9-307">See [combaseapi.h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) for more information.</span></span>

## <a name="managing-a-com-objects-lifetime"></a><span data-ttu-id="763a9-308">Gerenciando o tempo de vida de um objeto COM</span><span class="sxs-lookup"><span data-stu-id="763a9-308">Managing a COM object's lifetime</span></span>

<span data-ttu-id="763a9-309">Quando um objeto é criado, o sistema aloca os recursos de memória necessários.</span><span class="sxs-lookup"><span data-stu-id="763a9-309">When an object is created, the system allocates the necessary memory resources.</span></span> <span data-ttu-id="763a9-310">Quando um objeto não for mais necessário, ele deverá ser destruído.</span><span class="sxs-lookup"><span data-stu-id="763a9-310">When an object is no longer needed, it should be destroyed.</span></span> <span data-ttu-id="763a9-311">O sistema pode usar essa memória para outras finalidades.</span><span class="sxs-lookup"><span data-stu-id="763a9-311">The system can use that memory for other purposes.</span></span> <span data-ttu-id="763a9-312">Com objetos C++, você pode controlar o tempo de vida do objeto diretamente com os `new` `delete` operadores e nos casos em que você está operando nesse nível ou apenas usando a pilha e o tempo de vida do escopo.</span><span class="sxs-lookup"><span data-stu-id="763a9-312">With C++ objects, you can control the object's lifetime directly with the `new` and `delete` operators in cases where you're operating at that level, or just by using the stack and scope lifetime.</span></span> <span data-ttu-id="763a9-313">O COM não permite que você crie ou destrua objetos diretamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-313">COM doesn't enable you to directly create or destroy objects.</span></span> <span data-ttu-id="763a9-314">O motivo para esse design é que o mesmo objeto pode ser usado por mais de uma parte do seu aplicativo ou, em alguns casos, por mais de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="763a9-314">The reason for this design is that the same object may be used by more than one part of your application or, in some cases, by more than one application.</span></span> <span data-ttu-id="763a9-315">Se uma dessas referências fosse destruir o objeto, as outras referências se tornarão inválidas.</span><span class="sxs-lookup"><span data-stu-id="763a9-315">If one of those references were to destroy the object, then the other references would become invalid.</span></span> <span data-ttu-id="763a9-316">Em vez disso, COM usa um sistema de contagem de referência para controlar o tempo de vida de um objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-316">Instead, COM uses a system of reference counting to control an object's lifetime.</span></span>

<span data-ttu-id="763a9-317">A contagem de referência de um objeto é o número de vezes que uma de suas interfaces foi solicitada.</span><span class="sxs-lookup"><span data-stu-id="763a9-317">An object's reference count is the number of times one of its interfaces has been requested.</span></span> <span data-ttu-id="763a9-318">Cada vez que uma interface é solicitada, a contagem de referência é incrementada.</span><span class="sxs-lookup"><span data-stu-id="763a9-318">Each time that an interface is requested, the reference count is incremented.</span></span> <span data-ttu-id="763a9-319">Um aplicativo libera uma interface quando essa interface não é mais necessária, decrementando a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="763a9-319">An application releases an interface when that interface is no longer needed, decrementing the reference count.</span></span> <span data-ttu-id="763a9-320">Desde que a contagem de referência seja maior que zero, o objeto permanecerá na memória.</span><span class="sxs-lookup"><span data-stu-id="763a9-320">As long as the reference count is greater than zero, the object remains in memory.</span></span> <span data-ttu-id="763a9-321">Quando a contagem de referência chega a zero, o objeto se destrói.</span><span class="sxs-lookup"><span data-stu-id="763a9-321">When the reference count reaches zero, the object destroys itself.</span></span> <span data-ttu-id="763a9-322">Você não precisa saber nada sobre a contagem de referência de um objeto.</span><span class="sxs-lookup"><span data-stu-id="763a9-322">You don't need to know anything about the reference count of an object.</span></span> <span data-ttu-id="763a9-323">Desde que você obtenha e libere as interfaces de um objeto corretamente, o objeto terá o tempo de vida apropriado.</span><span class="sxs-lookup"><span data-stu-id="763a9-323">As long as you obtain and release an object's interfaces properly, the object will have the appropriate lifetime.</span></span>

<span data-ttu-id="763a9-324">Lidar corretamente com a contagem de referência é uma parte crucial da programação COM.</span><span class="sxs-lookup"><span data-stu-id="763a9-324">Properly handling reference counting is a crucial part of COM programming.</span></span> <span data-ttu-id="763a9-325">A falha em fazer isso pode criar facilmente um vazamento de memória ou uma falha.</span><span class="sxs-lookup"><span data-stu-id="763a9-325">Failure to do so can easily create a memory leak or a crash.</span></span> <span data-ttu-id="763a9-326">Um dos erros mais comuns que os programadores do COM faz é falhar ao liberar uma interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-326">One of the most common mistakes that COM programmers make is failing to release an interface.</span></span> <span data-ttu-id="763a9-327">Quando isso acontece, a contagem de referência nunca chega a zero e o objeto permanece na memória indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="763a9-327">When this happens, the reference count never reaches zero, and the object remains in memory indefinitely.</span></span>

> [!NOTE]
> <span data-ttu-id="763a9-328">O Direct3D 10 ou posterior tem regras de tempo de vida ligeiramente modificadas para objetos.</span><span class="sxs-lookup"><span data-stu-id="763a9-328">Direct3D 10 or later has slightly modified lifetime rules for objects.</span></span> <span data-ttu-id="763a9-329">Em particular, os objetos que derivam de **ID3DxxDeviceChild** nunca sobreviver Alémm seu dispositivo pai (ou seja, se o **ID3DxxDevice** proprietário chegar a 0 Refcount, todos os objetos filho também serão inválidos imediatamente).</span><span class="sxs-lookup"><span data-stu-id="763a9-329">In particular, objects that are derived from **ID3DxxDeviceChild** never outlive their parent device (that is, if the owning **ID3DxxDevice** hits a 0 refcount, then all child objects are immediately invalid as well).</span></span> <span data-ttu-id="763a9-330">Além disso, quando você usa métodos **set** para associar objetos ao pipeline de renderização, essas referências não aumentam a contagem de referência (ou seja, são referências fracas).</span><span class="sxs-lookup"><span data-stu-id="763a9-330">Also, when you use **Set** methods to bind objects to the render pipeline, these references don't increase the reference count (that is, they are weak references).</span></span> <span data-ttu-id="763a9-331">Na prática, isso é melhor tratado ao garantir que você libere todos os objetos filho do dispositivo completamente antes de liberar o dispositivo.</span><span class="sxs-lookup"><span data-stu-id="763a9-331">In practice, this is best handled by ensuring that you release all device child objects fully before you release the device.</span></span>

## <a name="incrementing-and-decrementing-the-reference-count"></a><span data-ttu-id="763a9-332">Incrementando e decrementando a contagem de referência</span><span class="sxs-lookup"><span data-stu-id="763a9-332">Incrementing and decrementing the reference count</span></span>

<span data-ttu-id="763a9-333">Sempre que você obtém um novo ponteiro de interface, a contagem de referência deve ser incrementada por uma chamada para [**IUnknown:: AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span><span class="sxs-lookup"><span data-stu-id="763a9-333">Whenever you obtain a new interface pointer, the reference count must be incremented by a call to [**IUnknown::AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span></span> <span data-ttu-id="763a9-334">No entanto, o aplicativo geralmente não precisa chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="763a9-334">However, your application doesn't usually need to call this method.</span></span> <span data-ttu-id="763a9-335">Se você obtiver um ponteiro de interface chamando um método de criação de objeto ou chamando **IUnknown:: QueryInterface**, o objeto incrementará automaticamente a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="763a9-335">If you obtain an interface pointer by calling an object creation method, or by calling **IUnknown::QueryInterface**, then the object automatically increments the reference count.</span></span> <span data-ttu-id="763a9-336">No entanto, se você criar um ponteiro de interface de alguma outra forma, como copiar um ponteiro existente, deverá chamar explicitamente **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="763a9-336">However, if you create an interface pointer in some other way, such as copying an existing pointer, then you must explicitly call **IUnknown::AddRef**.</span></span> <span data-ttu-id="763a9-337">Caso contrário, quando você liberar o ponteiro de interface original, o objeto poderá ser destruído, mesmo que ainda seja necessário usar a cópia do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="763a9-337">Otherwise, when you release the original interface pointer, the object may be destroyed even though you may still need to use the copy of the pointer.</span></span>

<span data-ttu-id="763a9-338">Você deve liberar todos os ponteiros de interface, independentemente se você ou o objeto incrementou a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="763a9-338">You must release all interface pointers, regardless of whether you or the object incremented the reference count.</span></span> <span data-ttu-id="763a9-339">Quando você não precisar mais de um ponteiro de interface, chame [**IUnknown:: Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) para diminuir a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="763a9-339">When you no longer need an interface pointer, call [**IUnknown::Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) to decrement the reference count.</span></span> <span data-ttu-id="763a9-340">Uma prática comum é inicializar todos os ponteiros de interface para `nullptr` e, em seguida, defini-los de volta para `nullptr` quando eles são liberados.</span><span class="sxs-lookup"><span data-stu-id="763a9-340">A common practice is to initialize all interface pointers to `nullptr`, and then to set them back to `nullptr` when they are released.</span></span> <span data-ttu-id="763a9-341">Essa Convenção permite testar todos os ponteiros de interface em seu código de limpeza.</span><span class="sxs-lookup"><span data-stu-id="763a9-341">That convention allows you to test all interface pointers in your cleanup code.</span></span> <span data-ttu-id="763a9-342">Aqueles que ainda não `nullptr` estão ativos, e você precisa liberá-los antes de encerrar o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="763a9-342">Those that are not `nullptr` are still active, and you need to release them before you terminate the application.</span></span>

<span data-ttu-id="763a9-343">O fragmento de código a seguir estende o exemplo mostrado anteriormente para ilustrar como tratar a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="763a9-343">The following code fragment extends the sample shown earlier to illustrate how to handle reference counting.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a><span data-ttu-id="763a9-344">Ponteiros inteligentes COM</span><span class="sxs-lookup"><span data-stu-id="763a9-344">COM Smart Pointers</span></span>

<span data-ttu-id="763a9-345">O código até agora foi chamado explicitamente ``Release`` e ``AddRef`` para manter as contagens de referência usando métodos **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="763a9-345">The code so far has explicitly called ``Release`` and ``AddRef`` to maintain the reference counts using **IUnknown** methods.</span></span> <span data-ttu-id="763a9-346">Esse padrão exige que o programador seja cuidadoso para se lembrar de manter a contagem corretamente em todos os caminhos possíveis.</span><span class="sxs-lookup"><span data-stu-id="763a9-346">This pattern requires the programmer to be diligent in remembering to properly maintain the count in all possible codepaths.</span></span> <span data-ttu-id="763a9-347">Isso pode resultar em tratamento de erros complicado, e com a manipulação de exceção do C++ habilitada pode ser particularmente difícil de implementar.</span><span class="sxs-lookup"><span data-stu-id="763a9-347">This can result in complicated error-handling, and with C++ exception handling enabled can be particularly difficult to implement.</span></span> <span data-ttu-id="763a9-348">Uma solução melhor com o C++ é usar um [ponteiro inteligente](/cpp/cpp/smart-pointers-modern-cpp).</span><span class="sxs-lookup"><span data-stu-id="763a9-348">A better solution with C++ is to make use of a [smart pointer](/cpp/cpp/smart-pointers-modern-cpp).</span></span>

* <span data-ttu-id="763a9-349">**winrt:: com_ptr** é um ponteiro inteligente fornecido pelas [projeções de linguagem C++/WinRT](/uwp/cpp-ref-for-winrt/com-ptr).</span><span class="sxs-lookup"><span data-stu-id="763a9-349">**winrt::com_ptr** is a smart pointer provided by the [C++/WinRT language projections](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="763a9-350">Este é o ponteiro inteligente COM recomendado a ser usado para aplicativos UWP.</span><span class="sxs-lookup"><span data-stu-id="763a9-350">This is the recommended COM smart pointer to use for UWP apps.</span></span> <span data-ttu-id="763a9-351">Observe que C++/WinRT requer C++ 17.</span><span class="sxs-lookup"><span data-stu-id="763a9-351">Note that C++/WinRT requires C++17.</span></span>

* <span data-ttu-id="763a9-352">**Microsoft:: WRL:: ComPtr** é um ponteiro inteligente fornecido pela [Windows Runtime biblioteca de modelos do C++ (WRL)](/cpp/cppcx/wrl/comptr-class).</span><span class="sxs-lookup"><span data-stu-id="763a9-352">**Microsoft::WRL::ComPtr** is a smart pointer provided by the [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span></span> <span data-ttu-id="763a9-353">Essa biblioteca é "pura" C++ para que possa ser utilizada para aplicativos Windows Runtime (via C++/CX ou C++/WinRT), bem como aplicativos de área de trabalho Win32 clássicos.</span><span class="sxs-lookup"><span data-stu-id="763a9-353">This library is "pure" C++ so it can be utilized for Windows Runtime applications (via C++/CX or C++/WinRT) as well as classic Win32 desktop applications.</span></span> <span data-ttu-id="763a9-354">Esse ponteiro inteligente também funciona em versões anteriores do Windows que não dão suporte às APIs de Windows Runtime.</span><span class="sxs-lookup"><span data-stu-id="763a9-354">This smart pointer also works on older versions of Windows that do not support the Windows Runtime APIs.</span></span> <span data-ttu-id="763a9-355">Para aplicativos de área de trabalho Win32, você pode usar ``#include <wrl/client.h>`` para incluir apenas essa classe e, opcionalmente, definir o símbolo de pré-processador ``__WRL_CLASSIC_COM_STRICT__`` também.</span><span class="sxs-lookup"><span data-stu-id="763a9-355">For Win32 desktop applications, you can use ``#include <wrl/client.h>`` to only include this class and optionally define the preprocessor symbol ``__WRL_CLASSIC_COM_STRICT__`` as well.</span></span> <span data-ttu-id="763a9-356">Para obter mais informações, consulte [apontadores inteligentes com revisitados](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span><span class="sxs-lookup"><span data-stu-id="763a9-356">For more information, see [COM smart pointers revisited](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span></span>

* <span data-ttu-id="763a9-357">**CComPtr** é um ponteiro inteligente fornecido pelo [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span><span class="sxs-lookup"><span data-stu-id="763a9-357">**CComPtr** is a smart pointer provided by the [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span></span> <span data-ttu-id="763a9-358">O **Microsoft:: WRL:: ComPtr** é uma versão mais recente dessa implementação que aborda vários problemas de uso sutis, portanto, o uso desse ponteiro inteligente não é recomendado para novos projetos.</span><span class="sxs-lookup"><span data-stu-id="763a9-358">The **Microsoft::WRL::ComPtr** is a newer version of this implementation that addresses a number of subtle usage issues, so use of this smart pointer is not recommended for new projects.</span></span> <span data-ttu-id="763a9-359">Para obter mais informações, consulte [como criar e usar CComPtr e CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span><span class="sxs-lookup"><span data-stu-id="763a9-359">For more information, see [How to create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span></span>


## <a name="using-atl-with-directx-9"></a><span data-ttu-id="763a9-360">Usando a ATL com o DirectX 9</span><span class="sxs-lookup"><span data-stu-id="763a9-360">Using ATL with DirectX 9</span></span>

<span data-ttu-id="763a9-361">Para usar o Active Template Library (ATL) com o DirectX 9, você deve redefinir as interfaces para compatibilidade com ATL.</span><span class="sxs-lookup"><span data-stu-id="763a9-361">To use the Active Template Library (ATL) with DirectX 9, you must redefine the interfaces for ATL compatibility.</span></span> <span data-ttu-id="763a9-362">Isso permite que você use corretamente a classe **CComQIPtr** para obter um ponteiro para uma interface.</span><span class="sxs-lookup"><span data-stu-id="763a9-362">This allows you to properly use the **CComQIPtr** class to obtain a pointer to an interface.</span></span>

<span data-ttu-id="763a9-363">Você saberá se não redefinir as interfaces para ATL, porque verá a seguinte mensagem de erro.</span><span class="sxs-lookup"><span data-stu-id="763a9-363">You'll know if you don't redefine the interfaces for ATL, because you'll see the following error message.</span></span>

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

<span data-ttu-id="763a9-364">O exemplo de código a seguir mostra como definir a interface IDirectXFileData.</span><span class="sxs-lookup"><span data-stu-id="763a9-364">The following code sample shows how to define the IDirectXFileData interface.</span></span>

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

<span data-ttu-id="763a9-365">Depois de redefinir a interface, você deve usar o método **Attach** para anexar a interface ao ponteiro de interface retornado por **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="763a9-365">After redefining the interface, you must use the **Attach** method to attach the interface to the interface pointer returned by **::Direct3DCreate9**.</span></span> <span data-ttu-id="763a9-366">Caso contrário, a interface **IDirect3D9** não será liberada corretamente pela classe de ponteiro inteligente.</span><span class="sxs-lookup"><span data-stu-id="763a9-366">If you don't, then the **IDirect3D9** interface won't be properly released by the smart pointer class.</span></span>

<span data-ttu-id="763a9-367">A classe **CComPtr** internamente chama **IUnknown:: AddRef** no ponteiro de interface quando o objeto é criado e quando uma interface é atribuída à classe **CComPtr** .</span><span class="sxs-lookup"><span data-stu-id="763a9-367">The **CComPtr** class internally calls **IUnknown::AddRef** on the interface pointer when the object is created and when an interface is assigned to the **CComPtr** class.</span></span> <span data-ttu-id="763a9-368">Para evitar o vazamento do ponteiro de interface, não chame \* \* IUnknown:: AddRef na interface retornada de **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="763a9-368">To avoid leaking the interface pointer, don't call \*\*IUnknown::AddRef on the interface returned from **::Direct3DCreate9**.</span></span>

<span data-ttu-id="763a9-369">O código a seguir libera corretamente a interface sem chamar **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="763a9-369">The following code properly releases the interface without calling **IUnknown::AddRef**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

<span data-ttu-id="763a9-370">Use o código anterior.</span><span class="sxs-lookup"><span data-stu-id="763a9-370">Use the previous code.</span></span> <span data-ttu-id="763a9-371">Não use o código a seguir, que chama **IUnknown:: AddRef** seguido por **IUnknown:: Release** e não libera a referência adicionada por **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="763a9-371">Don't use the following code, which calls **IUnknown::AddRef** followed by **IUnknown::Release**, and doesn't release the reference added by **::Direct3DCreate9**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

<span data-ttu-id="763a9-372">Observe que esse é o único lugar no Direct3D 9, no qual você terá que usar o método **Attach** dessa maneira.</span><span class="sxs-lookup"><span data-stu-id="763a9-372">Note that this is the only place in Direct3D 9 where you'll have to use the **Attach** method in this manner.</span></span>

<span data-ttu-id="763a9-373">Para obter mais informações sobre as classes **CComPTR** e **CComQIPtr** , consulte suas definições no `Atlbase.h` arquivo de cabeçalho.</span><span class="sxs-lookup"><span data-stu-id="763a9-373">For more information about the **CComPTR** and **CComQIPtr** classes, see their definitions in the `Atlbase.h` header file.</span></span>
