---
description: O procedimento a seguir descreve como implementar um MSP usando a ATL versão 2,1 ou a ATL versão 3,0 e as classes base MSP.
ms.assetid: 7485c34a-3c8a-412f-9cb9-8eb895084292
title: Usando as classes base TAPI 3 MSP
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6131d44b6746075c43fc61c9d35decbe0564773db4746bba6d72b0da4697cabd
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/11/2021
ms.locfileid: "119139709"
---
# <a name="using-the-tapi-3-msp-base-classes"></a>Usando as classes base TAPI 3 MSP

O procedimento a seguir descreve como implementar um MSP usando a ATL versão 2,1 ou a ATL versão 3,0 e as classes base MSP. Para obter mais informações e uma lista de bibliotecas e cabeçalhos, consulte [classes base TAPI 3 MSP](tapi-3-msp-base-classes.md). O conteúdo contido neste tópico pressupõe que o desenvolvedor tem um entendimento prático da ATL e COM e tem experiência na implementação de DLLs COM usando a ATL.

**Para implementar e MSP usando ATL 2,1 ou ATL 3,0**

1.  Crie um arquivo IDL para seu MSP. Esse arquivo define um CLSID para o MSP. Declare sua "coclass" do MSP como implementando a interface [**ITMSPAddress**](/windows/desktop/api/msp/nn-msp-itmspaddress) e declare essa interface como a interface padrão em seu objeto de classe. Para a definição de **ITMSPAddress**, importe o arquivo "msp. idl". Inclua sua "coclasse" MSP em uma biblioteca de tipos para seu MSP. Se o seu MSP der suporte a interfaces privadas (personalizadas), defina-as aqui e inclua-as em sua biblioteca de tipos. O exemplo de código a seguir é um arquivo IDL, conforme descrito acima, sem interfaces personalizadas.

    ``` syntax
    import "msp.idl";
    [
          uuid(4DDB6D35-3BC1-11d2-86F2-006008B0E5D2),
          version(2.0),
          helpstring("Wave MSP 2.0 Type Library")
    ]
    library WAVEMSPLib
    {
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(4DDB6D36-3BC1-11d2-86F2-006008B0E5D2),
    helpstring("Wave MSP Class")
    ]
    coclass WaveMSP
    {
    [default] interface ITMSPAddress;
    };
    };
    ```

2.  Modifique seu TSP para anunciar o CLSID do seu MSP quando Tapi3.dll solicitá-lo. Verifique se (1) seu TSP pode negociar \_ a TAPI VERSION3 \_ 0 ou superior na função TSPI [**TSPI \_ lineNegotiateTSPIVersion**](/windows/win32/api/tspi/nf-tspi-tspi_linenegotiatetspiversion), (2) sua estrutura de [**LINEDEVCAPS**](/windows/win32/api/tapi/ns-tapi-linedevcaps) do TSP tem o \_ sinalizador LINEDEVCAPFLAGS MSP definido no membro **dwDevCapFlags** e (3) o seu tsp retorna o CLSID msp na função TSPI [**\_**](/windows/win32/api/tspi/nf-tspi-tspi_linemspidentify)TSPI lineMSPIdentify. Deve ser o mesmo CLSID especificado em seu arquivo IDL; por exemplo, a segunda linha "UUID" no arquivo IDL de exemplo na etapa anterior.
3.  Compile o aplicativo de exemplo MSPBase, localizado no SDK (Software Development Kit) da plataforma, para criar a biblioteca MSPBaseSample. lib.
4.  Vincule sua DLL MSP com a biblioteca MSPBaseSample. lib.
5.  Inclua Mspbase. h do SDK para definições de classe base MSP.
6.  Implemente suas exportações de DLL (por exemplo, DllMain). Microsoft Visual C++ irá gerá-los para você. Em DllMain, em DLL \_ processo \_ anexar e \_ \_ reanexar processo dll, respectivamente, use as macros **MSPLOGREGISTER** e **MSPLOGDEREGISTER** para habilitar os recursos de log para sua dll. Especifique o nome da sua DLL na chamada **MSPLOGDEREGISTER** .
7.  Use a macro de LOG, definida em Msplog. h, para gerar mensagens de rastreamento da mesma maneira que as classes base. Defina o símbolo de pré-processador MSPLOG para incluir o registro em log em sua DLL; Deixe-o indefinido para criar uma DLL que não tenha registro em log.
8.  Derive uma classe de CMSPAddress que implementa endereços para seu MSP. Declare um mapa de objeto ATL global que instrui a ATL a criar uma instância de sua classe Address quando solicitado a **Cocriar** no CLSID especificado em seu arquivo IDL. Além disso, derive sua classe address do modelo ATL **CComCoClass** e inclua uma \_ declaração Declare Registry \_ ResourceId em sua classe address. Construa um script de recurso e um arquivo de cabeçalho correspondentes, como para qualquer outra DLL de COM ATL.
9.  Implemente as substituições de CMSPAddress necessárias para sua classe de endereço. Para [**MSPAddressAddRef**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressaddref) e [**MSPAddressRelease**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressrelease), chame os modelos de função auxiliar fornecidos. Para [**GetCallMediaTypes**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-getcallmediatypes), basta retornar um bitmap **DWORD** com todas as suas TAPIMEDIAMODEs or com suporte para MSP juntas. Para [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) e [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall), retorne e \_ NOTIMPL e compile e vincule seu MSP neste ponto. Agora, verifique se você pode registrar e criar uma instância do MSP a partir de aplicativos TAPI 3, mas não criar chamadas com êxito.
10. Derive uma classe de CMSPCallMultiGraph para implementar seus objetos de chamada MSP. Talvez você queira derivar de [**CMSPCallBase**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallbase) em vez de [**CMSPCallMultiGraph**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallmultigraph) se o modelo Filter-grafo-per-Stream não atender aos seus requisitos; Isso aumentará a complexidade da tarefa (no momento da redação deste artigo, todos os MSPs derivarão objetos de chamada diretamente do **CMSPCallMultiGraph**). No seu objeto de endereço, implemente [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) e [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall) para criar e desligar seu tipo específico de objeto de chamada usando os modelos de função auxiliar fornecidos. Em seu objeto de chamada, substitua [**Createstreamobject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) para retornar E \_ NOTIMPL. Substitua [**MSPCallAddRef**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcalladdref) e [**MSPCallRelease**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcallrelease) de maneira idêntica aos métodos de endereço correspondentes. Novamente, você deve ser capaz de compilar e vincular seu MSP; Agora, ele deve ser capaz de criar e desligar chamadas, mas as chamadas não farão streaming útil.
11. Derive uma classe de CMSPStream para implementar seus objetos de fluxo MSP. Em seu objeto de chamada, implemente [**Createstreamobject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) para criar e inicializar seu objeto Stream (normalmente chamando o ATL **CreateInstance** seguido pelo ATL **\_ InternalQueryInterface** para [**ITStream**](/windows/win32/api/tapi3if/nn-tapi3if-itstream) seguido chamando **init** no seu objeto Stream). Para dar suporte a um número fixo de fluxos (isso é comum para MSPs que não dão suporte à modificação de configurações de fluxo por outros pontos de extremidade na chamada), substitua **init**, [**CreateStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-createstream)e [**RemoveStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-removestream) em seu objeto de chamada. (A chamada **init** cria todos os fluxos inicialmente, e **CreateStream** e **RemoveStream** retornam os códigos de erro TAPI apropriados para impedir que o aplicativo crie ou remova fluxos). Caso contrário, substitua o método **init** da chamada para criar alguma configuração padrão inicial de fluxos usando os tipos de mídia solicitados para a chamada. Ao criar qualquer objeto de fluxo padrão no método **init** de sua chamada, use o método auxiliar [**InternalCreateStream**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-internalcreatestream) .
12. Implemente seu objeto Stream. A única substituição necessária é o método [**Get \_ Name**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-get_name) , que simplesmente retorna um nome amigável para o fluxo. Além disso, será necessário substituir vários outros métodos. Exatamente quais métodos substituir dependem de sua implementação e quando você decide executar as várias tarefas envolvidas na construção e na desconstrução de seu gráfico de filtro. Essas tarefas incluem a criação de filtros de "transporte" apropriados, codecs e assim por diante, e a inserção deles e sua remoção dos gráficos de filtro nos horários apropriados. Você também precisará usar a interface [**ITTerminalControl**](/windows/desktop/api/Termmgr/nn-termmgr-itterminalcontrol) em objetos de terminal para conectar os terminais selecionados aos seus fluxos. Talvez você queira substituir [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal) e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) no seu objeto de fluxo para limitar as configurações de terminal que seus fluxos aceitarão; limitar cada fluxo a um único terminal simplificará, especialmente, a construção de seus gráficos de filtro, mas sacrificará a funcionalidade do aplicativo, como visualização de vídeo. Dependendo de sua implementação, você posicionará a construção do grafo, a deconstrução e o código de conexão do terminal nos métodos [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**Initialize**](/windows/desktop/api/msp/nf-msp-itmspaddress-initialize), [**Shutdown**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdown), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , ou em seus próprios métodos com base na comunicação do tsp privado. Lembre-se de que um fluxo sem terminais selecionado deve controlar o estado do grafo desejado; uma chamada de **StartStream** seguida de uma chamada de **SelectTerminal** nesse fluxo deve resultar em um fluxo de dados. Substitua a maioria desses métodos para garantir que a construção, a desconstrução, a conexão e a desconexão corretas ocorram em cada caso, dependendo do estado do fluxo.
13. Implemente sua comunicação do TSP. Substitua [**CMSPAddress:: ReceiveTSPAddressData**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-receivetspaddressdata) e/ou [**CMSPCallBase:: ReceiveTSPCallData**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-receivetspcalldata)e/ou chamando [**IsEvent**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-postevent) no seu objeto address ou [**HandleStreamEvent**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-handlestreamevent) em seu objeto de chamada (de seus objetos Call ou Stream).
14. Use o CreateEvent em seu objeto address ou HandleStreamEvent em seu objeto de chamada (de seus objetos Call ou Stream) para enviar eventos de mídia de chamada para o aplicativo por meio de Tapi3.dll. Normalmente, você fará isso em seu objeto Stream, em métodos substituídos, incluindo os métodos [**ProcessGraphEvent**](/windows/desktop/api/Mspstrm/nf-mspstrm-cmspstream-processgraphevent), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , dependendo de como você implementa seus fluxos.
15. Implemente quaisquer interfaces privadas ou subfluxos desejados em seus objetos existentes (endereço, chamada e fluxo). Normalmente, não há nenhum. Lembre-se de que, ao implementar suas interfaces privadas, especifique o LIBID de sua biblioteca de tipos do seu arquivo IDL. Ou seja, os programadores de aplicativos devem usar sua biblioteca de tipos MSP ao usar suas interfaces personalizadas. As interfaces padrão do MSP, implementadas nas classes base MSP, usam o Tapi3.dll LIBID e, portanto, são acessíveis a todos os aplicativos TAPI 3.
16. Se estiver implementando objetos de terminal estáticos ou dinâmicos específicos do MSP para os terminais estáticos padrão (não típicos), você poderá usar as classes base de terminal fornecidas. Você precisará substituir vários métodos em seu objeto de endereço para fornecer métodos alternativos ou adicionais de criação de objetos de terminal.
17. Implemente a interface IObjectSafety em seus objetos de endereço, chamada, fluxo e terminal. Para usar o [mapeador de expedição](dispatch-mapper.md) para consultar interfaces em seus objetos msp, marque seus objetos como seguros para scripts nessas interfaces. Para fazer isso, implemente a interface **IObjectSafety** em seu objeto. Derivar de **CMSPObjectSafetyImpl** (uma classe auxiliar fornecida em Msputils. h) e adicionar **IOBJECTSAFETY** ao mapa com ATL de sua classe \_ tornará seus objetos seguros para scripts em todas as interfaces que eles expõem. Lembre-se de que o uso do mapeador de expedição em objetos MSP pode ser implícito. O endereço MSP e a chamada MSP são agregados por endereços TAPI e objetos de chamada TAPI. Se o mapeador de expedição for usado nos objetos TAPI para consultar as interfaces expostas pelos objetos MSP agregados, os objetos MSP agregados serão consultados quanto à segurança das interfaces solicitadas.

 

 
