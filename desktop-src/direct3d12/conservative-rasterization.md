---
title: Rasterização de Direct3D 12 conservador
description: A rasterização conservadora adiciona alguma certeza à renderização de pixels, que é útil em particular aos algoritmos de detecção de colisão.
ms.assetid: 081199AD-1702-4EC8-95AD-B1148C676199
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4e4fae3489d54ab7b6b7abfda56f54dd8d970962
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548323"
---
# <a name="direct3d-12-conservative-rasterization"></a><span data-ttu-id="9346a-103">Rasterização de Direct3D 12 conservador</span><span class="sxs-lookup"><span data-stu-id="9346a-103">Direct3D 12 Conservative Rasterization</span></span>

<span data-ttu-id="9346a-104">A rasterização conservadora adiciona alguma certeza à renderização de pixels, que é útil em particular aos algoritmos de detecção de colisão.</span><span class="sxs-lookup"><span data-stu-id="9346a-104">Conservative Rasterization adds some certainty to pixel rendering, which is helpful in particular to collision detection algorithms.</span></span>

-   [<span data-ttu-id="9346a-105">Visão geral</span><span class="sxs-lookup"><span data-stu-id="9346a-105">Overview</span></span>](#overview)
-   [<span data-ttu-id="9346a-106">Interações com o pipeline</span><span class="sxs-lookup"><span data-stu-id="9346a-106">Interactions with the pipeline</span></span>](#interactions-with-the-pipeline)
    -   [<span data-ttu-id="9346a-107">Interação de regras de rasterização</span><span class="sxs-lookup"><span data-stu-id="9346a-107">Rasterization Rules interaction</span></span>](#rasterization-rules-interaction)
    -   [<span data-ttu-id="9346a-108">Interação de multiamostrar</span><span class="sxs-lookup"><span data-stu-id="9346a-108">Multisampling interaction</span></span>](#multisampling-interaction)
    -   [<span data-ttu-id="9346a-109">Interação SampleMask</span><span class="sxs-lookup"><span data-stu-id="9346a-109">SampleMask interaction</span></span>](#samplemask-interaction)
    -   [<span data-ttu-id="9346a-110">Interação de teste de profundidade/estêncil</span><span class="sxs-lookup"><span data-stu-id="9346a-110">Depth/Stencil Test interaction</span></span>](#depthstencil-test-interaction)
    -   [<span data-ttu-id="9346a-111">Interação do pixel do auxiliar</span><span class="sxs-lookup"><span data-stu-id="9346a-111">Helper Pixel interaction</span></span>](#helper-pixel-interaction)
    -   [<span data-ttu-id="9346a-112">Interação de cobertura de saída</span><span class="sxs-lookup"><span data-stu-id="9346a-112">Output Coverage interaction</span></span>](#output-coverage-interaction)
    -   [<span data-ttu-id="9346a-113">Interação InputCoverage</span><span class="sxs-lookup"><span data-stu-id="9346a-113">InputCoverage interaction</span></span>](#inputcoverage-interaction)
    -   [<span data-ttu-id="9346a-114">Interação InnerCoverage</span><span class="sxs-lookup"><span data-stu-id="9346a-114">InnerCoverage interaction</span></span>](#innercoverage-interaction)
    -   [<span data-ttu-id="9346a-115">Interação de interpolação de atributo</span><span class="sxs-lookup"><span data-stu-id="9346a-115">Attribute Interpolation interaction</span></span>](#attribute-interpolation-interaction)
    -   [<span data-ttu-id="9346a-116">Interação de recorte</span><span class="sxs-lookup"><span data-stu-id="9346a-116">Clipping interaction</span></span>](#clipping-interaction)
    -   [<span data-ttu-id="9346a-117">Interação de distância do clipe</span><span class="sxs-lookup"><span data-stu-id="9346a-117">Clip Distance interaction</span></span>](#clip-distance-interaction)
    -   [<span data-ttu-id="9346a-118">Interação de rasterização independente de destino</span><span class="sxs-lookup"><span data-stu-id="9346a-118">Target Independent Rasterization interaction</span></span>](#target-independent-rasterization-interaction)
    -   [<span data-ttu-id="9346a-119">Interação da topologia primitiva de IA</span><span class="sxs-lookup"><span data-stu-id="9346a-119">IA Primitive Topology interaction</span></span>](#ia-primitive-topology-interaction)
    -   [<span data-ttu-id="9346a-120">Interação de consulta</span><span class="sxs-lookup"><span data-stu-id="9346a-120">Query interaction</span></span>](#query-interaction)
    -   [<span data-ttu-id="9346a-121">Seleção de interação de estado</span><span class="sxs-lookup"><span data-stu-id="9346a-121">Cull State interaction</span></span>](#cull-state-interaction)
    -   [<span data-ttu-id="9346a-122">Interação IsFrontFace</span><span class="sxs-lookup"><span data-stu-id="9346a-122">IsFrontFace interaction</span></span>](#isfrontface-interaction)
    -   [<span data-ttu-id="9346a-123">Interação dos modos de preenchimento</span><span class="sxs-lookup"><span data-stu-id="9346a-123">Fill Modes interaction</span></span>](#fill-modes-interaction)
-   [<span data-ttu-id="9346a-124">Detalhes da implementação</span><span class="sxs-lookup"><span data-stu-id="9346a-124">Implementation details</span></span>](#implementation-details)
-   [<span data-ttu-id="9346a-125">Resumo da API</span><span class="sxs-lookup"><span data-stu-id="9346a-125">API summary</span></span>](#api-summary)
-   [<span data-ttu-id="9346a-126">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="9346a-126">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="9346a-127">Visão geral</span><span class="sxs-lookup"><span data-stu-id="9346a-127">Overview</span></span>

<span data-ttu-id="9346a-128">A rasterização conservadora significa que todos os pixels que estão pelo menos parcialmente cobertos por um primitivo renderizado são rasterizados, o que significa que o sombreador de pixel é invocado.</span><span class="sxs-lookup"><span data-stu-id="9346a-128">Conservative Rasterization means that all pixels that are at least partially covered by a rendered primitive are rasterized, which means that the pixel shader is invoked.</span></span> <span data-ttu-id="9346a-129">O comportamento normal é a amostragem, que não é usada se a rasterização conservadora estiver habilitada.</span><span class="sxs-lookup"><span data-stu-id="9346a-129">Normal behavior is sampling, which is not used if Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="9346a-130">A rasterização conservadora é útil em várias situações, incluindo para ter certeza na detecção de colisão, na remoção de oclusão e na renderização de ladrilhos.</span><span class="sxs-lookup"><span data-stu-id="9346a-130">Conservative Rasterization is useful in a number of situations, including for certainty in collision detection, occlusion culling, and tiled rendering.</span></span>

<span data-ttu-id="9346a-131">Por exemplo, a figura a seguir mostra um triângulo verde renderizado usando a rasterização conservadora, como apareceria no rasterizador (ou seja, usando as coordenadas de vértice de ponto fixo 16,8).</span><span class="sxs-lookup"><span data-stu-id="9346a-131">For example, the following figure shows a green triangle rendered using Conservative Rasterization, as it would appear in the rasterizer (that is, using 16.8 fixed point vertex coordinates).</span></span> <span data-ttu-id="9346a-132">A área Brown é conhecida como "região incerteza" – uma região conceitual que representa os limites estendidos do triângulo, necessários para garantir que o primitivo no rasterizador seja conservador em relação às coordenadas do vértice do ponto flutuante original.</span><span class="sxs-lookup"><span data-stu-id="9346a-132">The brown area is known as an "uncertainty region" - a conceptual region that represents the extended bounds of the triangle, required to ensure the primitive in the rasterizer is conservative with respect to the original floating point vertex coordinates.</span></span> <span data-ttu-id="9346a-133">Os quadrados vermelhos em cada vértice mostram como a região de incertezas é calculada: como um quadrado removido.</span><span class="sxs-lookup"><span data-stu-id="9346a-133">The red squares at each vertex shows how the uncertainty region is calculated: as a swept square.</span></span>

<span data-ttu-id="9346a-134">Os quadrados cinzas grandes mostram os pixels que serão renderizados.</span><span class="sxs-lookup"><span data-stu-id="9346a-134">The large gray squares show the pixels that will be rendered.</span></span> <span data-ttu-id="9346a-135">Os quadrados rosa mostram pixels renderizados usando a "regra de cima para a esquerda", que entra em cena, pois a borda do triângulo cruza a borda dos pixels.</span><span class="sxs-lookup"><span data-stu-id="9346a-135">The pink squares show pixels rendered using the "Top-Left Rule", which comes into play as the edge of the triangle crosses the edge of the pixels.</span></span> <span data-ttu-id="9346a-136">Pode haver falsos positivos (conjunto de pixels que não deveriam ter sido) que o sistema normalmente, mas nem sempre irá fazer a seleção.</span><span class="sxs-lookup"><span data-stu-id="9346a-136">There can be false positives (pixels set that should not have been) which the system will normally but not always cull.</span></span>

![a regra superior esquerda](images/conservative-rasterization-0.png)

## <a name="interactions-with-the-pipeline"></a><span data-ttu-id="9346a-138">Interações com o pipeline</span><span class="sxs-lookup"><span data-stu-id="9346a-138">Interactions with the pipeline</span></span>

### <a name="rasterization-rules-interaction"></a><span data-ttu-id="9346a-139">Interação de regras de rasterização</span><span class="sxs-lookup"><span data-stu-id="9346a-139">Rasterization Rules interaction</span></span>

<span data-ttu-id="9346a-140">No modo de rasterização conservadora, as regras de rasterização se aplicam da mesma maneira que quando o modo de rasterização conservador não está habilitado com exceções para a regra de Top-Left, descrita acima e cobertura de pixel.</span><span class="sxs-lookup"><span data-stu-id="9346a-140">In Conservative Rasterization mode, Rasterization Rules apply the same way as when Conservative Rasterization mode is not enabled with exceptions for the Top-Left Rule, described above, and Pixel Coverage.</span></span> <span data-ttu-id="9346a-141">16,8 a precisão do rasterizador Fixed-Point deve ser usada.</span><span class="sxs-lookup"><span data-stu-id="9346a-141">16.8 Fixed-Point Rasterizer precision must be used.</span></span>

<span data-ttu-id="9346a-142">Pixels que não seriam abordados se o hardware estivesse usando coordenadas de vértice de ponto flutuante completo só pode ser incluído se estiverem dentro de uma região de incertezas que não tenham uma metade maior de um pixel no domínio de ponto fixo.</span><span class="sxs-lookup"><span data-stu-id="9346a-142">Pixels that would not be covered if hardware was using full floating point vertex coordinates may only be included if they are within an uncertainty region no larger half a pixel in the fixed point domain.</span></span> <span data-ttu-id="9346a-143">Espera-se que o hardware futuro atinja a região de incertezas rígida especificada na camada 2.</span><span class="sxs-lookup"><span data-stu-id="9346a-143">Future hardware is expected to reach the tightened uncertainty region specified in Tier 2.</span></span> <span data-ttu-id="9346a-144">Observe que esse requisito impede que os triângulos prata estendam além do necessário.</span><span class="sxs-lookup"><span data-stu-id="9346a-144">Note that this requirement prevents sliver triangles from extending further than necessary.</span></span>

<span data-ttu-id="9346a-145">Uma região de incerteza válida semelhante também se aplica a `InnerCoverage` , mas é mais rígida porque nenhuma implementação requer uma região de incerteza maior para esse caso.</span><span class="sxs-lookup"><span data-stu-id="9346a-145">A similar valid uncertainty region applies to `InnerCoverage` as well, but it is tighter since no implementations require a larger uncertainty region for this case.</span></span> <span data-ttu-id="9346a-146">Consulte a [interação do InnerCoverage](#innercoverage-interaction) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="9346a-146">See [InnerCoverage interaction](#innercoverage-interaction) for more detail.</span></span>

<span data-ttu-id="9346a-147">As regiões de incerteza internas e externas devem ser maiores ou iguais ao tamanho da metade da grade de subpixel, ou 1/512 de um pixel, no domínio de ponto fixo.</span><span class="sxs-lookup"><span data-stu-id="9346a-147">Inner and outer uncertainty regions must be greater than or equal to the size of half the sub-pixel grid, or 1/512 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="9346a-148">Esta é a região mínima de incerteza válida.</span><span class="sxs-lookup"><span data-stu-id="9346a-148">This is the minimum valid uncertainty region.</span></span> <span data-ttu-id="9346a-149">1/512 vem da representação de coordenada do rasterizador de ponto fixo 16,8 e a regra de ida e volta mais próxima que se aplica ao converter coordenadas de vértice de ponto flutuante para 16,8 coordenadas de ponto fixo.</span><span class="sxs-lookup"><span data-stu-id="9346a-149">1/512 comes from the 16.8 fixed point Rasterizer coordinate representation and the round-to-nearest rule that applies when converting floating point vertex coordinates to 16.8 fixed point coordinates.</span></span> <span data-ttu-id="9346a-150">1/512 poderá alterar se a precisão do rasterizador for alterada.</span><span class="sxs-lookup"><span data-stu-id="9346a-150">1/512 can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="9346a-151">Se uma implementação implementar essa região de incerteza mínima, ela deverá seguir a regra de Top-Left quando uma borda ou canto da região incerteza estiver ao longo da borda ou do canto de um pixel.</span><span class="sxs-lookup"><span data-stu-id="9346a-151">If an implementation implements this minimum uncertainty region, then they must follow the Top-Left Rule when an edge or corner of the uncertainty region falls along the edge or corner of a pixel.</span></span> <span data-ttu-id="9346a-152">As bordas recortadas da região incerteza devem ser tratadas como o vértice mais próximo, o que significa que ela conta como duas bordas: as duas que ingressam no vértice associado.</span><span class="sxs-lookup"><span data-stu-id="9346a-152">The clipped edges of the uncertainty region should be treated as the closest vertex, meaning that it counts as two edges: the two that join at the associated vertex.</span></span> <span data-ttu-id="9346a-153">Top-Left regra é necessária quando a região de incerteza mínima é usada porque, se não for, uma implementação de rasterização conservadora falhará ao rasterizar os pixels que poderiam ser cobertos quando o modo de rasterização conservador estiver desabilitado.</span><span class="sxs-lookup"><span data-stu-id="9346a-153">Top-Left Rule is required when the minimum uncertainty region is used because if it is not, then a Conservative Rasterization implementation would fail to rasterize pixels that could be covered when Conservative Rasterization mode is disabled.</span></span>

<span data-ttu-id="9346a-154">O diagrama a seguir ilustra uma região de incerteza externa válida produzida por meio da varredura de um quadrado em volta das bordas do primitivo no domínio de ponto fixo (ou seja, os vértices foram quantificados pela representação de ponto fixo 16,8).</span><span class="sxs-lookup"><span data-stu-id="9346a-154">The following diagram illustrates a valid outer uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="9346a-155">As dimensões desse quadrado se baseiam no tamanho de região de incerteza externa válido: para 1/2 de um pixel, o quadrado é de 1 pixel em largura e altura, para 1/512 de um pixel, o quadrado é 1/256 de um pixel em largura e altura.</span><span class="sxs-lookup"><span data-stu-id="9346a-155">The dimensions of this square are based on the valid outer uncertainty region size: for the 1/2 of a pixel, the square is 1 pixel in width and height, for 1/512 of a pixel, the square is 1/256 of a pixel in width and height.</span></span> <span data-ttu-id="9346a-156">O triângulo verde representa um determinado primitivo, a linha vermelha pontilhada representa o limite na rasterização conservadora estimada, os quadrados pretos sólidos representam o quadrado removido ao longo das bordas primitivas e a área quadriculada azul é a região de incerteza externa:</span><span class="sxs-lookup"><span data-stu-id="9346a-156">The green triangle represents a given primitive, the red dotted line represents the bound on Overestimated Conservative Rasterization, the solid black squares represent the square that is swept along the primitive edges, and the blue checkered area is the outer uncertainty region:</span></span>

![região de incerteza externa.](images/outercoverage.jpg)

### <a name="multisampling-interaction"></a><span data-ttu-id="9346a-158">Interação de multiamostrar</span><span class="sxs-lookup"><span data-stu-id="9346a-158">Multisampling interaction</span></span>

<span data-ttu-id="9346a-159">Independentemente do número de amostras em superfícies **renderTarget** / **DepthStencil** (ou se o *ForcedSampleCount* está sendo usado ou não), todos os exemplos são cobertos por pixels rasterizados pela rasterização conservadora.</span><span class="sxs-lookup"><span data-stu-id="9346a-159">Regardless of the number of samples in **RenderTarget**/**DepthStencil** surfaces (or whether *ForcedSampleCount* is being used or not), all samples are covered for pixels rasterized by Conservative Rasterization.</span></span> <span data-ttu-id="9346a-160">Os locais de exemplo individuais não são testados para se eles se enquadram no primitivo ou não.</span><span class="sxs-lookup"><span data-stu-id="9346a-160">Individual sample locations are not tested for whether they fall in the primitive or not.</span></span>

### <a name="samplemask-interaction"></a><span data-ttu-id="9346a-161">Interação SampleMask</span><span class="sxs-lookup"><span data-stu-id="9346a-161">SampleMask interaction</span></span>

<span data-ttu-id="9346a-162">O estado do rasterizador *SampleMask* se aplica da mesma maneira que quando a rasterização conservadora não está habilitada para `InputCoverage` , mas não afeta `InnerCoverage` (ou seja, não está AND'ed em uma entrada declarada com `InnerCoverage` ).</span><span class="sxs-lookup"><span data-stu-id="9346a-162">The *SampleMask* Rasterizer State applies the same way as when Conservative Rasterization is not enabled for `InputCoverage`, but does not affect `InnerCoverage` (i.e. it is not AND’ed into an input declared with `InnerCoverage`).</span></span> <span data-ttu-id="9346a-163">Isso ocorre porque `InnerCoverage` o não está relacionado a se os exemplos de MSAA são mascarados: 0 `InnerCoverage` apenas significa que não há garantia de que o pixel seja totalmente coberto, não que nenhum exemplo seja atualizado.</span><span class="sxs-lookup"><span data-stu-id="9346a-163">This is because `InnerCoverage` is unrelated to whether MSAA samples are masked out: 0 `InnerCoverage` only means that the pixel is not guaranteed to be fully covered, not that no samples will be updated.</span></span>

### <a name="depthstencil-test-interaction"></a><span data-ttu-id="9346a-164">Interação de teste de profundidade/estêncil</span><span class="sxs-lookup"><span data-stu-id="9346a-164">Depth/Stencil Test interaction</span></span>

<span data-ttu-id="9346a-165">O teste de profundidade/estêncil prossegue para um pixel com rasterização conservadora da mesma forma como se todas as amostras forem cobertas quando a rasterização conservadora não estiver habilitada.</span><span class="sxs-lookup"><span data-stu-id="9346a-165">Depth/Stencil Testing proceeds for a conservatively rasterized pixel the same way as if all samples are covered when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="9346a-166">Continuar com todos os exemplos cobertos pode causar extrapolação de profundidade, que é válida e deve ser clampedda ao visor, conforme especificado quando a rasterização conservadora não está habilitada.</span><span class="sxs-lookup"><span data-stu-id="9346a-166">Proceeding with all samples covered can cause Depth Extrapolation, which is valid and must be clamped to the viewport as specified when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="9346a-167">Isso é semelhante a quando os modos de interpolação de frequência de pixel são usados em um **renderTarget** com contagem de amostra maior que 1, embora no caso de uma rasterização conservadora, é o valor de profundidade que vai para o teste de profundidade de função fixa que pode ser extrapolado.</span><span class="sxs-lookup"><span data-stu-id="9346a-167">This is similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1, although in the case of Conservative Rasterization, it is the depth value going into the fixed function depth test that can be extrapolated.</span></span>

<span data-ttu-id="9346a-168">O comportamento de remoção de profundidade antecipada com extrapolação de profundidade é indefinido.</span><span class="sxs-lookup"><span data-stu-id="9346a-168">Early Depth culling behavior with Depth Extrapolation is undefined.</span></span> <span data-ttu-id="9346a-169">Isso ocorre porque alguma profundidade antecipada que escolhe o hardware não pode dar suporte adequado a valores de profundidade extrapolados.</span><span class="sxs-lookup"><span data-stu-id="9346a-169">This is because some Early Depth culling hardware cannot properly support extrapolated depth values.</span></span> <span data-ttu-id="9346a-170">No entanto, o comportamento de remoção de profundidade antecipada na presença da extrapolação de profundidade é problemática até mesmo com hardware que pode dar suporte a valores de profundidade extrapolados.</span><span class="sxs-lookup"><span data-stu-id="9346a-170">However, Early Depth culling behavior in the presence of Depth Extrapolation is problematic even with hardware that can support extrapolated depth values.</span></span> <span data-ttu-id="9346a-171">Esse problema pode ser solucionado por fixação MSS a profundidade de entrada do sombreador de pixel para os valores de profundidade mín. e máx. do primitivo que está sendo rasterizado e grava esse valor em `oDepth` (o registro de profundidade de saída do sombreador de pixel).</span><span class="sxs-lookup"><span data-stu-id="9346a-171">This issue can be worked around by clamping the Pixel Shader input depth to the min and max depth values of the primitive being rasterized and writing that value to `oDepth` (the pixel shader output depth register).</span></span> <span data-ttu-id="9346a-172">As implementações são necessárias para desabilitar a remoção de profundidade inicial nesse caso, devido à `oDepth` gravação.</span><span class="sxs-lookup"><span data-stu-id="9346a-172">Implementations are required to disable Early Depth culling in this case, due to the `oDepth` write.</span></span>

### <a name="helper-pixel-interaction"></a><span data-ttu-id="9346a-173">Interação do pixel do auxiliar</span><span class="sxs-lookup"><span data-stu-id="9346a-173">Helper Pixel interaction</span></span>

<span data-ttu-id="9346a-174">As regras de pixel do auxiliar se aplicam da mesma maneira que quando a rasterização conservadora não está habilitada.</span><span class="sxs-lookup"><span data-stu-id="9346a-174">Helper Pixel rules apply the same way as when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="9346a-175">Como parte disso, todos os pixels, incluindo os pixels auxiliares, devem relatar `InputCoverage` precisamente conforme especificado na `InputCoverage` seção de interação.</span><span class="sxs-lookup"><span data-stu-id="9346a-175">As part of this, all pixels including Helper Pixels must report `InputCoverage` accurately as specified in the `InputCoverage` interaction section.</span></span> <span data-ttu-id="9346a-176">Portanto, os pixels totalmente não cobertos pelo relatório 0 de cobertura.</span><span class="sxs-lookup"><span data-stu-id="9346a-176">So fully non-covered pixels report 0 coverage.</span></span>

### <a name="output-coverage-interaction"></a><span data-ttu-id="9346a-177">Interação de cobertura de saída</span><span class="sxs-lookup"><span data-stu-id="9346a-177">Output Coverage interaction</span></span>

<span data-ttu-id="9346a-178">A cobertura de saída ( `oMask` ) se comporta para um pixel com rasterização conservadora como faz quando a rasterização conservadora não está habilitada com todos os exemplos cobertos.</span><span class="sxs-lookup"><span data-stu-id="9346a-178">Output Coverage (`oMask`) behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

### <a name="inputcoverage-interaction"></a><span data-ttu-id="9346a-179">Interação InputCoverage</span><span class="sxs-lookup"><span data-stu-id="9346a-179">InputCoverage interaction</span></span>

<span data-ttu-id="9346a-180">No modo de rasterização conservador, esse registro de entrada é preenchido como se todas as amostras forem cobertas quando a rasterização conservadora não estiver habilitada para um determinado pixel rasterizado conservadoramente.</span><span class="sxs-lookup"><span data-stu-id="9346a-180">In Conservative Rasterization mode, this input register is populated as if all samples are covered when Conservative Rasterization is not enabled for a given conservatively rasterized pixel.</span></span> <span data-ttu-id="9346a-181">Isso significa que todas as interações existentes se aplicam (por exemplo, *SampleMask* é aplicado) e os primeiros n bits de `InputCoverage` de LSB são definidos como 1 para um pixel com rasterização conservadora, dada uma amostra n por pixel **renderTarget** e/ou **DepthStencil** buffer associado na **fusão de saída** ou um *ForcedSampleCount* de exemplo n.</span><span class="sxs-lookup"><span data-stu-id="9346a-181">That is to say, all existing interactions apply (e.g. *SampleMask* is applied), and the first n bits in `InputCoverage` from the LSB are set to 1 for a conservatively rasterized pixel, given an n sample per pixel **RenderTarget** and/or **DepthStencil** buffer bound at the **Output Merger**, or an n sample *ForcedSampleCount*.</span></span> <span data-ttu-id="9346a-182">O restante dos bits é 0.</span><span class="sxs-lookup"><span data-stu-id="9346a-182">The rest of the bits are 0.</span></span>

<span data-ttu-id="9346a-183">Essa entrada está disponível em um sombreador independentemente do uso de uma rasterização conservadora, embora a rasterização conservadora altere seu comportamento para mostrar apenas todos os exemplos cobertos (ou nenhum para pixels auxiliares).</span><span class="sxs-lookup"><span data-stu-id="9346a-183">This input is available in a shader regardless of the use of Conservative Rasterization, though Conservative Rasterization changes its behavior to only show all samples covered (or none for Helper Pixels).</span></span>

### <a name="innercoverage-interaction"></a><span data-ttu-id="9346a-184">Interação InnerCoverage</span><span class="sxs-lookup"><span data-stu-id="9346a-184">InnerCoverage interaction</span></span>

<span data-ttu-id="9346a-185">Esse recurso é exigido pelo, e só está disponível no, camada 3.</span><span class="sxs-lookup"><span data-stu-id="9346a-185">This feature is required by, and only available in, Tier 3.</span></span> <span data-ttu-id="9346a-186">O tempo de execução falhará na criação de sombreador para sombreadores que usam esse modo quando uma implementação dá suporte a uma camada menor que a camada 3.</span><span class="sxs-lookup"><span data-stu-id="9346a-186">The runtime will fail shader creation for shaders that use this mode when an implementation supports a Tier less than Tier 3.</span></span>

<span data-ttu-id="9346a-187">O sombreador de pixel tem um sistema inteiro escalar de 32 bits que gera o valor disponível: `InnerCoverage` .</span><span class="sxs-lookup"><span data-stu-id="9346a-187">The Pixel Shader has a 32-bit scalar integer System Generate Value available: `InnerCoverage`.</span></span> <span data-ttu-id="9346a-188">Esse é um campo de bits que tem um bit 0 do LSB definido como 1 para um determinado pixel rasterizado conservadoramente, somente quando esse pixel tem a garantia de estar inteiramente dentro do primitivo atual.</span><span class="sxs-lookup"><span data-stu-id="9346a-188">This is a bit-field that has bit 0 from the LSB set to 1 for a given conservatively rasterized pixel, only when that pixel is guaranteed to be entirely inside the current primitive.</span></span> <span data-ttu-id="9346a-189">Todos os outros bits de registro de entrada devem ser definidos como 0 quando o bit 0 não está definido, mas não é definido quando o bit 0 é definido como 1 (essencialmente, esse campo de bits representa um valor booliano em que false deve ser exatamente 0, mas true pode ser um valor diferente de zero (ou seja, 0)).</span><span class="sxs-lookup"><span data-stu-id="9346a-189">All other input register bits must be set to 0 when bit 0 is not set, but are undefined when bit 0 is set to 1 (essentially, this bit-field represents a Boolean value where false must be exactly 0, but true can be any odd (i.e. bit 0 set) non-zero value).</span></span> <span data-ttu-id="9346a-190">Essa entrada é usada para informações de rasterização conservadora subestimadas.</span><span class="sxs-lookup"><span data-stu-id="9346a-190">This input is used for underestimated Conservative Rasterization information.</span></span> <span data-ttu-id="9346a-191">Ele informa o sombreador de pixel se o pixel atual está completamente dentro da geometria.</span><span class="sxs-lookup"><span data-stu-id="9346a-191">It informs the Pixel Shader whether the current pixel lies completely inside the geometry.</span></span>

<span data-ttu-id="9346a-192">Isso deve considerar o erro de encaixe em resoluções maiores ou iguais à resolução na qual o empate atual está operando.</span><span class="sxs-lookup"><span data-stu-id="9346a-192">This must account for snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating.</span></span> <span data-ttu-id="9346a-193">Não deve haver falsos positivos (Configurando `InnerCoverage` bits quando o pixel não é totalmente coberto para qualquer erro de encaixe em resoluções maiores ou iguais à resolução na qual o empate atual está operando), mas falsos negativos são permitidos.</span><span class="sxs-lookup"><span data-stu-id="9346a-193">There must not be false positives (setting `InnerCoverage` bits when the pixel is not fully covered for any snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating), but false negatives are allowed.</span></span> <span data-ttu-id="9346a-194">Em resumo, a implementação não deve identificar incorretamente os pixels como totalmente cobertos que não seriam com coordenadas completas de vértice de ponto flutuante no rasterizador.</span><span class="sxs-lookup"><span data-stu-id="9346a-194">In summary, the implementation must not incorrectly identify pixels as fully covered that would not be with full floating point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="9346a-195">Os pixels que seriam totalmente cobertos se o hardware estivesse usando coordenadas de vértice de ponto flutuante completo só podem ser omitidos se interceptarem a região de incerteza interna, que não deve ser maior que o tamanho da grade de subpixel ou 1/256 de um pixel no domínio de ponto fixo.</span><span class="sxs-lookup"><span data-stu-id="9346a-195">Pixels that would be fully covered if hardware was using full floating point vertex coordinates may only be omitted if they intersect the inner uncertainty region, which must be no larger than the size of the sub-pixel grid, or 1/256 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="9346a-196">Dito outra forma, os pixels totalmente dentro do limite interno da região de incerteza interna devem ser marcados como totalmente cobertos.</span><span class="sxs-lookup"><span data-stu-id="9346a-196">Said another way, pixels entirely within the inner boundary of the inner uncertainty region must be marked as fully covered.</span></span> <span data-ttu-id="9346a-197">O limite interno da região incerteza é ilustrado no diagrama abaixo da linha pontilhada preta em negrito.</span><span class="sxs-lookup"><span data-stu-id="9346a-197">The inner boundary of the uncertainty region is illustrated in the diagram below by the bold black dotted line.</span></span> <span data-ttu-id="9346a-198">1/256 vem da representação de coordenada do rasterizador de ponto fixo 16,8, que pode ser alterada se a precisão do rasterizador for alterada.</span><span class="sxs-lookup"><span data-stu-id="9346a-198">1/256 comes from the 16.8 fixed point Rasterizer coordinate representation, which can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="9346a-199">Essa região de incerteza é suficiente para considerar o erro de ajuste causado pela conversão de coordenadas de vértice de ponto flutuante para coordenadas de vértice de ponto fixo no rasterizador.</span><span class="sxs-lookup"><span data-stu-id="9346a-199">This uncertainty region is enough to account for snapping error caused by the conversion of floating point vertex coordinates to fixed point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="9346a-200">Os mesmos requisitos de região de incerteza mínima de 1/512 definidos na interação de regras de rasterização também se aplicam aqui.</span><span class="sxs-lookup"><span data-stu-id="9346a-200">The same 1/512 minimum uncertainty region requirements defined in Rasterization Rules interaction apply here as well.</span></span>

<span data-ttu-id="9346a-201">O diagrama a seguir ilustra uma região de incerteza interna válida produzida por meio da varredura de um quadrado em volta das bordas do primitivo no domínio de ponto fixo (ou seja, os vértices foram quantificados pela representação de ponto fixo 16,8).</span><span class="sxs-lookup"><span data-stu-id="9346a-201">The following diagram illustrates a valid inner uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="9346a-202">As dimensões desse quadrado se baseiam no tamanho de região de incerteza interna válido: para 1/256 de um pixel, o quadrado é 1/128 de um pixel em largura e altura.</span><span class="sxs-lookup"><span data-stu-id="9346a-202">The dimensions of this square are based on the valid inner uncertainty region size: for 1/256 of a pixel, the square is 1/128 of a pixel in width and height.</span></span> <span data-ttu-id="9346a-203">O triângulo verde representa um determinado primitivo, a linha pontilhada preta em negrito representa o limite da região de incerteza interna, os quadrados pretos sólidos representam o quadrado removidodo ao longo das bordas primitivas, e a área quadriculada laranja é a região de incerteza interna:</span><span class="sxs-lookup"><span data-stu-id="9346a-203">The green triangle represents a given primitive, the bold black dotted line represents the boundary of the inner uncertainty region, the solid black squares represent the square that is swept along the primitive edges, and the orange checkered area is the inner uncertainty region:</span></span>

![incerteza interna reqion.](images/innercoverage.jpg)

<span data-ttu-id="9346a-205">O uso de não `InnerCoverage` afeta se um pixel é rasterizado de forma conservadora, ou seja, usar um desses `InputCoverage` modos não afeta quais pixels são rasterizados quando o modo de rasterização conservador está habilitado.</span><span class="sxs-lookup"><span data-stu-id="9346a-205">The use of `InnerCoverage` does not affect whether a pixel is conservatively rasterized, i.e. using one of these `InputCoverage` modes does not affect which pixels are rasterized when Conservative Rasterization mode is enabled.</span></span> <span data-ttu-id="9346a-206">Portanto, quando `InnerCoverage` é usado e o sombreador de pixel está processando um pixel que não é totalmente coberto pela geometria, seu valor será 0, mas a invocação do sombreador de pixel terá amostras atualizadas.</span><span class="sxs-lookup"><span data-stu-id="9346a-206">Therefore, when `InnerCoverage` is used and the Pixel Shader is processing a pixel that is not completely covered by the geometry its value will be 0, but the Pixel Shader invocation will have samples updated.</span></span> <span data-ttu-id="9346a-207">Isso é diferente de quando `InputCoverage` é 0, o que significa que nenhuma amostra será atualizada.</span><span class="sxs-lookup"><span data-stu-id="9346a-207">This is different from when `InputCoverage` is 0, meaning that no samples will be updated.</span></span>

<span data-ttu-id="9346a-208">Esta entrada é mutuamente exclusiva com `InputCoverage` : as duas não podem ser usadas.</span><span class="sxs-lookup"><span data-stu-id="9346a-208">This input is mutually exclusive with `InputCoverage` : both cannot be used.</span></span>

<span data-ttu-id="9346a-209">Para acessar `InnerCoverage` o, ele deve ser declarado como um único componente de um dos registros de entrada do sombreador de pixel.</span><span class="sxs-lookup"><span data-stu-id="9346a-209">To access `InnerCoverage`, it must be declared as a single component out of one of the Pixel Shader input registers.</span></span> <span data-ttu-id="9346a-210">O modo de interpolação na declaração deve ser constante (interpolação não se aplica).</span><span class="sxs-lookup"><span data-stu-id="9346a-210">The interpolation mode on the declaration must be constant (interpolation does not apply).</span></span>

<span data-ttu-id="9346a-211">O `InnerCoverage` campo de bits não é afetado por testes de profundidade/estêncil, nem ANDed com o estado do rasterizador *SampleMask* .</span><span class="sxs-lookup"><span data-stu-id="9346a-211">The `InnerCoverage` bit-field is not affected by depth/stencil tests, nor is it ANDed with the *SampleMask* Rasterizer state.</span></span>

<span data-ttu-id="9346a-212">Essa entrada só é válida no modo de rasterização conservadora.</span><span class="sxs-lookup"><span data-stu-id="9346a-212">This input is only valid in Conservative Rasterization mode.</span></span> <span data-ttu-id="9346a-213">Quando a rasterização conservadora não está habilitada, `InnerCoverage` o produz um valor indefinido.</span><span class="sxs-lookup"><span data-stu-id="9346a-213">When Conservative Rasterization is not enabled, `InnerCoverage` produces an undefined value.</span></span>

<span data-ttu-id="9346a-214">Invocações de sombreador de pixel causadas pela necessidade de pixels auxiliares, mas de outra forma não cobertas pelo primitivo, devem ter o `InnerCoverage` registro definido como 0.</span><span class="sxs-lookup"><span data-stu-id="9346a-214">Pixel Shader invocations caused by the need for Helper Pixels, but otherwise not covered by the primitive, must have the `InnerCoverage` register set to 0.</span></span>

### <a name="attribute-interpolation-interaction"></a><span data-ttu-id="9346a-215">Interação de interpolação de atributo</span><span class="sxs-lookup"><span data-stu-id="9346a-215">Attribute Interpolation interaction</span></span>

<span data-ttu-id="9346a-216">Os modos de interpolação de atributo são inalterados e prosseguem da mesma maneira que quando a rasterização conservadora não está habilitada, onde os vértices de escala de visor e de ponto fixo são usados.</span><span class="sxs-lookup"><span data-stu-id="9346a-216">Attribute interpolation modes are unchanged and proceed the same way as when Conservative Rasterization is not enabled, where the viewport-scaled and fixed-point-converted vertices are used.</span></span> <span data-ttu-id="9346a-217">Como todos os exemplos em um pixel rasterizado conservadormente são considerados cobertos, é válido que os valores sejam extrapolados, semelhante a quando os modos de interpolação de frequência de pixels são usados em um **renderTarget** com contagem de exemplo maior que 1.</span><span class="sxs-lookup"><span data-stu-id="9346a-217">Because all samples in a conservatively rasterized pixel are considered covered, it is valid for values to be extrapolated, similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1.</span></span> <span data-ttu-id="9346a-218">Os modos de interpolação de centróide produzem resultados idênticos ao modo de interpolação não-centróide correspondente; a noção de centróide não faz sentido nesse cenário, em que a cobertura de amostra é apenas completa ou 0.</span><span class="sxs-lookup"><span data-stu-id="9346a-218">Centroid interpolation modes produce results identical to the corresponding non-centroid interpolation mode; the notion of centroid is meaningless in this scenario – where sample coverage is only either full or 0.</span></span>

<span data-ttu-id="9346a-219">A rasterização conservadora permite que triângulos de degeneração gerem invocações de sombreador de pixel, portanto, os triângulos de degeneração devem usar os valores atribuídos ao vértice 0 para todos os valores interpolados.</span><span class="sxs-lookup"><span data-stu-id="9346a-219">Conservative Rasterization allows for degenerate triangles to produce Pixel Shader invocations, therefore, degenerate triangles must use the values assigned to Vertex 0 for all interpolated values.</span></span>

### <a name="clipping-interaction"></a><span data-ttu-id="9346a-220">Interação de recorte</span><span class="sxs-lookup"><span data-stu-id="9346a-220">Clipping interaction</span></span>

<span data-ttu-id="9346a-221">Quando o modo de rasterização conservador estiver habilitado e o clipe de profundidade estiver desabilitado (quando o estado do rasterizador *DepthClipEnable* for definido como false), pode haver variações na interpolação de atributo para segmentos de um primitivo que se enquadram fora do intervalo de 0 <= z <= w, dependendo da implementação: os valores constantes são usados de um ponto em que a primitiva intersecciona o plano relevante (próximo ou longe) ou a interpolação de atributo se comporta como quando o modo de rasterização conservador está desabilitado.</span><span class="sxs-lookup"><span data-stu-id="9346a-221">When Conservative Rasterization mode is enabled and depth clip is disabled (when the *DepthClipEnable* Rasterizer State is set to FALSE), there may be variances in attribute interpolation for segments of a primitive that fall outside the 0 <= z <= w range, depending on implementation: either constant values are used from a point where the primitive intersects the relevant plane (near or far), or attribute interpolation behaves as when Conservative Rasterization mode is disabled.</span></span> <span data-ttu-id="9346a-222">No entanto, o comportamento do valor de profundidade é o mesmo, independentemente do modo de rasterização conservador, ou seja, primitivos que se enquadram fora do intervalo de profundidade ainda devem receber o valor do limite mais próximo do intervalo de profundidade do visor.</span><span class="sxs-lookup"><span data-stu-id="9346a-222">However, the depth value behavior is the same regardless of Conservative Rasterization mode, i.e. primitives that fall outside of the depth range must still be given the value of the nearest limit of the viewport depth range.</span></span> <span data-ttu-id="9346a-223">O comportamento de interpolação de atributo dentro do intervalo de 0 <= z <= w deve permanecer inalterado.</span><span class="sxs-lookup"><span data-stu-id="9346a-223">Attribute interpolation behavior inside the 0 <= z <= w range must remain unchanged.</span></span>

### <a name="clip-distance-interaction"></a><span data-ttu-id="9346a-224">Interação de distância do clipe</span><span class="sxs-lookup"><span data-stu-id="9346a-224">Clip Distance interaction</span></span>

<span data-ttu-id="9346a-225">A distância do clipe é válida quando o modo de rasterização conservador está habilitado e se comporta para um pixel com rasterização conservadora como faz quando a rasterização conservadora não está habilitada com todos os exemplos cobertos.</span><span class="sxs-lookup"><span data-stu-id="9346a-225">Clip Distance is valid when Conservative Rasterization mode is enabled, and behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

<span data-ttu-id="9346a-226">Observe que a rasterização conservadora pode causar extrapolação da coordenada de vértice W, o que pode causar W <= 0.</span><span class="sxs-lookup"><span data-stu-id="9346a-226">Note that Conservative Rasterization can cause extrapolation of the W vertex coordinate, which may cause W <= 0.</span></span> <span data-ttu-id="9346a-227">Isso pode fazer com que as implementações de distância de clipe por pixel operem em uma distância de clipe que tenha sido uma perspectiva dividida por um valor W inválido.</span><span class="sxs-lookup"><span data-stu-id="9346a-227">This could cause per-pixel Clip Distance implementations to operate on a Clip Distance that has been Perspective Divided by an invalid W value.</span></span> <span data-ttu-id="9346a-228">As implementações de distância do clipe devem se proteger contra invocação de rasterização para pixels em que a coordenada de vértice W <= 0 (por exemplo, devido à extrapolação quando estiver no modo de rasterização conservador).</span><span class="sxs-lookup"><span data-stu-id="9346a-228">Clip Distance implementations must guard against invoking rasterization for pixels where vertex coordinate W <= 0 (e.g. due to extrapolation when in Conservative Rasterization mode).</span></span>

### <a name="target-independent-rasterization-interaction"></a><span data-ttu-id="9346a-229">Interação de rasterização independente de destino</span><span class="sxs-lookup"><span data-stu-id="9346a-229">Target Independent Rasterization interaction</span></span>

<span data-ttu-id="9346a-230">O modo de rasterização conservador é compatível com a TIR (rasterização independente de destino).</span><span class="sxs-lookup"><span data-stu-id="9346a-230">Conservative Rasterization mode is compatible with Target Independent Rasterization (TIR).</span></span> <span data-ttu-id="9346a-231">Regras e restrições do TIR se aplicam, comportando um pixel conservadormente rasterizado como se todas as amostras forem cobertas.</span><span class="sxs-lookup"><span data-stu-id="9346a-231">TIR rules and restrictions apply, behaving for a conservatively rasterized pixel as if all samples are covered.</span></span>

### <a name="ia-primitive-topology-interaction"></a><span data-ttu-id="9346a-232">Interação da topologia primitiva de IA</span><span class="sxs-lookup"><span data-stu-id="9346a-232">IA Primitive Topology interaction</span></span>

<span data-ttu-id="9346a-233">A rasterização conservadora não está definida para primitivos de linha ou de ponto.</span><span class="sxs-lookup"><span data-stu-id="9346a-233">Conservative Rasterization is not defined for line or point primitives.</span></span> <span data-ttu-id="9346a-234">Portanto, as topologias primitivas que especificam pontos ou linhas produzem um comportamento indefinido se forem alimentadas para a unidade rasterizadora quando a rasterização conservadora estiver habilitada.</span><span class="sxs-lookup"><span data-stu-id="9346a-234">Therefore, Primitive Topologies that specify points or lines produce undefined behavior if they are fed to the rasterizer unit when Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="9346a-235">A validação da camada de depuração verifica se os aplicativos não usam essas topologias primitivas.</span><span class="sxs-lookup"><span data-stu-id="9346a-235">The debug layer validation verifies applications do not use these Primitive Topologies.</span></span>

### <a name="query-interaction"></a><span data-ttu-id="9346a-236">Interação de consulta</span><span class="sxs-lookup"><span data-stu-id="9346a-236">Query interaction</span></span>

<span data-ttu-id="9346a-237">Para um pixel rasterizado conservadormente, as consultas se comportam como fazem quando a rasterização conservadora não é habilitada quando todas as amostras são cobertas.</span><span class="sxs-lookup"><span data-stu-id="9346a-237">For a conservatively rasterized pixel, queries behave as they do when Conservative Rasterization is not enabled when all samples are covered.</span></span> <span data-ttu-id="9346a-238">Por exemplo, para um pixel rasterizado conservadormente, o \_ \_ tipo de consulta D3D12 \_ oclusão e D3D12 \_ tipo de consulta as \_ \_ \_ Estatísticas de pipeline (de [**D3D12 \_ \_ tipo de consulta**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) devem se comportar como seriam quando a rasterização conservadora não está habilitada quando todas as amostras são cobertas.</span><span class="sxs-lookup"><span data-stu-id="9346a-238">For example, for a conservatively rasterized pixel, D3D12\_QUERY\_TYPE\_OCCLUSION and D3D12\_QUERY\_TYPE\_PIPELINE\_STATISTICS (from [**D3D12\_QUERY\_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) must behave as they would when Conservative Rasterization is not enabled when all samples are covered.</span></span>

<span data-ttu-id="9346a-239">As invocações do sombreador de pixel devem ser incrementadas para cada pixel com rasterização conservadora no modo de rasterização conservador.</span><span class="sxs-lookup"><span data-stu-id="9346a-239">Pixel Shader invocations should increment for every conservatively rasterized pixel in Conservative Rasterization mode.</span></span>

### <a name="cull-state-interaction"></a><span data-ttu-id="9346a-240">Seleção de interação de estado</span><span class="sxs-lookup"><span data-stu-id="9346a-240">Cull State interaction</span></span>

<span data-ttu-id="9346a-241">Todos os Estados de seleção são válidos no modo de rasterização conservadora e seguem as mesmas regras que quando a rasterização conservadora não está habilitada.</span><span class="sxs-lookup"><span data-stu-id="9346a-241">All Cull States are valid in Conservative Rasterization mode and follow the same rules as when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="9346a-242">Ao comparar a rasterização conservadora entre as resoluções para si mesma ou sem a rasterização conservadora habilitada, há a possibilidade de que alguns primitivos tenham uma certa incompatibilidade (ou seja, um voltado para frente, o outro front voltado).</span><span class="sxs-lookup"><span data-stu-id="9346a-242">When comparing Conservative Rasterization across resolutions to itself or without Conservative Rasterization enabled, there is the possibility that some primitives may have mismatched facedness (i.e. one back facing, the other front facing).</span></span> <span data-ttu-id="9346a-243">Os aplicativos podem evitar essa incerteza usando \_ \_ o modo \_ de seleção D3D12 nenhum (do [**\_ \_ modo de seleção D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) e não usando o `IsFrontFace` valor gerado pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="9346a-243">Applications can avoid this uncertainty by using D3D12\_CULL\_MODE\_NONE (from [**D3D12\_CULL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) and not using the `IsFrontFace` System Generated Value.</span></span>

### <a name="isfrontface-interaction"></a><span data-ttu-id="9346a-244">Interação IsFrontFace</span><span class="sxs-lookup"><span data-stu-id="9346a-244">IsFrontFace interaction</span></span>

<span data-ttu-id="9346a-245">O `IsFrontFace` valor gerado pelo sistema é válido para ser usado no modo de rasterização conservador e segue o comportamento definido quando a rasterização conservadora não está habilitada.</span><span class="sxs-lookup"><span data-stu-id="9346a-245">The `IsFrontFace` System Generated Value is valid to use in Conservative Rasterization mode, and follows the behavior defined when Conservative Rasterization is not enabled.</span></span>

### <a name="fill-modes-interaction"></a><span data-ttu-id="9346a-246">Interação dos modos de preenchimento</span><span class="sxs-lookup"><span data-stu-id="9346a-246">Fill Modes interaction</span></span>

<span data-ttu-id="9346a-247">O único [**modo de \_ preenchimento \_ de D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) válido para rasterização conservadora é D3D12 \_ preenchimento \_ sólido, qualquer outro modo de preenchimento é um parâmetro inválido para o estado do rasterizador.</span><span class="sxs-lookup"><span data-stu-id="9346a-247">The only valid [**D3D12\_FILL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) for Conservative Rasterization is D3D12\_FILL\_SOLID, any other fill mode is an invalid parameter for the Rasterizer State.</span></span>

<span data-ttu-id="9346a-248">Isso ocorre porque a especificação funcional D3D12 especifica que o modo de preenchimento de wireframe deve converter bordas de triângulo em linhas e seguir as regras de rasterização de linha e o comportamento de rasterização de linha conservador não foi definido.</span><span class="sxs-lookup"><span data-stu-id="9346a-248">This is because D3D12 functional specification specifies that wireframe fill mode should convert triangle edges to lines and follow the line rasterization rules and conservative line rasterization behavior has not been defined.</span></span>

## <a name="implementation-details"></a><span data-ttu-id="9346a-249">Detalhes de implementação</span><span class="sxs-lookup"><span data-stu-id="9346a-249">Implementation details</span></span>

<span data-ttu-id="9346a-250">O tipo de rasterização com suporte no Direct3D 12 é às vezes chamado de "rasterização conservadora estimada".</span><span class="sxs-lookup"><span data-stu-id="9346a-250">The type of rasterization supported in Direct3D 12 is sometimes referred to as "Overestimated Conservative Rasterization".</span></span> <span data-ttu-id="9346a-251">Também há o conceito de "rasterização conservadora subestimada", o que significa que apenas os pixels totalmente cobertos por um primitivo renderizado são rasterizados.</span><span class="sxs-lookup"><span data-stu-id="9346a-251">There is also the concept of "Underestimated Conservative Rasterization", which means that only pixels that are fully covered by a rendered primitive are rasterized.</span></span> <span data-ttu-id="9346a-252">As informações de rasterização conservadora subestimadas estão disponíveis por meio do sombreador de pixel através do uso de dados de cobertura de entrada e apenas a rasterização conservadora Sobreestimada está disponível como um modo de rasterização.</span><span class="sxs-lookup"><span data-stu-id="9346a-252">Underestimated Conservative Rasterization information is available through the pixel shader through the use of input coverage data, and only overestimated Conservative Rasterization is available as a rasterizing mode.</span></span>

<span data-ttu-id="9346a-253">Se qualquer parte de um primitivo sobrepuser um pixel, esse pixel será considerado coberto e, em seguida, será rasterizado.</span><span class="sxs-lookup"><span data-stu-id="9346a-253">If any part of a primitive overlaps a pixel, then that pixel is considered covered and is then rasterized.</span></span> <span data-ttu-id="9346a-254">Quando uma borda ou canto de um primitivo cai ao longo da borda ou do canto de um pixel, o aplicativo da "regra de cima para a esquerda" é específico da implementação.</span><span class="sxs-lookup"><span data-stu-id="9346a-254">When an edge or corner of a primitive falls along the edge or corner of a pixel, the application of the "top-left rule" is implementation-specific.</span></span> <span data-ttu-id="9346a-255">No entanto, para implementações que dão suporte a triângulos de degeneração, um triângulo degenerado ao longo de uma borda ou canto deve abranger pelo menos um pixel.</span><span class="sxs-lookup"><span data-stu-id="9346a-255">However, for implementations that support degenerate triangles, a degenerate triangle along an edge or corner must cover at least one pixel.</span></span>

<span data-ttu-id="9346a-256">Implementações de rasterização conservadoras podem variar em hardwares diferentes e produzir falsos positivos, o que significa que eles podem decidir incorretamente que os pixels são cobertos.</span><span class="sxs-lookup"><span data-stu-id="9346a-256">Conservative Rasterization implementations can vary on different hardware, and do produce false positives, meaning that they can incorrectly decide that pixels are covered.</span></span> <span data-ttu-id="9346a-257">Isso pode ocorrer devido a detalhes específicos da implementação, como erros primitivos de crescimento ou encaixe inerentes às coordenadas de vértice de ponto fixo usadas na rasterização.</span><span class="sxs-lookup"><span data-stu-id="9346a-257">This can occur because of implementation-specific details like primitive growing or snapping errors inherent in the fixed-point vertex coordinates used in rasterization.</span></span> <span data-ttu-id="9346a-258">O motivo pelo qual falsos positivos (em relação às coordenadas de vértice de ponto fixo) é válido porque alguns falsos positivos são necessários para permitir que uma implementação faça a avaliação de cobertura em vértices de postagem (ou seja, coordenadas de vértice que foram convertidas do ponto flutuante para o ponto fixo 16,8 usado no rasterizador), mas obedeça a cobertura produzida pelas coordenadas originais do vértice do ponto flutuante</span><span class="sxs-lookup"><span data-stu-id="9346a-258">The reason false positives (with respect to fixed point vertex coordinates) are valid is because some amount of false positives are needed to allow an implementation to do coverage evaluation against post-snapped vertices (i.e. vertex coordinates that have been converted from floating point to the 16.8 fixed-point used in the rasterizer), but honor the coverage produced by the original floating point vertex coordinates.</span></span>

<span data-ttu-id="9346a-259">Implementações de rasterização conservadoras não produzem falsos negativos em relação às coordenadas de vértice de ponto flutuante para primitivos post-snap não degenerados: se qualquer parte de um primitivo sobrepuser qualquer parte de um pixel, esse pixel será rasterizado.</span><span class="sxs-lookup"><span data-stu-id="9346a-259">Conservative Rasterization implementations do not produce false negatives with respect to the floating-point vertex coordinates for non-degenerate post-snap primitives: if any part of a primitive overlaps any part of a pixel, then that pixel is rasterized.</span></span>

<span data-ttu-id="9346a-260">Triângulos que são degenerados (índices duplicados em um buffer de índice ou colineares em 3D) ou tornam-se degenerados após a conversão de ponto fixo (vértices de colineares no rasterizador), pode ou não ser possível fazer a remoção; Ambos são comportamentos válidos.</span><span class="sxs-lookup"><span data-stu-id="9346a-260">Triangles that are degenerate (duplicate indices in an index buffer or collinear in 3D), or become degenerate after fixed-point conversion (collinear vertices in the rasterizer), may or may not be culled; both are valid behaviors.</span></span> <span data-ttu-id="9346a-261">Os triângulos de degeneração devem ser considerados voltados, portanto, se um comportamento específico for exigido por um aplicativo, ele poderá usar a remoção ou teste de face para frente.</span><span class="sxs-lookup"><span data-stu-id="9346a-261">Degenerate triangles must be considered back facing, so if a specific behavior is required by an application, it can use back-face culling or test for front facing.</span></span> <span data-ttu-id="9346a-262">Os triângulos de degeneração usam os valores atribuídos ao vértice 0 para todos os valores interpolados.</span><span class="sxs-lookup"><span data-stu-id="9346a-262">Degenerate triangles use the values assigned to Vertex 0 for all interpolated values.</span></span>

<span data-ttu-id="9346a-263">Há três camadas de suporte a hardware, além da possibilidade de que o hardware não ofereça suporte a esse recurso.</span><span class="sxs-lookup"><span data-stu-id="9346a-263">There are three tiers of hardware support, in addition to the possibility that the hardware does not support this feature.</span></span>

-   <span data-ttu-id="9346a-264">A camada 1 impõe uma região máxima de incerteza de 1/2 pixels e não oferece suporte a degerações de pós-snap.</span><span class="sxs-lookup"><span data-stu-id="9346a-264">Tier 1 enforces a maximum 1/2 pixel uncertainty region and does not support post-snap degenerates.</span></span> <span data-ttu-id="9346a-265">Isso é bom para a renderização de ladrilho, um Atlas de textura, geração de mapa claro e mapas de sombra de subpixel.</span><span class="sxs-lookup"><span data-stu-id="9346a-265">This is good for tiled rendering, a texture atlas, light map generation and sub-pixel shadow maps.</span></span>
-   <span data-ttu-id="9346a-266">A camada 2 reduz a região de incerteza máxima para 1/256 e exige que as congerações após o encaixe não sejam reescolhedas.</span><span class="sxs-lookup"><span data-stu-id="9346a-266">Tier 2 reduces the maximum uncertainty region to 1/256 and requires post-snap degenerates not be culled.</span></span> <span data-ttu-id="9346a-267">Essa camada é útil para a aceleração de algoritmos baseada em CPU (como voxelization).</span><span class="sxs-lookup"><span data-stu-id="9346a-267">This tier is helpful for CPU-based algorithm acceleration (such as voxelization).</span></span>
-   <span data-ttu-id="9346a-268">A camada 3 mantém uma região de incerteza máxima de 1/256 e adiciona suporte para cobertura de entrada interna.</span><span class="sxs-lookup"><span data-stu-id="9346a-268">Tier 3 maintains a maximum 1/256 uncertainty region and adds support for inner input coverage.</span></span> <span data-ttu-id="9346a-269">Cobertura de entrada interna adiciona o novo valor `SV_InnerCoverage` à HLSL (linguagem de sombreamento de alto nível).</span><span class="sxs-lookup"><span data-stu-id="9346a-269">Inner input coverage adds the new value `SV_InnerCoverage` to High Level Shading Language (HLSL).</span></span> <span data-ttu-id="9346a-270">Este é um inteiro escalar de 32 bits que pode ser especificado na entrada para um sombreador de pixel e representa as informações de rasterização conservadora subestimadas (ou seja, se um pixel é garantido para ser totalmente coberto).</span><span class="sxs-lookup"><span data-stu-id="9346a-270">This is a 32-bit scalar integer that can be specified on input to a pixel shader, and represents the underestimated Conservative Rasterization information (that is, whether a pixel is guaranteed-to-be-fully covered).</span></span> <span data-ttu-id="9346a-271">Essa camada é útil para a remoção de oclusão.</span><span class="sxs-lookup"><span data-stu-id="9346a-271">This tier is helpful for occlusion culling.</span></span>

## <a name="api-summary"></a><span data-ttu-id="9346a-272">Resumo da API</span><span class="sxs-lookup"><span data-stu-id="9346a-272">API summary</span></span>

<span data-ttu-id="9346a-273">Os seguintes métodos, estruturas, enumerações e classes auxiliares referenciam a rasterização conservadora:</span><span class="sxs-lookup"><span data-stu-id="9346a-273">The following methods, structures, enums, and helper classes reference Conservative Rasterization:</span></span>

-   <span data-ttu-id="9346a-274">[**D3D12 \_ Rerasterizador \_ desc**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : estrutura que contém a descrição do rasterizador.</span><span class="sxs-lookup"><span data-stu-id="9346a-274">[**D3D12\_RASTERIZER\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : structure holding the rasterizer description.</span></span>
-   <span data-ttu-id="9346a-275">[**D3D12 \_ \_ \_ Modo de rasterização conservador**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : valores de enumeração para o modo (ativado ou desativado).</span><span class="sxs-lookup"><span data-stu-id="9346a-275">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : enum values for the mode (on or off).</span></span>
-   <span data-ttu-id="9346a-276">[**D3D12 \_ \_Opções de \_ D3D12 \_ de dados de recurso**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : estrutura que mantém a camada de suporte.</span><span class="sxs-lookup"><span data-stu-id="9346a-276">[**D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : structure holding the tier of support.</span></span>
-   <span data-ttu-id="9346a-277">[**D3D12 \_ \_ \_ Camada de rasterização conservadora**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : valores de enumeração para cada camada de suporte pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="9346a-277">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : enum values for each tier of support by the hardware.</span></span>
-   <span data-ttu-id="9346a-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : método para acessar os recursos com suporte.</span><span class="sxs-lookup"><span data-stu-id="9346a-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : method to access the supported features.</span></span>
-   <span data-ttu-id="9346a-279">[**CD3DX12 \_ Classe do RASTERIZAdor \_ desc**](cd3dx12-rasterizer-desc.md) : Helper para criar descrições do rasterizador.</span><span class="sxs-lookup"><span data-stu-id="9346a-279">[**CD3DX12\_RASTERIZER\_DESC**](cd3dx12-rasterizer-desc.md) : helper class for creating rasterizer descriptions.</span></span>

## <a name="related-topics"></a><span data-ttu-id="9346a-280">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="9346a-280">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="9346a-281">Tutoriais de vídeo do DirectX Advanced Learning: rasterização conservadora</span><span class="sxs-lookup"><span data-stu-id="9346a-281">DirectX advanced learning video tutorials : Conservative Rasterization</span></span>](https://www.youtube.com/watch?v=zL0oSY_YmDY)
</dt> <dt>

[<span data-ttu-id="9346a-282">Exibições ordenadas do rasterizador</span><span class="sxs-lookup"><span data-stu-id="9346a-282">Rasterizer Ordered Views</span></span>](rasterizer-order-views.md)
</dt> <dt>

[<span data-ttu-id="9346a-283">Renderização</span><span class="sxs-lookup"><span data-stu-id="9346a-283">Rendering</span></span>](rendering.md)
</dt> </dl>

 

 




