---
title: Diferenças no modelo de associação do Direct3D 11
description: Uma das principais decisões de design por trás da Associação DirectX12 é separá-la de outras tarefas de gerenciamento. Isso coloca alguns requisitos no aplicativo para gerenciar determinados riscos potenciais.
ms.assetid: 3EE7E9AE-203D-40D4-9F12-4313ED179035
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 43b2785da6497fd4e775d9f88847928e7c4c08e8
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104526"
---
# <a name="differences-in-the-binding-model-from-direct3d-11"></a><span data-ttu-id="fff55-104">Diferenças no modelo de associação do Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="fff55-104">Differences in the Binding Model from Direct3D 11</span></span>

<span data-ttu-id="fff55-105">Uma das principais decisões de design por trás da Associação DirectX12 é separá-la de outras tarefas de gerenciamento.</span><span class="sxs-lookup"><span data-stu-id="fff55-105">One of the main design decisions behind DirectX12 binding is to separate it from other management tasks.</span></span> <span data-ttu-id="fff55-106">Isso coloca alguns requisitos no aplicativo para gerenciar determinados riscos potenciais.</span><span class="sxs-lookup"><span data-stu-id="fff55-106">This places some requirements on the app to manage certain potential hazards.</span></span>

<span data-ttu-id="fff55-107">A principal vantagem do modelo de associação D3D12 é que ele permite que os aplicativos alterem as associações de textura com frequência, sem um enorme custo de desempenho da CPU.</span><span class="sxs-lookup"><span data-stu-id="fff55-107">The main advantage of the D3D12 Binding Model is that it enables apps to change texture bindings frequently, without a huge CPU performance cost.</span></span> <span data-ttu-id="fff55-108">Outros benefícios são que os sombreadores têm acesso a um número muito grande de recursos, os sombreadores não precisam saber com antecedência quantos recursos serão associados e que um modelo de associação de recursos unificados pode ser usado independentemente do fluxo de conteúdo do hardware ou dos aplicativos.</span><span class="sxs-lookup"><span data-stu-id="fff55-108">Other benefits are that shaders have access to a very large number of resources, shaders need not know in advance how many resources will be bound, and that a unified resource binding model can be used regardless of hardware or the apps content flow.</span></span>

<span data-ttu-id="fff55-109">Para melhorar o desempenho, o modelo de associação não exige que o sistema acompanhe o controle de quais associações um aplicativo solicitou a GPU para usar, e há uma integração limpa entre a associação e as listas de comandos multi-threaded.</span><span class="sxs-lookup"><span data-stu-id="fff55-109">To improve performance, the binding model does not require the system to keep track of what bindings an app has requested the GPU to use, and there is a clean integration between binding and multi-threaded command lists.</span></span>

<span data-ttu-id="fff55-110">As seções a seguir listam algumas das alterações no modelo de associação de recursos desde o D3D11.</span><span class="sxs-lookup"><span data-stu-id="fff55-110">The following sections list some of the changes to the resource binding model since D3D11.</span></span>

-   [<span data-ttu-id="fff55-111">Gerenciamento de residência de memória separado da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-111">Memory Residency Management Separated From Binding</span></span>](#memory-residency-management-separated-from-binding)
-   [<span data-ttu-id="fff55-112">Gerenciamento de tempo de vida de objeto separado da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-112">Object Lifetime Management Separated From Binding</span></span>](#object-lifetime-management-separated-from-binding)
-   [<span data-ttu-id="fff55-113">Rastreamento de estado do recurso de driver separado da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-113">Driver Resource State Tracking Separated From Binding</span></span>](#driver-resource-state-tracking-separated-from-binding)
-   [<span data-ttu-id="fff55-114">Sincronização de memória mapeada da GPU de CPU separada da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-114">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>](#cpu-gpu-mapped-memory-synchronization-separated-from-binding)
-   [<span data-ttu-id="fff55-115">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="fff55-115">Related topics</span></span>](#related-topics)

## <a name="memory-residency-management-separated-from-binding"></a><span data-ttu-id="fff55-116">Gerenciamento de residência de memória separado da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-116">Memory Residency Management Separated From Binding</span></span>

<span data-ttu-id="fff55-117">Os aplicativos têm controle explícito sobre quais superfícies precisam estar disponíveis para que a GPU seja usada diretamente (chamada de "residente").</span><span class="sxs-lookup"><span data-stu-id="fff55-117">Applications have explicit control over which surfaces they need to be available for the GPU to use directly (called being "resident").</span></span> <span data-ttu-id="fff55-118">Por outro lado, eles podem aplicar outros Estados em recursos, como torná-los explicitamente não residentes ou deixar o sistema operacional escolher para determinadas classes de aplicativos que exigem um espaço mínimo de memória.</span><span class="sxs-lookup"><span data-stu-id="fff55-118">Conversely, they can apply other states on resources such as explicitly making them not resident, or letting the OS choose for certain classes of applications that require a minimal memory footprint.</span></span> <span data-ttu-id="fff55-119">O ponto importante aqui é que o gerenciamento do aplicativo do que é residente é completamente dissociado de como ele oferece acesso aos recursos para os sombreadores.</span><span class="sxs-lookup"><span data-stu-id="fff55-119">The important point here is that the application's management of what is resident is completely decoupled from how it gives access to resources to shaders.</span></span>

<span data-ttu-id="fff55-120">O desacoplamento do gerenciamento de residência do mecanismo para dar acesso aos sombreadores aos recursos reduz o custo do sistema/hardware para a renderização, uma vez que o sistema operacional não precisa inspecionar constantemente o estado de associação local para saber o que tornar-se residente.</span><span class="sxs-lookup"><span data-stu-id="fff55-120">The decoupling of residency management from the mechanism for giving shaders access to resources reduces the system/hardware cost for rendering since the OS doesn't have to constantly inspect the local binding state to know what to make resident.</span></span> <span data-ttu-id="fff55-121">Além disso, os sombreadores não precisam mais saber quais superfícies exatas talvez precisem fazer referência, desde que todo o conjunto de recursos possivelmente acessíveis tenha sido tornado residente antecipadamente.</span><span class="sxs-lookup"><span data-stu-id="fff55-121">Furthermore, shaders no longer have to know which exact surfaces they may need to reference, as long as the entire set of possibly accessible resources has been made resident ahead of time.</span></span>

## <a name="object-lifetime-management-separated-from-binding"></a><span data-ttu-id="fff55-122">Gerenciamento de tempo de vida de objeto separado da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-122">Object Lifetime Management Separated From Binding</span></span>

<span data-ttu-id="fff55-123">Ao contrário das APIs anteriores, o sistema não rastreia mais associações de recursos para o pipeline.</span><span class="sxs-lookup"><span data-stu-id="fff55-123">Unlike previous APIs, the system no longer tracks bindings of resources to the pipeline.</span></span> <span data-ttu-id="fff55-124">Isso é usado para permitir que o sistema mantenha os recursos alives que o aplicativo lançou porque eles ainda são referenciados pelo trabalho de GPU pendente.</span><span class="sxs-lookup"><span data-stu-id="fff55-124">This used to enable the system to keep alive resources that the application has released because they are still referenced by outstanding GPU work.</span></span>

<span data-ttu-id="fff55-125">Antes de liberar qualquer recurso, como uma textura, os aplicativos agora devem verificar se a GPU concluiu a referência a ela.</span><span class="sxs-lookup"><span data-stu-id="fff55-125">Before freeing any resource, such as a texture, applications now must make sure the GPU has completed referencing it.</span></span> <span data-ttu-id="fff55-126">Isso significa que antes de um aplicativo poder liberar com segurança um recurso, a GPU deve ter concluído a execução da lista de comandos que referencia o recurso.</span><span class="sxs-lookup"><span data-stu-id="fff55-126">This means before an application can safely free a resource the GPU must have completed execution of the command list referencing the resource.</span></span>

## <a name="driver-resource-state-tracking-separated-from-binding"></a><span data-ttu-id="fff55-127">Rastreamento de estado do recurso de driver separado da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-127">Driver Resource State Tracking Separated From Binding</span></span>

<span data-ttu-id="fff55-128">O sistema não inspeciona mais as associações de recursos para entender quando ocorreram transições de recursos que exigem um trabalho adicional de driver ou GPU.</span><span class="sxs-lookup"><span data-stu-id="fff55-128">The system no longer inspects resource bindings to understand when resource transitions have occurred which require additional driver or GPU work.</span></span> <span data-ttu-id="fff55-129">Um exemplo comum para muitas GPUs e drivers é ter que saber quando uma transição de superfície é usada como uma RTV (exibição de destino de renderização) para o Modo de Exibição de Recursos de sombreador (SRV).</span><span class="sxs-lookup"><span data-stu-id="fff55-129">A common example for many GPUs and drivers is having to know when a surface transitions from being used as a Render Target View (RTV) to Shader Resource View (SRV).</span></span> <span data-ttu-id="fff55-130">Os próprios aplicativos agora devem identificar quando as transições de recursos com as quais o sistema pode se preocupar estão acontecendo por meio de APIs dedicadas.</span><span class="sxs-lookup"><span data-stu-id="fff55-130">Applications themselves must now identify when any resource transitions that the system might care about are happening via dedicated APIs.</span></span>

## <a name="cpu-gpu-mapped-memory-synchronization-separated-from-binding"></a><span data-ttu-id="fff55-131">Sincronização de memória mapeada da GPU de CPU separada da Associação</span><span class="sxs-lookup"><span data-stu-id="fff55-131">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>

<span data-ttu-id="fff55-132">O sistema não inspeciona mais as associações de recursos para entender se o processamento precisa ser atrasado porque depende de um recurso que foi mapeado para acesso à CPU, mas ainda não foi mapeado.</span><span class="sxs-lookup"><span data-stu-id="fff55-132">The system no longer inspects resource bindings to understand if rendering needs to be delayed because it depends on a resource that has been mapped for CPU access but has not been unmapped yet.</span></span> <span data-ttu-id="fff55-133">Agora, os aplicativos têm a responsabilidade de sincronizar os acessos de memória de CPU e GPU.</span><span class="sxs-lookup"><span data-stu-id="fff55-133">Applications now have the responsibility to synchronize CPU and GPU memory accesses.</span></span> <span data-ttu-id="fff55-134">Para ajudar com isso, o sistema fornece mecanismos para que o aplicativo solicite o repouso de um thread de CPU até que o trabalho seja concluído.</span><span class="sxs-lookup"><span data-stu-id="fff55-134">To help with this, the system provides mechanisms for the application to request the sleeping of a CPU thread until work completes.</span></span> <span data-ttu-id="fff55-135">A sondagem também pode ser feita, mas pode ser menos eficiente.</span><span class="sxs-lookup"><span data-stu-id="fff55-135">Polling could also be done, but can be less efficient.</span></span>

## <a name="related-topics"></a><span data-ttu-id="fff55-136">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="fff55-136">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="fff55-137">Associação de recursos</span><span class="sxs-lookup"><span data-stu-id="fff55-137">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




