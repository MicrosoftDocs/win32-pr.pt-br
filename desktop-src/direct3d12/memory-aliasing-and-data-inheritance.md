---
title: Alias de memória e herança de dados
description: O recurso colocado e reservado pode alias de memória física em um heap. Os recursos inseridos permitem mais cenários de herança de dados do que os recursos reservados quando o heap tem o sinalizador compartilhado definido ou quando os recursos com alias têm layouts de memória totalmente definidos.
ms.assetid: 53C5804B-0F81-41AF-83D2-A96DCDFDC94A
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cace5b5997e2a460406ae72abb247224886f3926
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74103683"
---
# <a name="memory-aliasing-and-data-inheritance"></a><span data-ttu-id="96eb6-104">Alias de memória e herança de dados</span><span class="sxs-lookup"><span data-stu-id="96eb6-104">Memory Aliasing and Data Inheritance</span></span>

<span data-ttu-id="96eb6-105">O recurso colocado e reservado pode alias de memória física em um heap.</span><span class="sxs-lookup"><span data-stu-id="96eb6-105">Placed and reserved resource may alias physical memory within a heap.</span></span> <span data-ttu-id="96eb6-106">Os recursos inseridos permitem mais cenários de herança de dados do que os recursos reservados quando o heap tem o sinalizador compartilhado definido ou quando os recursos com alias têm layouts de memória totalmente definidos.</span><span class="sxs-lookup"><span data-stu-id="96eb6-106">Placed resources enable more data inheritance scenarios than reserved resources when the heap has the shared flag set or when the aliased resources have fully defined memory layouts.</span></span>

-   [<span data-ttu-id="96eb6-107">Atribuição de alias</span><span class="sxs-lookup"><span data-stu-id="96eb6-107">Aliasing</span></span>](#memory-aliasing-and-data-inheritance)
-   [<span data-ttu-id="96eb6-108">Herança de dados</span><span class="sxs-lookup"><span data-stu-id="96eb6-108">Data Inheritance</span></span>](#data-inheritance)
-   [<span data-ttu-id="96eb6-109">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="96eb6-109">Related topics</span></span>](#related-topics)

## <a name="aliasing"></a><span data-ttu-id="96eb6-110">Atribuição de alias</span><span class="sxs-lookup"><span data-stu-id="96eb6-110">Aliasing</span></span>

<span data-ttu-id="96eb6-111">Uma barreira de alias deve ser emitida entre o uso de dois recursos que compartilham a mesma memória física, mesmo se a herança de dados não for desejada.</span><span class="sxs-lookup"><span data-stu-id="96eb6-111">An aliasing barrier must be issued between the usage of two resources that share the same physical memory, even if data inheritance is not desired.</span></span> <span data-ttu-id="96eb6-112">Modelos de uso simples devem indicar, pelo menos, o recurso de destino envolvido em tal operação.</span><span class="sxs-lookup"><span data-stu-id="96eb6-112">Simple usage models must denote, at least, the destination resource involved in such an operation.</span></span> <span data-ttu-id="96eb6-113">Consulte [**CreatePlacedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) para obter mais detalhes e modelos de uso avançados.</span><span class="sxs-lookup"><span data-stu-id="96eb6-113">See [**CreatePlacedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) for more details and advanced usage models.</span></span>

<span data-ttu-id="96eb6-114">Depois que um recurso é acessado, todos os recursos que compartilham memória física com esse recurso se tornam invalidados, a menos que a herança de dados tenha permissão para ocorrer.</span><span class="sxs-lookup"><span data-stu-id="96eb6-114">After a resource is accessed, any resources which share physical memory with that resource become invalidated, unless data inheritance is allowed to occur.</span></span> <span data-ttu-id="96eb6-115">As leituras de recursos invalidados resultam em conteúdos indefinidos de recursos.</span><span class="sxs-lookup"><span data-stu-id="96eb6-115">Reads of invalidated resources result in undefined resource contents.</span></span> <span data-ttu-id="96eb6-116">Gravações em recursos invalidados também resultam em conteúdos indefinidos de recursos, a menos que duas condições ocorram:</span><span class="sxs-lookup"><span data-stu-id="96eb6-116">Writes to invalidated resources also result in undefined resource contents, unless two conditions occur:</span></span>

-   <span data-ttu-id="96eb6-117">O recurso não tem o \_ sinalizador de recurso D3D12 \_ \_ permitir destino de \_ renderização \_ ou \_ sinalizador de recurso D3D12 \_ \_ permitir estêncil de \_ profundidade \_ .</span><span class="sxs-lookup"><span data-stu-id="96eb6-117">The resource does not have either the D3D12\_RESOURCE\_FLAG\_ALLOW\_RENDER\_TARGET or D3D12\_RESOURCE\_FLAG\_ALLOW\_DEPTH\_STENCIL.</span></span>
-   <span data-ttu-id="96eb6-118">A gravação é uma operação de cópia ou limpeza em um subrecurso ou bloco inteiro.</span><span class="sxs-lookup"><span data-stu-id="96eb6-118">The write is a copy or clear operation to an entire subresource or tile.</span></span> <span data-ttu-id="96eb6-119">Bloco-a inicialização só está disponível para recursos com SWIZZLE de blocos de 64 KB \_ \_ indefinidos \_ e SWIZZLE padrão de bloco de 64 KB \_ \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="96eb6-119">Tile-initialization is only available for resources with 64KB\_TILE\_UNDEFINED\_SWIZZLE and 64KB\_TILE\_STANDARD\_SWIZZLE.</span></span>

<span data-ttu-id="96eb6-120">As invalidações sobrepostas são delimitadas a granularidades menores, quando os layouts fornecem informações sobre o local no local dos dados do Texel e quando os recursos estão em determinados Estados de barreira de transição.</span><span class="sxs-lookup"><span data-stu-id="96eb6-120">Overlapping invalidations are scoped to smaller granularities, when layouts provide information on the location on the location of texel data and when resources are in certain transition barrier states.</span></span> <span data-ttu-id="96eb6-121">No entanto, invalidações não podem passar por granularidades de alinhamento de recursos menores do que.</span><span class="sxs-lookup"><span data-stu-id="96eb6-121">But, invalidations cannot go any smaller than resource alignment granularities.</span></span>

<span data-ttu-id="96eb6-122">Uma granularidade de alinhamento de buffer é 64 KB, e A granularidade de alinhamento maior tem precedência.</span><span class="sxs-lookup"><span data-stu-id="96eb6-122">A buffer alignment granularity is 64KB, and larger alignment granularity takes precedence.</span></span> <span data-ttu-id="96eb6-123">Isso é importante ao considerar texturas de 4 KB, pois várias texturas de 4 KB podem residir em uma região de 64 KB sem sobreposição.</span><span class="sxs-lookup"><span data-stu-id="96eb6-123">This is important when considering 4KB textures, as multiple 4KB textures can reside in a 64KB region without overlapping each other.</span></span> <span data-ttu-id="96eb6-124">Mas, um alias de buffer da mesma região de 64 KB não pode ser usado em conjunto com nenhuma dessas texturas de 4 KB.</span><span class="sxs-lookup"><span data-stu-id="96eb6-124">But, a buffer aliasing the same 64KB region cannot be used in conjunction with any of those 4KB textures.</span></span> <span data-ttu-id="96eb6-125">O aplicativo não pode manter o acesso ao buffer de forma confiável, interseccionando as texturas de 4 KB, pois as GPUs são permitidas para dados de textura de 4 KB swizzle na região de 64 KB em um padrão indefinido.</span><span class="sxs-lookup"><span data-stu-id="96eb6-125">The application cannot reliably keep the access to the buffer from intersecting the 4KB textures, as GPUs are allowed to swizzle 4KB texture data within the 64KB region in an undefined pattern.</span></span>

<span data-ttu-id="96eb6-126">\_ \_ SWIZZLE de blocos indefinidos de 64 KB \_ , SWIZZLE padrão de bloco de 64 KB \_ \_ \_ e \_ layouts de textura de linha principal informam o aplicativo que a granularidade de alinhamento de sobreposição se tornou inválida.</span><span class="sxs-lookup"><span data-stu-id="96eb6-126">64KB\_TILE\_UNDEFINED\_SWIZZLE, 64KB\_TILE\_STANDARD\_SWIZZLE, and ROW\_MAJOR texture layouts inform the application which overlapping alignment granularities have become invalid.</span></span> <span data-ttu-id="96eb6-127">Por exemplo: um aplicativo pode criar uma matriz de textura de destino de renderização 2D com duas fatias de matriz, um único nível de MIP e o layout de SWIZZLE de bloco de 64 KB \_ \_ indefinido \_ .</span><span class="sxs-lookup"><span data-stu-id="96eb6-127">For example: An application can create a 2D render target texture array with 2 array slices, a single mip level, and the 64KB\_TILE\_UNDEFINED\_SWIZZLE layout.</span></span> <span data-ttu-id="96eb6-128">Suponha que o aplicativo entenda que cada fatia de matriz ocupa 100 blocos de 64 KB.</span><span class="sxs-lookup"><span data-stu-id="96eb6-128">Assume the application understands each array slice occupies 100 64KB tiles.</span></span> <span data-ttu-id="96eb6-129">O aplicativo pode abrem mão usando a fatia de matriz 0 e reutilizar essa memória para um buffer de ~ 6MB, uma textura de ~ 6 MB com layout indefinido, etc. Indo além, suponha que o aplicativo não reprecise mais do primeiro bloco da fatia de matriz 1.</span><span class="sxs-lookup"><span data-stu-id="96eb6-129">The application can forgo using array slice 0, and re-use that memory for either a ~6MB buffer, a ~6MB texture with undefined layout, etc. Going further, assume the application no longer required the first tile of array slice 1.</span></span> <span data-ttu-id="96eb6-130">Em seguida, o aplicativo também pode localizar um buffer de 64 KB até que o processamento exija novamente o primeiro bloco da fatia de matriz 1.</span><span class="sxs-lookup"><span data-stu-id="96eb6-130">Then, the application could also locate a 64KB buffer there until rendering would again require the first tile of array slice 1.</span></span> <span data-ttu-id="96eb6-131">O aplicativo precisaria fazer um bloco inteiro claro ou copiar para reutilizar o primeiro bloco com a matriz de textura novamente.</span><span class="sxs-lookup"><span data-stu-id="96eb6-131">The application would have to do a full tile clear or copy in order to re-use the first tile with the texture array again.</span></span>

<span data-ttu-id="96eb6-132">No entanto, até mesmo texturas com layouts definidos ainda têm casos problemáticos.</span><span class="sxs-lookup"><span data-stu-id="96eb6-132">However, even textures with defined layouts still have problematic cases.</span></span> <span data-ttu-id="96eb6-133">Os tamanhos de recursos de textura podem ser significativamente diferentes do que o aplicativo pode calcular, pois algumas arquiteturas de adaptador alocam memória extra para texturas a fim de reduzir a largura de banda efetiva durante cenários de renderização comuns.</span><span class="sxs-lookup"><span data-stu-id="96eb6-133">Texture resource sizes can significantly differ from what the application can calculate itself, because some adapter architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios.</span></span> <span data-ttu-id="96eb6-134">Todas as invalidações nessa região de memória extra fazem com que o recurso inteiro se torne invalidado.</span><span class="sxs-lookup"><span data-stu-id="96eb6-134">Any invalidations into that extra memory region cause the entire resource to become invalidated.</span></span> <span data-ttu-id="96eb6-135">Consulte [**GetResourceAllocationInfo**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="96eb6-135">See [**GetResourceAllocationInfo**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo) for more details.</span></span>

## <a name="data-inheritance"></a><span data-ttu-id="96eb6-136">Herança de dados</span><span class="sxs-lookup"><span data-stu-id="96eb6-136">Data Inheritance</span></span>

<span data-ttu-id="96eb6-137">Os recursos colocados permitem a herança de mais dados para texturas, mesmo com layouts de memória indefinidos.</span><span class="sxs-lookup"><span data-stu-id="96eb6-137">Placed resources enable the most data inheritance for textures, even with undefined memory layouts.</span></span> <span data-ttu-id="96eb6-138">Os aplicativos podem imitar os recursos de herança de dados que compartilharam os recursos confirmados, localizando duas texturas com propriedades de recurso idênticas no mesmo deslocamento em um heap compartilhado.</span><span class="sxs-lookup"><span data-stu-id="96eb6-138">Applications can mimic the data inheritance capabilities that shared committed resources enable by locating two textures with identical resource properties at the same offset in a shared heap.</span></span> <span data-ttu-id="96eb6-139">A descrição completa do recurso deve ser idêntica, incluindo o valor claro otimizado e o tipo de método de criação de recurso (colocado ou reservado).</span><span class="sxs-lookup"><span data-stu-id="96eb6-139">The entire resource description must be identical, including the optimized clear value and type of resource creation method (placed or reserved).</span></span> <span data-ttu-id="96eb6-140">Porém, os dois recursos podem ter tido Estados de barreira de transição inicial diferentes.</span><span class="sxs-lookup"><span data-stu-id="96eb6-140">But, both resources may have had different initial transition barrier states.</span></span>

<span data-ttu-id="96eb6-141">Os recursos reservados habilitam a herança de dados por bloco; Mas as restrições normalmente existem para Estados de barreira de transição de recursos.</span><span class="sxs-lookup"><span data-stu-id="96eb6-141">Reserved resources enable per-tile data inheritance; but restrictions commonly exist for resource transition barrier states.</span></span>

<span data-ttu-id="96eb6-142">Para herdar dados, ambos os recursos devem estar em um estado de barreira de transição de recurso compatível:</span><span class="sxs-lookup"><span data-stu-id="96eb6-142">To inherit data, both resources must be in a compatible resource transition barrier state:</span></span>

-   <span data-ttu-id="96eb6-143">Para buffers, texturas de acesso simultâneas e texturas de adaptador cruzado, o estado de transição de recurso não é importante e todos os Estados são "compatíveis".</span><span class="sxs-lookup"><span data-stu-id="96eb6-143">For buffers, simultaneous access textures, and cross-adapter textures, the resource transition state is not important and all states are “compatible”.</span></span>
-   <span data-ttu-id="96eb6-144">Para texturas reservadas sem as propriedades anteriores ou outra herança de dados por bloco por meio de 64 KB de bloco \_ \_ indefinido \_ SWIZZLE ou 64 KB \_ \_ Standard \_ SWIZZLE, o estado de barreira de transição de recursos, incluindo o bloco, deve estar no estado comum.</span><span class="sxs-lookup"><span data-stu-id="96eb6-144">For reserved textures without the previous properties or other per-tile data inheritance through 64KB\_TILE\_UNDEFINED\_SWIZZLE or 64KB\_TILE\_STANDARD\_SWIZZLE, the resource transition barrier state including the tile must be in the common state.</span></span>
-   <span data-ttu-id="96eb6-145">Para todas as outras texturas, em que as descrições de recursos correspondem exatamente, o estado de barreira de transição de recursos para cada par de subrecursos correspondente deve:</span><span class="sxs-lookup"><span data-stu-id="96eb6-145">For all other textures, where the resource descriptions match exactly, the resource transition barrier state for each corresponding pair of subresources must:</span></span>
    -   <span data-ttu-id="96eb6-146">Estar no estado comum.</span><span class="sxs-lookup"><span data-stu-id="96eb6-146">Be in the common state.</span></span>
    -   <span data-ttu-id="96eb6-147">Seja igual quando o estado tiver o mesmo sinalizador de gravação de GPU neles.</span><span class="sxs-lookup"><span data-stu-id="96eb6-147">Be equal when the state has the same GPU-write flag in them.</span></span>

<span data-ttu-id="96eb6-148">Quando a GPU dá suporte a swizzle padrão, os buffers e as texturas swizzle padrão podem ter um alias para a mesma memória e herdar dados entre eles.</span><span class="sxs-lookup"><span data-stu-id="96eb6-148">When the GPU supports standard swizzle, buffers and standard swizzle textures may be aliased to the same memory and inherit data between them.</span></span> <span data-ttu-id="96eb6-149">O aplicativo pode manipular texels da representação de buffer, pois o padrão swizzle padrão descreve como os texels são dispostos na memória.</span><span class="sxs-lookup"><span data-stu-id="96eb6-149">The application can manipulate texels from the buffer representation, because the standard swizzle pattern describes how texels are laid out in memory.</span></span> <span data-ttu-id="96eb6-150">O padrão swizzle visível da CPU é equivalente ao padrão swizzle visível da GPU visto em buffers.</span><span class="sxs-lookup"><span data-stu-id="96eb6-150">The CPU-visible swizzle pattern is equivalent to the GPU-visible swizzle pattern seen in buffers.</span></span>

## <a name="related-topics"></a><span data-ttu-id="96eb6-151">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="96eb6-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="96eb6-152">Subalocação dentro de heaps</span><span class="sxs-lookup"><span data-stu-id="96eb6-152">Suballocation Within Heaps</span></span>](suballocation-within-heaps.md)
</dt> </dl>

 

 




