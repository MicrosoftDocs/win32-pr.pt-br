---
title: Alterações importantes do Direct3D 11 para o Direct3D 12
description: O Direct3D 12 representa um desvio significativo do modelo de programação do Direct3D 11. O Direct3D 12 permite que os aplicativos fiquem mais próximos do hardware do que nunca.
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5be891d71d6c1f3a12d8d5aac3ec46785207ed31
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548218"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="13e3a-104">Alterações importantes do Direct3D 11 para o Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="13e3a-104">Important Changes from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="13e3a-105">O Direct3D 12 representa um desvio significativo do modelo de programação do Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13e3a-105">Direct3D 12 represents a significant departure from the Direct3D 11 programming model.</span></span> <span data-ttu-id="13e3a-106">O Direct3D 12 permite que os aplicativos fiquem mais próximos do hardware do que nunca.</span><span class="sxs-lookup"><span data-stu-id="13e3a-106">Direct3D 12 lets apps get closer to hardware than ever before.</span></span> <span data-ttu-id="13e3a-107">Ao se aproximar do hardware, o Direct3D 12 é mais rápido e mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="13e3a-107">By being closer to hardware, Direct3D 12 is faster and more efficient.</span></span> <span data-ttu-id="13e3a-108">Mas, a desvantagem de seu aplicativo ter aumentado a velocidade e a eficiência com o Direct3D 12 é que você é responsável por mais tarefas do que era com o Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13e3a-108">But, the trade-off of your app having increased speed and efficiency with Direct3D 12 is that you are responsible for more tasks than you were with Direct3D 11.</span></span>

-   [<span data-ttu-id="13e3a-109">Sincronização explícita</span><span class="sxs-lookup"><span data-stu-id="13e3a-109">Explicit Synchronization</span></span>](#explicit-synchronization)
-   [<span data-ttu-id="13e3a-110">Gerenciamento de residência de memória física</span><span class="sxs-lookup"><span data-stu-id="13e3a-110">Physical Memory Residency Management</span></span>](#physical-memory-residency-management)
-   [<span data-ttu-id="13e3a-111">Objetos de estado do pipeline</span><span class="sxs-lookup"><span data-stu-id="13e3a-111">Pipeline state objects</span></span>](#pipeline-state-objects)
-   [<span data-ttu-id="13e3a-112">Listas de comandos e pacotes</span><span class="sxs-lookup"><span data-stu-id="13e3a-112">Command lists and bundles</span></span>](#command-lists-and-bundles)
-   [<span data-ttu-id="13e3a-113">Heaps e tabelas do descritor</span><span class="sxs-lookup"><span data-stu-id="13e3a-113">Descriptor heaps and tables</span></span>](#descriptor-heaps-and-tables)
-   [<span data-ttu-id="13e3a-114">Portando do Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="13e3a-114">Porting from Direct3D 11</span></span>](#porting-from-direct3d-11)
-   [<span data-ttu-id="13e3a-115">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="13e3a-115">Related topics</span></span>](#related-topics)

<span data-ttu-id="13e3a-116">O Direct3D 12 é um retorno para programação de baixo nível; Ele oferece mais controle sobre os elementos gráficos de seus jogos e aplicativos introduzindo esses novos recursos: objetos para representar o estado geral do pipeline, listas de comandos e pacotes para envio de trabalho e heaps e tabelas de descritores para acesso aos recursos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-116">Direct3D 12 is a return to low-level programming; it gives you more control over the graphical elements of your games and apps by introducing these new features: objects to represent the overall state of the pipeline, command lists and bundles for work submission, and descriptor heaps and tables for resource access.</span></span>

<span data-ttu-id="13e3a-117">Seu aplicativo aumentou a velocidade e a eficiência com o Direct3D 12, mas você é responsável por mais tarefas do que era com o Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13e3a-117">Your app has increased speed and efficiency with Direct3D 12, but you are responsible for more tasks than you were with Direct3D 11.</span></span>

## <a name="explicit-synchronization"></a><span data-ttu-id="13e3a-118">Sincronização explícita</span><span class="sxs-lookup"><span data-stu-id="13e3a-118">Explicit Synchronization</span></span>

-   <span data-ttu-id="13e3a-119">No Direct3D 12, a sincronização de GPU de CPU agora é a responsabilidade explícita do aplicativo e não é mais implicitamente executada pelo tempo de execução, como no Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13e3a-119">In Direct3D 12, CPU-GPU synchronization is now the explicit responsibility of the app and is no longer implicitly performed by the runtime, as it is in Direct3D 11.</span></span> <span data-ttu-id="13e3a-120">Esse fato também significa que nenhuma verificação automática de riscos de pipeline é executada pelo Direct3D 12; Portanto, novamente essa é a responsabilidade dos aplicativos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-120">This fact also means that no automatic checking for pipeline hazards is performed by Direct3D 12, so again this is the apps responsibility.</span></span>
-   <span data-ttu-id="13e3a-121">No Direct3D 12, os aplicativos são responsáveis por atualizações de dados de pipeline.</span><span class="sxs-lookup"><span data-stu-id="13e3a-121">In Direct3D 12, apps are responsible for pipelining data updates.</span></span> <span data-ttu-id="13e3a-122">Ou seja, o padrão "mapear/bloquear-descartar" no Direct3D 11 deve ser executado manualmente no Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="13e3a-122">That is, the "Map/Lock-DISCARD" pattern in Direct3D 11 must be performed manually in Direct3D 12.</span></span> <span data-ttu-id="13e3a-123">No Direct3D 11, se a GPU ainda estiver usando o buffer quando você chamar [**ID3D11DeviceContext:: map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) com [**\_ descarte de \_ gravação \_ de mapa D3D11**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), o tempo de execução retornará um ponteiro para uma nova região de memória em vez dos dados de buffer antigos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-123">In Direct3D 11, if the GPU is still using the buffer when you call [**ID3D11DeviceContext::Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) with [**D3D11\_MAP\_WRITE\_DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), the runtime returns a pointer to a new region of memory instead of the old buffer data.</span></span> <span data-ttu-id="13e3a-124">Isso permite que a GPU continue usando os dados antigos enquanto o aplicativo coloca os dados no novo buffer.</span><span class="sxs-lookup"><span data-stu-id="13e3a-124">This allows the GPU to continue using the old data while the app places data in the new buffer.</span></span> <span data-ttu-id="13e3a-125">Nenhum gerenciamento de memória adicional é necessário no aplicativo; o buffer antigo é reutilizado ou destruído automaticamente quando a GPU é concluída com ele.</span><span class="sxs-lookup"><span data-stu-id="13e3a-125">No additional memory management is required in the app; the old buffer is reused or destroyed automatically when the GPU is finished with it.</span></span>
-   <span data-ttu-id="13e3a-126">No Direct3D 12, todas as atualizações dinâmicas (incluindo buffers de constantes, buffers de vértice dinâmicos, texturas dinâmicas e assim por diante) são explicitamente controladas pelo aplicativo.</span><span class="sxs-lookup"><span data-stu-id="13e3a-126">In Direct3D 12, all dynamic updates (including constant buffers, dynamic vertex buffers, dynamic textures, and so on) are explicitly controlled by the app.</span></span> <span data-ttu-id="13e3a-127">Essas atualizações dinâmicas incluem todos os limites ou buffers de GPU necessários.</span><span class="sxs-lookup"><span data-stu-id="13e3a-127">These dynamic updates include any required GPU fences or buffering.</span></span> <span data-ttu-id="13e3a-128">O aplicativo é responsável por manter a memória disponível até que ela não seja mais necessária.</span><span class="sxs-lookup"><span data-stu-id="13e3a-128">The app is responsible for keeping the memory available until it is no longer needed.</span></span>
-   <span data-ttu-id="13e3a-129">O Direct3D 12 usa a contagem de referência de estilo COM apenas para os tempos de vida de interfaces (usando o modelo de referência fraca do Direct3D ligado ao tempo de vida do dispositivo).</span><span class="sxs-lookup"><span data-stu-id="13e3a-129">Direct3D 12 uses COM-style reference counting only for the lifetimes of interfaces (by using the weak reference model of Direct3D tied to the lifetime of the device).</span></span> <span data-ttu-id="13e3a-130">Todos os tempos de vida de memória de recursos e de descrição são o único responsável pelo aplicativo a ser mantido durante a duração apropriada e não são contados como referência.</span><span class="sxs-lookup"><span data-stu-id="13e3a-130">All resource and description memory lifetimes are the sole responsibly of the app to maintain for the proper duration, and are not reference counted.</span></span> <span data-ttu-id="13e3a-131">O Direct3D 11 usa a contagem de referência para gerenciar os tempos de vida de dependências de interface também.</span><span class="sxs-lookup"><span data-stu-id="13e3a-131">Direct3D 11 uses reference counting to manage the lifetimes of interface dependencies as well.</span></span>

## <a name="physical-memory-residency-management"></a><span data-ttu-id="13e3a-132">Gerenciamento de residência de memória física</span><span class="sxs-lookup"><span data-stu-id="13e3a-132">Physical Memory Residency Management</span></span>

<span data-ttu-id="13e3a-133">Um aplicativo Direct3D 12 deve impedir as condições de corrida entre várias filas, vários adaptadores e os threads de CPU.</span><span class="sxs-lookup"><span data-stu-id="13e3a-133">A Direct3D 12 application must prevent race-conditions between multiple queues, multiple adapters, and the CPU threads.</span></span> <span data-ttu-id="13e3a-134">O D3D12 não sincroniza mais a CPU e a GPU nem oferece suporte a mecanismos convenientes de renomeação de recursos ou de vários buffers.</span><span class="sxs-lookup"><span data-stu-id="13e3a-134">D3D12 no longer synchronizes the CPU and GPU, nor supports convenient mechanisms for resource renaming or multi-buffering.</span></span> <span data-ttu-id="13e3a-135">Os limites devem ser usados para evitar que várias unidades de processamento substituam a memória excessiva antes que outra unidade de processamento termine de usá-la.</span><span class="sxs-lookup"><span data-stu-id="13e3a-135">Fences must be used to avoid multiple processing units from over-writing memory before another processing unit finishes using it.</span></span>

<span data-ttu-id="13e3a-136">O aplicativo Direct3D 12 deve garantir que os dados estejam residentes na memória enquanto a GPU lê.</span><span class="sxs-lookup"><span data-stu-id="13e3a-136">The Direct3D 12 application must ensure data is resident in memory while the GPU reads it.</span></span> <span data-ttu-id="13e3a-137">A memória usada por cada objeto torna-se residente durante a criação do objeto.</span><span class="sxs-lookup"><span data-stu-id="13e3a-137">Memory used by each object is made resident during the creation of the object.</span></span> <span data-ttu-id="13e3a-138">Os aplicativos que chamam esses métodos devem usar limites para garantir que a GPU não acesse objetos que foram removidos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-138">Applications which call these methods must use fences to ensure the GPU doesn't access objects which have been evicted.</span></span>

<span data-ttu-id="13e3a-139">As barreiras de recursos são outro tipo de sincronização necessária, usadas para sincronizar as transições de recurso e de subrecurso em um nível muito granular.</span><span class="sxs-lookup"><span data-stu-id="13e3a-139">Resource barriers are another type of synchronization needed, used to synchronize resource and subresource transitions at a very granular level.</span></span>

<span data-ttu-id="13e3a-140">Consulte [Gerenciamento de memória no Direct3D 12](memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="13e3a-140">Refer to [Memory Management in Direct3D 12](memory-management.md).</span></span>

## <a name="pipeline-state-objects"></a><span data-ttu-id="13e3a-141">Objetos de estado do pipeline</span><span class="sxs-lookup"><span data-stu-id="13e3a-141">Pipeline state objects</span></span>

<span data-ttu-id="13e3a-142">O Direct3D 11 permite a manipulação do estado do pipeline por meio de um grande conjunto de objetos independentes.</span><span class="sxs-lookup"><span data-stu-id="13e3a-142">Direct3D 11 allows pipeline state manipulation through a large set of independent objects.</span></span> <span data-ttu-id="13e3a-143">Por exemplo, o estado do assembler de entrada, o estado do sombreador de pixel, o estado do rasterizador e o estado de fusão de saída podem ser modificados independentemente.</span><span class="sxs-lookup"><span data-stu-id="13e3a-143">For example, input assembler state, pixel shader state, rasterizer state, and output merger state can all be independently modified.</span></span> <span data-ttu-id="13e3a-144">Esse design fornece uma representação conveniente e relativamente de alto nível do pipeline de gráficos, mas não utiliza os recursos do hardware moderno, principalmente porque os vários Estados geralmente são interdependentes.</span><span class="sxs-lookup"><span data-stu-id="13e3a-144">This design provides a convenient and relatively high-level representation of the graphics pipeline, but it doesn’t utilize the capabilities of modern hardware, primarily because the various states are often interdependent.</span></span> <span data-ttu-id="13e3a-145">Por exemplo, muitas GPUs combinam o sombreador de pixel e o estado de fusão de saída em uma única representação de hardware.</span><span class="sxs-lookup"><span data-stu-id="13e3a-145">For example, many GPUs combine pixel shader and output merger state into a single hardware representation.</span></span> <span data-ttu-id="13e3a-146">Mas como a API do Direct3D 11 permite que esses estágios de pipeline sejam definidos separadamente, o driver de vídeo não pode resolver problemas de estado do pipeline até que o estado seja finalizado, o que não é até o momento do desenho.</span><span class="sxs-lookup"><span data-stu-id="13e3a-146">But because the Direct3D 11 API allows these pipeline stages to be set separately, the display driver can't resolve issues of pipeline state until the state is finalized, which isn’t until draw time.</span></span> <span data-ttu-id="13e3a-147">Esse esquema atrasa a configuração do estado do hardware, o que significa sobrecarga extra e menos chamadas de desenho máximas por quadro.</span><span class="sxs-lookup"><span data-stu-id="13e3a-147">This scheme delays hardware state setup, which means extra overhead and fewer maximum draw calls per frame.</span></span>

<span data-ttu-id="13e3a-148">O Direct3D 12 trata desse esquema, unificando grande parte do estado do pipeline em PSOs (objetos de estado de pipeline) imutáveis, que são finalizados após a criação.</span><span class="sxs-lookup"><span data-stu-id="13e3a-148">Direct3D 12 addresses this scheme by unifying much of the pipeline state into immutable pipeline state objects (PSOs), which are finalized upon creation.</span></span> <span data-ttu-id="13e3a-149">Hardware e drivers podem então converter imediatamente o PSO em quaisquer instruções e Estados nativos de hardware necessários para executar o trabalho de GPU.</span><span class="sxs-lookup"><span data-stu-id="13e3a-149">Hardware and drivers can then immediately convert the PSO into whatever hardware native instructions and state are required to execute GPU work.</span></span> <span data-ttu-id="13e3a-150">Você ainda pode alterar dinamicamente qual PSO está em uso, mas para fazer isso, o hardware precisa apenas copiar a quantidade mínima de Estado previamente computado diretamente para os registros de hardware, em vez de computar o estado do hardware em tempo real.</span><span class="sxs-lookup"><span data-stu-id="13e3a-150">You can still dynamically change which PSO is in use, but to do so, the hardware only needs to copy the minimal amount of pre-computed state directly to the hardware registers, rather than computing the hardware state on the fly.</span></span> <span data-ttu-id="13e3a-151">Usando PSOs, a sobrecarga de chamada de desenho é reduzida de forma significativa e muitas outras chamadas de desenho podem ocorrer por quadro.</span><span class="sxs-lookup"><span data-stu-id="13e3a-151">By using PSOs, draw call overhead is reduced significantly, and many more draw calls can occur per frame.</span></span> <span data-ttu-id="13e3a-152">Para obter mais informações sobre o PSOs, consulte [Gerenciando o estado do pipeline de gráficos no Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="13e3a-152">For more information about PSOs, see [Managing graphics pipeline state in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="command-lists-and-bundles"></a><span data-ttu-id="13e3a-153">Listas de comandos e pacotes</span><span class="sxs-lookup"><span data-stu-id="13e3a-153">Command lists and bundles</span></span>

<span data-ttu-id="13e3a-154">No Direct3D 11, todo o envio de trabalho é feito por meio do [contexto imediato](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), que representa um único fluxo de comandos que vão para a GPU.</span><span class="sxs-lookup"><span data-stu-id="13e3a-154">In Direct3D 11, all work submission is done via the [immediate context](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), which represents a single stream of commands that go to the GPU.</span></span> <span data-ttu-id="13e3a-155">Para obter o dimensionamento multithread, os jogos também têm [contextos adiados](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) disponíveis para eles.</span><span class="sxs-lookup"><span data-stu-id="13e3a-155">To achieve multithreaded scaling, games also have [deferred contexts](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) available to them.</span></span> <span data-ttu-id="13e3a-156">Contextos adiados no Direct3D 11 não são mapeados perfeitamente para hardware, portanto, relativamente pouco trabalho pode ser feito neles.</span><span class="sxs-lookup"><span data-stu-id="13e3a-156">Deferred contexts in Direct3D 11 don't map perfectly to hardware, so relatively little work can be done in them.</span></span>

<span data-ttu-id="13e3a-157">O Direct3D 12 introduz um novo modelo de envio de trabalho com base em listas de comandos que contêm todo o necessário de informações necessárias para executar uma carga de trabalhos específica na GPU.</span><span class="sxs-lookup"><span data-stu-id="13e3a-157">Direct3D 12 introduces a new model for work submission based on command lists that contain the entirety of information needed to execute a particular workload on the GPU.</span></span> <span data-ttu-id="13e3a-158">Cada nova lista de comandos contém informações como qual PSO usar, quais recursos de textura e buffer são necessários e os argumentos para todas as chamadas de desenho.</span><span class="sxs-lookup"><span data-stu-id="13e3a-158">Each new command list contains information such as which PSO to use, what texture and buffer resources are needed, and the arguments to all draw calls.</span></span> <span data-ttu-id="13e3a-159">Como cada lista de comandos é independente e não herda nenhum estado, o driver pode pré-testar previamente todos os comandos de GPU necessários antes e em uma maneira de thread livre.</span><span class="sxs-lookup"><span data-stu-id="13e3a-159">Because each command list is self-contained and inherits no state, the driver can pre-compute all necessary GPU commands up-front and in a free-threaded manner.</span></span> <span data-ttu-id="13e3a-160">O único processo serial necessário é o envio final de listas de comandos para a GPU por meio da fila de comandos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-160">The only serial process necessary is the final submission of command lists to the GPU via the command queue.</span></span>

<span data-ttu-id="13e3a-161">Além das listas de comandos, o Direct3D 12 também introduz um segundo nível de trabalho de computação prévia: *grupos*.</span><span class="sxs-lookup"><span data-stu-id="13e3a-161">In addition to command lists, Direct3D 12 also introduces a second level of work pre-computation: *bundles*.</span></span> <span data-ttu-id="13e3a-162">Ao contrário das listas de comandos, que são completamente independentes e são normalmente construídas, enviadas uma vez e descartadas, os grupos fornecem uma forma de herança de estado que permite a reutilização.</span><span class="sxs-lookup"><span data-stu-id="13e3a-162">Unlike command lists, which are completely self-contained and are typically constructed, submitted once, and discarded, bundles provide a form of state inheritance that permits reuse.</span></span> <span data-ttu-id="13e3a-163">Por exemplo, se um jogo quiser desenhar dois modelos de caractere com texturas diferentes, uma abordagem será registrar uma lista de comandos com dois conjuntos de chamadas de desenho idênticas.</span><span class="sxs-lookup"><span data-stu-id="13e3a-163">For example, if a game wants to draw two character models with different textures, one approach is to record a command list with two sets of identical draw calls.</span></span> <span data-ttu-id="13e3a-164">Mas outra abordagem é "registrar" um pacote que desenha um único modelo de caractere e, em seguida, "reproduzir" o pacote duas vezes na lista de comandos usando diferentes recursos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-164">But another approach is to "record" one bundle that draws a single character model, then "play back" the bundle twice on the command list using different resources.</span></span> <span data-ttu-id="13e3a-165">No último caso, o driver de vídeo só precisa computar as instruções apropriadas uma vez e criar a lista de comandos é basicamente uma quantidade de duas chamadas de função de baixo custo.</span><span class="sxs-lookup"><span data-stu-id="13e3a-165">In the latter case, the display driver only has to compute the appropriate instructions once, and creating the command list essentially amounts to two low-cost function calls.</span></span>

<span data-ttu-id="13e3a-166">Para obter mais informações sobre listas de comandos e pacotes, consulte [envio de trabalho no Direct3D 12](command-queues-and-command-lists.md).</span><span class="sxs-lookup"><span data-stu-id="13e3a-166">For more information about command lists and bundles, see [Work Submission in Direct3D 12](command-queues-and-command-lists.md).</span></span>

## <a name="descriptor-heaps-and-tables"></a><span data-ttu-id="13e3a-167">Heaps e tabelas do descritor</span><span class="sxs-lookup"><span data-stu-id="13e3a-167">Descriptor heaps and tables</span></span>

<span data-ttu-id="13e3a-168">A associação de recursos no Direct3D 11 é altamente abstrata e conveniente, mas deixa muitos recursos de hardware modernos subutilizados.</span><span class="sxs-lookup"><span data-stu-id="13e3a-168">Resource binding in Direct3D 11 is highly abstracted and convenient, but leaves many modern hardware capabilities underutilized.</span></span> <span data-ttu-id="13e3a-169">No Direct3D 11, os jogos criam objetos de *exibição* de recursos e associam essas exibições a vários *Slots* em vários estágios de sombreador no pipeline.</span><span class="sxs-lookup"><span data-stu-id="13e3a-169">In Direct3D 11, games create *view* objects of resources, then bind those views to several *slots* at various shader stages in the pipeline.</span></span> <span data-ttu-id="13e3a-170">Os sombreadores, por sua vez, lêem dados desses slots de ligação explícitos, que são corrigidos no momento do empate.</span><span class="sxs-lookup"><span data-stu-id="13e3a-170">Shaders, in turn, read data from those explicit bind slots, which are fixed at draw time.</span></span> <span data-ttu-id="13e3a-171">Esse modelo significa que sempre que um jogo for desenhado usando recursos diferentes, ele deverá reassociar diferentes modos de exibição a Slots diferentes e chamar o Draw novamente.</span><span class="sxs-lookup"><span data-stu-id="13e3a-171">This model means that whenever a game will draw using different resources, it must re-bind different views to different slots, and call draw again.</span></span> <span data-ttu-id="13e3a-172">Esse caso também representa a sobrecarga que pode ser eliminada por meio da utilização completa dos recursos de hardware modernos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-172">This case also represents overhead that can be eliminated by fully utilizing modern hardware capabilities.</span></span>

<span data-ttu-id="13e3a-173">O Direct3D 12 altera o modelo de associação para corresponder ao hardware moderno e melhora significativamente o desempenho.</span><span class="sxs-lookup"><span data-stu-id="13e3a-173">Direct3D 12 changes the binding model to match modern hardware and significantly improves performance.</span></span> <span data-ttu-id="13e3a-174">Em vez de exigir exibições de recursos autônomos e mapeamento explícito para slots, o Direct3D 12 fornece um heap de descritor no qual os jogos criam seus diversos modos de exibição de recursos.</span><span class="sxs-lookup"><span data-stu-id="13e3a-174">Instead of requiring standalone resource views and explicit mapping to slots, Direct3D 12 provides a descriptor heap into which games create their various resource views.</span></span> <span data-ttu-id="13e3a-175">Esse esquema fornece um mecanismo para a GPU gravar diretamente a descrição do recurso nativo do hardware (descritor) na memória ativa.</span><span class="sxs-lookup"><span data-stu-id="13e3a-175">This scheme provides a mechanism for the GPU to directly write the hardware-native resource description (descriptor) to memory up-front.</span></span> <span data-ttu-id="13e3a-176">Para declarar quais recursos devem ser usados pelo pipeline para uma chamada de desenho particular, os jogos especificam uma ou mais tabelas de descritores que representam subintervalos do heap de descritor completo.</span><span class="sxs-lookup"><span data-stu-id="13e3a-176">To declare which resources are to be used by the pipeline for a particular draw call, games specify one or more descriptor tables that represent sub-ranges of the full descriptor heap.</span></span> <span data-ttu-id="13e3a-177">Como o heap de descritor já foi populado com os dados apropriados de descritor específicos de hardware, a alteração de tabelas de descritores é uma operação de custo extremamente baixo.</span><span class="sxs-lookup"><span data-stu-id="13e3a-177">As the descriptor heap has already been populated with the appropriate hardware-specific descriptor data, changing descriptor tables is an extremely low-cost operation.</span></span>

<span data-ttu-id="13e3a-178">Além do desempenho aprimorado oferecido pelos heaps e tabelas do descritor, o Direct3D 12 também permite que os recursos sejam indexados dinamicamente em sombreadores, o que fornece flexibilidade incomparável e desbloqueia novas técnicas de renderização.</span><span class="sxs-lookup"><span data-stu-id="13e3a-178">In addition to the improved performance offered by descriptor heaps and tables, Direct3D 12 also allows resources to be dynamically indexed in shaders, which provides unprecedented flexibility and unlocks new rendering techniques.</span></span> <span data-ttu-id="13e3a-179">Por exemplo, os mecanismos de renderização adiados modernos normalmente codificam um material ou identificador de objeto de algum tipo para o g-buffer intermediário.</span><span class="sxs-lookup"><span data-stu-id="13e3a-179">As an example, modern deferred rendering engines typically encode a material or object identifier of some kind to the intermediate g-buffer.</span></span> <span data-ttu-id="13e3a-180">No Direct3D 11, esses mecanismos devem ter cuidado para evitar o uso de materiais demais, pois incluir muitas em um g-buffer pode retardar significativamente a passagem de renderização final.</span><span class="sxs-lookup"><span data-stu-id="13e3a-180">In Direct3D 11, these engines must be careful to avoid using too many materials, as including too many in one g-buffer can significantly slow down the final render pass.</span></span> <span data-ttu-id="13e3a-181">Com recursos indexáveis dinamicamente, uma cena com milhares de materiais pode ser finalizada com a mesma rapidez que apenas uma com dez.</span><span class="sxs-lookup"><span data-stu-id="13e3a-181">With dynamically indexable resources, a scene with a thousand materials can be finalized just as quickly as one with only ten.</span></span>

<span data-ttu-id="13e3a-182">Para obter mais informações sobre heaps e tabelas do descritor, consulte [Associação de recursos](resource-binding.md)e [diferenças no modelo de associação do Direct3D 11](binding-model.md).</span><span class="sxs-lookup"><span data-stu-id="13e3a-182">For more information about descriptor heaps and tables, see [Resource Binding](resource-binding.md), and [Differences in the Binding Model from Direct3D 11](binding-model.md).</span></span>

## <a name="porting-from-direct3d-11"></a><span data-ttu-id="13e3a-183">Portando do Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="13e3a-183">Porting from Direct3D 11</span></span>

<span data-ttu-id="13e3a-184">O portamento do Direct3D 11 é um processo envolvido, descrito em [portando do Direct3D 11 para o Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="13e3a-184">Porting from Direct3D 11 is an involved process, described in [Porting from Direct3D 11 to Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span></span> <span data-ttu-id="13e3a-185">Consulte também o intervalo de opções em [trabalhando com o Direct3D 11, o Direct3D 10 e o Direct2D](direct3d-12-interop.md).</span><span class="sxs-lookup"><span data-stu-id="13e3a-185">Also refer to the range of options in [Working with Direct3D 11, Direct3D 10 and Direct2D](direct3d-12-interop.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="13e3a-186">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="13e3a-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="13e3a-187">Entendendo o Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="13e3a-187">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> </dl>

 

 