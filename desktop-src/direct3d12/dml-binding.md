---
title: Associação no DirectML
description: No DirectML, a associação refere-se ao anexo de recursos para o pipeline a ser usado pela GPU durante a inicialização e execução de seus operadores de aprendizado de máquina.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: a04bf0bcc63fff810604e3db72fe507cc10040f5
ms.sourcegitcommit: db89157e3be911fdce2e543e99faa31fb2403bc8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/18/2020
ms.locfileid: "104548254"
---
# <a name="binding-in-directml"></a><span data-ttu-id="4d60d-103">Associação no DirectML</span><span class="sxs-lookup"><span data-stu-id="4d60d-103">Binding in DirectML</span></span>

<span data-ttu-id="4d60d-104">No DirectML, a *Associação* refere-se ao anexo de recursos para o pipeline a ser usado pela GPU durante a inicialização e execução de seus operadores de aprendizado de máquina.</span><span class="sxs-lookup"><span data-stu-id="4d60d-104">In DirectML, *binding* refers to the attachment of resources to the pipeline for the GPU to use during the initialization and execution of your machine learning operators.</span></span> <span data-ttu-id="4d60d-105">Esses recursos podem ser tempos de entrada e de saída, por exemplo, bem como quaisquer recursos temporários ou persistentes que o operador precisa.</span><span class="sxs-lookup"><span data-stu-id="4d60d-105">These resources can be input and output tensors, for example, as well as any temporary or persistent resources that the operator needs.</span></span>

<span data-ttu-id="4d60d-106">Este tópico aborda os detalhes conceituais e de procedimento de Binding.</span><span class="sxs-lookup"><span data-stu-id="4d60d-106">This topic addresses the conceptual and procedural details of binding.</span></span> <span data-ttu-id="4d60d-107">Recomendamos que você também leia por completo a documentação das APIs que chama, incluindo os parâmetros e comentários.</span><span class="sxs-lookup"><span data-stu-id="4d60d-107">We recommend that you also fully read the documentation for the APIs that you call, including parameters and Remarks.</span></span>

## <a name="important-ideas-in-binding"></a><span data-ttu-id="4d60d-108">Ideias importantes na associação</span><span class="sxs-lookup"><span data-stu-id="4d60d-108">Important ideas in binding</span></span>

<span data-ttu-id="4d60d-109">A lista de etapas abaixo contém uma descrição de alto nível das tarefas relacionadas à associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-109">The list of steps below contain a high-level description of binding-related tasks.</span></span> <span data-ttu-id="4d60d-110">Você precisa seguir estas etapas sempre que você [executar um expatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)um que pode ser expedivel &mdash; é um inicializador de operador ou um operador compilado.</span><span class="sxs-lookup"><span data-stu-id="4d60d-110">You need to follow these steps each time you execute a [dispatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)&mdash;a dispatchable is either an operator initializer or a compiled operator.</span></span> <span data-ttu-id="4d60d-111">Essas etapas apresentam as ideias, estruturas e métodos importantes envolvidos na associação DirectML.</span><span class="sxs-lookup"><span data-stu-id="4d60d-111">These steps introduce the important ideas, structures, and methods involved in DirectML binding.</span></span>

<span data-ttu-id="4d60d-112">As seções subsequentes neste tópico se aprofundam e explicam essas tarefas de vinculação com mais detalhes, com trechos de código ilustrativos extraídos do exemplo de código de [aplicativo DirectML mínimo](dml-min-app.md) .</span><span class="sxs-lookup"><span data-stu-id="4d60d-112">Subsequent sections in this topic dig deeper and explain these binding tasks in more detail, with illustrative code snippets taken from the [minimal DirectML application](dml-min-app.md) code example.</span></span>

- <span data-ttu-id="4d60d-113">Chame [**IDMLDispatchable:: Getbindproperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) no expedible para determinar quantos descritores ele precisa e também suas necessidades de recursos temporário/persistente.</span><span class="sxs-lookup"><span data-stu-id="4d60d-113">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) on the dispatchable to determine how many descriptors it needs, and also its temporary/persistent resource needs.</span></span>
- <span data-ttu-id="4d60d-114">Crie um heap de descritor do Direct3D 12 grande o suficiente para os descritores e associe-o ao pipeline.</span><span class="sxs-lookup"><span data-stu-id="4d60d-114">Create a Direct3D 12 descriptor heap large enough for the descriptors, and bind it to the pipeline.</span></span>
- <span data-ttu-id="4d60d-115">Chame [**IDMLDevice:: Createbindtable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) para criar uma tabela de associação DirectML para representar os recursos associados ao pipeline.</span><span class="sxs-lookup"><span data-stu-id="4d60d-115">Call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create a DirectML binding table to represent the resources bound to the pipeline.</span></span> <span data-ttu-id="4d60d-116">Use a estrutura [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) para descrever sua tabela de associação, incluindo o subconjunto dos descritores que aponta para o heap do descritor.</span><span class="sxs-lookup"><span data-stu-id="4d60d-116">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the subset of the descriptors that it points to in the descriptor heap.</span></span>
- <span data-ttu-id="4d60d-117">Crie recursos temporários/persistentes como recursos de buffer do Direct3D 12, descreva-os com estruturas [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) e [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) e adicione-os à tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-117">Create temporary/persistent resources as Direct3D 12 buffer resources, describe them with [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) and [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structures, and add them to the binding table.</span></span>
- <span data-ttu-id="4d60d-118">Se o expatchable for um operador compilado, crie um buffer de elementos tensor como um recurso de buffer do Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="4d60d-118">If the dispatchable is a compiled operator, then create a buffer of tensor elements as a Direct3D 12 buffer resource.</span></span> <span data-ttu-id="4d60d-119">Preencha/carregue-o, descreva-o com estruturas **DML_BUFFER_BINDING** e **DML_BINDING_DESC** e adicione-o à tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-119">Populate/upload it, describe it with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and add it to the binding table.</span></span>
- <span data-ttu-id="4d60d-120">Passe sua tabela de associação como um parâmetro ao chamar [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="4d60d-120">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

## <a name="retrieve-the-binding-properties-of-a-dispatchable"></a><span data-ttu-id="4d60d-121">Recuperar as propriedades de associação de um impedible</span><span class="sxs-lookup"><span data-stu-id="4d60d-121">Retrieve the binding properties of a dispatchable</span></span>

<span data-ttu-id="4d60d-122">A estrutura de [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) descreve as necessidades de associação de um expatchable (inicializador de operador ou operador compilado).</span><span class="sxs-lookup"><span data-stu-id="4d60d-122">The [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) structure describes the binding needs of a dispatchable (operator initializer or compiled operator).</span></span> <span data-ttu-id="4d60d-123">Essas propriedades relacionadas à associação incluem o número de descritores que você deve associar ao expatchable, bem como o tamanho em bytes de qualquer recurso temporário e/ou persistente necessário.</span><span class="sxs-lookup"><span data-stu-id="4d60d-123">These binding-related properties include the number of descriptors that you should bind to the dispatchable, as well as the size in bytes of any temporary and/or persistent resource that it needs.</span></span>

> [!NOTE]
> <span data-ttu-id="4d60d-124">Mesmo para vários operadores do mesmo tipo, não faça suposições sobre eles com os mesmos requisitos de ligação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-124">Even for multiple operators of the same type, don't make assumptions about them having the same binding requirements.</span></span> <span data-ttu-id="4d60d-125">Consulte as propriedades de associação para cada inicializador e operador que você criar.</span><span class="sxs-lookup"><span data-stu-id="4d60d-125">Query the binding properties for every initializer and operator that you create.</span></span>

<span data-ttu-id="4d60d-126">Chame [**IDMLDispatchable:: Getbindproperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) para recuperar um **DML_BINDING_PROPERTIES**.</span><span class="sxs-lookup"><span data-stu-id="4d60d-126">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) to retrieve a **DML_BINDING_PROPERTIES**.</span></span>

```cppwinrt
winrt::com_ptr<::IDMLCompiledOperator> dmlCompiledOperator;
// Code to create and compile a DirectML operator goes here.

DML_BINDING_PROPERTIES executeDmlBindingProperties{
    dmlCompiledOperator->GetBindingProperties()
};

winrt::com_ptr<::IDMLOperatorInitializer> dmlOperatorInitializer;
// Code to create a DirectML operator initializer goes here.

DML_BINDING_PROPERTIES initializeDmlBindingProperties{
    dmlOperatorInitializer->GetBindingProperties()
};

UINT descriptorCount = ...
```

<span data-ttu-id="4d60d-127">O `descriptorCount` valor que você recupera aqui determina o tamanho (mínimo) do heap do descritor e da tabela de associação que você cria nas próximas duas etapas.</span><span class="sxs-lookup"><span data-stu-id="4d60d-127">The `descriptorCount` value that you retrieve here determines the (minimum) size of the descriptor heap and of the binding table that you create in the next two steps.</span></span>

<span data-ttu-id="4d60d-128">**DML_BINDING_PROPERTIES** também contém um `TemporaryResourceSize` membro, que é o tamanho mínimo em bytes do recurso temporário que deve ser associado à tabela de associação para esse objeto que pode ser expedido.</span><span class="sxs-lookup"><span data-stu-id="4d60d-128">**DML_BINDING_PROPERTIES** also contains a `TemporaryResourceSize` member, which is the minimum size in bytes of the temporary resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="4d60d-129">Um valor de zero significa que um recurso temporário não é necessário.</span><span class="sxs-lookup"><span data-stu-id="4d60d-129">A value of zero means that a temporary resource is not required.</span></span>

<span data-ttu-id="4d60d-130">E um `PersistentResourceSize` membro, que é o tamanho mínimo em bytes do recurso persistente que deve ser associado à tabela de associação para esse objeto que pode ser expedido.</span><span class="sxs-lookup"><span data-stu-id="4d60d-130">And a `PersistentResourceSize` member, which is the minimum size in bytes of the persistent resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="4d60d-131">Um valor de zero significa que um recurso persistente não é necessário.</span><span class="sxs-lookup"><span data-stu-id="4d60d-131">A value of zero means that a persistent resource is not required.</span></span> <span data-ttu-id="4d60d-132">Um recurso persistente, se for necessário, deve ser fornecido durante a inicialização de um operador compilado (onde está associado como uma saída do inicializador do operador), bem como durante a execução.</span><span class="sxs-lookup"><span data-stu-id="4d60d-132">A persistent resource, if one is needed, must be supplied during initialization of a compiled operator (where it is bound as an output of the operator initializer) as well as during execution.</span></span> <span data-ttu-id="4d60d-133">Há mais informações sobre isso posteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="4d60d-133">There's more about this later in this topic.</span></span> <span data-ttu-id="4d60d-134">Somente operadores compilados têm recursos persistentes – inicializadores de operador sempre retornam um valor de 0 para esse membro.</span><span class="sxs-lookup"><span data-stu-id="4d60d-134">Only compiled operators have persistent resources—operator initializers always return a value of 0 for this member.</span></span>

<span data-ttu-id="4d60d-135">Se você chamar **IDMLDispatchable:: Getbindproperties** em um inicializador de operador antes e depois de uma chamada para [**IDMLOperatorInitializer:: Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), os dois conjuntos de propriedades de associação recuperados não terão a garantia de serem idênticos.</span><span class="sxs-lookup"><span data-stu-id="4d60d-135">If you call **IDMLDispatchable::GetBindingProperties** on an operator initializer both before and after a call to [**IDMLOperatorInitializer::Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), then the two sets of binding properties retrieved are not guaranteed to be identical.</span></span>

## <a name="describe-create-and-bind-a-descriptor-heap"></a><span data-ttu-id="4d60d-136">Descrever, criar e associar um heap de descritor</span><span class="sxs-lookup"><span data-stu-id="4d60d-136">Describe, create, and bind a descriptor heap</span></span>

<span data-ttu-id="4d60d-137">Em termos de descritores, sua responsabilidade começa e termina com o próprio heap de descritor.</span><span class="sxs-lookup"><span data-stu-id="4d60d-137">In terms of descriptors, your responsibility begins and ends with the descriptor heap itself.</span></span> <span data-ttu-id="4d60d-138">O próprio DirectML cuida da criação e do gerenciamento dos descritores dentro do heap que você fornece.</span><span class="sxs-lookup"><span data-stu-id="4d60d-138">DirectML itself takes care of creating and managing the descriptors inside of the heap that you provide.</span></span>

<span data-ttu-id="4d60d-139">Portanto, use uma estrutura de [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) para descrever um heap grande o suficiente para o número de descritores que o expedible precisa.</span><span class="sxs-lookup"><span data-stu-id="4d60d-139">So, use a [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) structure to describe a heap large enough for the number of descriptors that the dispatchable needs.</span></span> <span data-ttu-id="4d60d-140">Em seguida, crie-o com [**ID3D12Device:: CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span><span class="sxs-lookup"><span data-stu-id="4d60d-140">Then create it with [**ID3D12Device::CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span></span> <span data-ttu-id="4d60d-141">E, por fim, chame [**ID3D12GraphicsCommandList:: SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) para associar o heap de descritor ao pipeline.</span><span class="sxs-lookup"><span data-stu-id="4d60d-141">And, lastly, call [**ID3D12GraphicsCommandList::SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) to bind your descriptor heap to the pipeline.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12DescriptorHeap> d3D12DescriptorHeap;

D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription{};
descriptorHeapDescription.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
descriptorHeapDescription.NumDescriptors = descriptorCount;
descriptorHeapDescription.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

winrt::check_hresult(
    d3D12Device->CreateDescriptorHeap(
        &descriptorHeapDescription,
        _uuidof(d3D12DescriptorHeap),
        d3D12DescriptorHeap.put_void()
    )
);

std::array<ID3D12DescriptorHeap*, 1> d3D12DescriptorHeaps{ d3D12DescriptorHeap.get() };
d3D12GraphicsCommandList->SetDescriptorHeaps(
    static_cast<UINT>(d3D12DescriptorHeaps.size()),
    d3D12DescriptorHeaps.data()
);
```

## <a name="describe-and-create-a-binding-table"></a><span data-ttu-id="4d60d-142">Descrever e criar uma tabela de associação</span><span class="sxs-lookup"><span data-stu-id="4d60d-142">Describe and create a binding table</span></span>

<span data-ttu-id="4d60d-143">Uma tabela de associação DirectML representa os recursos que você associa ao pipeline para que um seja impedido de usar.</span><span class="sxs-lookup"><span data-stu-id="4d60d-143">A DirectML binding table represents the resources that you bind to the pipeline for a dispatchable to use.</span></span> <span data-ttu-id="4d60d-144">Esses recursos podem ser de entrada e de saída (ou outros parâmetros) para um operador, ou podem ser vários recursos persistentes e temporários com os quais um impedible funciona.</span><span class="sxs-lookup"><span data-stu-id="4d60d-144">Those resources could be input and output tensors (or other parameters) for an operator, or they could be various persistent and temporary resources that a dispatchable works with.</span></span>

<span data-ttu-id="4d60d-145">Use a estrutura [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) para descrever sua tabela de associação, incluindo o expatchable para o qual a tabela de associação representará as associações e o intervalo de descritores (do heap de descrição que você acabou de criar) ao qual você deseja que a tabela de associação se refira (e em que DirectML pode gravar descritores).</span><span class="sxs-lookup"><span data-stu-id="4d60d-145">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the dispatchable for which the binding table will represent the bindings, and the range of descriptors (from the descriptor heap that you just created) that you wish the binding table to refer to (and into which DirectML may write descriptors).</span></span> <span data-ttu-id="4d60d-146">O `descriptorCount` valor (uma das propriedades de associação que recuperamos na primeira etapa) nos informa qual tamanho mínimo é, em descritores, da tabela de associação necessária para o objeto que pode ser expedido.</span><span class="sxs-lookup"><span data-stu-id="4d60d-146">The `descriptorCount` value (one of the binding properties that we retrieved in the first step) tells us what minimum size is, in descriptors, of the binding table required for the dispatchable object.</span></span> <span data-ttu-id="4d60d-147">Aqui, usamos esse valor para indicar o número máximo de descritores que o DirectML tem permissão para gravar em nosso heap, desde o início dos identificadores de CPU e de descritores de GPU fornecidos.</span><span class="sxs-lookup"><span data-stu-id="4d60d-147">Here, we use that value to indicate the maximum number of descriptors that DirectML is permitted to write into our heap, from the start of both the supplied CPU and GPU descriptor handles.</span></span>

<span data-ttu-id="4d60d-148">Em seguida, chame [**IDMLDevice:: Createbindtable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) para criar a tabela de associação DirectML.</span><span class="sxs-lookup"><span data-stu-id="4d60d-148">Then call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create the DirectML binding table.</span></span> <span data-ttu-id="4d60d-149">Em etapas posteriores, depois de criarmos outros recursos para o que pode ser expedido, adicionaremos esses recursos à tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-149">In later steps, after we've created further resources for the dispatchable, we'll add those resources to the binding table.</span></span>

<span data-ttu-id="4d60d-150">Em vez de passar um **DML_BINDING_TABLE_DESC** para essa chamada, você pode passar `nullptr` , indicando uma tabela de associação vazia.</span><span class="sxs-lookup"><span data-stu-id="4d60d-150">Instead of passing a **DML_BINDING_TABLE_DESC** to this call, you can pass `nullptr`, indicating an empty binding table.</span></span>

```cppwinrt
DML_BINDING_TABLE_DESC dmlBindingTableDesc{};
dmlBindingTableDesc.Dispatchable = dmlOperatorInitializer.get();
dmlBindingTableDesc.CPUDescriptorHandle = d3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.GPUDescriptorHandle = d3D12DescriptorHeap->GetGPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.SizeInDescriptors = descriptorCount;

winrt::com_ptr<::IDMLBindingTable> dmlBindingTable;
winrt::check_hresult(
    dmlDevice->CreateBindingTable(
        &dmlBindingTableDesc,
        __uuidof(dmlBindingTable),
        dmlBindingTable.put_void()
    )
);
```

<span data-ttu-id="4d60d-151">A ordem na qual o DirectML grava os descritores no heap não é especificado, de modo que seu aplicativo deve tomar cuidado para não substituir os descritores encapsulados pela tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-151">The order in which DirectML writes descriptors into the heap is unspecified, so your application must take care not to overwrite the descriptors wrapped by the binding table.</span></span> <span data-ttu-id="4d60d-152">Os identificadores de CPU e de descritores de GPU fornecidos podem vir de heaps diferentes. no entanto, é responsabilidade do seu aplicativo garantir que todo o intervalo de descritores referido pelo identificador do descritor de CPU seja copiado para o intervalo referido pelo identificador do descritor de GPU antes da execução usando essa tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-152">The supplied CPU and GPU descriptor handles may come from different heaps, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span> <span data-ttu-id="4d60d-153">O heap de descritor do qual os identificadores são fornecidos deve ter o tipo **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span><span class="sxs-lookup"><span data-stu-id="4d60d-153">The descriptor heap from which the handles are supplied must have type **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span></span> <span data-ttu-id="4d60d-154">Além disso, o heap referido pelo `GPUDescriptorHandle` deve ser um heap de descritor visível para sombreador.</span><span class="sxs-lookup"><span data-stu-id="4d60d-154">Additionally, the heap referred to by the `GPUDescriptorHandle` must be a shader-visible descriptor heap.</span></span>

<span data-ttu-id="4d60d-155">Você pode redefinir uma tabela de associação para remover todos os recursos que você adicionou a ela, enquanto, ao mesmo tempo, altera qualquer propriedade definida em seu **DML_BINDING_TABLE_DESC** inicial (para encapsular um novo intervalo de descritores ou para reutilizá-lo para um distribuidor diferente).</span><span class="sxs-lookup"><span data-stu-id="4d60d-155">You can reset a binding table to remove any resources that you've added to it, while at the same time changing any property that you set on its initial **DML_BINDING_TABLE_DESC** (to wrap a new range of descriptors, or to re-use it for a different dispatchable).</span></span> <span data-ttu-id="4d60d-156">Basta fazer as alterações na estrutura de descrição e chamar [**IDMLBindingTable:: Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span><span class="sxs-lookup"><span data-stu-id="4d60d-156">Just make the changes to the description structure, and call [**IDMLBindingTable::Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span></span>

```cppwinrt
dmlBindingTableDesc.Dispatchable = pIDMLCompiledOperator.get();

winrt::check_hresult(
    pIDMLBindingTable->Reset(
        &dmlBindingTableDesc
    )
);
```

## <a name="describe-and-bind-any-temporarypersistent-resources"></a><span data-ttu-id="4d60d-157">Descrever e associar qualquer recurso temporário/persistente</span><span class="sxs-lookup"><span data-stu-id="4d60d-157">Describe and bind any temporary/persistent resources</span></span>

<span data-ttu-id="4d60d-158">A estrutura de **DML_BINDING_PROPERTIES** que populamos quando [recuperamos as propriedades de associação](#retrieve-the-binding-properties-of-a-dispatchable) de nosso expedible contém o tamanho em bytes de qualquer recurso temporário e/ou persistente que o expedible precisa.</span><span class="sxs-lookup"><span data-stu-id="4d60d-158">The **DML_BINDING_PROPERTIES** structure that we populated when we [retrieved the binding properties](#retrieve-the-binding-properties-of-a-dispatchable) of our dispatchable contains the size in bytes of any temporary and/or persistent resource that the dispatchable needs.</span></span> <span data-ttu-id="4d60d-159">Se um desses tamanhos for diferente de zero, crie um recurso de buffer do Direct3D 12 e adicione-o à tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-159">If either of these sizes is non-zero, then create a Direct3D 12 buffer resource and add it to the binding table.</span></span>

<span data-ttu-id="4d60d-160">No exemplo de código abaixo, criamos um recurso temporário ( `temporaryResourceSize` bytes de tamanho) para o que pode ser expedido.</span><span class="sxs-lookup"><span data-stu-id="4d60d-160">In the code example below, we create a temporary resource (`temporaryResourceSize` bytes in size) for the dispatchable.</span></span> <span data-ttu-id="4d60d-161">Descrevemos como desejamos associar o recurso e, em seguida, adicionamos essa associação à tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-161">We describe how we wish to bind the resource, and then we add that binding to the binding table.</span></span>

<span data-ttu-id="4d60d-162">Como estamos ligando um único recurso de buffer, descrevemos nossa associação com uma estrutura de [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) .</span><span class="sxs-lookup"><span data-stu-id="4d60d-162">Since we're binding a single buffer resource, we describe our binding with a [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) structure.</span></span> <span data-ttu-id="4d60d-163">Nessa estrutura, especificamos o recurso de buffer do Direct3D 12 (o recurso deve ter a dimensão [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), bem como um deslocamento e um tamanho no buffer.</span><span class="sxs-lookup"><span data-stu-id="4d60d-163">In that structure, we specify the Direct3D 12 buffer resource (the resource must have dimension [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), as well as an offset-and-size into the buffer.</span></span> <span data-ttu-id="4d60d-164">Também é possível descrever uma associação para uma matriz de buffers (em vez de para um único buffer) e a estrutura de [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) existe para essa finalidade.</span><span class="sxs-lookup"><span data-stu-id="4d60d-164">It's also possible to describe a binding for an array of buffers (rather than for a single buffer), and the [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) structure exists for that purpose.</span></span>

<span data-ttu-id="4d60d-165">Para abstrair a distinção entre uma associação de buffer e uma associação de matriz de buffer, usamos a estrutura de  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) .</span><span class="sxs-lookup"><span data-stu-id="4d60d-165">To abstract away the distinction between a buffer binding and a buffer array binding, we use the  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structure.</span></span> <span data-ttu-id="4d60d-166">Você pode definir o `Type` membro do **DML_BINDING_DESC** como [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) ou **DML_BINDING_TYPE_BUFFER_ARRAY**.</span><span class="sxs-lookup"><span data-stu-id="4d60d-166">You can set the `Type` member of the **DML_BINDING_DESC** to either [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) or **DML_BINDING_TYPE_BUFFER_ARRAY**.</span></span> <span data-ttu-id="4d60d-167">E, em seguida, você pode definir o `Desc` membro para apontar para um **DML_BUFFER_BINDING** ou para um **DML_BUFFER_ARRAY_BINDING**, dependendo de `Type` .</span><span class="sxs-lookup"><span data-stu-id="4d60d-167">And you can then set the `Desc` member to point to either a **DML_BUFFER_BINDING** or to a **DML_BUFFER_ARRAY_BINDING**, depending on `Type`.</span></span>

<span data-ttu-id="4d60d-168">Estamos lidando com o recurso temporário neste exemplo, portanto, o adicionamos à tabela de associação com uma chamada para [**IDMLBindingTable:: BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span><span class="sxs-lookup"><span data-stu-id="4d60d-168">We're dealing with the temporary resource in this example, so we add it to the binding table with a call to [**IDMLBindingTable::BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span></span>

```cppwinrt
D3D12_HEAP_PROPERTIES defaultHeapProperties{ CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT) };
winrt::com_ptr<::ID3D12Resource> temporaryBuffer;

D3D12_RESOURCE_DESC temporaryBufferDesc{ CD3DX12_RESOURCE_DESC::Buffer(temporaryResourceSize) };
winrt::check_hresult(
    d3D12Device->CreateCommittedResource(
        &defaultHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &temporaryBufferDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        __uuidof(temporaryBuffer),
        temporaryBuffer.put_void()
    )
);

DML_BUFFER_BINDING bufferBinding{ temporaryBuffer.get(), 0, temporaryResourceSize };
DML_BINDING_DESC bindingDesc{ DML_BINDING_TYPE_BUFFER, &bufferBinding };
dmlBindingTable->BindTemporaryResource(&bindingDesc);
```

<span data-ttu-id="4d60d-169">Um recurso temporário (se necessário) é a memória temporária que é usada internamente durante a execução do operador, para que você não precise se preocupar com seu conteúdo.</span><span class="sxs-lookup"><span data-stu-id="4d60d-169">A temporary resource (if one is needed) is scratch memory that's used internally during the execution of the operator, so you don't need to be concerned with its contents.</span></span> <span data-ttu-id="4d60d-170">Nem você precisa mantê-lo depois que sua chamada para [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) foi concluída na GPU.</span><span class="sxs-lookup"><span data-stu-id="4d60d-170">Nor do you need to keep it around after your call to [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) has completed on the GPU.</span></span> <span data-ttu-id="4d60d-171">Isso significa que seu aplicativo pode liberar ou substituir o recurso temporário entre expatches do operador compilado.</span><span class="sxs-lookup"><span data-stu-id="4d60d-171">This means that your application may release or overwrite the temporary resource in between dispatches of the compiled operator.</span></span> <span data-ttu-id="4d60d-172">O intervalo de buffer fornecido a ser associado como o recurso temporário deve ter seu deslocamento de início alinhado com [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="4d60d-172">The supplied buffer range to be bound as the temporary resource must have its start offset aligned to [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="4d60d-173">O tipo do heap subjacente ao buffer deve ser **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="4d60d-173">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

<span data-ttu-id="4d60d-174">No entanto, se o expedivel relatar um tamanho diferente de zero para seu recurso persistente de vida mais longa, o procedimento será um pouco diferente.</span><span class="sxs-lookup"><span data-stu-id="4d60d-174">If the dispatchable reports a non-zero size for its more long-lived persistent resource, though, then the procedure is a little different.</span></span> <span data-ttu-id="4d60d-175">Você deve criar um buffer e descrever uma associação seguindo o mesmo padrão, conforme mostrado acima.</span><span class="sxs-lookup"><span data-stu-id="4d60d-175">You should create a buffer and describe a binding following the same pattern as shown above.</span></span> <span data-ttu-id="4d60d-176">Mas adicione-o à tabela de associação do inicializador do operador com uma chamada para [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), porque é o trabalho do inicializador do operador para inicializar o recurso persistente.</span><span class="sxs-lookup"><span data-stu-id="4d60d-176">But add it to your operator initializer's binding table with a call to [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), because it's the operator initializer's job to initialize the persistent resource.</span></span> <span data-ttu-id="4d60d-177">Em seguida, adicione-o à tabela de associação do operador compilado com uma chamada para [**IDMLBindingTable:: BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span><span class="sxs-lookup"><span data-stu-id="4d60d-177">Then add it to your compiled operator's binding table with a call to [**IDMLBindingTable::BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span></span> <span data-ttu-id="4d60d-178">Consulte o exemplo de código do [aplicativo DirectML mínimo](dml-min-app.md) para ver esse fluxo de trabalho em ação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-178">See the [minimal DirectML application](dml-min-app.md) code example to see this workflow in action.</span></span> <span data-ttu-id="4d60d-179">O conteúdo e o tempo de vida do recurso persistente devem persistir desde que o operador compilado faça.</span><span class="sxs-lookup"><span data-stu-id="4d60d-179">The persistent resource's contents and lifetime must persist as long as the compiled operator does.</span></span> <span data-ttu-id="4d60d-180">Ou seja, se um operador exigir um recurso persistente, seu aplicativo deverá fornecê-lo durante a inicialização e, posteriormente, também fornecê-lo a todas as futuras realizações do operador sem modificar seu conteúdo.</span><span class="sxs-lookup"><span data-stu-id="4d60d-180">That is, if an operator requires a persistent resource, then your application must supply it during initialization and subsequently also supply it to all future executes of the operator without modifying its contents.</span></span> <span data-ttu-id="4d60d-181">Normalmente, o recurso persistente é usado pelo DirectML para armazenar tabelas de pesquisa ou outros dados de longa duração que são computados durante a inicialização de um operador e reutilizados em execuções futuras desse operador.</span><span class="sxs-lookup"><span data-stu-id="4d60d-181">The persistent resource is typically used by DirectML to store lookup tables or other long-lived data that is computed during initialization of an operator and reused on future executions of that operator.</span></span> <span data-ttu-id="4d60d-182">O intervalo de buffer fornecido a ser associado como o buffer persistente deve ter seu deslocamento de início alinhado com [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="4d60d-182">The supplied buffer range to be bound as the persistent buffer must have its start offset aligned to [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="4d60d-183">O tipo do heap subjacente ao buffer deve ser **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="4d60d-183">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

## <a name="describe-and-bind-any-tensors"></a><span data-ttu-id="4d60d-184">Descrever e associar quaisquer tempos</span><span class="sxs-lookup"><span data-stu-id="4d60d-184">Describe and bind any tensors</span></span>

<span data-ttu-id="4d60d-185">Se você estiver lidando com um operador compilado (em vez de um inicializador de operador), você precisará associar recursos de entrada e saída (para dezenases e outros parâmetros) à tabela de associação do operador.</span><span class="sxs-lookup"><span data-stu-id="4d60d-185">If you're dealing with a compiled operator (rather than with an operator initializer), then you need to bind input and output resources (for tensors and other parameters) to the operator's binding table.</span></span> <span data-ttu-id="4d60d-186">O número de associações deve corresponder exatamente ao número de entradas do operador, incluindo os tempos opcionais.</span><span class="sxs-lookup"><span data-stu-id="4d60d-186">The number of bindings must exactly match the number of inputs of the operator, including optional tensors.</span></span> <span data-ttu-id="4d60d-187">Os tempos de entrada e saída específicos e outros parâmetros que um operador usa são documentados no tópico para esse operador (por exemplo, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span><span class="sxs-lookup"><span data-stu-id="4d60d-187">The particular input and output tensors and other parameters that an operator takes are documented in the topic for that operator (for example, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span></span>

<span data-ttu-id="4d60d-188">Um recurso tensor é um buffer que contém os valores de elemento individuais de tensor.</span><span class="sxs-lookup"><span data-stu-id="4d60d-188">A tensor resource is a buffer that contains the individual element values of the tensor.</span></span> <span data-ttu-id="4d60d-189">Você carrega e lê esse buffer de/para a GPU usando as técnicas regulares do Direct3D 12 ([carregar recursos](/windows/desktop/direct3d12/uploading-resources) e [ler dados por meio de um buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span><span class="sxs-lookup"><span data-stu-id="4d60d-189">You upload and read back such a buffer to/from the GPU using the regular Direct3D 12 techniques ([Upload resources](/windows/desktop/direct3d12/uploading-resources) and [Read back data via a buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span></span> <span data-ttu-id="4d60d-190">Consulte o exemplo de código do [aplicativo DirectML mínimo](dml-min-app.md) para ver essas técnicas em ação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-190">See the [minimal DirectML application](dml-min-app.md) code example to see these techniques in action.</span></span>

<span data-ttu-id="4d60d-191">Por fim, descreva as associações de recursos de entrada e saída com estruturas **DML_BUFFER_BINDING** e **DML_BINDING_DESC** e, em seguida, adicione-as à tabela de associação do operador compilado com chamadas para [**IDMLBindingTable:: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) e [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="4d60d-191">Lastly, describe your input and output resource bindings with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and then add them to the compiled operator's binding table with calls to [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span> <span data-ttu-id="4d60d-192">Quando você chama um método \**IDMLBindingTable:: \* BIND* _, o DirectML grava um ou mais descritores no intervalo de descritores de CPU.</span><span class="sxs-lookup"><span data-stu-id="4d60d-192">When you call an \**IDMLBindingTable::Bind\** _ method, DirectML writes one or more descriptors into the range of CPU descriptors.</span></span>

```cppwinrt
DML_BUFFER_BINDING inputBufferBinding{ inputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC inputBindingDesc{ DML_BINDING_TYPE_BUFFER, &inputBufferBinding };
dmlBindingTable->BindInputs(1, &inputBindingDesc);

DML_BUFFER_BINDING outputBufferBinding{ outputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC outputBindingDesc{ DML_BINDING_TYPE_BUFFER, &outputBufferBinding };
dmlBindingTable->BindOutputs(1, &outputBindingDesc);
```

<span data-ttu-id="4d60d-193">Uma das etapas na criação de um operador DirectML (consulte [_ *IDMLDevice:: createoperator* \*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) é declarar uma ou mais estruturas de [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) para descrever os buffers de dados do tensor que o operador usa e retorna.</span><span class="sxs-lookup"><span data-stu-id="4d60d-193">One of the steps in creating a DirectML operator (see [_ *IDMLDevice::CreateOperator*\*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) is to declare one or more [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) structures to describe the tensor data buffers that the operator takes and returns.</span></span> <span data-ttu-id="4d60d-194">Assim como o tipo e o tamanho do buffer tensor, você pode opcionalmente especificar o sinalizador [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) .</span><span class="sxs-lookup"><span data-stu-id="4d60d-194">As well as the tensor buffer's type and size, you can optionally specify the [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) flag.</span></span>

<span data-ttu-id="4d60d-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indica que os dados de tensor devem ser de propriedade e gerenciados pelo DirectML.</span><span class="sxs-lookup"><span data-stu-id="4d60d-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indicates that the tensor data should be owned and managed by DirectML.</span></span> <span data-ttu-id="4d60d-196">O DirectML faz uma cópia dos dados do tensor durante a inicialização do operador e o armazena no recurso persistente.</span><span class="sxs-lookup"><span data-stu-id="4d60d-196">DirectML makes a copy of the tensor data during initialization of the operator, and stores it in the persistent resource.</span></span> <span data-ttu-id="4d60d-197">Isso permite que o DirectML realize a reformatação dos dados do tensor para outras formas mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="4d60d-197">This allows DirectML to perform reformatting of the tensor data into other, more efficient forms.</span></span> <span data-ttu-id="4d60d-198">Definir esse sinalizador pode aumentar o desempenho, mas geralmente é útil apenas para os dezenases cujos dados não são alterados durante o tempo de vida do operador (por exemplo, tempos de peso).</span><span class="sxs-lookup"><span data-stu-id="4d60d-198">Setting this flag may increase performance, but it's typically only useful for tensors whose data doesn't change for the lifetime of the operator (for example, weight tensors).</span></span> <span data-ttu-id="4d60d-199">E o sinalizador só pode ser usado em tempos de entrada.</span><span class="sxs-lookup"><span data-stu-id="4d60d-199">And the flag may only be used on input tensors.</span></span> <span data-ttu-id="4d60d-200">Quando o sinalizador é definido em uma descrição tensor específica, o tensor correspondente deve ser associado à tabela de associação durante a inicialização do operador e não durante a execução (o que resultará em um erro).</span><span class="sxs-lookup"><span data-stu-id="4d60d-200">When the flag is set on a particular tensor description, the corresponding tensor must be bound to the binding table during operator initialization, and not during execution (which will result in an error).</span></span> <span data-ttu-id="4d60d-201">Esse é o oposto do comportamento padrão (o comportamento sem o sinalizador DML_TENSOR_FLAG_OWNED_BY_DML), em que o tensor deve ser associado durante a execução, e não durante a inicialização.</span><span class="sxs-lookup"><span data-stu-id="4d60d-201">That's the opposite of the default behavior (the behavior without the DML_TENSOR_FLAG_OWNED_BY_DML flag), where the tensor is expected to be bound during execution, and not during initialization.</span></span> <span data-ttu-id="4d60d-202">Quando você fornece os dados de tensor para um inicializador de operador, é legal associar um UPLOAD em vez de um heap padrão, pois o DirectML faz uma cópia dos dados.</span><span class="sxs-lookup"><span data-stu-id="4d60d-202">When you supply the tensor data to an operator initializer, it's legal to bind an UPLOAD rather than a DEFAULT heap, because DirectML makes a copy of the data.</span></span> <span data-ttu-id="4d60d-203">Em todos os outros casos, todos os recursos associados a DirectML devem ser recursos de heap padrão.</span><span class="sxs-lookup"><span data-stu-id="4d60d-203">In all other cases, all resources bound to DirectML must be DEFAULT heap resources.</span></span>

<span data-ttu-id="4d60d-204">Para obter mais informações, consulte [**IDMLBindingTable:: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) e [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="4d60d-204">For more info, see [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span>

## <a name="execute-the-dispatchable"></a><span data-ttu-id="4d60d-205">Executar o impedible</span><span class="sxs-lookup"><span data-stu-id="4d60d-205">Execute the dispatchable</span></span>

<span data-ttu-id="4d60d-206">Passe sua tabela de associação como um parâmetro ao chamar [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="4d60d-206">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

<span data-ttu-id="4d60d-207">Quando você usa a tabela de associação durante uma chamada para **IDMLCommandRecorder:: RecordDispatch**, DirectML associa os descritores de GPU correspondentes ao pipeline.</span><span class="sxs-lookup"><span data-stu-id="4d60d-207">When you use the binding table during a call to **IDMLCommandRecorder::RecordDispatch**, DirectML binds the corresponding GPU descriptors to the pipeline.</span></span> <span data-ttu-id="4d60d-208">Os identificadores de CPU e de descritores de GPU não precisam apontar para as mesmas entradas em um heap de descritor, no entanto, é responsabilidade do seu aplicativo garantir que todo o intervalo de descritor referido pelo identificador do descritor de CPU seja copiado para o intervalo referido pelo identificador do descritor de GPU antes da execução usando essa tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-208">The CPU and GPU descriptor handles aren't required to point to the same entries in a descriptor heap, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12GraphicsCommandList> d3D12GraphicsCommandList;
// Code to create a Direct3D 12 command list goes here.

winrt::com_ptr<::IDMLCommandRecorder> dmlCommandRecorder;
// Code to create a DirectML command recorder goes here.

dmlCommandRecorder->RecordDispatch(
    d3D12GraphicsCommandList.get(),
    dmlOperatorInitializer.get(),
    dmlBindingTable.get()
);
```

<span data-ttu-id="4d60d-209">Por fim, feche a lista de comandos do Direct3D 12 e envie-a para execução como faria com qualquer outra lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="4d60d-209">Finally, close your Direct3D 12 command list, and submit it for execution as you would any other command list.</span></span>

<span data-ttu-id="4d60d-210">Antes da execução de **RecordDispatch** na GPU, você deve fazer a transição de todos os recursos associados para o estado **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** ou para um estado implicitamente passível de promoção para **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, como **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="4d60d-210">Prior to execution of **RecordDispatch** on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="4d60d-211">Depois que essa chamada for concluída, os recursos permanecerão no estado de **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="4d60d-211">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="4d60d-212">A única exceção a isso é para o carregamento de heaps vinculados ao executar um inicializador de operador e enquanto um ou mais dezenasrs tem o sinalizador de **DML_TENSOR_FLAG_OWNED_BY_DML** definido.</span><span class="sxs-lookup"><span data-stu-id="4d60d-212">The only exception to this is for upload heaps bound when executing an operator initializer and while one or more tensors has the **DML_TENSOR_FLAG_OWNED_BY_DML** flag set.</span></span> <span data-ttu-id="4d60d-213">Nesse caso, qualquer heap de carregamento associado à entrada deve estar no estado **D3D12_RESOURCE_STATE_GENERIC_READ** e permanecerá nesse estado, conforme exigido por todos os heaps de carregamento.</span><span class="sxs-lookup"><span data-stu-id="4d60d-213">In that case, any upload heaps bound for input must be in the **D3D12_RESOURCE_STATE_GENERIC_READ** state and will remain in that state, as required by all upload heaps.</span></span> <span data-ttu-id="4d60d-214">Se **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** não foi definido durante a compilação do operador, todas as associações deverão ser definidas na tabela de associação antes de **RecordDispatch** ser chamada, caso contrário, o comportamento será indefinido.</span><span class="sxs-lookup"><span data-stu-id="4d60d-214">If **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** was not set when compiling the operator, then all bindings must be set on the binding table before **RecordDispatch** is called, otherwise the behavior is undefined.</span></span> <span data-ttu-id="4d60d-215">Caso contrário, se um operador oferecer suporte à [associação tardia](#optionally-specify-late-bound-operator-bindings), a associação de recursos poderá ser adiada até que a lista de comandos do Direct3D 12 seja enviada para a fila de comandos para execução.</span><span class="sxs-lookup"><span data-stu-id="4d60d-215">Otherwise, if an operator supports [late binding](#optionally-specify-late-bound-operator-bindings), then binding of resources may be deferred until the Direct3D 12 command list is submitted to the command queue for execution.</span></span>

<span data-ttu-id="4d60d-216">**RecordDispatch** age logicamente como uma chamada para [**ID3D12GraphicsCommandList::D ispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span><span class="sxs-lookup"><span data-stu-id="4d60d-216">**RecordDispatch** acts logically like a call to [**ID3D12GraphicsCommandList::Dispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span></span> <span data-ttu-id="4d60d-217">Assim, as barreiras de UAV (exibição de acesso não ordenado) são necessárias para garantir a ordenação correta se houver dependências de dados entre expedimentos.</span><span class="sxs-lookup"><span data-stu-id="4d60d-217">As such, unordered access view (UAV) barriers are necessary to ensure correct ordering if there are data dependencies between dispatches.</span></span> <span data-ttu-id="4d60d-218">Esse método não insere barreiras de UAV em recursos de entrada e saída.</span><span class="sxs-lookup"><span data-stu-id="4d60d-218">This method does not insert UAV barriers on input nor output resources.</span></span> <span data-ttu-id="4d60d-219">Seu aplicativo deve garantir que as barreiras de UAV corretas sejam executadas em qualquer entrada se seu conteúdo depender de um despacho upstream e em qualquer saída se houver despachos downstream que dependem dessas saídas.</span><span class="sxs-lookup"><span data-stu-id="4d60d-219">Your application must ensure that the correct UAV barriers are performed on any inputs if their contents depend on an upstream dispatch, and on any outputs if there are downstream dispatches that depend on those outputs.</span></span>

## <a name="lifetime-and-synchronization-of-descriptors-and-binding-table"></a><span data-ttu-id="4d60d-220">Tempo de vida e sincronização de descritores e tabela de associação</span><span class="sxs-lookup"><span data-stu-id="4d60d-220">Lifetime and synchronization of descriptors and binding table</span></span>

<span data-ttu-id="4d60d-221">Um bom modelo mental de associação em DirectML é que, por trás dos bastidores, a própria tabela de associação DirectML está criando e gerenciando descritores UAV (modo de exibição de acesso não ordenado) dentro do heap de descritor que você fornece.</span><span class="sxs-lookup"><span data-stu-id="4d60d-221">A good mental model of binding in DirectML is that behind the scenes the DirectML binding table itself is creating and managing unordered access view (UAV) descriptors inside the descriptor heap that you provide.</span></span> <span data-ttu-id="4d60d-222">Portanto, todas as regras comuns do Direct3D 12 se aplicam ao sincronizar o acesso a esse heap e a seus descritores.</span><span class="sxs-lookup"><span data-stu-id="4d60d-222">So, all of the usual Direct3D 12 rules apply around synchronizing access to that heap and to its descriptors.</span></span> <span data-ttu-id="4d60d-223">É responsabilidade do seu aplicativo executar a sincronização correta entre o trabalho de CPU e a GPU que usa uma tabela de associação.</span><span class="sxs-lookup"><span data-stu-id="4d60d-223">It's your application's responsibility to perform correct synchronization between the CPU and GPU work that uses a binding table.</span></span>

<span data-ttu-id="4d60d-224">Uma tabela de associação não pode substituir um descritor enquanto o descritor está em uso (por um quadro anterior, por exemplo).</span><span class="sxs-lookup"><span data-stu-id="4d60d-224">A binding table can't overwrite a descriptor while the descriptor is in use (by a prior frame, for example).</span></span> <span data-ttu-id="4d60d-225">Portanto, se você quiser reutilizar um heap de descritor já associado (por exemplo, chamando BIND \* novamente em uma tabela de associação que aponta para ele ou substituindo manualmente o heap do descritor), deverá aguardar o Despatch que está usando o heap do descritor para concluir a execução na GPU.</span><span class="sxs-lookup"><span data-stu-id="4d60d-225">So, if you want to reuse an already-bound descriptor heap (for example, by calling Bind\* again on a binding table that points to it, or by overwriting the descriptor heap manually), then you should wait for the dispatchable that's currently using the descriptor heap to finish executing on the GPU.</span></span> <span data-ttu-id="4d60d-226">Uma tabela de associação não mantém uma referência forte no heap do descritor que ele grava, de modo que você não deve liberar o heap de descritor visível do sombreador até que todo o trabalho que usa essa tabela de associação tenha concluído a execução na GPU.</span><span class="sxs-lookup"><span data-stu-id="4d60d-226">A binding table doesn't maintain a strong reference on the descriptor heap that it writes into, so you mustn't release the backing shader-visible descriptor heap until all work using that binding table has completed execution on the GPU.</span></span>

<span data-ttu-id="4d60d-227">Por outro lado, enquanto uma tabela de associação especifica e gerencia um heap de descritor, a tabela não *contém* a mesma memória.</span><span class="sxs-lookup"><span data-stu-id="4d60d-227">On the other hand, while a binding table does specify and manage a descriptor heap, the table doesn't itself *contain* any of that memory.</span></span> <span data-ttu-id="4d60d-228">Portanto, você pode liberar ou redefinir uma tabela de associação a qualquer momento depois de ter chamado [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) com ela (você não precisa esperar que essa chamada seja concluída na GPU, desde que os descritores subjacentes permaneçam válidos).</span><span class="sxs-lookup"><span data-stu-id="4d60d-228">So, you may release or reset a binding table any time after you've called [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) with it (you don't need to wait for that call to complete on the GPU, so long as the underlying descriptors remain valid).</span></span>

<span data-ttu-id="4d60d-229">A tabela de associação não mantém referências fortes em todos os recursos associados usando ti &mdash; seu aplicativo deve garantir que os recursos não sejam excluídos enquanto ainda estiverem em uso pela GPU.</span><span class="sxs-lookup"><span data-stu-id="4d60d-229">The binding table doesn't keep strong references on any resources bound using it&mdash;your application must ensure that resources are not deleted while still in use by the GPU.</span></span> <span data-ttu-id="4d60d-230">Além disso, uma tabela de associação não é thread-safe &mdash; seu aplicativo não deve chamar métodos em uma tabela de associação simultaneamente de threads diferentes sem sincronização.</span><span class="sxs-lookup"><span data-stu-id="4d60d-230">Also, a binding table isn't thread safe&mdash;your application must not call methods on a binding table simultaneously from different threads without synchronization.</span></span>

<span data-ttu-id="4d60d-231">E considere que, em qualquer caso, a reassociação é necessária somente quando você altera quais recursos estão associados.</span><span class="sxs-lookup"><span data-stu-id="4d60d-231">And consider that in any case rebinding is necessary only when you change which resources are bound.</span></span> <span data-ttu-id="4d60d-232">Se você não precisar alterar os recursos associados, poderá associar uma vez na inicialização e passar a mesma tabela de ligação sempre que chamar **RecordDispatch**.</span><span class="sxs-lookup"><span data-stu-id="4d60d-232">If you don't need to change the bound resources, then you can bind once at startup, and pass the same binding table each time you call **RecordDispatch**.</span></span>

<span data-ttu-id="4d60d-233">Para intercalar as cargas de trabalho de aprendizado de máquina e renderização, apenas verifique se as tabelas de associação de cada quadro apontam para os intervalos do heap de descritores que ainda não estão em uso na GPU.</span><span class="sxs-lookup"><span data-stu-id="4d60d-233">For interleaving machine learning and rendering workloads, just ensure that each frame's binding tables points to ranges of the descriptor heap that are not already in use on the GPU.</span></span>

## <a name="optionally-specify-late-bound-operator-bindings"></a><span data-ttu-id="4d60d-234">Opcionalmente, especificar associações de operador de associação tardia</span><span class="sxs-lookup"><span data-stu-id="4d60d-234">Optionally specify late-bound operator bindings</span></span>

<span data-ttu-id="4d60d-235">Se você estiver lidando com um operador compilado (em vez de um inicializador de operador), terá a opção de especificar a associação tardia para o operador.</span><span class="sxs-lookup"><span data-stu-id="4d60d-235">If you're dealing with a compiled operator (rather than with an operator initializer), then you have the option to specify late binding for the operator.</span></span> <span data-ttu-id="4d60d-236">Sem associação tardia, você deve definir todas as associações na tabela de associação antes de gravar um operador em uma lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="4d60d-236">Without late binding, you must set all bindings on the binding table before you record an operator into a command list.</span></span> <span data-ttu-id="4d60d-237">Com a associação tardia, você pode definir (ou alterar) associações em operadores que você já registrou em uma lista de comandos, antes que ele seja enviado para a fila de comandos.</span><span class="sxs-lookup"><span data-stu-id="4d60d-237">With late binding, you can set (or change) bindings on operators that you've already recorded into a command list, before it has been submitted to the command queue.</span></span>

<span data-ttu-id="4d60d-238">Para especificar a associação tardia, chame [**IDMLDevice:: CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) com um `flags` argumento de [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span><span class="sxs-lookup"><span data-stu-id="4d60d-238">To specify late binding, call [**IDMLDevice::CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) with a `flags` argument of [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span></span>