---
title: Estratégias de gerenciamento de memória
description: Um Gerenciador de memória para o Direct3D 12 poderia ficar muito complicado com todas as diferentes camadas de suporte, para adaptadores de uma ou discretos (não de uma) e com uma variedade considerável de diferenças de arquitetura entre os adaptadores de GPU. A estratégia recomendada para o gerenciamento de memória do Direct3D 12, descrita nesta seção, é \ 0034; classificar, orçamento e fluxo \ 0034;.
ms.assetid: BC9894F7-D496-46F2-A5C3-C7CA31FD4BA8
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dad04055a5acdeeeaead3a56f0bd04e64aa90fe0
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548261"
---
# <a name="memory-management-strategies"></a><span data-ttu-id="294af-103">Estratégias de gerenciamento de memória</span><span class="sxs-lookup"><span data-stu-id="294af-103">Memory Management Strategies</span></span>

<span data-ttu-id="294af-104">Um Gerenciador de memória para o Direct3D 12 poderia ficar muito complicado com todas as diferentes camadas de suporte, para adaptadores de uma ou discretos (não de uma) e com uma variedade considerável de diferenças de arquitetura entre os adaptadores de GPU.</span><span class="sxs-lookup"><span data-stu-id="294af-104">A memory manager for Direct3D 12 could get very complicated quickly with all the different tiers of support, for UMA or discrete (non-UMA) adapters, and with a considerable range of architecture differences between GPU adapters.</span></span>

<span data-ttu-id="294af-105">A estratégia recomendada para o gerenciamento de memória do Direct3D 12, descrita nesta seção, é "classificar, orçamento e fluxo".</span><span class="sxs-lookup"><span data-stu-id="294af-105">The recommended strategy for Direct3D 12 memory management , described in this section, is "classify, budget and stream".</span></span>

-   [<span data-ttu-id="294af-106">Tipos de recursos</span><span class="sxs-lookup"><span data-stu-id="294af-106">Resource types</span></span>](#resource-types)
-   [<span data-ttu-id="294af-107">Orçamento de memória</span><span class="sxs-lookup"><span data-stu-id="294af-107">Memory budget</span></span>](#memory-budget)
-   [<span data-ttu-id="294af-108">Estratégia de classificação</span><span class="sxs-lookup"><span data-stu-id="294af-108">Classification strategy</span></span>](#classification-strategy)
-   [<span data-ttu-id="294af-109">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="294af-109">Related topics</span></span>](#related-topics)

## <a name="resource-types"></a><span data-ttu-id="294af-110">Tipos de recurso</span><span class="sxs-lookup"><span data-stu-id="294af-110">Resource types</span></span>

<span data-ttu-id="294af-111">O conceito básico de "recurso confirmado" (criando espaços de endereços virtuais e físicos inicializados na memória física gerenciada) já existe desde o Direct3D 9, embora o endereçamento virtual (VA) e o endereçamento físico possam ser separados no Direct3D 12 para permitir que o aplicativo gerencie cuidadosamente a memória física.</span><span class="sxs-lookup"><span data-stu-id="294af-111">The basic concept of a "committed resource" (creating both virtual and physical address spaces initialized in managed physical memory) has been around since Direct3D 9, though the virtual addressing (VA) and physical addressing can be teased apart in Direct3D 12 to allow the app to carefully manage physical memory.</span></span>

<span data-ttu-id="294af-112">Além dos recursos confirmados, a construção de heap do Direct3D 12 permite dois outros tipos de recurso: "posicionado" e "reservado".</span><span class="sxs-lookup"><span data-stu-id="294af-112">In addition to committed resources, the heap construct of Direct3D 12 enables two other types of resource: "placed" and "reserved".</span></span> <span data-ttu-id="294af-113">No Direct3D 11, um recurso "reservado" era conhecido como "recurso ao lado".</span><span class="sxs-lookup"><span data-stu-id="294af-113">In Direct3D 11 a "reserved" resource was known as a "tiled resource".</span></span>

<span data-ttu-id="294af-114">Os recursos reservados diferem dos recursos inseridos, pois os recursos reservados têm seu próprio espaço de endereço virtual de GPU exclusivo.</span><span class="sxs-lookup"><span data-stu-id="294af-114">Reserved resources differ from placed resources in that reserved resources have their own unique GPU virtual address space.</span></span> <span data-ttu-id="294af-115">Isso permite uma grande alocação do espaço de VA de antecedência e, em seguida, habilita o mapeamento de páginas de VA para determinadas seções do heap posteriormente, e o aplicativo reconfigura a organização em tempo real.</span><span class="sxs-lookup"><span data-stu-id="294af-115">This allows a large allocation of VA space up front and then enables mapping of VA pages to certain sections of the heap later, and the application reconfigures the arrangement on the fly.</span></span> <span data-ttu-id="294af-116">O espaço de VA é contíguo e pode ser mapeado de forma grosseira para.</span><span class="sxs-lookup"><span data-stu-id="294af-116">The VA space is contiguous, and can be sparsely mapped to.</span></span>

<span data-ttu-id="294af-117">O recurso reservado pode ser feito para referenciar regiões no heap com chamadas à API, como [**UpdateTileMappings**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-updatetilemappings) , e podem se tornar residentes pelo aplicativo atualizando tabelas de páginas dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="294af-117">The reserved resource can be made to reference regions in the heap with API calls such as [**UpdateTileMappings**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-updatetilemappings) and they can be made resident by the app by updating page tables on the fly.</span></span> <span data-ttu-id="294af-118">Quando um intervalo de VA é mapeado para nulo ou para um heap não residente, essa parte do recurso é considerada não-residente.</span><span class="sxs-lookup"><span data-stu-id="294af-118">When a VA range is mapped to NULL or a non-resident heap, that portion of the resource is considered non-resident.</span></span> <span data-ttu-id="294af-119">Quando um intervalo de VA é mapeado para um heap residente, essa parte do recurso é considerada residente.</span><span class="sxs-lookup"><span data-stu-id="294af-119">When a VA range is mapped to a resident heap, that portion of the resource is considered resident.</span></span> <span data-ttu-id="294af-120">Os heaps são residentes após a criação.</span><span class="sxs-lookup"><span data-stu-id="294af-120">Heaps are resident upon creation.</span></span>

<span data-ttu-id="294af-121">Os recursos inseridos são um design muito mais simples, sendo simplesmente um ponteiro para uma determinada região de um heap (por exemplo, uma região de 1Mb para uma textura em um heap de 5 MB).</span><span class="sxs-lookup"><span data-stu-id="294af-121">Placed resources are a much simpler design, being simply a pointer to a certain region of a heap (for example, a 1Mb region for a texture in a 5Mb heap).</span></span> <span data-ttu-id="294af-122">As barreiras de alias permitem o uso de recursos inseridos sobrepostos (consulte [**CreatePlacedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) e [**ResourceBarrier**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier)).</span><span class="sxs-lookup"><span data-stu-id="294af-122">Aliasing barriers enable the use of overlapping placed resources (refer to [**CreatePlacedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) and [**ResourceBarrier**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier)).</span></span>

<span data-ttu-id="294af-123">Os recursos reservados não estão disponíveis em todos os hardwares do Direct3D 12, e os recursos colocados são um fallback razoável, embora os recursos inseridos devam ser contíguos e não possam ser parcialmente residentes.</span><span class="sxs-lookup"><span data-stu-id="294af-123">Reserved resources are not available on all Direct3D 12 hardware, and placed resources are a reasonable fallback, though placed resources must be contiguous and cannot be partially resident.</span></span>

## <a name="memory-budget"></a><span data-ttu-id="294af-124">Orçamento de memória</span><span class="sxs-lookup"><span data-stu-id="294af-124">Memory budget</span></span>

<span data-ttu-id="294af-125">No Direct3D 12, ao alocar um heap, você está criando o aspecto de memória física de um recurso confirmado.</span><span class="sxs-lookup"><span data-stu-id="294af-125">In Direct3D 12 when you allocate a heap you are creating the physical memory aspect of a committed resource.</span></span> <span data-ttu-id="294af-126">Uma opção de segmento de memória mais explícita está disponível no Direct3D 12 (escolhendo entre vídeo e memória do sistema).</span><span class="sxs-lookup"><span data-stu-id="294af-126">More explicit memory segment choice is available in Direct3D 12 (choosing between video and system memory).</span></span> <span data-ttu-id="294af-127">Os adaptadores de um só têm um único segmento de memória, a memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="294af-127">UMA adapters only have a single memory segment, system memory.</span></span>

<span data-ttu-id="294af-128">As GPUs não dão suporte à falha de página, de modo que os desenvolvedores devem estar atentos de que não estão excedendo a confirmação, especialmente em sistemas, digamos com apenas 1 GB de memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="294af-128">GPUs do not support page faulting, so developers must be conscious that they do not over commit, especially to systems say with only 1Gb of system memory.</span></span> <span data-ttu-id="294af-129">Se um aplicativo efetuar a confirmação, o sistema operacional usará o agendamento refinado de processos mais esparsos por sua demanda na memória física.</span><span class="sxs-lookup"><span data-stu-id="294af-129">If an app does over commit, then the OS uses coarser-grained scheduling of processes by their demand on physical memory.</span></span> <span data-ttu-id="294af-130">O Agendador congelará processos em primeiro plano e, essencialmente, paginará um pouco, a fim de paginar um processo em segundo plano que deseja executar.</span><span class="sxs-lookup"><span data-stu-id="294af-130">The scheduler will freeze foreground processes and essentially page some of it out, in order to page-in a background process that wants to run.</span></span> <span data-ttu-id="294af-131">A memória física disponível pode variar consideravelmente dependendo do que o usuário está fazendo em segundo plano (como executar um navegador ou assistir a um vídeo).</span><span class="sxs-lookup"><span data-stu-id="294af-131">Available physical memory can vary considerably depending on what the user is doing in the background (such as running a browser or watching a video).</span></span>

<span data-ttu-id="294af-132">A API para o orçamento de memória é [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo).</span><span class="sxs-lookup"><span data-stu-id="294af-132">The API for memory budget is [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo).</span></span> <span data-ttu-id="294af-133">Para adaptadores discretos "local" é a memória de vídeo, "não local" é a memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="294af-133">For discrete adapters "local" is video memory, "non-local" is system memory.</span></span> <span data-ttu-id="294af-134">Para adaptadores de uma não local é sempre zero.</span><span class="sxs-lookup"><span data-stu-id="294af-134">For UMA adapters non-local is always zero.</span></span> <span data-ttu-id="294af-135">Uma pergunta de design é se o mecanismo gerenciará orçamentos ou apenas o orçamento local.</span><span class="sxs-lookup"><span data-stu-id="294af-135">One design question is whether your engine will manage both budgets or just the local budget.</span></span> <span data-ttu-id="294af-136">Gerenciar apenas o orçamento local é mais simples, mas tem algumas limitações; por exemplo, digamos que haja um orçamento local máximo de 1 GB, todos os heaps serão provenientes de 1 GB em um sistema de uma e não haverá estouro na memória do sistema (claramente, pois não há nenhum).</span><span class="sxs-lookup"><span data-stu-id="294af-136">Managing only the local budget is simpler but has some caveats; for example say there is a maximum local budget of 1Gb, then all heaps will come from that 1Gb in a UMA system and there is no overflow to system memory (clearly, as there is none).</span></span>

<span data-ttu-id="294af-137">Desde a Direct3D11 de memória gerenciada para aplicativos, os recursos não utilizados essencialmente seriam paginados.</span><span class="sxs-lookup"><span data-stu-id="294af-137">Since Direct3D11 managed memory for applications, unused resources would essentially be paged out.</span></span>

<span data-ttu-id="294af-138">Escolha as dimensões de recurso mais apropriadas.</span><span class="sxs-lookup"><span data-stu-id="294af-138">Choose the most appropriate resource dimensions.</span></span> <span data-ttu-id="294af-139">Considere se o tamanho de um recurso é apropriado para a situação na qual o aplicativo está realmente sendo executado.</span><span class="sxs-lookup"><span data-stu-id="294af-139">Consider whether the size of a resource is appropriate for the situation the application is actually running in.</span></span> <span data-ttu-id="294af-140">Alguns usuários podem executar o aplicativo em uma janela ou com uma resolução de tela de 800x600.</span><span class="sxs-lookup"><span data-stu-id="294af-140">Some users may run the application in a window or with a screen resolution of 800x600.</span></span>

## <a name="classification-strategy"></a><span data-ttu-id="294af-141">Estratégia de classificação</span><span class="sxs-lookup"><span data-stu-id="294af-141">Classification strategy</span></span>

<span data-ttu-id="294af-142">Para gerenciar recursos com eficiência em cenários de limite de memória, considere classificar os recursos no seguinte:</span><span class="sxs-lookup"><span data-stu-id="294af-142">In order to manage resources effectively in memory bound scenarios, consider classifying resources into the following:</span></span>



| <span data-ttu-id="294af-143">classificação</span><span class="sxs-lookup"><span data-stu-id="294af-143">Classification</span></span>      | <span data-ttu-id="294af-144">Exemplos</span><span class="sxs-lookup"><span data-stu-id="294af-144">Examples</span></span>                                                                                         | <span data-ttu-id="294af-145">Objetos e recursos de API</span><span class="sxs-lookup"><span data-stu-id="294af-145">Objects and API features</span></span>                                                                                           | <span data-ttu-id="294af-146">Notas de gerenciamento</span><span class="sxs-lookup"><span data-stu-id="294af-146">Management notes</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|---------------------|--------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="294af-147">Crítico</span><span class="sxs-lookup"><span data-stu-id="294af-147">Critical</span></span>            | <span data-ttu-id="294af-148">Interface do usuário do jogo</span><span class="sxs-lookup"><span data-stu-id="294af-148">Game UI</span></span>                                                                                          | <span data-ttu-id="294af-149">Alocador de comando, filas de comando, heaps de consulta, recursos e heaps de recursos.</span><span class="sxs-lookup"><span data-stu-id="294af-149">Command allocator, command queues, query heaps, resources and resource heaps.</span></span>                                      | <span data-ttu-id="294af-150">Esses elementos devem ficar em memória não paginável/sempre confirmada.</span><span class="sxs-lookup"><span data-stu-id="294af-150">These elements should go in non-pageable/always committed memory.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="294af-151">Escalado/opcional</span><span class="sxs-lookup"><span data-stu-id="294af-151">Scaled/ Optional</span></span>    | <span data-ttu-id="294af-152">Modelos e texturas específicos de nível, cadeias de permuta, caixas céu, modelos de caractere de jogador de primeira pessoa</span><span class="sxs-lookup"><span data-stu-id="294af-152">Level-specific models and textures, swap chains, sky boxes, first-person player character models</span></span> | <span data-ttu-id="294af-153">Recursos e heaps.</span><span class="sxs-lookup"><span data-stu-id="294af-153">Resources and heaps.</span></span> <span data-ttu-id="294af-154">Os recursos confirmados, mas também os recursos colocados e reservados podem funcionar também.</span><span class="sxs-lookup"><span data-stu-id="294af-154">Committed resources, but also placed and reserved resources might work just as well.</span></span>          | <span data-ttu-id="294af-155">Integre o orçamento de residência de memória nos algoritmos de renderização.</span><span class="sxs-lookup"><span data-stu-id="294af-155">Integrate memory residency budgeting into the rendering algorithms.</span></span> <span data-ttu-id="294af-156">Escolha o nível apropriado de detalhes disponíveis e reavalie menos de uma vez por quadro.</span><span class="sxs-lookup"><span data-stu-id="294af-156">Choose the appropriate level of available detail and re-evaluate less than once per-frame.</span></span> <span data-ttu-id="294af-157">As técnicas incluem o uso de recursos de tamanho variável e dimensionamento da cadeia de permuta.</span><span class="sxs-lookup"><span data-stu-id="294af-157">Techniques include using variable-sized resources and swap chain scaling.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="294af-158">Recursos reutilizados</span><span class="sxs-lookup"><span data-stu-id="294af-158">Re-used Resources</span></span>   | <span data-ttu-id="294af-159">Buffers de sombra, recursos de renderização adiados, recursos de pós-processamento, caches de dados de iluminação</span><span class="sxs-lookup"><span data-stu-id="294af-159">Shadow buffers, deferred rendering resources, post-processing resources, lighting data caches</span></span>    | <span data-ttu-id="294af-160">Recursos e heaps.</span><span class="sxs-lookup"><span data-stu-id="294af-160">Resources and heaps.</span></span> <span data-ttu-id="294af-161">Sobreposição de recursos posicionados em heaps e barreiras de alias.</span><span class="sxs-lookup"><span data-stu-id="294af-161">Overlapping placed resources on heaps and aliasing barriers.</span></span>                                  | <span data-ttu-id="294af-162">Reutilize os recursos grandes ou regiões de heap dentro de um quadro para reduzir os requisitos para todo o quadro.</span><span class="sxs-lookup"><span data-stu-id="294af-162">Reuse large resources or heap regions within a frame to cut-down on requirements for the entire frame.</span></span> <span data-ttu-id="294af-163">Use a técnica de reutilização de memória dentro do quadro.</span><span class="sxs-lookup"><span data-stu-id="294af-163">Use the technique of intra-frame memory reuse.</span></span> <span data-ttu-id="294af-164">No Direct3D 11, os aplicativos podiam reutilizar recursos com o mesmo tipo e dimensões possivelmente grandes o suficiente.</span><span class="sxs-lookup"><span data-stu-id="294af-164">In Direct3D 11, applications could only reuse resources with the same type and potentially large enough dimensions.</span></span> <span data-ttu-id="294af-165">Os heaps do Direct3D 12 permitem a sobreposição de recursos para uma reutilização muito mais simples e maior.</span><span class="sxs-lookup"><span data-stu-id="294af-165">Direct3D 12 heaps allow overlapping resources for much simpler and greater reuse.</span></span><br/>                                                                                                                                                                                                                              |
| <span data-ttu-id="294af-166">Recursos de streaming</span><span class="sxs-lookup"><span data-stu-id="294af-166">Streaming Resources</span></span> | <span data-ttu-id="294af-167">Terrenos, texturas e geometrias do Open World</span><span class="sxs-lookup"><span data-stu-id="294af-167">Terrain, open-world textures and geometry</span></span>                                                        | <span data-ttu-id="294af-168">Recursos e heaps.</span><span class="sxs-lookup"><span data-stu-id="294af-168">Resources and heaps.</span></span> <span data-ttu-id="294af-169">Criação de thread livre, threads de CPU em segundo plano e filas e listas de comandos de cópia em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="294af-169">Free-threaded creation, background CPU threads, and background copy command queues and lists.</span></span> | <span data-ttu-id="294af-170">Residência parcial, normalmente baseada na visibilidade (usando a exibição frustum ou avaliação baseada em distância) e reavaliar a residência precisa de cada quadro.</span><span class="sxs-lookup"><span data-stu-id="294af-170">Partial residency, commonly based on visibility (using the view-frustum or distance-based evaluation) and re-evaluate residency needs every frame.</span></span><br/> <span data-ttu-id="294af-171">A técnica de usar um gerenciamento de residência parcial por bloco e a reutilização entre quadros está disponível quando o adaptador de GPU dá suporte a recursos reservados dentro de heaps.</span><span class="sxs-lookup"><span data-stu-id="294af-171">The technique of using a per-tile partial residency management and inter-frame reuse is available when the GPU adapter supports reserved resources within heaps.</span></span><br/> <span data-ttu-id="294af-172">Usando a técnica de uso da reutilização de memória entre quadros, a residência parcial de subrecurso pode ser realizada, mas é menos adequada.</span><span class="sxs-lookup"><span data-stu-id="294af-172">Using the technique of using inter-frame memory re-use, partial subresource residency can be accomplished, but is less optimal.</span></span> <span data-ttu-id="294af-173">Os recursos inseridos com heaps devem permitir reciclagem mais rápida, mas os recursos confirmados podem ser usados como um fallback.</span><span class="sxs-lookup"><span data-stu-id="294af-173">Placed resources with heaps should enable faster recycling, but committed resources can be used as a fallback.</span></span><br/> |



 

<span data-ttu-id="294af-174">Quanto mais aplicativos gravitam ao streaming de recursos para a maior parte do trabalho, mais eles aproveitarão os recursos colocados e reservados, o que maximizará a reutilização da memória entre essas quatro classificações.</span><span class="sxs-lookup"><span data-stu-id="294af-174">The more applications gravitate to streaming resources for most of the work, the more they will leverage placed and reserved resources, which will maximize memory re-use between these four classifications.</span></span> <span data-ttu-id="294af-175">Quanto mais aplicativos forem transmitidos, mais eles terão orçamento e priorizarão a largura de banda.</span><span class="sxs-lookup"><span data-stu-id="294af-175">The more applications stream, the more they budget and prioritize bandwidth.</span></span>

<span data-ttu-id="294af-176">Normalmente, com os mecanismos gráficos do Direct3D 12, é necessário respeitar um orçamento mais diversificado e dinâmico e fazê-lo mais estritamente do que fazia no passado.</span><span class="sxs-lookup"><span data-stu-id="294af-176">Typically with Direct3D 12 graphics engines need to honor a more diverse and dynamic budget, and do it more strictly than they did in the past.</span></span> <span data-ttu-id="294af-177">Os melhores aplicativos localizarão todas as quatro categorias no orçamento fornecido ao processo, dimensionando o jogo para o aplicativo móvel em segundo plano para orçamentos discretos em tela inteira.</span><span class="sxs-lookup"><span data-stu-id="294af-177">The best applications will locate all four categories into the budget given to the process, scaling the game play from background mobile app to full-screen discrete budgets.</span></span> <span data-ttu-id="294af-178">Mas, muitos aplicativos provavelmente terão dificuldades ao iniciar com muitos tipos críticos de categoria de recursos.</span><span class="sxs-lookup"><span data-stu-id="294af-178">But, many applications will likely struggle by starting with too many critical category types of resources.</span></span> <span data-ttu-id="294af-179">Os recursos habilitados para Direct3D 11 são criados anonimamente e ocupam o status crítico sem afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="294af-179">Direct3D 11 enabled resources to be anonymously created and occupy critical status without impacting performance.</span></span> <span data-ttu-id="294af-180">No entanto, para o Direct3D 12, os desenvolvedores devem procurar por recursos criados aleatoriamente em todo o mecanismo e middleware e atribuí-los novamente a uma das outras categorias.</span><span class="sxs-lookup"><span data-stu-id="294af-180">However, for Direct3D 12, developers must diligently search for randomly created resources throughout their engine and middleware and re-assign them to one of the other categories.</span></span>

<span data-ttu-id="294af-181">Outras áreas problemáticas são componentes de middleware, controles de usuário e streaming intra-frame.</span><span class="sxs-lookup"><span data-stu-id="294af-181">Other problem areas are middleware components, user controls, and intra-frame streaming.</span></span> <span data-ttu-id="294af-182">Os componentes de middleware podem não ser expostos a um orçamento, nem devem trabalhar juntos.</span><span class="sxs-lookup"><span data-stu-id="294af-182">Middleware components may not be exposed to a budget, nor have to work tightly together.</span></span> <span data-ttu-id="294af-183">Os componentes de middleware provavelmente poderiam expor recursos como técnicas de renderização; e o aplicativo poderia depender de expor as configurações de middleware e de mecanismo.</span><span class="sxs-lookup"><span data-stu-id="294af-183">Middleware components likely could expose features as rendering techniques; and the application could rely on exposing middleware and engine settings.</span></span> <span data-ttu-id="294af-184">Os desenvolvedores poderiam contar com o Direct3D 11 para fazer a paginação e atingir a taxa de quadros correta.</span><span class="sxs-lookup"><span data-stu-id="294af-184">Developers could rely on Direct3D 11 to do the paging and achieve the right frame rate.</span></span> <span data-ttu-id="294af-185">Em alguns casos, os aplicativos do Direct3D 11 podem ter sido paginando o conteúdo dos recursos dentro e fora de cada quadro; e isso resultou em taxas de quadros aceitáveis para o usuário.</span><span class="sxs-lookup"><span data-stu-id="294af-185">In some cases, Direct3D 11 applications may have been paging resource contents in and out every frame; and it resulted in acceptable frame rates for the user.</span></span> <span data-ttu-id="294af-186">A maioria dos mecanismos só transmite dados de recursos como uma atividade em segundo plano, em que ele não tem nenhum fallback normal para streaming de alta prioridade dentro do quadro.</span><span class="sxs-lookup"><span data-stu-id="294af-186">Most engines only stream resource data as a background activity, where it has no graceful fallback to high-priority intra-frame streaming.</span></span> <span data-ttu-id="294af-187">Solicitar que os mecanismos implementem que erode alguns dos ganhos de sobrecarga da CPU que eles buscam ao migrar para o Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="294af-187">Asking engines to implement that will erode some of the CPU overhead gains they are seeking by moving to Direct3D 12.</span></span> <span data-ttu-id="294af-188">Os desenvolvedores de mecanismos podem considerar separar seus quadros em fases para fornecer mais oportunidades para recursos reutilizáveis; e, provavelmente, trabalhar com fornecedores de middleware para dar suporte a recursos e heaps posicionados para reutilização de memória intra-frame.</span><span class="sxs-lookup"><span data-stu-id="294af-188">Engine developers could consider teasing their frames into phases to provide more opportunity for re-usable resources; and likely work with middleware vendors to support placed resources and heaps for intra-frame memory re-use.</span></span>

## <a name="related-topics"></a><span data-ttu-id="294af-189">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="294af-189">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="294af-190">**CreateCommittedResource**</span><span class="sxs-lookup"><span data-stu-id="294af-190">**CreateCommittedResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createcommittedresource)
</dt> <dt>

[<span data-ttu-id="294af-191">**CreateReservedResource**</span><span class="sxs-lookup"><span data-stu-id="294af-191">**CreateReservedResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createreservedresource)
</dt> <dt>

[<span data-ttu-id="294af-192">Guia de programação do Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="294af-192">Direct3D 12 Programming Guide</span></span>](directx-12-programming-guide.md)
</dt> <dt>

[<span data-ttu-id="294af-193">Gerenciamento de memória</span><span class="sxs-lookup"><span data-stu-id="294af-193">Memory Management</span></span>](memory-management.md)
</dt> <dt>

[<span data-ttu-id="294af-194">Associação de recursos</span><span class="sxs-lookup"><span data-stu-id="294af-194">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

