---
title: Visão geral da Associação de recursos
description: A chave para a associação de recursos no DirectX 12 são os conceitos de um descritor, tabelas de descritores, heaps de descritores e uma assinatura de raiz.
ms.assetid: 92E100CA-822D-46B1-BD37-FF57C3FB703D
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2bc7e78255c123777716eddb43d9443e19113b34
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104874"
---
# <a name="resource-binding-overview"></a><span data-ttu-id="92f93-103">Visão geral da Associação de recursos</span><span class="sxs-lookup"><span data-stu-id="92f93-103">Resource Binding Overview</span></span>

<span data-ttu-id="92f93-104">A chave para a associação de recursos no DirectX 12 são os conceitos de um *descritor*, *tabelas de descritores*, *heaps de descritores* e uma *assinatura de raiz*.</span><span class="sxs-lookup"><span data-stu-id="92f93-104">The key to resource binding in DirectX 12 are the concepts of a *descriptor*, *descriptor tables*, *descriptor heaps*, and a *root signature*.</span></span>

-   [<span data-ttu-id="92f93-105">Recursos e pipeline de gráficos</span><span class="sxs-lookup"><span data-stu-id="92f93-105">Resources and the Graphics Pipeline</span></span>](#resources-and-the-graphics-pipeline)
-   [<span data-ttu-id="92f93-106">Tipos de recursos e exibições</span><span class="sxs-lookup"><span data-stu-id="92f93-106">Resource types and views</span></span>](#resource-types-and-views)
-   [<span data-ttu-id="92f93-107">Fluxo de controle de associação de recursos</span><span class="sxs-lookup"><span data-stu-id="92f93-107">Resource Binding Flow of Control</span></span>](#resource-binding-overview)
-   [<span data-ttu-id="92f93-108">Subalocação</span><span class="sxs-lookup"><span data-stu-id="92f93-108">Suballocation</span></span>](#suballocation)
-   [<span data-ttu-id="92f93-109">Liberando recursos</span><span class="sxs-lookup"><span data-stu-id="92f93-109">Freeing Resources</span></span>](#freeing-resources)
-   [<span data-ttu-id="92f93-110">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="92f93-110">Related topics</span></span>](#related-topics)

## <a name="resources-and-the-graphics-pipeline"></a><span data-ttu-id="92f93-111">Recursos e pipeline de gráficos</span><span class="sxs-lookup"><span data-stu-id="92f93-111">Resources and the Graphics Pipeline</span></span>

<span data-ttu-id="92f93-112">Os recursos do sombreador (como texturas, tabelas constantes, imagens, buffers e assim por diante) não são associados diretamente ao pipeline do sombreador; em vez disso, eles são referenciados por meio de um *descritor*.</span><span class="sxs-lookup"><span data-stu-id="92f93-112">Shader resources (such as textures, constant tables, images, buffers and so on) are not bound directly to the shader pipeline; instead, they are referenced through a *descriptor*.</span></span> <span data-ttu-id="92f93-113">Um descritor é um objeto pequeno que contém informações sobre um recurso.</span><span class="sxs-lookup"><span data-stu-id="92f93-113">A descriptor is a small object that contains information about one resource.</span></span>

<span data-ttu-id="92f93-114">Os descritores são agrupados em tabelas de *descritores* de formulário.</span><span class="sxs-lookup"><span data-stu-id="92f93-114">Descriptors are grouped together to form *descriptor tables*.</span></span> <span data-ttu-id="92f93-115">Cada tabela de descritores armazena informações sobre um intervalo de tipos de recursos.</span><span class="sxs-lookup"><span data-stu-id="92f93-115">Each descriptor table stores information about one range of types of resource.</span></span> <span data-ttu-id="92f93-116">Há muitos tipos diferentes de recursos.</span><span class="sxs-lookup"><span data-stu-id="92f93-116">There are many different types of resources.</span></span> <span data-ttu-id="92f93-117">Os recursos mais comuns são:</span><span class="sxs-lookup"><span data-stu-id="92f93-117">The most common resources are:</span></span>

-   <span data-ttu-id="92f93-118">Exibições de buffer de constantes (CBVs)</span><span class="sxs-lookup"><span data-stu-id="92f93-118">Constant buffer views (CBVs)</span></span>
-   <span data-ttu-id="92f93-119">Exibições de acesso não ordenado (UAVs)</span><span class="sxs-lookup"><span data-stu-id="92f93-119">Unordered access views (UAVs)</span></span>
-   <span data-ttu-id="92f93-120">Exibições de recursos do sombreador (SRVs)</span><span class="sxs-lookup"><span data-stu-id="92f93-120">Shader resource views (SRVs)</span></span>
-   <span data-ttu-id="92f93-121">Amostradores</span><span class="sxs-lookup"><span data-stu-id="92f93-121">Samplers</span></span>

<span data-ttu-id="92f93-122">Os descritores SRV, UAV e CBVs podem ser combinados na mesma tabela de descritores.</span><span class="sxs-lookup"><span data-stu-id="92f93-122">SRV, UAV, and CBVs descriptors can be combined into the same descriptor table.</span></span>

<span data-ttu-id="92f93-123">Os pipelines de computação e gráficos têm acesso aos recursos referenciando em tabelas de descritores por índice.</span><span class="sxs-lookup"><span data-stu-id="92f93-123">The graphics and compute pipelines gain access to resources by referencing into descriptor tables by index.</span></span>

<span data-ttu-id="92f93-124">As tabelas de descritores são armazenadas em um *heap de descritor*.</span><span class="sxs-lookup"><span data-stu-id="92f93-124">Descriptor tables are stored in a *descriptor heap*.</span></span> <span data-ttu-id="92f93-125">Os heaps de descritores idealmente conterão todos os descritores (em tabelas de descritores) para que um ou mais quadros sejam renderizados.</span><span class="sxs-lookup"><span data-stu-id="92f93-125">Descriptor heaps will ideally contain all the descriptors (in descriptor tables) for one or more frames to be rendered.</span></span> <span data-ttu-id="92f93-126">Todos os recursos serão armazenados em heaps de modo de usuário.</span><span class="sxs-lookup"><span data-stu-id="92f93-126">All the resources will be stored in user mode heaps.</span></span>

<span data-ttu-id="92f93-127">Outro conceito é o de uma *assinatura raiz*.</span><span class="sxs-lookup"><span data-stu-id="92f93-127">Another concept is that of a *root signature*.</span></span> <span data-ttu-id="92f93-128">A assinatura raiz é uma Convenção de associação, definida pelo aplicativo, que é usada por sombreadores para localizar os recursos aos quais precisam de acesso.</span><span class="sxs-lookup"><span data-stu-id="92f93-128">The root signature is a binding convention, defined by the application, that is used by shaders to locate the resources that they need access to.</span></span> <span data-ttu-id="92f93-129">A assinatura raiz pode armazenar:</span><span class="sxs-lookup"><span data-stu-id="92f93-129">The root signature can store:</span></span>

-   <span data-ttu-id="92f93-130">Índices para tabelas de descritores em um heap de descritor, em que o layout da tabela de descritores foi predefinido.</span><span class="sxs-lookup"><span data-stu-id="92f93-130">Indexes to descriptor tables in a descriptor heap, where the layout of the descriptor table has been pre-defined.</span></span>
-   <span data-ttu-id="92f93-131">As constantes, portanto, os aplicativos podem ligar constantes definidas pelo usuário (conhecidas como *constantes raiz*) diretamente a sombreadores sem precisar passar por descritores e tabelas de descrição.</span><span class="sxs-lookup"><span data-stu-id="92f93-131">Constants, so apps can bind user-defined constants (known as *root constants*) directly to shaders without having to go through descriptors and descriptor tables.</span></span>
-   <span data-ttu-id="92f93-132">Um número muito pequeno de descritores diretamente dentro da assinatura raiz, como uma CBV (exibição de buffer constante) que muda por empate, poupando assim o aplicativo de precisar colocar esses descritores em um heap de descritor.</span><span class="sxs-lookup"><span data-stu-id="92f93-132">A very small number of descriptors directly inside the root signature, such as a constant buffer view (CBV) that changes per draw, thereby saving the application from needing to put those descriptors in a descriptor heap.</span></span>

<span data-ttu-id="92f93-133">Em outras palavras, a assinatura raiz fornece otimizações de desempenho adequadas para pequenas quantidades de dados que são alteradas por empate.</span><span class="sxs-lookup"><span data-stu-id="92f93-133">In other words, the root signature provides performance optimizations suitable for small amounts of data that change per draw.</span></span>

<span data-ttu-id="92f93-134">O design do Direct3D 12 para associação o separa de outras tarefas, como gerenciamento de memória, gerenciamento de tempo de vida de objeto, rastreamento de estado e sincronização de memória (consulte [as diferenças no modelo de associação do Direct3D 11](binding-model.md)).</span><span class="sxs-lookup"><span data-stu-id="92f93-134">The Direct3D 12 design for binding separates it from other tasks, such as memory management, object lifetime management, state tracking, and memory synchronization (refer to [Differences in the Binding Model from Direct3D 11](binding-model.md)).</span></span> <span data-ttu-id="92f93-135">A ligação do Direct3D 12 foi projetada para ser baixa sobrecarga e otimizada para as chamadas à API que são feitas com mais frequência.</span><span class="sxs-lookup"><span data-stu-id="92f93-135">Direct3D 12 binding is designed to be low overhead and optimized for the API calls that are made most frequently.</span></span> <span data-ttu-id="92f93-136">Ele também é escalonável em hardware de ponta a ponta e é escalonável do mais antigo (o pipeline Direct3D 11 mais linear) para as abordagens mais recentes (mais paralelas) à programação do mecanismo de gráficos.</span><span class="sxs-lookup"><span data-stu-id="92f93-136">It is also scalable across low end to high end hardware, and scalable from older (the more linear Direct3D 11 pipeline) to the newer (more parallel) approaches to graphics engine programming.</span></span>

## <a name="resource-types-and-views"></a><span data-ttu-id="92f93-137">Tipos de recursos e exibições</span><span class="sxs-lookup"><span data-stu-id="92f93-137">Resource types and views</span></span>

<span data-ttu-id="92f93-138">Os tipos de recurso são os mesmos que o Direct3D 11, ou seja:</span><span class="sxs-lookup"><span data-stu-id="92f93-138">Resource types are the same as Direct3D 11, namely:</span></span>

-   <span data-ttu-id="92f93-139">Texture1D e Texture1DArray</span><span class="sxs-lookup"><span data-stu-id="92f93-139">Texture1D, and Texture1DArray</span></span>
-   <span data-ttu-id="92f93-140">Texture2D e Texture2DArray, Texture2DMS, Texture2DMSArray</span><span class="sxs-lookup"><span data-stu-id="92f93-140">Texture2D, and Texture2DArray, Texture2DMS, Texture2DMSArray</span></span>
-   <span data-ttu-id="92f93-141">Texture3D</span><span class="sxs-lookup"><span data-stu-id="92f93-141">Texture3D</span></span>
-   <span data-ttu-id="92f93-142">Buffers (digitados, estruturados e brutos)</span><span class="sxs-lookup"><span data-stu-id="92f93-142">Buffers (typed, structured and raw)</span></span>

<span data-ttu-id="92f93-143">As exibições de recursos são semelhantes, mas ligeiramente diferentes das exibições do Direct3D 11, do vértice e do buffer do índice foram adicionadas.</span><span class="sxs-lookup"><span data-stu-id="92f93-143">Resource views are similar but slightly different from Direct3D 11, vertex and index buffer views have been added.</span></span>

-   <span data-ttu-id="92f93-144">Modo de exibição de buffer constante (CBV)</span><span class="sxs-lookup"><span data-stu-id="92f93-144">Constant buffer view (CBV)</span></span>
-   <span data-ttu-id="92f93-145">Modo de exibição de acesso não ordenado (UAV)</span><span class="sxs-lookup"><span data-stu-id="92f93-145">Unordered access view (UAV)</span></span>
-   <span data-ttu-id="92f93-146">Exibição de recurso de sombreador (SRV)</span><span class="sxs-lookup"><span data-stu-id="92f93-146">Shader resource view (SRV)</span></span>
-   <span data-ttu-id="92f93-147">Amostradores</span><span class="sxs-lookup"><span data-stu-id="92f93-147">Samplers</span></span>
-   <span data-ttu-id="92f93-148">Renderizar exibição de destino (RTV)</span><span class="sxs-lookup"><span data-stu-id="92f93-148">Render Target View (RTV)</span></span>
-   <span data-ttu-id="92f93-149">Exibição de estêncil de profundidade (DSV)</span><span class="sxs-lookup"><span data-stu-id="92f93-149">Depth Stencil View (DSV)</span></span>
-   <span data-ttu-id="92f93-150">IBV (exibição de buffer de índice)</span><span class="sxs-lookup"><span data-stu-id="92f93-150">Index Buffer View (IBV)</span></span>
-   <span data-ttu-id="92f93-151">Exibição de buffer de vértice (VBV)</span><span class="sxs-lookup"><span data-stu-id="92f93-151">Vertex Buffer View (VBV)</span></span>
-   <span data-ttu-id="92f93-152">Exibição de saída de fluxo (SOV)</span><span class="sxs-lookup"><span data-stu-id="92f93-152">Stream Output View (SOV)</span></span>

<span data-ttu-id="92f93-153">Somente as quatro primeiras dessas exibições são realmente visíveis para os sombreadores, consulte [heaps de descritores visíveis do sombreador](shader-visible-descriptor-heaps.md) e [heaps de descritor visíveis sem sombreador](non-shader-visible-descriptor-heaps.md).</span><span class="sxs-lookup"><span data-stu-id="92f93-153">Only the first four of these views are actually visible to shaders, refer to [Shader Visible Descriptor Heaps](shader-visible-descriptor-heaps.md) and [Non Shader Visible Descriptor Heaps](non-shader-visible-descriptor-heaps.md).</span></span>

## <a name="resource-binding-flow-of-control"></a><span data-ttu-id="92f93-154">Fluxo de controle de associação de recursos</span><span class="sxs-lookup"><span data-stu-id="92f93-154">Resource Binding Flow of Control</span></span>

<span data-ttu-id="92f93-155">Concentrando-se apenas nas assinaturas raiz, nos descritores raiz, nas constantes raiz, nas tabelas de descritores e nos heaps de descritores, o fluxo de lógica de renderização de um aplicativo deve ser semelhante ao seguinte:</span><span class="sxs-lookup"><span data-stu-id="92f93-155">Focusing just on root signatures, root descriptors, root constants, descriptor tables, and descriptor heaps, the flow of rendering logic for an app should be similar to the following:</span></span>

-   <span data-ttu-id="92f93-156">Crie um ou mais objetos de assinatura raiz – um para cada configuração de ligação diferente que um aplicativo precisa.</span><span class="sxs-lookup"><span data-stu-id="92f93-156">Create one or more root signature objects – one for every different binding configuration an application needs.</span></span>
-   <span data-ttu-id="92f93-157">Crie sombreadores e estado de pipeline com os objetos de assinatura raiz com os quais eles serão usados.</span><span class="sxs-lookup"><span data-stu-id="92f93-157">Create shaders and pipeline state with the root signature objects they will be used with.</span></span>
-   <span data-ttu-id="92f93-158">Crie um (ou, se necessário, mais) heaps de descritores que conterão todos os descritores SRV, UAV e CBV para cada quadro de renderização.</span><span class="sxs-lookup"><span data-stu-id="92f93-158">Create one (or, if necessary, more) descriptor heaps that will contain all the SRV, UAV, and CBV descriptors for each frame of rendering.</span></span>
-   <span data-ttu-id="92f93-159">Inicialize os heaps de descritores com descriprs, onde possível para conjuntos de descritores que serão reutilizados em vários quadros.</span><span class="sxs-lookup"><span data-stu-id="92f93-159">Initialize the descriptor heap(s) with descriptors where possible for sets of descriptors that will be reused across many frames.</span></span>
-   <span data-ttu-id="92f93-160">Para cada quadro a ser renderizado:</span><span class="sxs-lookup"><span data-stu-id="92f93-160">For each frame to be rendered:</span></span>
    -   <span data-ttu-id="92f93-161">Para cada lista de comandos:</span><span class="sxs-lookup"><span data-stu-id="92f93-161">For each command list:</span></span>
        -   <span data-ttu-id="92f93-162">Defina a assinatura raiz atual a ser usada (e altere se necessário durante o processamento – o que raramente é necessário).</span><span class="sxs-lookup"><span data-stu-id="92f93-162">Set the current root signature to use (and change if needed during rendering – which is rarely required).</span></span>
        -   <span data-ttu-id="92f93-163">Atualize algumas constantes da assinatura raiz e/ou descritores de assinatura raiz para a nova exibição (como projeções do mundo/exibição).</span><span class="sxs-lookup"><span data-stu-id="92f93-163">Update some root signature’s constants and/or root signature descriptors for the new view (such as world/view projections).</span></span>
        -   <span data-ttu-id="92f93-164">Para cada item a ser desenhado:</span><span class="sxs-lookup"><span data-stu-id="92f93-164">For each item to draw:</span></span>
            -   <span data-ttu-id="92f93-165">Defina os novos descritores nos heaps do descritor conforme necessário para a renderização por objeto.</span><span class="sxs-lookup"><span data-stu-id="92f93-165">Define any new descriptors in descriptor heaps as needed for per-object rendering.</span></span> <span data-ttu-id="92f93-166">Para heaps de descritores visíveis para sombreador, o aplicativo deve se certificar de usar o espaço de heap de descritor que ainda não está sendo referenciado pela renderização que poderia estar em trânsito – por exemplo, alocar espaço linearmente por meio do heap de descritor durante a renderização.</span><span class="sxs-lookup"><span data-stu-id="92f93-166">For shader-visible descriptor heaps, the app must make sure to use descriptor heap space that isn’t already being referenced by rendering that could be in flight – for example, linearly allocating space through the descriptor heap during rendering.</span></span>
            -   <span data-ttu-id="92f93-167">Atualize a assinatura raiz com ponteiros para as regiões necessárias dos heaps de descritor.</span><span class="sxs-lookup"><span data-stu-id="92f93-167">Update the root signature with pointers to the required regions of the descriptor heaps.</span></span> <span data-ttu-id="92f93-168">Por exemplo, uma tabela de descritores pode apontar para alguns descritores estáticos (inalteráveis) inicializados anteriormente, enquanto outra tabela de descritores pode apontar para alguns descriprs dinâmicos configurados para a renderização atual.</span><span class="sxs-lookup"><span data-stu-id="92f93-168">For example, one descriptor table might point to some static (unchanging) descriptors initialized earlier, while another descriptor table might point to some dynamic descriptors configured for the current rendering.</span></span>
            -   <span data-ttu-id="92f93-169">Atualize algumas constantes de assinatura raiz e/ou descritores de assinatura raiz para renderização por item.</span><span class="sxs-lookup"><span data-stu-id="92f93-169">Update some root signature’s constants and/or root signature descriptors for per-item rendering.</span></span>
            -   <span data-ttu-id="92f93-170">Defina o estado do pipeline para o item a ser desenhado (somente se a alteração for necessária), compatível com a assinatura de raiz atualmente associada.</span><span class="sxs-lookup"><span data-stu-id="92f93-170">Set the pipeline state for the item to draw (only if change needed), compatible with the currently bound root signature.</span></span>
            -   <span data-ttu-id="92f93-171">Draw</span><span class="sxs-lookup"><span data-stu-id="92f93-171">Draw</span></span>
        -   <span data-ttu-id="92f93-172">Repetir (próximo item)</span><span class="sxs-lookup"><span data-stu-id="92f93-172">Repeat (next item)</span></span>
    -   <span data-ttu-id="92f93-173">REPEAT (próxima lista de comandos)</span><span class="sxs-lookup"><span data-stu-id="92f93-173">Repeat (next command list)</span></span>
    -   <span data-ttu-id="92f93-174">Estritamente quando a GPU termina com qualquer memória que não será mais usada, ela pode ser liberada.</span><span class="sxs-lookup"><span data-stu-id="92f93-174">Strictly when the GPU has finished with any memory that will no longer be used, it can be released.</span></span> <span data-ttu-id="92f93-175">As referências de descritores a ele não precisam ser excluídas se a renderização adicional que usa esses descritores não for enviada.</span><span class="sxs-lookup"><span data-stu-id="92f93-175">Descriptors' references to it do not need to be deleted if additional rendering that uses those descriptors is not submitted.</span></span> <span data-ttu-id="92f93-176">Portanto, a renderização subsequente pode apontar para outras áreas em heaps de descritor ou os descritores obsoletos podem ser substituídos por descritores válidos para reutilizar o espaço de heap do descritor.</span><span class="sxs-lookup"><span data-stu-id="92f93-176">So, subsequent rendering can point to other areas in descriptor heaps, or stale descriptors can be overwritten with valid descriptors to reuse the descriptor heap space.</span></span>
-   <span data-ttu-id="92f93-177">Repetir (próximo quadro)</span><span class="sxs-lookup"><span data-stu-id="92f93-177">Repeat (next frame)</span></span>

<span data-ttu-id="92f93-178">Observe que outros tipos de descritores, RTVs (exibições de destino de renderização), DSV (exibições de estêncil de profundidade), IBVs (exibições de buffer de índice), VBVs (exibições de buffer de vértice) e SOV (exibições de objeto do sombreador) são gerenciados de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="92f93-178">Note that other descriptor types, render target views (RTVs), depth stencil views (DSV), index buffer views (IBVs), vertex buffer views (VBVs), and shader object views (SOV), are managed differently.</span></span> <span data-ttu-id="92f93-179">O driver manipula o controle de versão do conjunto de descritores associado para cada desenho durante a gravação da lista de comandos (semelhante à forma como as associações de assinatura raiz têm controle de versão do hardware/driver).</span><span class="sxs-lookup"><span data-stu-id="92f93-179">The driver handles the versioning of the set of descriptors bound for each draw during recording of the command list (similar to how the root signature bindings are versioned by the hardware/driver).</span></span> <span data-ttu-id="92f93-180">Isso é diferente do conteúdo de heaps de descritores visíveis para sombreador, para os quais o aplicativo deve alocar manualmente por meio do heap, pois faz referência a descritores diferentes entre o desenho.</span><span class="sxs-lookup"><span data-stu-id="92f93-180">This is different from the contents of shader-visible descriptor heaps, for which the application must manually allocate through the heap as it references different descriptors between draws.</span></span> <span data-ttu-id="92f93-181">O controle de versão do conteúdo de heap que está visível para sombreador é deixado para o aplicativo porque permite que os aplicativos façam coisas como os descritores de reutilização que não mudam ou usam grandes conjuntos estáticos de descritores e usam a indexação de sombreador (como por ID de material) para selecionar os descritores a serem usados a partir do heap de descrição ou usar combinações de técnicas para</span><span class="sxs-lookup"><span data-stu-id="92f93-181">Versioning of heap content that is shader-visible is left to the application because it allows applications to do things like reuse descriptors that don’t change, or use large static sets of descriptors and use shader indexing (such as by material ID) to select descriptors to use from the descriptor heap, or use combinations of techniques for different sets of descriptors.</span></span> <span data-ttu-id="92f93-182">O hardware não está equipado para lidar com esse tipo de flexibilidade para os outros tipos de descritores (RTV, DSV, IBV, VBV, SOV).</span><span class="sxs-lookup"><span data-stu-id="92f93-182">The hardware isn’t equipped to handle this type of flexibility for the other descriptor types (RTV, DSV, IBV, VBV, SOV).</span></span>

## <a name="suballocation"></a><span data-ttu-id="92f93-183">Subalocação</span><span class="sxs-lookup"><span data-stu-id="92f93-183">Suballocation</span></span>

<span data-ttu-id="92f93-184">No Direct3D 12, o aplicativo tem controle de baixo nível sobre o gerenciamento de memória.</span><span class="sxs-lookup"><span data-stu-id="92f93-184">In Direct3D 12, the app has low-level control over memory management.</span></span> <span data-ttu-id="92f93-185">Em versões anteriores do Direct3D, incluindo o Direct3D 11, haveria uma alocação por recurso.</span><span class="sxs-lookup"><span data-stu-id="92f93-185">In earlier versions of Direct3D, including Direct3D 11, there would be one allocation per resource.</span></span> <span data-ttu-id="92f93-186">No Direct3D 12, o aplicativo pode usar a API para alocar um grande bloco de memória, maior do que qualquer objeto individual precisaria.</span><span class="sxs-lookup"><span data-stu-id="92f93-186">In Direct3D 12, the app can use the API to allocate a large block of memory, larger than any single object would need.</span></span> <span data-ttu-id="92f93-187">Depois que isso for feito, o aplicativo poderá criar descritores para apontar para seções desse grande bloco de memória.</span><span class="sxs-lookup"><span data-stu-id="92f93-187">After this is done, the app can create descriptors to point to sections of that large memory block.</span></span> <span data-ttu-id="92f93-188">Esse processo de decidir o que colocar onde (blocos menores dentro do bloco grande) é conhecido como *subalocação*.</span><span class="sxs-lookup"><span data-stu-id="92f93-188">This process of deciding what to put where (smaller blocks inside the large block) is known as *suballocation*.</span></span> <span data-ttu-id="92f93-189">Habilitar o aplicativo para fazer isso pode produzir ganhos no uso eficiente da computação e da memória.</span><span class="sxs-lookup"><span data-stu-id="92f93-189">Enabling the app to do this can yield gains in efficient use of computation and memory.</span></span> <span data-ttu-id="92f93-190">Por exemplo, a renomeação de recursos é renderizada como obsoleta.</span><span class="sxs-lookup"><span data-stu-id="92f93-190">For example, resource renaming is rendered obsolete.</span></span> <span data-ttu-id="92f93-191">Em vez disso, os aplicativos podem usar limites para determinar quando um recurso específico está sendo usado e quando não é por meio do isolamento nas execuções da lista de comandos, em que a lista de comandos requer o uso desse recurso específico.</span><span class="sxs-lookup"><span data-stu-id="92f93-191">In place of this, apps can use fences to determine when a particular resource is being used and when it's not by fencing on command list executions where the command list requires the use of that particular resource.</span></span>

## <a name="freeing-resources"></a><span data-ttu-id="92f93-192">Liberando recursos</span><span class="sxs-lookup"><span data-stu-id="92f93-192">Freeing Resources</span></span>

<span data-ttu-id="92f93-193">Antes que qualquer memória que tenha sido associada ao pipeline possa ser liberada, a GPU deve ser concluída com ela.</span><span class="sxs-lookup"><span data-stu-id="92f93-193">Before any memory that has been bound to the pipeline can be freed, the GPU must be finished with it.</span></span>

<span data-ttu-id="92f93-194">Aguardar a renderização de quadros provavelmente é a maneira mais grosseira de ter certeza de que a GPU foi concluída.</span><span class="sxs-lookup"><span data-stu-id="92f93-194">Waiting for frame rendering is probably the coarsest way to be certain that the GPU has finished.</span></span> <span data-ttu-id="92f93-195">Em um detalhamento mais detalhado, você pode usar novamente os limites — quando um comando é registrado em uma lista de comandos que você deseja controlar a conclusão, insira um limite imediatamente após ele.</span><span class="sxs-lookup"><span data-stu-id="92f93-195">At a finer grain, you can again use fences—when a command is recorded into a command list that you want to track the completion of, insert a fence immediately after it.</span></span> <span data-ttu-id="92f93-196">Em seguida, você pode fazer várias operações de sincronização com a cerca.</span><span class="sxs-lookup"><span data-stu-id="92f93-196">Then, you can do various synchronization operations with the fence.</span></span> <span data-ttu-id="92f93-197">Você envia um novo trabalho (listas de comandos) que aguarda até que um limite especificado tenha passado na GPU, o que indica que tudo antes de ser concluído ou que você pode solicitar que um evento de CPU seja gerado quando a cerca passada (que o aplicativo pode estar aguardando com um thread em suspensão).</span><span class="sxs-lookup"><span data-stu-id="92f93-197">You submit new work (command lists) that waits until a specified fence has passed on the GPU, which indicates that everything before it is complete, or you can request that a CPU event be raised when the fence has passed (which the app can be waiting on with a sleeping thread).</span></span> <span data-ttu-id="92f93-198">No Direct3D 11, isso era `EnqueueSetEvent` ().</span><span class="sxs-lookup"><span data-stu-id="92f93-198">In Direct3D 11, this was `EnqueueSetEvent`().</span></span>

## <a name="related-topics"></a><span data-ttu-id="92f93-199">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="92f93-199">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="92f93-200">Associação de recursos</span><span class="sxs-lookup"><span data-stu-id="92f93-200">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




