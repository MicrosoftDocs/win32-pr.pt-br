---
title: Assinatura raiz versão 1.1
description: A finalidade da Assinatura Raiz versão 1.1 é permitir que os aplicativos indiquem aos drivers quando descritores em um heap de descritor não mudarem ou os descritores de dados apontarem para não mudarão.
ms.assetid: 8FE42C1C-7F1D-4E70-A7EE-D5EC67237327
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 04a7a32576efa4d93a8d26aa57282f06e0d5a02f
ms.sourcegitcommit: b40a986d5ded926ae7617119cdd35d99b533bad9
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/24/2021
ms.locfileid: "110343661"
---
# <a name="root-signature-version-11"></a><span data-ttu-id="65d62-103">Assinatura raiz versão 1.1</span><span class="sxs-lookup"><span data-stu-id="65d62-103">Root Signature Version 1.1</span></span>

<span data-ttu-id="65d62-104">A finalidade da Assinatura Raiz versão 1.1 é permitir que os aplicativos indiquem aos drivers quando descritores em um heap de descritor não mudarem ou os descritores de dados apontarem para não mudarão.</span><span class="sxs-lookup"><span data-stu-id="65d62-104">The purpose of Root Signature version 1.1 is to enable applications to indicate to drivers when descriptors in a descriptor heap won’t change or the data descriptors point to won’t change.</span></span> <span data-ttu-id="65d62-105">Isso permite que os drivers façam otimizações que podem ser possíveis sabendo que um descritor ou a memória que ele aponta é estática por algum período.</span><span class="sxs-lookup"><span data-stu-id="65d62-105">This allows the option for drivers to make optimizations that might be possible knowing that a descriptor or the memory it points to is static for some period of time.</span></span>

-   [<span data-ttu-id="65d62-106">Visão geral</span><span class="sxs-lookup"><span data-stu-id="65d62-106">Overview</span></span>](#overview)
-   [<span data-ttu-id="65d62-107">Sinalizadores estáticos e voláteis</span><span class="sxs-lookup"><span data-stu-id="65d62-107">Static and Volatile Flags</span></span>](#static-and-volatile-flags)
    -   [<span data-ttu-id="65d62-108">DESCRITORES \_ VOLÁTEIS</span><span class="sxs-lookup"><span data-stu-id="65d62-108">DESCRIPTORS\_VOLATILE</span></span>](#descriptors_volatile)
    -   [<span data-ttu-id="65d62-109">DADOS \_ VOLÁTEIS</span><span class="sxs-lookup"><span data-stu-id="65d62-109">DATA\_VOLATILE</span></span>](#data_volatile)
    -   [<span data-ttu-id="65d62-110">DADOS \_ \_ ESTÁTICOS \_ ENQUANTO \_ DEFINIDOS EM \_ EXECUTE</span><span class="sxs-lookup"><span data-stu-id="65d62-110">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>](#data_static_while_set_at_execute)
    -   [<span data-ttu-id="65d62-111">DADOS \_ ESTÁTICOS</span><span class="sxs-lookup"><span data-stu-id="65d62-111">DATA\_STATIC</span></span>](#data_static)
    -   [<span data-ttu-id="65d62-112">Combinando sinalizadores</span><span class="sxs-lookup"><span data-stu-id="65d62-112">Combining Flags</span></span>](#combining-flags)
    -   [<span data-ttu-id="65d62-113">Resumo do sinalizador</span><span class="sxs-lookup"><span data-stu-id="65d62-113">Flag Summary</span></span>](#flag-summary)
-   [<span data-ttu-id="65d62-114">Resumo da API da versão 1.1</span><span class="sxs-lookup"><span data-stu-id="65d62-114">Version 1.1 API Summary</span></span>](#version-11-api-summary)
    -   [<span data-ttu-id="65d62-115">Enumerações</span><span class="sxs-lookup"><span data-stu-id="65d62-115">Enums</span></span>](#enums)
    -   [<span data-ttu-id="65d62-116">Estruturas</span><span class="sxs-lookup"><span data-stu-id="65d62-116">Structures</span></span>](#helper-structures)
    -   [<span data-ttu-id="65d62-117">Funções</span><span class="sxs-lookup"><span data-stu-id="65d62-117">Functions</span></span>](#functions)
    -   [<span data-ttu-id="65d62-118">Métodos</span><span class="sxs-lookup"><span data-stu-id="65d62-118">Methods</span></span>](#methods)
    -   [<span data-ttu-id="65d62-119">Estruturas auxiliares</span><span class="sxs-lookup"><span data-stu-id="65d62-119">Helper structures</span></span>](#helper-structures)
-   [<span data-ttu-id="65d62-120">Consequências da violação de sinalizadores de estática</span><span class="sxs-lookup"><span data-stu-id="65d62-120">Consequences of violating static-ness flags</span></span>](#consequences-of-violating-static-ness-flags)
-   [<span data-ttu-id="65d62-121">Gerenciamento de versão</span><span class="sxs-lookup"><span data-stu-id="65d62-121">Version management</span></span>](#version-management)
-   [<span data-ttu-id="65d62-122">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="65d62-122">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="65d62-123">Visão geral</span><span class="sxs-lookup"><span data-stu-id="65d62-123">Overview</span></span>

<span data-ttu-id="65d62-124">A Assinatura Raiz versão 1.0 permite que o conteúdo dos heaps de descritor e a memória que eles apontam sejam alterados livremente pelos aplicativos sempre que os comandos listar/agrupar que os referenciam estarão potencialmente em voo na GPU.</span><span class="sxs-lookup"><span data-stu-id="65d62-124">Root Signature version 1.0 allows the contents of descriptor heaps and the memory they point at to be freely changed by applications any time that command lists / bundles referencing them are potentially in flight on the GPU.</span></span> <span data-ttu-id="65d62-125">Muitas vezes, no entanto, os aplicativos não precisam de flexibilidade para alterar descritores ou memória depois que os comandos que os referenciam foram gravados.</span><span class="sxs-lookup"><span data-stu-id="65d62-125">Very often, however, applications don’t actually need the flexibility to change descriptors or memory after commands that reference them have been recorded.</span></span>

<span data-ttu-id="65d62-126">Os aplicativos geralmente são triviaismente capazes de:</span><span class="sxs-lookup"><span data-stu-id="65d62-126">Applications are often trivially able to:</span></span>

-   <span data-ttu-id="65d62-127">Configurar descritores (e possível a memória para a que eles apontam) antes de vincular tabelas de descritor ou descritores raiz em uma lista de comandos ou pacote.</span><span class="sxs-lookup"><span data-stu-id="65d62-127">Set up descriptors (and possible the memory they point to) before binding descriptor tables or root descriptors on a command list or bundle.</span></span>
-   <span data-ttu-id="65d62-128">Verifique se esses descritores não serão alterados até que a lista de comandos /bundles que os referencie tenha terminado de executar pela última vez.</span><span class="sxs-lookup"><span data-stu-id="65d62-128">Ensure that these descriptors will not change until the command list /bundles referencing them have finished executing for the last time.</span></span>
-   <span data-ttu-id="65d62-129">Certifique-se de que os dados que os descritores apontam não alterem para a mesma duração completa.</span><span class="sxs-lookup"><span data-stu-id="65d62-129">Ensure the data the descriptors point to does not change for the same full duration.</span></span>

<span data-ttu-id="65d62-130">Como alternativa, um aplicativo só pode ser capaz de honrar que os dados não são alterados por uma duração menor no tempo.</span><span class="sxs-lookup"><span data-stu-id="65d62-130">Alternatively, an application may only be able to honor that data doesn’t change for a shorter duration in time.</span></span> <span data-ttu-id="65d62-131">Em particular, os dados podem ser estáticos para a janela no tempo durante a execução da lista de comandos que uma associação de parâmetro raiz (tabela de descritores ou descritor raiz) aponta para os dados no momento.</span><span class="sxs-lookup"><span data-stu-id="65d62-131">In particular data might be static for the window in time during command list execution that a root parameter binding (descriptor table or root descriptor) currently points to the data.</span></span> <span data-ttu-id="65d62-132">Em outras palavras, um aplicativo pode desejar executar a execução na linha do tempo da GPU que atualiza alguns dados entre os períodos de tempo em que são definidos por meio de um parâmetro raiz, sabendo que, quando ele for definido, será estático.</span><span class="sxs-lookup"><span data-stu-id="65d62-132">In other words, an application may wish to perform execution on the GPU timeline that updates some data in between time periods where it is set via a root parameter, knowing that when it is set it will be static.</span></span>

<span data-ttu-id="65d62-133">Se descritores ou os descritores de dados apontarem para, não serão alterados, os drivers de otimizações específicos podem ser específicos do fornecedor de hardware e, de forma importante, não alteram o comportamento, o que não é possível melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="65d62-133">If descriptors, or the data descriptors point to, will not change, then the specific optimizations drivers might do are hardware vendor specific, and importantly they do not change behavior other than possibly improving performance.</span></span> <span data-ttu-id="65d62-134">A preservação da maior parte do conhecimento sobre a intenção do aplicativo, como possível, não sobrecarrega os aplicativos.</span><span class="sxs-lookup"><span data-stu-id="65d62-134">Preserving as much knowledge about application intent as possible does not put a burden on applications.</span></span>

<span data-ttu-id="65d62-135">Uma otimização é que muitos drivers podem produzir acessos de memória mais eficientes por sombreadores, caso saibam as promessas que um aplicativo pode tomar sobre o qualidade estático de descritores e dados.</span><span class="sxs-lookup"><span data-stu-id="65d62-135">One optimization is that many drivers can produce more efficient memory accesses by shaders if they know the promises an application can make about the static-ness of descriptors and data.</span></span> <span data-ttu-id="65d62-136">Por exemplo, os drivers podem remover um nível de indireção para acessar um descritor em um heap convertendo-o em um descritor raiz se o hardware específico não for sensível ao tamanho do argumento raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-136">For example, drivers could remove a level of indirection for accessing a descriptor in a heap by converting it into a root descriptor if the particular hardware is not sensitive to root argument size.</span></span>

<span data-ttu-id="65d62-137">A tarefa adicional para o desenvolvedor usar a versão 1,1 é tornar as promessas sobre volatilidade e qualidade de dados sempre que possível, para que os drivers possam fazer as otimizações que fazem sentido.</span><span class="sxs-lookup"><span data-stu-id="65d62-137">The additional task for developer using Version 1.1 is to make promises about the volatility and static-ness of data wherever possible, so that drivers can make the optimizations that make sense.</span></span> <span data-ttu-id="65d62-138">Os desenvolvedores não precisam fazer nenhuma promessa sobre qualidade estático.</span><span class="sxs-lookup"><span data-stu-id="65d62-138">Developers do not have to make any promises about static-ness.</span></span>

<span data-ttu-id="65d62-139">A assinatura de raiz versão 1,0 continua a funcionar inalterada, embora os aplicativos que recompilam assinaturas raiz tenham como padrão a assinatura raiz 1,1 agora (com uma opção para forçar a versão 1,0, se desejado).</span><span class="sxs-lookup"><span data-stu-id="65d62-139">Root Signature version 1.0 continues to function unchanged, though applications that recompile root signatures will default to Root Signature 1.1 now (with an option to force version 1.0 if desired).</span></span>

## <a name="static-and-volatile-flags"></a><span data-ttu-id="65d62-140">Sinalizadores estáticos e voláteis</span><span class="sxs-lookup"><span data-stu-id="65d62-140">Static and Volatile Flags</span></span>

<span data-ttu-id="65d62-141">Os sinalizadores a seguir fazem parte da assinatura raiz para permitir que os drivers escolham uma estratégia de como lidar melhor com os argumentos raiz individuais quando eles são definidos e também incorporar as mesmas suposições aos objetos de estado do pipeline (PSOs) quando eles são compilados originalmente – já que a assinatura raiz faz parte de um PSO.</span><span class="sxs-lookup"><span data-stu-id="65d62-141">The following flags are part of the root signature to allow drivers to choose a strategy for how to best handle individual root arguments when they are set, and also embed the same assumptions into Pipeline State Objects (PSOs) when they are originally compiled - since the root signature is part of a PSO.</span></span>

<span data-ttu-id="65d62-142">Os sinalizadores a seguir são definidos pelo aplicativo e aplicam-se a descritores ou dados.</span><span class="sxs-lookup"><span data-stu-id="65d62-142">The following flags are set by the app and apply to descriptors or data.</span></span>

``` syntax
typedef enum D3D12_DESCRIPTOR_RANGE_FLAGS
{
    D3D12_DESCRIPTOR_RANGE_FLAG_NONE    = 0,
    D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE    = 0x1,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE   = 0x2,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE    = 0x4,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC = 0x8
} D3D12_DESCRIPTOR_RANGE_FLAGS;

typedef enum D3D12_ROOT_DESCRIPTOR_FLAGS
{
    D3D12_ROOT_DESCRIPTOR_FLAG_NONE = 0,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE    = 0x2,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE = 0x4,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC  = 0x8
} D3D12_ROOT_DESCRIPTOR_FLAGS;
```

### <a name="descriptors_volatile"></a><span data-ttu-id="65d62-143">DESCRITOres \_ voláteis</span><span class="sxs-lookup"><span data-stu-id="65d62-143">DESCRIPTORS\_VOLATILE</span></span>

<span data-ttu-id="65d62-144">Com esse sinalizador definido, os descritores em um heap de descritores apontados por uma tabela de descritor raiz podem ser alterados pelo aplicativo a qualquer momento, exceto quando a lista de comandos/pacotes que associam a tabela de descritores foram enviados e não concluíram a execução.</span><span class="sxs-lookup"><span data-stu-id="65d62-144">With this flag set, the descriptors in a descriptor heap pointed to by a root descriptor table can be changed by the application any time except while the command list / bundles that bind the descriptor table have been submitted and have not finished executing.</span></span> <span data-ttu-id="65d62-145">Por exemplo, gravar uma lista de comandos e, subsequentemente, alterar os descritores em um heap de descritores ao qual se refere *antes* de enviar a lista de comandos para execução é válido.</span><span class="sxs-lookup"><span data-stu-id="65d62-145">For instance, recording a command list and subsequently changing descriptors in a descriptor heap it refers to *before* submitting the command list for execution is valid.</span></span> <span data-ttu-id="65d62-146">Esse é o único comportamento com suporte da assinatura raiz versão 1,0.</span><span class="sxs-lookup"><span data-stu-id="65d62-146">This is the only supported behavior of Root Signature version 1.0.</span></span>

<span data-ttu-id="65d62-147">Se o sinalizador volátil dos DESCRITOres \_ *não* for definido, os descritores serão estáticos.</span><span class="sxs-lookup"><span data-stu-id="65d62-147">If the DESCRIPTORS\_VOLATILE flag is *not* set then descriptors are static.</span></span> <span data-ttu-id="65d62-148">Não há nenhum sinalizador para esse modo.</span><span class="sxs-lookup"><span data-stu-id="65d62-148">There is no flag for this mode.</span></span> <span data-ttu-id="65d62-149">Os descritores estáticos significam que os descritores em um heap de descritores apontados por uma tabela de descrição de raiz foram inicializados pela hora em que a tabela de descritores é definida em uma lista de comandos/pacote (durante a gravação) e os descritores não podem ser alterados até que a lista de comandos/pacote tenha terminado a execução pela última vez.</span><span class="sxs-lookup"><span data-stu-id="65d62-149">Static descriptors mean the descriptors in a descriptor heap pointed to by a root descriptor table have been initialized by the time the descriptor table is set on a command list / bundle (during recording), and the descriptors cannot be changed until the command list / bundle has finished executing for the last time.</span></span> <span data-ttu-id="65d62-150">*Para a assinatura raiz versão 1,1, os descritores estáticos são a suposição padrão* e o aplicativo precisa especificar o sinalizador volátil dos descritores \_ quando necessário.</span><span class="sxs-lookup"><span data-stu-id="65d62-150">*For Root Signature version 1.1, static descriptors are the default assumption*, and the application has to specify the DESCRIPTORS\_VOLATILE flag when needed.</span></span>

<span data-ttu-id="65d62-151">Para os pacotes que usam tabelas de descritores com descripdores estáticos, os descritores precisam estar prontos começando no momento em que o pacote é registrado (ao contrário de quando o pacote é chamado) e não é alterado até que a execução do pacote seja concluída pela última vez.</span><span class="sxs-lookup"><span data-stu-id="65d62-151">For bundles using descriptor tables with static descriptors, the descriptors have to be ready starting at the time the bundle is recorded (as opposed to when the bundle is called), and not change until the bundle has finished executing for the last time.</span></span> <span data-ttu-id="65d62-152">As tabelas de descritores que apontam para descritores estáticos precisam ser definidas durante a gravação do pacote e não herdadas no grupo.</span><span class="sxs-lookup"><span data-stu-id="65d62-152">Descriptor tables pointing to static descriptors have to be set during bundle recording and not inherited into the bundle.</span></span> <span data-ttu-id="65d62-153">É válido para uma lista de comandos usar uma tabela de descritor com descritores estáticos que foram definidos em um pacote e retornados de volta à lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="65d62-153">It is valid for a command list to use a descriptor table with static descriptors that has been set in a bundle and returned back to the command list.</span></span>

<span data-ttu-id="65d62-154">Quando os descritores são estáticos, há outra alteração no comportamento que exige que o sinalizador DESCRIPTORS \_ VOLATILE seja definido.</span><span class="sxs-lookup"><span data-stu-id="65d62-154">When descriptors are static there is another change in behavior that requires the DESCRIPTORS\_VOLATILE flag to be set.</span></span> <span data-ttu-id="65d62-155">Os acessos fora dos limites a qualquer exibição de Buffer (em vez das exibições Texture1D/2D/3D/Cube) são inválidos e produzem resultados indefinido, incluindo possível redefinição de dispositivo, em vez de retornar valores padrão para leituras ou descartar gravações.</span><span class="sxs-lookup"><span data-stu-id="65d62-155">Out of bounds accesses to any Buffer views (as opposed to Texture1D/2D/3D/Cube views) are invalid and produce undefined results, including possible device reset, rather than returning default values for reads or dropping writes.</span></span> <span data-ttu-id="65d62-156">A finalidade de remover a capacidade de os aplicativos dependerem da verificação de acesso de hardware fora dos limites é permitir que os drivers optem por promover acessos de descritor estático aos acessos do descritor raiz se eles o consideram mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="65d62-156">The purpose for removing the ability for applications to depend on hardware out of bounds access checking is to allow drivers to choose to promote static descriptor accesses to root descriptor accesses if they deem that more efficient.</span></span> <span data-ttu-id="65d62-157">Os descritores raiz não suportam nenhuma verificação fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="65d62-157">Root descriptors don’t support any out of bounds checking.</span></span>

<span data-ttu-id="65d62-158">Se os aplicativos dependerem do comportamento de acesso à memória fora dos limites ao acessar descritores, eles precisarão marcar os intervalos de descritores que acessam esses descritores como DESCRIPTORS \_ VOLATILE.</span><span class="sxs-lookup"><span data-stu-id="65d62-158">If applications depend on safe out of bounds memory access behavior when accessing descriptors, they need to mark the descriptor ranges that access those descriptors as DESCRIPTORS\_VOLATILE.</span></span>

### <a name="data_volatile"></a><span data-ttu-id="65d62-159">DADOS \_ VOLÁTEIS</span><span class="sxs-lookup"><span data-stu-id="65d62-159">DATA\_VOLATILE</span></span>

<span data-ttu-id="65d62-160">Com esse sinalizador definido, os dados apontados pelos descritores podem ser alterados pela CPU a qualquer momento, exceto enquanto a lista de comandos/pacotes que vinculam a tabela de descritor foram enviados e não foram concluídos na execução.</span><span class="sxs-lookup"><span data-stu-id="65d62-160">With this flag set, the data pointed to by descriptors can be changed by the CPU any time except while the command list / bundles that bind the descriptor table have been submitted and have not finished executing.</span></span> <span data-ttu-id="65d62-161">Esse é o único comportamento com suporte da Assinatura Raiz versão 1.0.</span><span class="sxs-lookup"><span data-stu-id="65d62-161">This is the only supported behavior of Root Signature version 1.0.</span></span>

<span data-ttu-id="65d62-162">O sinalizador está disponível em sinalizadores de intervalo de descritor e sinalizadores de descritor raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-162">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="data_static_while_set_at_execute"></a><span data-ttu-id="65d62-163">DADOS \_ \_ ESTÁTICOS \_ ENQUANTO \_ DEFINIDOS EM \_ EXECUTE</span><span class="sxs-lookup"><span data-stu-id="65d62-163">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>

<span data-ttu-id="65d62-164">Com esse sinalizador definido, os dados apontados pelos descritores não podem ser alterados a partir do momento em que o descritor raiz subjacente ou a tabela do descritor é definido em uma lista de comandos/pacote durante a execução na linha do tempo da GPU e termina quando os pacotes/expedições subsequentes não referenciam mais os dados.</span><span class="sxs-lookup"><span data-stu-id="65d62-164">With this flag set, the data pointed to by descriptors cannot change starting from when the underlying root descriptor or descriptor table is set on a command list / bundle during execution on the GPU timeline, and ending when subsequent draws/dispatches will no longer reference the data.</span></span>

<span data-ttu-id="65d62-165">Antes que uma tabela de descritor ou descritor raiz tenha  sido definida na GPU, esses dados podem ser alterados até mesmo pela mesma lista de comandos/pacote.</span><span class="sxs-lookup"><span data-stu-id="65d62-165">Before a root descriptor or descriptor table has been set on the GPU, this data *can* be changed even by the same command list / bundle.</span></span> <span data-ttu-id="65d62-166">Os dados também podem ser alterados enquanto um descritor raiz ou uma tabela de descritores apontando para ele ainda estiver definido na lista de comandos/pacote, desde que os empates/expedimentos que fazem referência a ele tenham sido concluídos.</span><span class="sxs-lookup"><span data-stu-id="65d62-166">The data can also be changed while a root descriptor or descriptor table pointing to it is still set on the command list / bundle, as long as draw/dispatches referencing it have completed.</span></span> <span data-ttu-id="65d62-167">No entanto, isso requer que a tabela de descritores seja reassociada à lista de comandos novamente antes da próxima vez que a tabela de descritor ou descritor raiz for desreferenciada.</span><span class="sxs-lookup"><span data-stu-id="65d62-167">However, doing so requires the descriptor table be rebound to the command list again before the next time the root descriptor or descriptor table is dereferenced.</span></span> <span data-ttu-id="65d62-168">Isso permite que o driver saiba que os dados apontados por um descritor raiz ou uma tabela de descritores foram alterados.</span><span class="sxs-lookup"><span data-stu-id="65d62-168">This allows the driver to know that data pointed to by a root descriptor or descriptor table has changed.</span></span>

<span data-ttu-id="65d62-169">A diferença essencial entre os dados \_ estáticos \_ enquanto \_ definido \_ em \_ Execute e dados \_ voláteis é com dados \_ voláteis um driver não pode informar se as cópias de dados em uma lista de comandos alteraram os dados apontados por um descritor, sem fazer acompanhamento de estado extra.</span><span class="sxs-lookup"><span data-stu-id="65d62-169">The essential difference between DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE and DATA\_VOLATILE is with DATA\_VOLATILE a driver can’t tell whether data copies in a command list have changed the data pointed to by a descriptor, without doing extra state tracking.</span></span> <span data-ttu-id="65d62-170">Portanto, se, por exemplo, um driver puder inserir qualquer tipo de comando de pré-busca de dados em sua lista de comandos (para tornar o sombreador o acesso a dados conhecidos mais eficiente, por exemplo), \_ os dados estáticos \_ enquanto \_ definidos \_ em \_ Execute permitem que o driver saiba que ele só precisa executar a pré-busca de dados no momento em que ele é definido por meio de [**SetGraphicsRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable), [**SetComputeRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) ou um dos métodos para definir a exibição de buffer constante, a exibição de recursos do sombreador ou a exibição de acesso não ordenado.</span><span class="sxs-lookup"><span data-stu-id="65d62-170">So if, for instance, a driver can insert any sort of data pre-fetching commands into their command list (to make shader access to known data more efficient, for example), DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE lets the driver know it only needs to perform data pre-fetching at the moment it is set via [**SetGraphicsRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable), [**SetComputeRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) or one of the methods to set the constant buffer view, shader resource view, or unordered access view.</span></span>

<span data-ttu-id="65d62-171">Para os pacotes, a promessa de que os dados são estáticos enquanto definido em executar aplica-se exclusivamente a cada execução do pacote.</span><span class="sxs-lookup"><span data-stu-id="65d62-171">For bundles, the promise that data is static while set at execute applies uniquely to each execution of the bundle.</span></span>

<span data-ttu-id="65d62-172">O sinalizador está disponível nos sinalizadores de intervalo de descritores e no descritor de raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-172">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="data_static"></a><span data-ttu-id="65d62-173">DADOS \_ estáticos</span><span class="sxs-lookup"><span data-stu-id="65d62-173">DATA\_STATIC</span></span>

<span data-ttu-id="65d62-174">Se esse sinalizador for definido, os dados apontados por descritores serão inicializados no momento em que uma tabela de descritor ou descritor de raiz que faz referência à memória foi definida em uma lista de comandos/pacote durante a gravação, e os dados não poderão ser alterados até que a lista de comandos/pacote tenha terminado a execução pela última vez.</span><span class="sxs-lookup"><span data-stu-id="65d62-174">If this flag is set, the data pointed to by descriptors has been initialized by the time a root descriptor or descriptor table referencing the memory has been set on a command list / bundle during recording, and the data cannot be changed until the command list / bundle has finished executing for the last time.</span></span>

<span data-ttu-id="65d62-175">Para os pacotes, a duração estática começa no descritor raiz ou na configuração da tabela de descritores durante a gravação do pacote, em oposição à gravação de uma lista de comandos de chamada.</span><span class="sxs-lookup"><span data-stu-id="65d62-175">For bundles, the static duration starts at root descriptor or descriptor table setting during the recording of the bundle, as opposed to recording of a calling command list.</span></span> <span data-ttu-id="65d62-176">Além disso, uma tabela de descritor apontando para dados estáticos deve ser definida no pacote e não herdada.</span><span class="sxs-lookup"><span data-stu-id="65d62-176">In addition, a descriptor table pointing to static data must be set in the bundle and not inherited.</span></span> <span data-ttu-id="65d62-177">É válido para uma lista de comandos usar uma tabela de descritor apontando para dados estáticos que foram definidos em um pacote e retornados para a lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="65d62-177">It is valid for a command list to use a descriptor table pointing to static data that has been set in a bundle and returned back to the command list.</span></span>

<span data-ttu-id="65d62-178">O sinalizador está disponível em sinalizadores de intervalo de descritor e sinalizadores de descritor raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-178">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="combining-flags"></a><span data-ttu-id="65d62-179">Combinando sinalizadores</span><span class="sxs-lookup"><span data-stu-id="65d62-179">Combining Flags</span></span>

<span data-ttu-id="65d62-180">No máximo um dos sinalizadores DATA pode ser especificado de cada vez, exceto para intervalos de descritores do Sampler que não são suportados por sinalizadores DATA, pois os exemplos não apontam para os dados.</span><span class="sxs-lookup"><span data-stu-id="65d62-180">At most one of the DATA flags can be specified at a time, except for Sampler descriptor ranges which do not support DATA flags at all since samplers do not point to data.</span></span>

<span data-ttu-id="65d62-181">A ausência de sinalizadores DATA para intervalos de descritores SRV e CBV significa que um padrão de comportamento DATA \_ STATIC WHILE SET AT EXECUTE é \_ \_ \_ \_ assumido.</span><span class="sxs-lookup"><span data-stu-id="65d62-181">The absence of any DATA flags for SRV and CBV descriptor ranges means a default of DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE behavior is assumed.</span></span> <span data-ttu-id="65d62-182">O motivo pelo qual esse padrão é escolhido em vez de DADOS ESTÁTICOs é que DATA STATIC WHILE SET AT EXECUTE tem muito mais probabilidade de ser um padrão seguro para a maioria dos casos, ao mesmo tempo que ainda gera alguma oportunidade de otimização melhor do que o padrão \_ \_ de DATA \_ \_ \_ \_ \_ VOLATILE.</span><span class="sxs-lookup"><span data-stu-id="65d62-182">The reason this default is chosen rather than DATA\_STATIC is that DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is much more likely to be a safe default for a majority of cases, while still yielding some optimization opportunity better than defaulting to DATA\_VOLATILE.</span></span>

<span data-ttu-id="65d62-183">A ausência de sinalizadores DATA para intervalos de descritores UAV significa que um padrão de comportamento DATA VOLATILE é assumido, considerando que normalmente \_ os UAVs são gravados.</span><span class="sxs-lookup"><span data-stu-id="65d62-183">The absence of DATA flags for UAV descriptor ranges means a default of DATA\_VOLATILE behavior is assumed, given typically UAVs are written to.</span></span>

<span data-ttu-id="65d62-184">OS DESCRITORES \_ VOLATILE não *podem* ser combinados com DATA \_ STATIC, mas *podem* ser combinados com os outros sinalizadores DE DADOS.</span><span class="sxs-lookup"><span data-stu-id="65d62-184">DESCRIPTORS\_VOLATILE *cannot* be combined with DATA\_STATIC, but *can* be combined with the other DATA flags.</span></span> <span data-ttu-id="65d62-185">O motivo pelo qual OS DESCRITORES VOLATILE podem ser combinados com DATA STATIC WHILE SET AT EXECUTE é que os descritores voláteis ainda exigem que os descritores sejam prontos durante a execução da lista de comandos/pacote e DATA STATIC WHILE SET AT EXECUTE está fazendo promessas apenas sobre a estática dentro de um subconjunto de lista de \_ \_ \_ \_ \_ \_ \_ \_ \_ \_ \_ comandos/execução de pacote.</span><span class="sxs-lookup"><span data-stu-id="65d62-185">The reason DESCRIPTORS\_VOLATILE can be combined with DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is that volatile descriptors still require the descriptors be ready during command list / bundle execution, and DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is only making promises about the static-ness within a subset of command list / bundle execution.</span></span>

### <a name="flag-summary"></a><span data-ttu-id="65d62-186">Resumo do sinalizador</span><span class="sxs-lookup"><span data-stu-id="65d62-186">Flag Summary</span></span>

<span data-ttu-id="65d62-187">As tabelas a seguir resumem as combinações de sinalizadores que podem ser empregadas.</span><span class="sxs-lookup"><span data-stu-id="65d62-187">The following tables summarize the flag combinations that might be employed.</span></span>



| <span data-ttu-id="65d62-188">Configurações \_ \_ válidas de SINALIZADORES DE INTERVALO DO DESCRITOR D3D12 \_</span><span class="sxs-lookup"><span data-stu-id="65d62-188">Valid D3D12\_DESCRIPTOR\_RANGE\_FLAGS settings</span></span>                                                               | <span data-ttu-id="65d62-189">Descrição</span><span class="sxs-lookup"><span data-stu-id="65d62-189">Description</span></span>                                                                                                                                                                                                                                                                                                                                                     |
|----------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="65d62-190">Nenhum conjunto de sinalizadores</span><span class="sxs-lookup"><span data-stu-id="65d62-190">No flags set</span></span>                                                   | <span data-ttu-id="65d62-191">Os descritores são estáticos (o padrão).</span><span class="sxs-lookup"><span data-stu-id="65d62-191">Descriptors are static (the default).</span></span> <span data-ttu-id="65d62-192">Suposições padrão para dados: para SRV/CBV: DATA STATIC WHILE SET AT EXECUTE e para \_ \_ \_ \_ \_ UAV: DATA \_ VOLATILE.</span><span class="sxs-lookup"><span data-stu-id="65d62-192">Default assumptions for data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span> <span data-ttu-id="65d62-193">Esses padrões para SRV/CBV se ajustarão com segurança aos padrões de uso para a maioria das assinaturas raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-193">These defaults for SRV/CBV will safely fit the usage patterns for the majority of root signatures.</span></span>                                                                                              |
| <span data-ttu-id="65d62-194">DADOS \_ estáticos</span><span class="sxs-lookup"><span data-stu-id="65d62-194">DATA\_STATIC</span></span>                                                   | <span data-ttu-id="65d62-195">Os dois descritores e os dados são estáticos.</span><span class="sxs-lookup"><span data-stu-id="65d62-195">Both descriptors and data are static.</span></span> <span data-ttu-id="65d62-196">Isso maximiza o potencial para otimização de driver.</span><span class="sxs-lookup"><span data-stu-id="65d62-196">This maximizes the potential for driver optimization.</span></span>                                                                                                                                                                                                                                                          |
| <span data-ttu-id="65d62-197">DADOS \_ voláteis</span><span class="sxs-lookup"><span data-stu-id="65d62-197">DATA\_VOLATILE</span></span>                                                 | <span data-ttu-id="65d62-198">Os descritores são estáticos e os dados são voláteis.</span><span class="sxs-lookup"><span data-stu-id="65d62-198">Descriptors are static and the data is volatile.</span></span>                                                                                                                                                                                                                                                                                                     |
| <span data-ttu-id="65d62-199">DADOS \_ estáticos \_ ao serem \_ definidos \_ em \_ execução</span><span class="sxs-lookup"><span data-stu-id="65d62-199">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>                          | <span data-ttu-id="65d62-200">Os descritores são estáticos e os dados são estáticos enquanto definidos em execute.</span><span class="sxs-lookup"><span data-stu-id="65d62-200">Descriptors are static and data is static while set at execute.</span></span>                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="65d62-201">DESCRITOres \_ voláteis</span><span class="sxs-lookup"><span data-stu-id="65d62-201">DESCRIPTORS\_VOLATILE</span></span>                                          | <span data-ttu-id="65d62-202">Os descritores são voláteis e as suposições padrão são feitas sobre os dados: para SRV/CBV: os dados são \_ estáticos \_ enquanto \_ definidos \_ em \_ Execute e para UAV: data \_ volatile.</span><span class="sxs-lookup"><span data-stu-id="65d62-202">Descriptors are volatile, and default assumptions are made about data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span>                                                                                                                                                                                              |
| <span data-ttu-id="65d62-203">dados voláteis de DESCRITOres voláteis \_ \| \_</span><span class="sxs-lookup"><span data-stu-id="65d62-203">DESCRIPTORS\_VOLATILE \| DATA\_VOLATILE</span></span>                        | <span data-ttu-id="65d62-204">Os dois descritores e os dados são voláteis, equivalentes à assinatura raiz 1,0.</span><span class="sxs-lookup"><span data-stu-id="65d62-204">Both descriptors and data are volatile, equivalent to Root Signature 1.0.</span></span>                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="65d62-205">\_ \| dados voláteis de descritores \_ estáticos \_ enquanto \_ definidos \_ em \_ execução</span><span class="sxs-lookup"><span data-stu-id="65d62-205">DESCRIPTORS\_VOLATILE \| DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span> | <span data-ttu-id="65d62-206">Os descritores são voláteis, mas observe que ainda não permite que eles sejam alterados durante a execução da lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="65d62-206">Descriptors are volatile, but note that still doesn’t allow them to change during command list execution.</span></span> <span data-ttu-id="65d62-207">Portanto, é válido combinar a declaração adicional de que os dados são estáticos ao serem definidos por meio da tabela do descritor raiz durante a execução – os descritores subjacentes são efetivamente estáticos por mais tempo do que os dados estão sendo prometidos para serem estáticos.</span><span class="sxs-lookup"><span data-stu-id="65d62-207">So it is valid to combine the additional declaration that data is static while set via root descriptor table during execution – the underlying descriptors are effectively static for longer than the data is being promised to be static.</span></span> |



 



| <span data-ttu-id="65d62-208">Configurações de \_ \_ sinalizadores do descritor raiz D3D12 válido \_</span><span class="sxs-lookup"><span data-stu-id="65d62-208">Valid D3D12\_ROOT\_DESCRIPTOR\_FLAGS settings</span></span>                                                  |  <span data-ttu-id="65d62-209">Descrição</span><span class="sxs-lookup"><span data-stu-id="65d62-209">Description</span></span>                                                                                                                                                                                                                 |
|---------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="65d62-210">Nenhum sinalizador definido</span><span class="sxs-lookup"><span data-stu-id="65d62-210">No flags set</span></span>                                      | <span data-ttu-id="65d62-211">Suposições padrão para dados: para SRV/CBV: dados \_ estáticos \_ enquanto \_ definidos \_ em \_ Execute e para UAV: data \_ volatile.</span><span class="sxs-lookup"><span data-stu-id="65d62-211">Default assumptions for data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span> <span data-ttu-id="65d62-212">Esses padrões para SRV/CBV se ajustarão com segurança aos padrões de uso para a maioria das assinaturas raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-212">These defaults for SRV/CBV will safely fit the usage patterns for the majority of root signatures.</span></span> |
| <span data-ttu-id="65d62-213">DADOS \_ estáticos</span><span class="sxs-lookup"><span data-stu-id="65d62-213">DATA\_STATIC</span></span>                                      | <span data-ttu-id="65d62-214">Os dados são estáticos, o melhor potencial para otimização do driver.</span><span class="sxs-lookup"><span data-stu-id="65d62-214">Data is static, the best potential for driver optimization.</span></span>                                                                                                                                                       |
| <span data-ttu-id="65d62-215">DADOS \_ \_ ESTÁTICOS \_ ENQUANTO \_ DEFINIDOS EM \_ EXECUTE</span><span class="sxs-lookup"><span data-stu-id="65d62-215">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>             | <span data-ttu-id="65d62-216">Os dados são estáticos enquanto são definidos em execução.</span><span class="sxs-lookup"><span data-stu-id="65d62-216">Data is static while set at execute.</span></span>                                                                                                                                                                              |
| <span data-ttu-id="65d62-217">DADOS \_ VOLÁTEIS</span><span class="sxs-lookup"><span data-stu-id="65d62-217">DATA\_VOLATILE</span></span>                                    | <span data-ttu-id="65d62-218">Equivalente à Assinatura Raiz 1.0.</span><span class="sxs-lookup"><span data-stu-id="65d62-218">Equivalent to Root Signature 1.0.</span></span>                                                                                                                                                                                 |



 

## <a name="version-11-api-summary"></a><span data-ttu-id="65d62-219">Resumo da API da versão 1.1</span><span class="sxs-lookup"><span data-stu-id="65d62-219">Version 1.1 API Summary</span></span>

<span data-ttu-id="65d62-220">As chamadas à API a seguir habilitam a versão 1.1.</span><span class="sxs-lookup"><span data-stu-id="65d62-220">The following API calls enable version 1.1.</span></span>

### <a name="enums"></a><span data-ttu-id="65d62-221">Enumerações</span><span class="sxs-lookup"><span data-stu-id="65d62-221">Enums</span></span>

<span data-ttu-id="65d62-222">Essas enumerações contêm os sinalizadores de chave para especificar o descritor e a volátibilidade de dados.</span><span class="sxs-lookup"><span data-stu-id="65d62-222">These enumerations contain the key flags to specify descriptor and data volatility.</span></span>

-   <span data-ttu-id="65d62-223">[**D3D \_ ROOT \_ SIGNATURE \_ VERSION:**](/windows/desktop/api/d3d12/ne-d3d12-d3d_root_signature_version) ids de versão.</span><span class="sxs-lookup"><span data-stu-id="65d62-223">[**D3D\_ROOT\_SIGNATURE\_VERSION**](/windows/desktop/api/d3d12/ne-d3d12-d3d_root_signature_version) : version ids.</span></span>
-   <span data-ttu-id="65d62-224">[**D3D12 \_ SINALIZADORES \_ DE INTERVALO \_ DE DESCRITOR:**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags) um intervalo de sinalizadores que determina se os descritores ou os dados são voláteis ou estáticos.</span><span class="sxs-lookup"><span data-stu-id="65d62-224">[**D3D12\_DESCRIPTOR\_RANGE\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags) : a range of flags determining if descriptors or data are volatile or static.</span></span>
-   <span data-ttu-id="65d62-225">[**D3D12 \_ SINALIZADORES \_ DE DESCRITOR \_ RAIZ:**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_root_descriptor_flags) um intervalo semelhante de sinalizadores para SINALIZADORES DE INTERVALO DE DESCRITOR [**D3D12 \_ \_ \_**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags), exceto que somente sinalizadores de dados se aplicam a descritores raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-225">[**D3D12\_ROOT\_DESCRIPTOR\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_root_descriptor_flags) : a similar range of flags to [**D3D12\_DESCRIPTOR\_RANGE\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags), except that only data flags apply to root descriptors.</span></span>

### <a name="structures"></a><span data-ttu-id="65d62-226">Estruturas</span><span class="sxs-lookup"><span data-stu-id="65d62-226">Structures</span></span>

<span data-ttu-id="65d62-227">Estruturas atualizadas (da versão 1.0) contêm referências aos sinalizadores estáticos/de artificialidade.</span><span class="sxs-lookup"><span data-stu-id="65d62-227">Updated structures (from version 1.0) contain references to the volatility/static flags.</span></span>

-   <span data-ttu-id="65d62-228">[**D3D12 \_ FEATURE \_ DATA \_ ROOT \_ SIGNATURE:**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_root_signature) passe essa estrutura para [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) para verificar se há suporte à Assinatura Raiz Versão 1.1.</span><span class="sxs-lookup"><span data-stu-id="65d62-228">[**D3D12\_FEATURE\_DATA\_ROOT\_SIGNATURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_root_signature) : pass this structure to [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) to check for Root Signature Version 1.1 support.</span></span>
-   <span data-ttu-id="65d62-229">[**D3D12 \_ \_VERSIONED ROOT \_ SIGNATURE \_ DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) : pode conter qualquer versão de uma descrição de assinatura raiz e foi projetado para ser usado com as funções de serialização/desserialização listadas abaixo.</span><span class="sxs-lookup"><span data-stu-id="65d62-229">[**D3D12\_VERSIONED\_ROOT\_SIGNATURE\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) : can hold any version of a root signature description, and is designed to be used with the serialization/deserialization functions listed below.</span></span>
-   <span data-ttu-id="65d62-230">Essas estruturas são equivalentes às usadas na versão 1.0, com a adição de novos campos de sinalizadores para intervalos de descritores e descritores raiz:</span><span class="sxs-lookup"><span data-stu-id="65d62-230">These structures are equivalent to those used in version 1.0, with the addition of new flags fields for descriptor ranges and root descriptors:</span></span>

    -   [<span data-ttu-id="65d62-231">**D3D12 \_ ROOT \_ SIGNATURE \_ DESC1**</span><span class="sxs-lookup"><span data-stu-id="65d62-231">**D3D12\_ROOT\_SIGNATURE\_DESC1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_signature_desc1)
    -   [<span data-ttu-id="65d62-232">**D3D12 \_ DESCRIPTOR \_ RANGE1**</span><span class="sxs-lookup"><span data-stu-id="65d62-232">**D3D12\_DESCRIPTOR\_RANGE1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_range1)
    -   [<span data-ttu-id="65d62-233">**D3D12 \_ ROOT \_ DESCRIPTOR \_ TABLE1**</span><span class="sxs-lookup"><span data-stu-id="65d62-233">**D3D12\_ROOT\_DESCRIPTOR\_TABLE1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_descriptor_table1)
    -   [<span data-ttu-id="65d62-234">**D3D12 \_ ROOT \_ DESCRIPTOR1**</span><span class="sxs-lookup"><span data-stu-id="65d62-234">**D3D12\_ROOT\_DESCRIPTOR1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_descriptor1)
    -   [<span data-ttu-id="65d62-235">**D3D12 \_ ROOT \_ PARAMETER1**</span><span class="sxs-lookup"><span data-stu-id="65d62-235">**D3D12\_ROOT\_PARAMETER1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_parameter1)

### <a name="functions"></a><span data-ttu-id="65d62-236">Funções</span><span class="sxs-lookup"><span data-stu-id="65d62-236">Functions</span></span>

<span data-ttu-id="65d62-237">Os métodos listados aqui substituem as funções [**D3D12SerializeRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializerootsignature) e [**D3D12CreateRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createrootsignaturedeserializer) originais, pois elas são projetadas para funcionar em qualquer versão da assinatura raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-237">The methods listed here supersede the original [**D3D12SerializeRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializerootsignature) and [**D3D12CreateRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createrootsignaturedeserializer) functions, as they are designed to work on any version of root signature.</span></span> <span data-ttu-id="65d62-238">O formulário serializado é o que é passado para a API [**CreateRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createrootsignature) .</span><span class="sxs-lookup"><span data-stu-id="65d62-238">The serialized form is what is passed into the [**CreateRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createrootsignature) API.</span></span> <span data-ttu-id="65d62-239">Se um sombreador tiver sido criado com uma assinatura raiz nele, o sombreador compilado conterá uma assinatura de raiz serializada já existente.</span><span class="sxs-lookup"><span data-stu-id="65d62-239">If a shader has been authored with a root signature in it, the compiled shader will contain a serialized root signature in it already.</span></span>

-   <span data-ttu-id="65d62-240">[**D3D12SerializeVersionedRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializeversionedrootsignature) : se um aplicativo gerar um procedimento de acordo com a estrutura de dados da [**\_ \_ \_ assinatura raiz do D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) , ele deverá fazer o formulário serializado usando essa função.</span><span class="sxs-lookup"><span data-stu-id="65d62-240">[**D3D12SerializeVersionedRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializeversionedrootsignature) : if an application procedurally generates the [**D3D12\_VERSIONED\_ROOT\_SIGNATURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) data structure, it must make the serialized form using this function.</span></span>
-   <span data-ttu-id="65d62-241">[**D3D12CreateVersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createversionedrootsignaturedeserializer) : gera uma interface que pode retornar a estrutura de dados desserializada, por meio de [**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc).</span><span class="sxs-lookup"><span data-stu-id="65d62-241">[**D3D12CreateVersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createversionedrootsignaturedeserializer) : generates an interface that can return the deserialized data structure, via [**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc).</span></span>

### <a name="methods"></a><span data-ttu-id="65d62-242">Métodos</span><span class="sxs-lookup"><span data-stu-id="65d62-242">Methods</span></span>

<span data-ttu-id="65d62-243">A interface [**ID3D12VersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nn-d3d12-id3d12versionedrootsignaturedeserializer) é criada para desserializar a estrutura de dados de assinatura raiz.</span><span class="sxs-lookup"><span data-stu-id="65d62-243">The [**ID3D12VersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nn-d3d12-id3d12versionedrootsignaturedeserializer) interface is created to deserialize the root signature data structure.</span></span>

-   <span data-ttu-id="65d62-244">[**GetRootSignatureDescAtVersion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getrootsignaturedescatversion) : converte estruturas de descrição de assinatura raiz para uma versão solicitada.</span><span class="sxs-lookup"><span data-stu-id="65d62-244">[**GetRootSignatureDescAtVersion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getrootsignaturedescatversion) : converts root signature description structures to a requested version.</span></span>
-   <span data-ttu-id="65d62-245">[**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc) : retorna um ponteiro para uma [**estrutura \_ \_ \_ \_ desc de assinatura raiz D3D12 com controle de versão**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) .</span><span class="sxs-lookup"><span data-stu-id="65d62-245">[**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc) : returns a pointer to a [**D3D12\_VERSIONED\_ROOT\_SIGNATURE\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) structure.</span></span>

### <a name="helper-structures"></a><span data-ttu-id="65d62-246">Estruturas auxiliares</span><span class="sxs-lookup"><span data-stu-id="65d62-246">Helper structures</span></span>

<span data-ttu-id="65d62-247">Foram adicionadas estruturas auxiliares para auxiliar na inicialização de algumas das estruturas da versão 1,1.</span><span class="sxs-lookup"><span data-stu-id="65d62-247">Helper structures have been added to aid in the initialization of some of the version 1.1 structures.</span></span>

-   <span data-ttu-id="65d62-248">CD3DX12 \_ descritor \_ RANGE1</span><span class="sxs-lookup"><span data-stu-id="65d62-248">CD3DX12\_DESCRIPTOR\_RANGE1</span></span>
-   <span data-ttu-id="65d62-249">CD3DX12 \_ raiz \_ parâmetro1</span><span class="sxs-lookup"><span data-stu-id="65d62-249">CD3DX12\_ROOT\_PARAMETER1</span></span>
-   <span data-ttu-id="65d62-250">\_SAMPLER1 CD3DX12 static \_</span><span class="sxs-lookup"><span data-stu-id="65d62-250">CD3DX12\_STATIC\_SAMPLER1</span></span>
-   <span data-ttu-id="65d62-251">\_Desc. de \_ \_ assinatura raiz \_ CD3DX12 com versão</span><span class="sxs-lookup"><span data-stu-id="65d62-251">CD3DX12\_VERSIONED\_ROOT\_SIGNATURE\_DESC</span></span>

<span data-ttu-id="65d62-252">Consulte [estruturas auxiliares e funções para D3D12](helper-structures-and-functions-for-d3d12.md).</span><span class="sxs-lookup"><span data-stu-id="65d62-252">Refer to [Helper Structures and Functions for D3D12](helper-structures-and-functions-for-d3d12.md).</span></span>

## <a name="consequences-of-violating-static-ness-flags"></a><span data-ttu-id="65d62-253">Consequências de violar sinalizadores qualidade estáticos</span><span class="sxs-lookup"><span data-stu-id="65d62-253">Consequences of violating static-ness flags</span></span>

<span data-ttu-id="65d62-254">Os sinalizadores de descritor e de dados descritos acima (bem como os padrões implícitos pela ausência de sinalizadores específicos) definem uma promessa pelo aplicativo para o driver sobre como ele se comportará.</span><span class="sxs-lookup"><span data-stu-id="65d62-254">The descriptor and data flags described above (as well as the defaults implied by the absence of particular flags) define a promise by the application to the driver about how it is going to behave.</span></span> <span data-ttu-id="65d62-255">Se um aplicativo violar a promessa, esse é um comportamento inválido: os resultados são indefinido e podem ser diferentes entre drivers e hardware diferentes.</span><span class="sxs-lookup"><span data-stu-id="65d62-255">If an application violates the promise, this is invalid behavior: results are undefined and might be different across different drivers and hardware.</span></span>

<span data-ttu-id="65d62-256">A camada de depuração tem opções para validar que os aplicativos estão de acordo com suas promessas, incluindo as promessas padrão que vêm com o uso da Assinatura Raiz versão 1.1 sem definir nenhum sinalizador.</span><span class="sxs-lookup"><span data-stu-id="65d62-256">The debug layer has options for validating that applications honor their promises, including the default promises that come with using Root Signature version 1.1 without setting any flags.</span></span>

## <a name="version-management"></a><span data-ttu-id="65d62-257">Gerenciamento de versão</span><span class="sxs-lookup"><span data-stu-id="65d62-257">Version management</span></span>

<span data-ttu-id="65d62-258">Ao compilar assinaturas raiz anexadas a sombreadores, os compiladores HLSL mais novos terão como padrão compilar a assinatura raiz na versão 1.1, enquanto os compiladores HLSL antigos só darão suporte a 1.0.</span><span class="sxs-lookup"><span data-stu-id="65d62-258">When compiling root signatures attached to shaders, newer HLSL compilers will default to compiling the root signature at version 1.1, whereas old HLSL compilers only support 1.0.</span></span> <span data-ttu-id="65d62-259">Observe que as assinaturas raiz 1.1 não funcionarão em sos que não deem suporte à assinatura raiz 1.1.</span><span class="sxs-lookup"><span data-stu-id="65d62-259">Note that 1.1 root signatures will not work on OS’s that don’t support root signature 1.1.</span></span>

<span data-ttu-id="65d62-260">A versão de assinatura raiz compilada com um sombreador pode ser forçada a uma versão específica usando `/force_rootsig_ver <version>` .</span><span class="sxs-lookup"><span data-stu-id="65d62-260">The root signature version compiled with a shader can be forced to a particular version using `/force_rootsig_ver <version>`.</span></span> <span data-ttu-id="65d62-261">Forçar a versão terá êxito se o compilador puder preservar o comportamento da assinatura raiz que está sendo compilada na versão forçada, por exemplo, soltando sinalizadores sem suporte na assinatura raiz que servem apenas para fins de otimização, mas não afetam o comportamento.</span><span class="sxs-lookup"><span data-stu-id="65d62-261">Forcing the version will succeed if the compiler can preserve the behavior of the root signature being compiled at the forced version, for example by dropping unsupported flags in the root signature that serve only for optimization purposes but do not affect behavior.</span></span>

<span data-ttu-id="65d62-262">Dessa forma, um aplicativo pode, por exemplo, compilar uma assinatura raiz 1.1 para 1.0 e 1.1 ao compilar o aplicativo e selecionar a versão apropriada em runtime, dependendo do nível de suporte do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="65d62-262">This way an application can, for instance, compile a 1.1 root signature to both 1.0 and 1.1 when building the application and select the appropriate version at runtime depending on the level of OS support.</span></span> <span data-ttu-id="65d62-263">No entanto, seria mais eficiente o espaço para um aplicativo compilar assinaturas raiz individualmente (especialmente se várias versões são necessárias), separadamente dos sombreadores.</span><span class="sxs-lookup"><span data-stu-id="65d62-263">It would be most space efficient, however, for an application to compile root signatures individually (particularly if multiple versions are needed), separately from shaders.</span></span> <span data-ttu-id="65d62-264">Mesmo que os sombreadores não sejam compilados inicialmente com uma assinatura raiz anexada, o benefício da validação do compilador da compatibilidade de assinatura raiz com um sombreador pode ser preservado usando a opção `/verifyrootsignature` do compilador.</span><span class="sxs-lookup"><span data-stu-id="65d62-264">Even if shaders aren’t initially compiled with a root signature attached, the benefit of compiler validation of root signature compatibility with a shader can be preserved by using the `/verifyrootsignature` compiler option.</span></span> <span data-ttu-id="65d62-265">Posteriormente no runtime, os PSOs podem ser criados usando sombreadores que não têm assinaturas raiz neles ao passar a assinatura raiz desejada (talvez a versão apropriada com suporte pelo sistema operacional) como um parâmetro separado.</span><span class="sxs-lookup"><span data-stu-id="65d62-265">Later at runtime, PSOs can be created using shaders that don’t have root signatures in them while passing the desired root signature (perhaps the appropriate version supported by the OS) as a separate parameter.</span></span>

## <a name="related-topics"></a><span data-ttu-id="65d62-266">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="65d62-266">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="65d62-267">Como criar uma assinatura raiz</span><span class="sxs-lookup"><span data-stu-id="65d62-267">Creating a Root Signature</span></span>](creating-a-root-signature.md)
</dt> <dt>

[<span data-ttu-id="65d62-268">Assinaturas raiz</span><span class="sxs-lookup"><span data-stu-id="65d62-268">Root Signatures</span></span>](root-signatures.md)
</dt> <dt>

[<span data-ttu-id="65d62-269">Como especificar assinaturas raiz no HLSL</span><span class="sxs-lookup"><span data-stu-id="65d62-269">Specifying Root Signatures in HLSL</span></span>](specifying-root-signatures-in-hlsl.md)
</dt> </dl>

 

 




