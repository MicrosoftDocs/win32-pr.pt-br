---
title: Visão geral de heaps de descritores
description: Heaps de descritores contêm muitos tipos de objeto que não fazem parte de um PSO (objeto de estado de pipeline), como SRVs (exibições de recursos de sombreamento), UAVs (exibições de acesso não ordenado), CBVs (exibições de buffer de constantes) e amostras.
ms.assetid: 14561E77-44E0-4A58-8456-F40D59ECA175
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a8bf720ebb71d016457fa4383a8d33aa62e2eee4
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74103944"
---
# <a name="descriptor-heaps-overview"></a><span data-ttu-id="db9c3-103">Visão geral de heaps de descritores</span><span class="sxs-lookup"><span data-stu-id="db9c3-103">Descriptor Heaps Overview</span></span>

<span data-ttu-id="db9c3-104">Heaps de descritores contêm muitos tipos de objeto que não fazem parte de um PSO (objeto de estado de pipeline), como SRVs (exibições de recursos de sombreamento), UAVs (exibições de acesso não ordenado), CBVs (exibições de buffer de constantes) e amostras.</span><span class="sxs-lookup"><span data-stu-id="db9c3-104">Descriptor heaps contain many object types that are not part of a Pipeline State Object (PSO), such as Shader Resource Views (SRVs), Unordered Access Views (UAVs), Constant Buffer Views (CBVs), and Samplers.</span></span>

-   [<span data-ttu-id="db9c3-105">A finalidade dos heaps de descritor</span><span class="sxs-lookup"><span data-stu-id="db9c3-105">The Purpose of Descriptor Heaps</span></span>](#the-purpose-of-descriptor-heaps)
-   [<span data-ttu-id="db9c3-106">Sincronização</span><span class="sxs-lookup"><span data-stu-id="db9c3-106">Synchronization</span></span>](#synchronization)
-   [<span data-ttu-id="db9c3-107">Associação</span><span class="sxs-lookup"><span data-stu-id="db9c3-107">Binding</span></span>](#binding)
-   [<span data-ttu-id="db9c3-108">Alternando heaps</span><span class="sxs-lookup"><span data-stu-id="db9c3-108">Switching heaps</span></span>](#switching-heaps)
-   [<span data-ttu-id="db9c3-109">Pacotes</span><span class="sxs-lookup"><span data-stu-id="db9c3-109">Bundles</span></span>](#bundles)
-   [<span data-ttu-id="db9c3-110">Gerenciamento</span><span class="sxs-lookup"><span data-stu-id="db9c3-110">Management</span></span>](#management)
-   [<span data-ttu-id="db9c3-111">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="db9c3-111">Related topics</span></span>](#related-topics)

## <a name="the-purpose-of-descriptor-heaps"></a><span data-ttu-id="db9c3-112">A finalidade dos heaps de descritor</span><span class="sxs-lookup"><span data-stu-id="db9c3-112">The Purpose of Descriptor Heaps</span></span>

<span data-ttu-id="db9c3-113">A principal finalidade de um heap de descritor é abranger a quantidade de alocação de memória necessária para armazenar as especificações de descritor dos tipos de objetos que os sombreadores fazem referência para o maior número possível de uma janela de renderização (idealmente um quadro inteiro de renderização ou mais).</span><span class="sxs-lookup"><span data-stu-id="db9c3-113">The primary purpose of a descriptor heap is to encompass the bulk of memory allocation required for storing the descriptor specifications of object types that shaders reference for as large of a window of rendering as possible (ideally an entire frame of rendering or more).</span></span> <span data-ttu-id="db9c3-114">Se um aplicativo estiver alternando as texturas que o pipeline vê rapidamente da API, precisa haver espaço na pilha do descritor para definir tabelas de descritores em tempo real para cada conjunto de estado necessário.</span><span class="sxs-lookup"><span data-stu-id="db9c3-114">If an application is switching which textures the pipeline sees rapidly from the API, there has to be space in the descriptor heap to define descriptor tables on the fly for every set of state needed.</span></span> <span data-ttu-id="db9c3-115">O aplicativo pode optar por reutilizar as definições se os recursos forem usados novamente em outro objeto, por exemplo, ou apenas atribuir o espaço de heap sequencialmente, pois ele alterna vários tipos de objeto.</span><span class="sxs-lookup"><span data-stu-id="db9c3-115">The application can choose to reuse definitions if the resources are used again in another object, for example, or just assign the heap space sequentially as it switches various object types.</span></span>

<span data-ttu-id="db9c3-116">Os heaps de descritores também permitem que componentes de software individuais gerenciem o armazenamento do descritor separadamente um do outro.</span><span class="sxs-lookup"><span data-stu-id="db9c3-116">Descriptor heaps also allow individual software components to manage descriptor storage separately from each other.</span></span>

<span data-ttu-id="db9c3-117">Todos os heaps são visíveis para a CPU.</span><span class="sxs-lookup"><span data-stu-id="db9c3-117">All heaps are visible to the CPU.</span></span> <span data-ttu-id="db9c3-118">O aplicativo também pode solicitar quais propriedades de acesso da CPU um heap de descritor deve ter (se houver) – gravar combinado, gravar novamente e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="db9c3-118">The application can also request which CPU access properties a descriptor heap should have (if any) – write combined, write back, and so on.</span></span> <span data-ttu-id="db9c3-119">Os aplicativos podem criar quantos heaps de descritor forem desejados com quaisquer propriedades desejadas.</span><span class="sxs-lookup"><span data-stu-id="db9c3-119">Apps can create as many descriptor heaps as desired with whatever properties are desired.</span></span> <span data-ttu-id="db9c3-120">Os aplicativos sempre têm a opção de criar heaps de descritores que são puramente para fins de preparo que não são restringidos em tamanho e copiando para heaps de descritores que são usados para renderização conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="db9c3-120">Apps always have the option to create descriptor heaps that are purely for staging purposes that are unconstrained in size, and copying to descriptor heaps that are used for rendering as necessary.</span></span>

<span data-ttu-id="db9c3-121">Há algumas restrições no que pode ir no mesmo heap de descritor.</span><span class="sxs-lookup"><span data-stu-id="db9c3-121">There are some restrictions in what can go in the same descriptor heap.</span></span> <span data-ttu-id="db9c3-122">As entradas CBV, UAV e SRV podem estar no mesmo heap de descritor.</span><span class="sxs-lookup"><span data-stu-id="db9c3-122">CBV, UAV and SRV entries can be in the same descriptor heap.</span></span> <span data-ttu-id="db9c3-123">No entanto, as entradas de amostra não podem compartilhar um heap com entradas CBV, UAV ou SRV.</span><span class="sxs-lookup"><span data-stu-id="db9c3-123">However, Samplers entries cannot share a heap with CBV, UAV or SRV entries.</span></span> <span data-ttu-id="db9c3-124">Normalmente, há dois conjuntos de heaps de descritores, um para os recursos comuns e o segundo para amostras.</span><span class="sxs-lookup"><span data-stu-id="db9c3-124">Typically, there are two sets of descriptor heaps, one for the common resources and the second for Samplers.</span></span>

<span data-ttu-id="db9c3-125">O uso de heaps de descritores por Direct3D 12 reflete o que a maioria dos hardwares de GPU faz, o que deve exigir que os descritores estejam em tempo real apenas em heaps de descritor ou simplesmente que menos bits de endereçamento sejam necessários se esses heaps forem usados.</span><span class="sxs-lookup"><span data-stu-id="db9c3-125">The use of descriptor heaps by Direct3D 12 mirrors what most GPU hardware does, which is to either require descriptors live only in descriptor heaps, or simply that fewer addressing bits are needed if these heaps are used.</span></span> <span data-ttu-id="db9c3-126">O Direct3D 12 exige o uso de heaps de descritores, não há nenhuma opção para colocar descritores em qualquer lugar na memória.</span><span class="sxs-lookup"><span data-stu-id="db9c3-126">Direct3D 12 does require the use of descriptor heaps, there is no option to put descriptors anywhere in memory.</span></span>

<span data-ttu-id="db9c3-127">Os heaps de descritores só podem ser editados imediatamente pela CPU, não há nenhuma opção para editar um heap de descritor pela GPU.</span><span class="sxs-lookup"><span data-stu-id="db9c3-127">Descriptor heaps can only be edited immediately by the CPU, there is no option to edit a descriptor heap by the GPU.</span></span>

## <a name="synchronization"></a><span data-ttu-id="db9c3-128">Sincronização</span><span class="sxs-lookup"><span data-stu-id="db9c3-128">Synchronization</span></span>

<span data-ttu-id="db9c3-129">O conteúdo do heap do descritor pode ser alterado antes, durante e após a gravação de listas de comandos que fazem referência a ele.</span><span class="sxs-lookup"><span data-stu-id="db9c3-129">Descriptor heap contents can be changed before, during and after recording command lists that reference it.</span></span> <span data-ttu-id="db9c3-130">No entanto, os descritores não podem ser alterados enquanto uma lista de comandos enviada para execução pode fazer referência a esse local, pois isso poderia invocar uma condição de corrida.</span><span class="sxs-lookup"><span data-stu-id="db9c3-130">However, descriptors cannot be changed while a command list submitted for execution might reference that location, as this could invoke a race condition.</span></span>

## <a name="binding"></a><span data-ttu-id="db9c3-131">Associação</span><span class="sxs-lookup"><span data-stu-id="db9c3-131">Binding</span></span>

<span data-ttu-id="db9c3-132">No máximo um heap combinado CBV/SRV/UAV e um heap de amostra podem ser associados a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="db9c3-132">At most one CBV/SRV/UAV combined heap and one Sampler heap can be bound at any one time.</span></span> <span data-ttu-id="db9c3-133">Esses heaps são compartilhados entre os pipelines de computação e de gráficos (descritos em seus PSOs).</span><span class="sxs-lookup"><span data-stu-id="db9c3-133">These heaps are shared between both the graphics and compute pipelines (described in their PSOs).</span></span>

## <a name="switching-heaps"></a><span data-ttu-id="db9c3-134">Alternando heaps</span><span class="sxs-lookup"><span data-stu-id="db9c3-134">Switching heaps</span></span>

<span data-ttu-id="db9c3-135">É aceitável que um aplicativo alterne heaps dentro da mesma lista de comandos ou em diferentes, usando as APIs [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) e [**Reset**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) .</span><span class="sxs-lookup"><span data-stu-id="db9c3-135">It is acceptable for an application to switch heaps within the same command list or in different ones using the [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) and [**Reset**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) APIs.</span></span> <span data-ttu-id="db9c3-136">Em alguns hardwares, isso pode ser uma operação cara, exigindo uma parada de GPU para liberar todo o trabalho que depende do heap de descritor associado no momento.</span><span class="sxs-lookup"><span data-stu-id="db9c3-136">On some hardware, this can be an expensive operation, requiring a GPU stall to flush all work that depends on the currently bound descriptor heap.</span></span> <span data-ttu-id="db9c3-137">Como resultado, se os heaps do descritor tiverem que ser alterados, os aplicativos devem tentar fazer isso quando a carga de trabalho da GPU for relativamente clara, talvez limitando as alterações no início de uma lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="db9c3-137">As a result, if descriptor heaps must be changed, applications should try to do so when the GPU workload is relatively light, perhaps limiting changes to the start of a command list.</span></span>

## <a name="bundles"></a><span data-ttu-id="db9c3-138">Pacotes</span><span class="sxs-lookup"><span data-stu-id="db9c3-138">Bundles</span></span>

<span data-ttu-id="db9c3-139">Com os pacotes, só pode haver uma chamada para o método [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) , e o conjunto de heaps do descritor deve corresponder exatamente àqueles da lista de comandos que chamam o pacote.</span><span class="sxs-lookup"><span data-stu-id="db9c3-139">With bundles there can only be one call to the [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) method, and the descriptor heaps set must match exactly those of the command list calling the bundle.</span></span> <span data-ttu-id="db9c3-140">Se o pacote não alterar tabelas de descritor, ele não precisará definir os heaps de descritor.</span><span class="sxs-lookup"><span data-stu-id="db9c3-140">If the bundle does not change descriptor tables, it does not need to set the descriptor heaps.</span></span>

<span data-ttu-id="db9c3-141">Para obter uma lista de chamadas de API que não podem ser usadas com grupos, consulte [criando e gravando listas de comandos e pacotes](recording-command-lists-and-bundles.md).</span><span class="sxs-lookup"><span data-stu-id="db9c3-141">For a list of API calls that cannot be used with bundles, refer to [Creating and Recording Command Lists and Bundles](recording-command-lists-and-bundles.md).</span></span>

## <a name="management"></a><span data-ttu-id="db9c3-142">Gerenciamento</span><span class="sxs-lookup"><span data-stu-id="db9c3-142">Management</span></span>

<span data-ttu-id="db9c3-143">Para renderizar todos os objetos em uma cena, muitos descritores serão necessários e há algumas estratégias de gerenciamento diferentes que podem ser seguidas.</span><span class="sxs-lookup"><span data-stu-id="db9c3-143">To render all of the objects in a scene, many descriptors will be needed, and there are some different management strategies that can be followed.</span></span>

<span data-ttu-id="db9c3-144">A estratégia mais básica seria preencher uma área atualizada do heap de descritores com todos os requisitos para a próxima chamada de desenho.</span><span class="sxs-lookup"><span data-stu-id="db9c3-144">The most basic strategy would be to fill in a fresh area of the descriptor heap with all of the requirements for the next draw call.</span></span> <span data-ttu-id="db9c3-145">Portanto, logo antes de emitir a chamada de desenho na lista de comandos, um ponteiro de tabela de descritores seria definido como o início da tabela populada recentemente.</span><span class="sxs-lookup"><span data-stu-id="db9c3-145">So, just before issuing the draw call on the command list, a descriptor table pointer would be set to the start of the freshly populated table.</span></span> <span data-ttu-id="db9c3-146">A vantagem é que não há necessidade de registrar onde qualquer descritor específico está no heap.</span><span class="sxs-lookup"><span data-stu-id="db9c3-146">The upside is that there is no need to record where any particular descriptor is in the heap.</span></span>

<span data-ttu-id="db9c3-147">A desvantagem dessa estratégia é que pode haver muita repetição de descritores no heap de descrição, especialmente quando uma cena muito semelhante está sendo renderizada e esse espaço de heap de descritor será usado rapidamente.</span><span class="sxs-lookup"><span data-stu-id="db9c3-147">The downside to this strategy is that there could be a lot of repetition of descriptors in the descriptor heap, especially when a very similar scene is being rendered, and that descriptor heap space is going to be used up quickly.</span></span> <span data-ttu-id="db9c3-148">Heaps de descritores separados para aqueles que estão sendo processados na GPU e para aqueles que estão sendo gravados pela CPU provavelmente seriam necessários para evitar conflitos.</span><span class="sxs-lookup"><span data-stu-id="db9c3-148">Separate descriptor heaps for those being rendered on the GPU and for those being recorded by the CPU, would probably be necessary to avoid conflict.</span></span> <span data-ttu-id="db9c3-149">Como alternativa, um sistema de subalocação pode ser usado.</span><span class="sxs-lookup"><span data-stu-id="db9c3-149">Alternatively a sub-allocation system could be used.</span></span>

<span data-ttu-id="db9c3-150">Além disso, o sistema básico pode ser mais otimizado pelo uso cuidadoso de tabelas de descritores sobrepostas de uma chamada de desenho para a próxima, para que apenas os novos descritores necessários sejam adicionados.</span><span class="sxs-lookup"><span data-stu-id="db9c3-150">Also, the basic system could be further optimized by careful use of overlapping descriptor tables from one draw call to the next, so that only the new descriptors required are added.</span></span>

<span data-ttu-id="db9c3-151">Uma estratégia mais eficiente do que a básica seria preencher previamente os heaps de descritores com os descritores necessários para os objetos (ou materiais) que são conhecidos como parte da cena.</span><span class="sxs-lookup"><span data-stu-id="db9c3-151">A more efficient strategy than the basic one would be to pre-fill descriptor heaps with descriptors required for the objects (or materials) that are known to be part of the scene.</span></span> <span data-ttu-id="db9c3-152">A ideia aqui é que só é necessário definir a tabela de descritores no momento do desenho, pois o heap do descritor é preenchido antecipadamente.</span><span class="sxs-lookup"><span data-stu-id="db9c3-152">The idea here is that it is only necessary to set the descriptor table at draw time, as the descriptor heap is populated ahead of time.</span></span>

<span data-ttu-id="db9c3-153">Uma variação da estratégia de pré-teste é tratar o heap do descritor como uma matriz enorme, contendo todos os descritores necessários em locais conhecidos fixos.</span><span class="sxs-lookup"><span data-stu-id="db9c3-153">A variation of the pre-filling strategy is to treat the descriptor heap as one huge array, containing all the required descriptors in fixed known locations.</span></span> <span data-ttu-id="db9c3-154">Em seguida, a chamada de desenho precisa apenas receber um conjunto de constantes que são os índices na matriz de onde os descritores precisam ser usados.</span><span class="sxs-lookup"><span data-stu-id="db9c3-154">Then the draw call needs only to receive a set of constants which are the indices into the array of where the descriptors are that need to be used.</span></span>

<span data-ttu-id="db9c3-155">Uma otimização adicional é garantir que as constantes raiz e os descritores de raiz contenham as que são alteradas com mais frequência, em vez de posicionar constantes no heap do descritor.</span><span class="sxs-lookup"><span data-stu-id="db9c3-155">A further optimization is to ensure root constants and root descriptors contain those that change most frequently, rather than place constants in the descriptor heap.</span></span> <span data-ttu-id="db9c3-156">Para a maioria dos hardwares, essa é uma maneira eficiente de lidar com constantes.</span><span class="sxs-lookup"><span data-stu-id="db9c3-156">For most hardware this is an efficient way of handling constants.</span></span>

<span data-ttu-id="db9c3-157">Na prática, um mecanismo de gráficos pode usar uma estratégia diferente em situações diferentes e combinar elementos de cada estratégia para atender aos requisitos de desenho específicos.</span><span class="sxs-lookup"><span data-stu-id="db9c3-157">In practice a graphics engine might use a different strategy in different situations, and combine elements of each strategy to suit the particular drawing requirements.</span></span>

## <a name="related-topics"></a><span data-ttu-id="db9c3-158">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="db9c3-158">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="db9c3-159">Heaps de descritores</span><span class="sxs-lookup"><span data-stu-id="db9c3-159">Descriptor Heaps</span></span>](descriptor-heaps.md)
</dt> </dl>

 

 




