---
title: Uso avançado de tabelas de descritores
description: As seções a seguir fornecem informações sobre o uso avançado de tabelas de descritores.
ms.assetid: BB0CA29C-65CB-48B1-8351-EE13CC470B54
ms.date: 05/31/2018
ms.localizationpriority: high
ms.topic: article
ms.openlocfilehash: 79dad6914cff07726c2d40ed2ee27cccb6a0cf1e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74103854"
---
# <a name="advanced-use-of-descriptor-tables"></a><span data-ttu-id="36454-103">Uso avançado de tabelas de descritores</span><span class="sxs-lookup"><span data-stu-id="36454-103">Advanced use of Descriptor Tables</span></span>

<span data-ttu-id="36454-104">As seções a seguir fornecem informações sobre o uso avançado de tabelas de descritores.</span><span class="sxs-lookup"><span data-stu-id="36454-104">The following sections provide information about the advanced use of descriptor tables.</span></span>

-   [<span data-ttu-id="36454-105">Alterando as entradas da tabela de descritores entre chamadas de renderização</span><span class="sxs-lookup"><span data-stu-id="36454-105">Changing Descriptor Table Entries between Rendering Calls</span></span>](#changing-descriptor-table-entries-between-rendering-calls)
-   [<span data-ttu-id="36454-106">Indexação fora de limites</span><span class="sxs-lookup"><span data-stu-id="36454-106">Out of Bounds Indexing</span></span>](#out-of-bounds-indexing)
-   [<span data-ttu-id="36454-107">Derivações de sombreador e indexação divergente</span><span class="sxs-lookup"><span data-stu-id="36454-107">Shader Derivatives and Divergent Indexing</span></span>](#shader-derivatives-and-divergent-indexing)
-   [<span data-ttu-id="36454-108">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="36454-108">Related topics</span></span>](#related-topics)

## <a name="changing-descriptor-table-entries-between-rendering-calls"></a><span data-ttu-id="36454-109">Alterando as entradas da tabela de descritores entre chamadas de renderização</span><span class="sxs-lookup"><span data-stu-id="36454-109">Changing Descriptor Table Entries between Rendering Calls</span></span>

<span data-ttu-id="36454-110">Depois que as listas de comandos que definem tabelas de descritores foram enviadas para uma fila para execução, o aplicativo não deve editar da CPU as partes dos heaps de descritores que a GPU pode referenciar até que o aplicativo saiba que a GPU terminou de usar as referências.</span><span class="sxs-lookup"><span data-stu-id="36454-110">After command lists that set descriptor tables have been submitted to a queue for execution, the application must not edit from the CPU the portions of descriptor heaps that the GPU might reference until the application knows that the GPU has finished using the references.</span></span>

<span data-ttu-id="36454-111">A conclusão do trabalho pode ser determinada em um limite rígido usando limites de API para acompanhar o progresso da GPU, ou mecanismos mais grossos como aguardar para ver que a renderização foi enviada para exibição, o que for adequado para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="36454-111">Work completion can be determined at a tight bound using API fences for tracking GPU progress, or more coarse mechanisms like waiting to see that rendering has been sent to display - whatever suits the application.</span></span> <span data-ttu-id="36454-112">Se um aplicativo sabe que apenas um subconjunto da região que uma tabela de descritores apontará será acessado (digamos devido ao controle de fluxo no sombreador), os outros descritores não referenciados ainda estão livres para serem alterados.</span><span class="sxs-lookup"><span data-stu-id="36454-112">If an application knows that only a subset of the region a descriptor table points to will be accessed (say due to flow control in the shader), the other unreferenced descriptors are still free to be changed.</span></span> <span data-ttu-id="36454-113">Se um aplicativo precisar alternar entre diferentes tabelas de descritores entre chamadas de renderização, há algumas abordagens entre as quais o aplicativo pode escolher:</span><span class="sxs-lookup"><span data-stu-id="36454-113">If an application needs to switch between different descriptor tables between rendering calls, there are a few approaches the application can choose from:</span></span>

-   <span data-ttu-id="36454-114">Controle de versão de tabela de descritor: crie (ou reutilize) uma tabela de descritor separada para cada coleção exclusiva de descripdores que deve ser referenciada por uma lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="36454-114">Descriptor Table Versioning: Create (or reuse) a separate descriptor table for every unique collection of descriptors that is to be referenced by a command list.</span></span> <span data-ttu-id="36454-115">Ao editar e reutilizar áreas previamente populadas em heaps de descritor, os aplicativos devem primeiro garantir que a GPU tenha terminado de usar qualquer parte de um heap de descritor que será reciclado.</span><span class="sxs-lookup"><span data-stu-id="36454-115">When editing and reusing previously populated areas on descriptor heaps, applications must first ensure that the GPU has finished using any portion of a descriptor heap that will be recycled.</span></span>
-   <span data-ttu-id="36454-116">Indexação dinâmica: os aplicativos podem organizar objetos que variam de acordo com o empate/expedição (ou até mesmo variam em um empate) em um intervalo de heap de descritores, definem uma tabela de descritores que abrange todos eles e, do sombreador, usam a indexação dinâmica da tabela durante a execução do sombreador para selecionar qual objeto usar.</span><span class="sxs-lookup"><span data-stu-id="36454-116">Dynamic Indexing: Applications can arrange objects that vary across draw/dispatch (or even vary within a draw) in a range of a descriptor heap, define a descriptor table that spans all of them, and from the shader, use dynamic indexing of the table during shader execution to select which object to use.</span></span>
-   <span data-ttu-id="36454-117">Colocando descritores na assinatura raiz diretamente.</span><span class="sxs-lookup"><span data-stu-id="36454-117">Putting descriptors in the root signature directly.</span></span> <span data-ttu-id="36454-118">Apenas um número muito pequeno de descritores pode ser gerenciado dessa forma porque o espaço de assinatura raiz é limitado.</span><span class="sxs-lookup"><span data-stu-id="36454-118">Only a very small number of descriptors can be managed this way because root signature space is limited.</span></span>

<span data-ttu-id="36454-119">A implicação de usar o controle de versão de tabela de descritor é que a memória do descritor fora de um heap de descritor deve ser gravada para cada conjunto exclusivo de descripdores referenciados pelo pipeline de gráficos para cada lista de comandos que pode estar em execução, na fila para execução ou ser gravada em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="36454-119">The implication of using descriptor table versioning is that descriptor memory out of a descriptor heap must be burned through for every unique set of descriptors referenced by the graphics pipeline for every command list that could be either executing, queued for execution, or being recorded at any given time.</span></span>

<span data-ttu-id="36454-120">D3D12 deixa a responsabilidade de gerenciar o controle de versão para o aplicativo para os tipos de objeto gerenciados por meio de heaps de descritor e tabelas de descritores.</span><span class="sxs-lookup"><span data-stu-id="36454-120">D3D12 leaves the responsibility of managing versioning to the application for the object types managed via descriptor heaps and descriptor tables.</span></span> <span data-ttu-id="36454-121">Um dos benefícios disso é que os aplicativos podem optar por reutilizar o conteúdo da tabela do descritor o máximo possível, em vez de sempre definir uma nova versão da tabela de descritores para cada envio da lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="36454-121">One benefit of this is that applications can choose to reuse descriptor table contents as much as possible rather than always defining a new descriptor table version for every command list submission.</span></span> <span data-ttu-id="36454-122">A assinatura raiz é um espaço que o driver D3D12 automaticamente versões.</span><span class="sxs-lookup"><span data-stu-id="36454-122">The root signature is a space that the D3D12 driver automatically versions.</span></span>

<span data-ttu-id="36454-123">A capacidade de associar várias tabelas de descritores à assinatura raiz (e, assim, ao pipeline) de cada vez permite que os aplicativos agrupem e alternem conjuntos de referências de descritores em frequências diferentes, se desejado.</span><span class="sxs-lookup"><span data-stu-id="36454-123">The ability to bind multiple descriptor tables to the root signature (and thus to the pipeline) at a time allows applications to group and switch sets of descriptor references at different frequencies if desired.</span></span> <span data-ttu-id="36454-124">Por exemplo, um aplicativo pode usar um pequeno número (talvez apenas um) de grandes tabelas de descritores estáticos que raramente mudam ou em quais regiões na memória heap do descritor subjacente estão sendo populadas conforme necessário, com o uso de indexação dinâmica do sombreador para selecionar texturas.</span><span class="sxs-lookup"><span data-stu-id="36454-124">For example, an application could use a small number (perhaps just one) of large static descriptor tables that rarely change, or in which regions in the underlying descriptor heap memory are being populated as needed, with the use of dynamic indexing from the shader to select textures.</span></span> <span data-ttu-id="36454-125">Ao mesmo tempo, o aplicativo pode manter outra classe de recursos em que o conjunto referenciado por cada chamada de desenho é alternado da CPU usando a técnica de controle de versão da tabela de descritores.</span><span class="sxs-lookup"><span data-stu-id="36454-125">At the same time, the application could maintain another class of resources where the set referenced by each draw call is switched from the CPU using the descriptor table versioning technique.</span></span>

## <a name="out-of-bounds-indexing"></a><span data-ttu-id="36454-126">Indexação fora de limites</span><span class="sxs-lookup"><span data-stu-id="36454-126">Out of Bounds Indexing</span></span>

<span data-ttu-id="36454-127">A indexação fora dos limites de qualquer tabela de descritores do sombreador resulta em um acesso de memória amplamente indefinido, incluindo a possibilidade de ler memória arbitrária em processo como se fosse um descritor de estado de hardware e viver com a conseqüência do que o hardware faz com ele.</span><span class="sxs-lookup"><span data-stu-id="36454-127">Out of bounds indexing of any descriptor table from the shader results in a largely undefined memory access, including the possibility of reading arbitrary in-process memory as if it is a hardware state descriptor and living with the consequence of what the hardware does with that.</span></span> <span data-ttu-id="36454-128">Isso pode produzir uma redefinição de dispositivo, mas não causará falhas no Windows.</span><span class="sxs-lookup"><span data-stu-id="36454-128">This could produce a device reset, but will not crash Windows.</span></span>

## <a name="shader-derivatives-and-divergent-indexing"></a><span data-ttu-id="36454-129">Derivações de sombreador e indexação divergente</span><span class="sxs-lookup"><span data-stu-id="36454-129">Shader Derivatives and Divergent Indexing</span></span>

<span data-ttu-id="36454-130">Se invocações de sombreador de pixel que estão sendo executadas em um carimbo 2x2 (para dar suporte a cálculos derivados), escolha índices de textura diferentes para amostrar de uma tabela de descritor e, se a configuração de amostra e a textura selecionadas para qualquer pixel especificado exigir um cálculo de LOD de derivações de coordenadas de textura, o processo de amostragem de LOD e de textura será feito pelo hardware , o que afetará o desempenho.</span><span class="sxs-lookup"><span data-stu-id="36454-130">If pixel shader invocations that are executing in a 2x2 stamp (to support derivative calculations) choose different texture indices to sample from out of a descriptor table, and if the selected sampler configuration and texture for any given pixel requires an LOD calculation from texture coordinate derivatives, then the LOD calculation and texture sampling process is done by the hardware independently for each texture lookup in the 2x2 stamp, which will impact performance.</span></span>

## <a name="related-topics"></a><span data-ttu-id="36454-131">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="36454-131">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="36454-132">Tabelas de descritores</span><span class="sxs-lookup"><span data-stu-id="36454-132">Descriptor Tables</span></span>](descriptor-tables.md)
</dt> </dl>

 

 




