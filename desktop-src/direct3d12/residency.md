---
title: Residência
description: Um objeto é considerado residente quando ele é acessível pela GPU.
ms.assetid: 956F80D7-EEC8-4D88-B251-EE325614F31E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6b842ce5b3e89c3877f50036e747a90f14104bce
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548282"
---
# <a name="residency"></a><span data-ttu-id="8c0d5-103">Residência</span><span class="sxs-lookup"><span data-stu-id="8c0d5-103">Residency</span></span>

<span data-ttu-id="8c0d5-104">Um objeto é considerado *residente* quando ele é acessível pela GPU.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-104">An object is considered to be *resident* when it is accessible by the GPU.</span></span>

-   [<span data-ttu-id="8c0d5-105">Orçamento de residência</span><span class="sxs-lookup"><span data-stu-id="8c0d5-105">Residency budget</span></span>](#residency-budget)
-   [<span data-ttu-id="8c0d5-106">Recursos de heap</span><span class="sxs-lookup"><span data-stu-id="8c0d5-106">Heap resources</span></span>](#heap-resources)
-   [<span data-ttu-id="8c0d5-107">Prioridades de residência</span><span class="sxs-lookup"><span data-stu-id="8c0d5-107">Residency priorities</span></span>](#residency-priorities)
    -   [<span data-ttu-id="8c0d5-108">Algoritmo de prioridade padrão</span><span class="sxs-lookup"><span data-stu-id="8c0d5-108">Default priority algorithm</span></span>](#default-priority-algorithm)
-   [<span data-ttu-id="8c0d5-109">Gerenciamento de residência de programação</span><span class="sxs-lookup"><span data-stu-id="8c0d5-109">Programming residency management</span></span>](#programming-residency-management)
-   [<span data-ttu-id="8c0d5-110">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="8c0d5-110">Related topics</span></span>](#related-topics)

## <a name="residency-budget"></a><span data-ttu-id="8c0d5-111">Orçamento de residência</span><span class="sxs-lookup"><span data-stu-id="8c0d5-111">Residency budget</span></span>

<span data-ttu-id="8c0d5-112">As GPUs ainda não dão suporte à falha de página, portanto, os aplicativos devem confirmar dados na memória física enquanto a GPU puder acessá-la.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-112">GPUs do not yet support page-faulting, so applications must commit data into physical memory while the GPU could access it.</span></span> <span data-ttu-id="8c0d5-113">Esse processo é conhecido como "tornar algo residente" e deve ser feito para a memória física do sistema e para a memória de vídeo discreta física.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-113">This process is known as “making something resident”, and must be done for both physical system memory and physical discrete video memory.</span></span> <span data-ttu-id="8c0d5-114">No D3D12, a maioria dos objetos de API encapsula uma quantidade de memória acessível por GPU.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-114">In D3D12, most API objects encapsulate some amount of GPU-accessible memory.</span></span> <span data-ttu-id="8c0d5-115">Essa memória acessível por GPU é tornada residente durante a criação do objeto de API e removida na destruição de objeto de API.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-115">That GPU-accessible memory is made resident during the creation of the API object, and evicted on API object destruction.</span></span>

<span data-ttu-id="8c0d5-116">A quantidade de memória física disponível para o processo é conhecida como o orçamento de memória de vídeo.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-116">The amount of physical memory available for the process is known as the video memory budget.</span></span> <span data-ttu-id="8c0d5-117">O orçamento pode flutuar visivelmente enquanto os processos em segundo plano são ativados e suspensos; e flutuar drasticamente quando o usuário mudar para outro aplicativo.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-117">The budget can fluctuate noticeably as background processes wake-up and sleep; and fluctuate dramatically when the user switches away to another application.</span></span> <span data-ttu-id="8c0d5-118">O aplicativo pode ser notificado quando o orçamento for alterado e sondar o orçamento atual e a quantidade de memória consumida atualmente.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-118">The application can be notified when the budget changes and poll both the current budget and the currently consumed amount of memory.</span></span> <span data-ttu-id="8c0d5-119">Se um aplicativo não permanecer dentro de seu orçamento, o processo será congelado intermitentemente para permitir que outros aplicativos sejam executados e/ou as APIs de criação retornarão uma falha.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-119">If an application doesn’t stay within its budget, the process will be intermittently frozen to allow other applications to run and/or the creation APIs will return failure.</span></span> <span data-ttu-id="8c0d5-120">A interface [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) fornece os métodos que pertencem a essa funcionalidade, em particular [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) e [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span><span class="sxs-lookup"><span data-stu-id="8c0d5-120">The [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) interface provides the methods pertaining to this functionality, in particular [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) and [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span></span>

<span data-ttu-id="8c0d5-121">Os aplicativos são incentivados a usar uma reserva para denotar a quantidade de memória que não podem ir sem.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-121">Applications are encouraged to use a reservation to denote the amount of memory they cannot go without.</span></span> <span data-ttu-id="8c0d5-122">Idealmente, as configurações de gráficos "baixas" especificadas pelo usuário, ou algo ainda menor, são o valor certo para tal reserva.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-122">Ideally, the user-specified “low” graphics settings, or something even lower, is the right value for such a reservation.</span></span> <span data-ttu-id="8c0d5-123">A definição de uma reserva nunca proporcionará a um aplicativo um orçamento mais alto do que normalmente seria recebido.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-123">Setting a reservation won’t ever give an application a higher budget than it would normally receive.</span></span> <span data-ttu-id="8c0d5-124">Em vez disso, as informações de reserva ajudam o kernel do sistema operacional a minimizar rapidamente o impacto de grandes situações de pressão de memória.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-124">Instead, the reservation information helps the OS kernel quickly minimize the impact of large memory pressure situations.</span></span> <span data-ttu-id="8c0d5-125">Até mesmo a reserva não tem garantia de estar disponível para o aplicativo quando o aplicativo não é o aplicativo em primeiro plano.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-125">Even the reservation is not guaranteed to be available to the application when the application isn’t the foreground application.</span></span>

## <a name="heap-resources"></a><span data-ttu-id="8c0d5-126">Recursos de heap</span><span class="sxs-lookup"><span data-stu-id="8c0d5-126">Heap resources</span></span>

<span data-ttu-id="8c0d5-127">Embora muitos objetos de API encapsulam alguma memória acessível por GPU, os heaps & recursos devem ser a maneira mais significativa que os aplicativos consomem e gerenciam a memória física.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-127">While many API objects encapsulate some GPU-accessible memory, heaps & resources are expected to be the most significant way applications consume and manage physical memory.</span></span> <span data-ttu-id="8c0d5-128">Um heap é a unidade de nível mais baixa para gerenciar a memória física, portanto, é bom ter alguma familiaridade com suas propriedades de residência.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-128">A heap is the lowest level unit to manage physical memory, so it’s good to have some familiarity with their residency properties.</span></span>

-   <span data-ttu-id="8c0d5-129">Os heaps não podem se tornar parcialmente residentes, mas existem soluções reservadas com recursos reservados.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-129">Heaps cannot be made partially resident, but workarounds exists with reserved resources.</span></span>
-   <span data-ttu-id="8c0d5-130">Os heaps devem ser orçados como parte de um determinado pool.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-130">Heaps should be budgeted as part of a particular pool.</span></span> <span data-ttu-id="8c0d5-131">Os adaptadores de uma têm um pool, enquanto os adaptadores discretos têm dois pools.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-131">UMA adapters have one pool, while discrete adapters have two pools.</span></span> <span data-ttu-id="8c0d5-132">Embora seja verdade que o kernel possa deslocar alguns heaps em adaptadores discretos da memória de vídeo para a memória do sistema, ele só faz isso como um último recurso extremo.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-132">While it is true that kernel can shift some heaps on discrete adapters from video memory to system memory, it does so only as an extreme last resort.</span></span> <span data-ttu-id="8c0d5-133">Os aplicativos não devem depender do comportamento de orçamento excedente do kernel e devem se concentrar em um bom gerenciamento de orçamento em vez disso.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-133">Applications should not rely on the over-budget behavior of the kernel, and should focus on good budget management instead.</span></span>
-   <span data-ttu-id="8c0d5-134">Os heaps podem ser removidos da residência, o que permite que seu conteúdo seja paginado para o disco.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-134">Heaps can be evicted from residency, which allows their content to be paged out to disk.</span></span> <span data-ttu-id="8c0d5-135">Mas, a destruição de heaps é uma técnica mais confiável para liberar residências em todas as arquiteturas de adaptadores.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-135">But, destruction of heaps is a more reliable technique to free up residency across all adapter architectures.</span></span> <span data-ttu-id="8c0d5-136">Em adaptadores em que o campo *theMaxGPUVirtualAddressBitsPerProcess* do [**\_ \_ \_ \_ \_ \_ suporte de endereço virtual de GPU de dados de recurso D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) está próximo do tamanho do orçamento, a [**remoção**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) não recuperará de forma confiável a residência.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-136">On adapters where *theMaxGPUVirtualAddressBitsPerProcess* field of [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) is near the budget size, [**Evict**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) won’t reliably reclaim residency.</span></span>
-   <span data-ttu-id="8c0d5-137">A criação de heap pode ser lenta; Mas é otimizado para processamento de thread em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-137">Heap creation can be slow; but it is optimized for background thread processing.</span></span> <span data-ttu-id="8c0d5-138">É recomendável criar heaps em threads em segundo plano para evitar a falha do thread de renderização.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-138">It’s recommended to create heaps on background threads to avoid glitching the render thread.</span></span> <span data-ttu-id="8c0d5-139">No D3D12, vários threads podem chamar com segurança as rotinas de criação simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-139">In D3D12, multiple threads may safely call create routines concurrently.</span></span>

<span data-ttu-id="8c0d5-140">O D3D12 apresenta mais flexibilidade e versatilidade em seu modelo de recursos para permitir mais opções para aplicativos.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-140">D3D12 introduces more flexibility and orthogonality into its resource model in order to enable more options for applications.</span></span> <span data-ttu-id="8c0d5-141">Há três tipos de recursos de alto nível no D3D12: confirmados, colocados e reservados.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-141">There are three high-level types of resources in D3D12: committed, placed, and reserved.</span></span>

-   <span data-ttu-id="8c0d5-142">Os recursos confirmados criam um recurso e um heap ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-142">Committed resources create both a resource and a heap at the same time.</span></span> <span data-ttu-id="8c0d5-143">O heap é implícito e não pode ser acessado diretamente.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-143">The heap is implicit and cannot be accessed directly.</span></span> <span data-ttu-id="8c0d5-144">O heap é dimensionado adequadamente para localizar o recurso inteiro dentro do heap.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-144">The heap is appropriately sized to locate the entire resource within the heap.</span></span>
-   <span data-ttu-id="8c0d5-145">Os recursos inseridos permitem o posicionamento de um recurso em um deslocamento diferente de zero em um heap.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-145">Placed resources allow the placement of a resource at a non-zero offset within a heap.</span></span> <span data-ttu-id="8c0d5-146">Os deslocamentos devem ser normalmente alinhados a 64 KB; Mas existem algumas exceções em ambas as direções.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-146">Offsets must typically be aligned to 64KB; but some exceptions exist in both directions.</span></span> <span data-ttu-id="8c0d5-147">Os recursos de MSAA exigem um alinhamento de deslocamento de 4MB e o alinhamento de deslocamento de 4 KB está disponível para texturas pequenas.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-147">MSAA resources require 4MB offset alignment, and 4KB offset alignment is available for small textures.</span></span> <span data-ttu-id="8c0d5-148">Os recursos inseridos não podem ser realocados ou remapeados para outro heap diretamente; Mas eles habilitam a realocação simples dos dados do recurso entre heaps.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-148">Placed resources cannot be relocated or remapped to another heap directly; but they enable simple relocation of the resource data between heaps.</span></span> <span data-ttu-id="8c0d5-149">Depois de criar um novo recurso inserido em um heap diferente e copiar os dados do recurso, os novos descritores de recursos precisarão ser usados para o novo local de dados do recurso.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-149">After creating a new placed resource in a different heap and copying the resource data, new resource descriptors will have to be used for the new resource data location.</span></span>
-   <span data-ttu-id="8c0d5-150">Os recursos reservados só estão disponíveis quando o adaptador dá suporte à camada 1 ou superior dos recursos do lado do ladrilho.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-150">Reserved resources are only available when the adapter supports tiled resources tier 1 or greater.</span></span> <span data-ttu-id="8c0d5-151">Quando disponíveis, eles oferecem as técnicas de gerenciamento de residência mais avançadas disponíveis; Mas nem todos os adaptadores dão suporte a eles no momento.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-151">When available, they offer the most advanced residency management techniques available; but not all adapters currently support them.</span></span> <span data-ttu-id="8c0d5-152">Eles habilitam o remapeamento de um recurso sem a necessidade de regeneração de descritores de recursos, residência de nível parcial de MIP e cenários de textura esparsa, etc. Nem todos os tipos de recursos têm suporte mesmo quando recursos reservados estão disponíveis, portanto, um Gerenciador de residência baseado em página totalmente geral ainda não é viável.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-152">They enable remapping a resource without requiring regeneration of resource descriptors, partial mip level residency, and sparse texture scenarios, etc. Not all resources types are supported even when reserved resources are available, so a fully general page-based residency manager isn’t yet feasible.</span></span>

## <a name="residency-priorities"></a><span data-ttu-id="8c0d5-153">Prioridades de residência</span><span class="sxs-lookup"><span data-stu-id="8c0d5-153">Residency priorities</span></span>

<span data-ttu-id="8c0d5-154">A atualização do Windows 10 para criadores permite que os desenvolvedores influenciem quais heaps e recursos serão preferidos para permanecerem residentes quando a pressão de memória exigir que alguns de seus recursos sejam rebaixados.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-154">The Windows 10 Creators Update enables developers to influence which heaps and resources will be prefered to stay resident when memory pressure requires that some of its resources be demoted.</span></span> <span data-ttu-id="8c0d5-155">Isso ajuda os desenvolvedores a criar aplicativos de melhor desempenho aproveitando o conhecimento de que o tempo de execução não pode inferir do uso da API.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-155">This helps developers create better performing applications by leveraging knowlege that the runtime can't infer from API usage.</span></span> <span data-ttu-id="8c0d5-156">Espera-se que os desenvolvedores se tornem mais confortáveis e possam especificar prioridades à medida que eles fazem a transição do uso de recursos confirmados para reservado e recursos ao lado.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-156">Its expected that developers will become more comfortable and capable specifying priorities as they transition from using commited resources to resereved and tiled resources.</span></span>

<span data-ttu-id="8c0d5-157">Aplicar essas prioridades deve ser mais fácil do que gerenciar dois orçamentos de memória dinâmica, rebaixando e promovendo manualmente os recursos bettween-los, já que os aplicativos já podem fazer isso.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-157">Applying these priorities must be easier than manageing two dynamic memory budgets, manually demoting and promoting resources bettween them, since applications can already do that.</span></span> <span data-ttu-id="8c0d5-158">Portanto, o design da API de prioridade de residência é naturalmente refinado com prioridades padrão razoáveis atribuídas a cada heap ou recurso como seu criado.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-158">Therefore, the design of the residency priority API is coursely-grained with reasonable default priorities assigned to each heap or resource as its created.</span></span> <span data-ttu-id="8c0d5-159">Para obter mais informações, consulte [**ID3D12Device1:: SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) e a enumeração de [**prioridade de \_ residência \_ do D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) .</span><span class="sxs-lookup"><span data-stu-id="8c0d5-159">For more information, see [**ID3D12Device1::SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) and the [**D3D12\_RESIDENCY\_PRIORITY**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) enumeration.</span></span>

<span data-ttu-id="8c0d5-160">Com as prioridades, os desenvolvedores devem:</span><span class="sxs-lookup"><span data-stu-id="8c0d5-160">With priorities, developers are expected to either:</span></span>

-   <span data-ttu-id="8c0d5-161">Aumente a prioridade de alguns heaps excepcionais para atenuar melhor o impacto no desempenho de que esses heaps estão sendo rebaixados antes ou com mais frequência do que os padrões de acesso natural exigiram.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-161">Raise the priority of a few exceptional heaps to better mitigate the experienced performance impact of these heaps being demoted sooner or more frequently than their natural access patterns would demand.</span></span> <span data-ttu-id="8c0d5-162">Espera-se que essa abordagem seja utilizada por aplicativos portados de APIs gráficas como Direct3D 11 ou OpenGL, que é o modelo de gerenciamento de recursos é significativamente diferente do Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-162">This approach is expected to be leveraged by applications ported from graphics APIs such as Direct3D 11 or OpenGL, who's resource management model is significantly different than that of Direct3D 12.</span></span>
-   <span data-ttu-id="8c0d5-163">Substituir quase todas as prioridades de heap com o próprio esquema de bucketização do aplicativo, seja fixo, com base no conhecimento do programador de frequência de acesso ou dinâmico; um esquema fixo é mais simples de gerenciar do que um dinâmico, mas pode ser menos eficiente e exigir intevention de programador conforme os padrões de uso mudam no decorrer do desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-163">Override nearly all heap priorities with the application's own bucketization scheme, either fixed, based on the programmer's knowlege of access frequency, or dynamic; a fixed scheme is simpler to manage than a dynamic one, but can be less effective and require programmer intevention as use patterns change over the course of development.</span></span> <span data-ttu-id="8c0d5-164">Espera-se que essa abordagem seja utilizada por aplicativos criados com o gerenciamento de recursos do estilo Direct3D 12 em mente, como aqueles que usam a biblioteca de residência (especialmente esquemas dinâmicos).</span><span class="sxs-lookup"><span data-stu-id="8c0d5-164">This approach is expected to be leveraged by applications that are built with Direct3D 12-style resource management in mind, such as those that use the residency library (especially dynamic schemes).</span></span>

### <a name="default-priority-algorithm"></a><span data-ttu-id="8c0d5-165">Algoritmo de prioridade padrão</span><span class="sxs-lookup"><span data-stu-id="8c0d5-165">Default priority algorithm</span></span>

<span data-ttu-id="8c0d5-166">Um aplicativo não pode especificar prioridades úteis para qualquer heap que ele tente gerenciar sem primeiro se substanr o algoritmo de prioridade padrão.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-166">An application can't specify useful priorities for any heap it attempts to manage without first understaning the default priority algorithm.</span></span> <span data-ttu-id="8c0d5-167">Isso ocorre porque o valor de atribuição de uma prioridade específica a um heap é derivado de sua prioridade relativa para outros heaps priorizados que conpetem para a mesma memória.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-167">This is because the value of assigning a particular priority to a heap is derived from its relative priority to other prioritized heaps that compete for the same memory.</span></span>

<span data-ttu-id="8c0d5-168">A estratégia escolhida para a geração de prioridades padrão é categorizar os heaps em dois buckets, favorecer (fornecendo prioridade mais alta para) os heaps que são considerados escritos com frequência pela GPU sobre heaps que não são.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-168">The strategy chosen for generating default priorities is to categorize heaps into two buckets, favoring (giving higher priority to) heaps that are assumed to be written frequently by the GPU over heaps that aren't.</span></span>

<span data-ttu-id="8c0d5-169">O Bucket de alta prioridade contém heaps e recursos que são criados com sinalizadores que os identificam como destinos de renderização, buffers de estêncil de profundidade ou modos de exibição de acesso não ordenado (UAVs).</span><span class="sxs-lookup"><span data-stu-id="8c0d5-169">The high-priority bucket contains heaps and resources that are created with flags that identify them as render targets, depth-stencil buffers, or Unordered Access Views (UAVs).</span></span> <span data-ttu-id="8c0d5-170">Esses são os valores de prioridade atribuídos no intervalo a partir da **\_ prioridade de residência D3D12 \_ \_ alta**; para priorizar ainda mais entre esses recursos e heaps, os 16 bits mais baixos da prioridade são definidos como o tamanho do heap ou do recurso dividido por 10MB (saturação para 0xFFFF para heaps extremamente grandes).</span><span class="sxs-lookup"><span data-stu-id="8c0d5-170">These are assigned priority values in the range starting at **D3D12\_RESIDENCY\_PRIORITY\_HIGH**; to further prioritize among these heaps and resources, the lowest 16-bits of the priority are set to the size of the heap or resource divided by 10MB (saturating to 0xFFFF for extremely large heaps).</span></span> <span data-ttu-id="8c0d5-171">Essa priorização adicional favorece maiores heaps e recursos.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-171">This additional prioritization favors larger heaps and resources.</span></span>

<span data-ttu-id="8c0d5-172">O Bucket de baixa prioridade contém todos os outros recursos e heaps, que recebem um valor de prioridade de **D3D12 de \_ prioridade de residência \_ \_ normal**.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-172">The low-priority bucket contains all other heaps and resources, which are assigned a priority value of **D3D12\_RESIDENCY\_PRIORITY\_NORMAL**.</span></span> <span data-ttu-id="8c0d5-173">Não há tentativa de mais priorização entre esses heaps e recursos.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-173">No further prioritization among these heaps and resources is attempted.</span></span>

## <a name="programming-residency-management"></a><span data-ttu-id="8c0d5-174">Gerenciamento de residência de programação</span><span class="sxs-lookup"><span data-stu-id="8c0d5-174">Programming residency management</span></span>

<span data-ttu-id="8c0d5-175">Aplicativos simples podem ser capazes de obter simplesmente criar recursos confirmados até que haja falhas de memória insuficiente.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-175">Simple applications may be able to get by merely creating committed resources until experiencing out-of-memory failures.</span></span> <span data-ttu-id="8c0d5-176">Após a falha, o aplicativo pode destruir outros recursos confirmados ou objetos de API para permitir que mais novas criações de recursos tenham êxito.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-176">Upon failure, the application can destroy other committed resources or API objects to enable further resource creations to succeed.</span></span> <span data-ttu-id="8c0d5-177">Mas, até mesmo aplicativos simples são altamente recomendáveis para observar alterações de orçamento negativo e destruir objetos de API não utilizados, aproximadamente uma vez por quadro.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-177">But, even simple applications are strongly recommended to watch for negative budget changes and destroy unused API objects roughly once a frame.</span></span>

<span data-ttu-id="8c0d5-178">A complexidade de um design de gerenciamento de residência será exibida ao tentar otimizar para arquiteturas de adaptador ou incorporar prioridades de residência.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-178">The complexity of a residency management design will go up when trying to optimize for adapter architectures or incorporating residency priorities.</span></span> <span data-ttu-id="8c0d5-179">O orçamento e o gerenciamento discretos de dois pools de memória discreta serão mais complexos do que o gerenciamento de apenas um, e a atribuição de prioridades fixas em uma ampla escala poderá se tornar uma carga de manutenção se o uso de padrões evoluir.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-179">Discretely budgeting and managing two pools of discrete memory will be more complex than managing only one, and assigning fixed priorities on a wide scale can become a maintainance burden if use patterns evolve.</span></span> <span data-ttu-id="8c0d5-180">Estourar texturas na memória do sistema aumenta a complexidade, pois o recurso incorreto na memória do sistema pode afetar seriamente a taxa de quadros.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-180">Overflowing textures into system memory adds more complexity, as the wrong resource in system-memory can severely impact frame rate.</span></span> <span data-ttu-id="8c0d5-181">Além disso, não há uma funcionalidade simples para ajudar a identificar os recursos que se beneficiariam da maior largura de banda de GPU ou tolerar uma menor largura de banda de GPU.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-181">And, there is no simple functionality to help identify the resources that would either benefit from higher GPU bandwidth or tolerate lower GPU bandwidth.</span></span>

<span data-ttu-id="8c0d5-182">Designs ainda mais complicados consultarão os recursos do adaptador atual.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-182">Even more complicated designs will query for the features of the current adapter.</span></span> <span data-ttu-id="8c0d5-183">Essas informações estão disponíveis em [**\_ \_ \_ \_ \_ \_ suporte ao endereço virtual da GPU de dados de recursos do D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**\_ \_ \_ arquitetura de dados**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture)de recursos do D3D12, [**\_ \_ \_ camada de recursos do lado do D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier)e [**\_ \_ \_ camada de heap de recurso do D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span><span class="sxs-lookup"><span data-stu-id="8c0d5-183">This information is available in [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**D3D12\_FEATURE\_DATA\_ARCHITECTURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), [**D3D12\_TILED\_RESOURCES\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier), and [**D3D12\_RESOURCE\_HEAP\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span></span>

<span data-ttu-id="8c0d5-184">Várias partes de um aplicativo provavelmente aparecerão usando técnicas diferentes.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-184">Multiple parts of an application will likely wind up using different techniques.</span></span> <span data-ttu-id="8c0d5-185">Por exemplo, algumas texturas grandes e caminhos de código raramente exercitados podem usar recursos confirmados, enquanto muitas texturas podem ser designadas com uma propriedade de streaming e usar uma técnica de recurso inserido geral.</span><span class="sxs-lookup"><span data-stu-id="8c0d5-185">For example, some large textures and rarely exercised code paths may use committed resources, while many textures may be designated with a streaming property and use a general placed-resource technique.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8c0d5-186">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="8c0d5-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8c0d5-187">**ID3D12Heap**</span><span class="sxs-lookup"><span data-stu-id="8c0d5-187">**ID3D12Heap**</span></span>](/windows/desktop/api/d3d12/nn-d3d12-id3d12heap)
</dt> <dt>

[<span data-ttu-id="8c0d5-188">Gerenciamento de memória</span><span class="sxs-lookup"><span data-stu-id="8c0d5-188">Memory Management</span></span>](memory-management.md)
</dt> </dl>

 

 