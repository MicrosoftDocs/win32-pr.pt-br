---
title: Barreiras de UAV e barreiras de estado de recursos no DirectML
description: Descreve os benefícios de correção das barreiras e como você pode trabalhar com elas no DirectML.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: 9bfc93d4fb28cff5d7d196287c6573e3e494d1d5
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548255"
---
# <a name="uav-barriers-and-resource-state-barriers-in-directml"></a><span data-ttu-id="ee75e-103">Barreiras de UAV e barreiras de estado de recursos no DirectML</span><span class="sxs-lookup"><span data-stu-id="ee75e-103">UAV barriers and resource state barriers in DirectML</span></span>

## <a name="unordered-access-view-uav-barrier-requirements"></a><span data-ttu-id="ee75e-104">Requisitos de barreira de UAV (exibição de acesso não ordenado)</span><span class="sxs-lookup"><span data-stu-id="ee75e-104">Unordered Access View (UAV) barrier requirements</span></span>

### <a name="uav-barriers-in-direct3d-12"></a><span data-ttu-id="ee75e-105">Barreiras de UAV no Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="ee75e-105">UAV barriers in Direct3D 12</span></span>

<span data-ttu-id="ee75e-106">No Direct3D 12, os despachos de sombreador de computação adjacentes na mesma lista de comandos têm permissão para serem executados em paralelo na GPU, a menos que sejam sincronizados com uma barreira de UAV (exibição de acesso não ordenado) intermediária.</span><span class="sxs-lookup"><span data-stu-id="ee75e-106">In Direct3D 12, adjacent compute shader dispatches within the same command list are permitted to execute in parallel on the GPU unless they're synchronized with an intervening unordered access view (UAV) barrier.</span></span> <span data-ttu-id="ee75e-107">Isso pode melhorar o desempenho aumentando a utilização do hardware de GPU.</span><span class="sxs-lookup"><span data-stu-id="ee75e-107">This can improve performance by increasing utilization of GPU hardware.</span></span> <span data-ttu-id="ee75e-108">No entanto, por padrão, sem o uso de uma barreira UAV, a execução paralela de dois expedimentos adjacentes poderá causar uma condição de corrida se existir uma dependência de dados entre os dois despachos; ou se ambos os despachos executam gravações UAV nas mesmas regiões de memória.</span><span class="sxs-lookup"><span data-stu-id="ee75e-108">However, by default, without the use of a UAV barrier, the parallel execution of two adjacent dispatches can cause a race condition if there exists a data dependency between the two dispatches; or if both dispatches perform UAV writes to the same regions of memory.</span></span>

<span data-ttu-id="ee75e-109">Uma barreira UAV força todos os despachos enviados anteriormente para concluir o execução na GPU antes que os despachos subsequentes possam começar.</span><span class="sxs-lookup"><span data-stu-id="ee75e-109">A UAV barrier forces all previously-submitted dispatches to complete exection on the GPU before subsequent dispatches may begin.</span></span> <span data-ttu-id="ee75e-110">As barreiras de UAV são usadas para sincronizar entre expatches na mesma lista de comandos para evitar corridas de dados.</span><span class="sxs-lookup"><span data-stu-id="ee75e-110">UAV barriers are used to synchronize between dispatches on the same command list to avoid data races.</span></span> <span data-ttu-id="ee75e-111">Você pode emitir uma barreira UAV usando o método [ **ID3D12GraphicsCommandList:: ResourceBarrier**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).</span><span class="sxs-lookup"><span data-stu-id="ee75e-111">You can issue a UAV barrier by using the [**ID3D12GraphicsCommandList::ResourceBarrier** method](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).</span></span>

### <a name="uav-barriers-in-directml"></a><span data-ttu-id="ee75e-112">UAV barreiras no DirectML</span><span class="sxs-lookup"><span data-stu-id="ee75e-112">UAV barriers in DirectML</span></span>

<span data-ttu-id="ee75e-113">No DirectML, os operadores são expedidos de uma maneira semelhante à forma como os sombreadores de computação são expedidos no Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="ee75e-113">In DirectML, operators are dispatched in a way that's similar to the way compute shaders are dispatched in Direct3D 12.</span></span> <span data-ttu-id="ee75e-114">Ou seja, os expedimentos adjacentes de operadores têm permissão para serem executados em paralelo na GPU, a menos que exista uma barreira de UAV intermediária entre eles.</span><span class="sxs-lookup"><span data-stu-id="ee75e-114">That is, adjacent dispatches of operators are permitted to execute in parallel on the GPU unless there exists an intervening UAV barrier between them.</span></span> <span data-ttu-id="ee75e-115">Um modelo de aprendizado de máquina típico contém dependências de dados entre seus operadores; por exemplo, a saída de um operador alimenta a entrada de outro.</span><span class="sxs-lookup"><span data-stu-id="ee75e-115">A typical machine learning model contains data dependencies between its operators; for instance, the output of one operator feeds into the input of another.</span></span> <span data-ttu-id="ee75e-116">Portanto, é importante usar barreiras UAV para sincronizar os expedimentos corretamente.</span><span class="sxs-lookup"><span data-stu-id="ee75e-116">It's therefore important to use UAV barriers to correctly synchronize dispatches.</span></span>

<span data-ttu-id="ee75e-117">O DirectML garante que ele nunca lerá (e nunca gravará) os tempos de entrada.</span><span class="sxs-lookup"><span data-stu-id="ee75e-117">DirectML guarantees that it will only ever read from (and never write to) input tensors.</span></span> <span data-ttu-id="ee75e-118">Ele também garante que nunca fabricará gravações para um tensor de saída fora do intervalo do membro [**DML_BUFFER_TENSOR_DESC:: TotalTensorSizeInBytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) do tensor.</span><span class="sxs-lookup"><span data-stu-id="ee75e-118">It also guarantees that it will never manufacture writes to an output tensor outside the range of the tensor's [**DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) member.</span></span> <span data-ttu-id="ee75e-119">Isso significa que as dependências de dados entre operadores em DirectML podem ser geradas observando apenas as associações de entrada e saída de um operador.</span><span class="sxs-lookup"><span data-stu-id="ee75e-119">This means that data dependencies between operators in DirectML can be reasoned about by looking only at an operator's input and output bindings.</span></span>

<span data-ttu-id="ee75e-120">Por exemplo, essas garantias permitem que você despache dois operadores que associam a mesma região de um recurso como uma entrada, sem a necessidade de emitir uma barreira de UAV intermediária.</span><span class="sxs-lookup"><span data-stu-id="ee75e-120">For example, these guarantees allow you to dispatch two operators that bind the same region of a resource as an input, without having to issue an intervening UAV barrier.</span></span> <span data-ttu-id="ee75e-121">Isso é sempre seguro porque DirectML nunca grava em dezenases de entrada.</span><span class="sxs-lookup"><span data-stu-id="ee75e-121">This is always safe because DirectML never writes to input tensors.</span></span> <span data-ttu-id="ee75e-122">Como outro exemplo, é sempre seguro associar os tempos de saída de dois despachos de operador simultâneos ao mesmo recurso do Direct3D 12 (desde que seus grandes prazos não se sobreponham), porque DirectML nunca grava fora dos limites de um tensor (conforme definido pelo DML_BUFFER_TENSOR_DESC da tensor **:: TotalTensorSizeInBytes**).</span><span class="sxs-lookup"><span data-stu-id="ee75e-122">As another example, it's always safe to bind the output tensors of two concurrent operator dispatches to the same Direct3D 12 resource (so long as their tensors don't overlap), because DirectML never writes outside the bounds of a tensor (as defined by the tensor's **DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**).</span></span>

<span data-ttu-id="ee75e-123">Como as barreiras de UAV são uma forma de sincronização, o uso desnecessário de barreiras de UAV pode afetar negativamente o desempenho.</span><span class="sxs-lookup"><span data-stu-id="ee75e-123">As UAV barriers are a form of synchronization, unnecessary use of UAV barriers might negatively impact performance.</span></span> <span data-ttu-id="ee75e-124">Portanto, é melhor usar o número mínimo de barreiras UAV necessárias para sincronizar corretamente os despachos dentro de uma lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="ee75e-124">Therefore, it's best for you to use the minimum number of UAV barriers necessary to correctly synchronize the dispatches within a command list.</span></span>

### <a name="example-1"></a><span data-ttu-id="ee75e-125">Exemplo 1</span><span class="sxs-lookup"><span data-stu-id="ee75e-125">Example 1</span></span>

<span data-ttu-id="ee75e-126">No exemplo a seguir, a saída de um operador de convolução é inserida em uma ativação do ReLU, seguida por uma normalização do lote.</span><span class="sxs-lookup"><span data-stu-id="ee75e-126">In the following example, a convolution operator's output is fed into a ReLU activation, followed by a batch normalization.</span></span>

```console
    CONVOLUTION (conv1)
         |
  ACTIVATION_RELU (relu1)
         |
BATCH_NORMALIZATION (batch1)
```

<span data-ttu-id="ee75e-127">Como existe uma dependência de dados entre todos os três operadores, você precisará de uma barreira UAV entre cada expedição sucessiva (consulte [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span><span class="sxs-lookup"><span data-stu-id="ee75e-127">Since a data dependency exists between all three operators, you'll need a UAV barrier between each successive dispatch (see [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span></span>

1. <span data-ttu-id="ee75e-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
2. <span data-ttu-id="ee75e-129">`d3d12CommandList->ResourceBarrier(`**Barreira UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-129">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="ee75e-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span></span>
4. <span data-ttu-id="ee75e-131">`d3d12CommandList->ResourceBarrier(`**Barreira UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-131">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
5. <span data-ttu-id="ee75e-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span></span>

### <a name="example-2"></a><span data-ttu-id="ee75e-133">Exemplo 2</span><span class="sxs-lookup"><span data-stu-id="ee75e-133">Example 2</span></span>

```console
     MAX_POOLING (pool1)
        /    \
CONVOLUTION  CONVOLUTION
  (conv1)      (conv2)
        \    /
         JOIN (join1)
```

<span data-ttu-id="ee75e-134">Aqui, a saída do pooling é inserida em duas convolução, cujas saídas são concatenadas em conjunto usando o operador JOIN.</span><span class="sxs-lookup"><span data-stu-id="ee75e-134">Here the output of pooling is fed into two convolutions, whose outputs are then concatenated together using the JOIN operator.</span></span> <span data-ttu-id="ee75e-135">Existe uma dependência de dados entre `pool1` e `conv1` e `conv2` ; bem como entre `conv1` e `conv2` e e `join1` .</span><span class="sxs-lookup"><span data-stu-id="ee75e-135">A data dependency exists between `pool1` and both `conv1` and `conv2`; as well as between both `conv1` and `conv2` and `join1`.</span></span> <span data-ttu-id="ee75e-136">Aqui está uma maneira válida de executar esse grafo.</span><span class="sxs-lookup"><span data-stu-id="ee75e-136">Here's one valid way to execute this graph.</span></span>

1. <span data-ttu-id="ee75e-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span></span>
2. <span data-ttu-id="ee75e-138">`d3d12CommandList->ResourceBarrier(`**Barreira UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-138">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="ee75e-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
4. <span data-ttu-id="ee75e-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`</span></span>
5. <span data-ttu-id="ee75e-141">`d3d12CommandList->ResourceBarrier(`**Barreira UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-141">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
6. <span data-ttu-id="ee75e-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`</span><span class="sxs-lookup"><span data-stu-id="ee75e-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`</span></span>

<span data-ttu-id="ee75e-143">Nesse caso, `conv1` e `conv2` são capazes de executar simultaneamente na GPU, o que pode melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="ee75e-143">In this case, `conv1` and `conv2` are able to execute concurrently on the GPU, which may improve performance.</span></span>

## <a name="resource-barrier-state-requirements"></a><span data-ttu-id="ee75e-144">Requisitos de estado de barreira de recurso</span><span class="sxs-lookup"><span data-stu-id="ee75e-144">Resource barrier state requirements</span></span>

<span data-ttu-id="ee75e-145">Como o chamador, é sua responsabilidade garantir que todos os recursos do Direct3D 12 estejam no estado de barreira do recurso correto antes de executar expedimentos do DirectML na GPU.</span><span class="sxs-lookup"><span data-stu-id="ee75e-145">As the caller, it's your responsibility to ensure that all Direct3D 12 resources are in the correct resource barrier state prior to executing DirectML dispatches on the GPU.</span></span> <span data-ttu-id="ee75e-146">O DirectML não realiza nenhuma barreiras de transição em seu nome.</span><span class="sxs-lookup"><span data-stu-id="ee75e-146">DirectML doesn't perform any transition barriers on your behalf.</span></span>

<span data-ttu-id="ee75e-147">Antes da execução de [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) na GPU, você deve fazer a transição de todos os recursos associados para o estado **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** ou para um estado implicitamente passível de promoção para **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, como **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="ee75e-147">Prior to execution of [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="ee75e-148">Depois que essa chamada for concluída, os recursos permanecerão no estado de **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="ee75e-148">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="ee75e-149">Para obter mais detalhes, consulte [Binding in DirectML](dml-binding.md).</span><span class="sxs-lookup"><span data-stu-id="ee75e-149">For more details, see [Binding in DirectML](dml-binding.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="ee75e-150">Confira também</span><span class="sxs-lookup"><span data-stu-id="ee75e-150">See also</span></span>

* [<span data-ttu-id="ee75e-151">Usando barreiras de recursos para sincronizar Estados de recursos no Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="ee75e-151">Using resource barriers to synchronize resource states in Direct3D 12</span></span>](/windows/desktop/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12)
* [<span data-ttu-id="ee75e-152">Associação no DirectML</span><span class="sxs-lookup"><span data-stu-id="ee75e-152">Binding in DirectML</span></span>](dml-binding.md)
